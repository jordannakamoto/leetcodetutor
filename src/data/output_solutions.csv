problem_id,contents
"1","class Solution:
  def twoSum(self, nums: list[int], target: int) -> list[int]:
    numToIndex = {}

    for i, num in enumerate(nums):
      if target - num in numToIndex:
        return numToIndex[target - num], i
      numToIndex[num] = i"
"10","class Solution:
  def isMatch(self, s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    # dp[i][j] := True if s[0..i) matches p[0..j)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    def isMatch(i: int, j: int) -> bool:
      return j >= 0 and p[j] == '.' or s[i] == p[j]

    for j, c in enumerate(p):
      if c == '*' and dp[0][j - 1]:
        dp[0][j + 1] = True

    for i in range(m):
      for j in range(n):
        if p[j] == '*':
          # The minimum index of '*' is 1.
          noRepeat = dp[i + 1][j - 1]
          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]
          dp[i + 1][j + 1] = noRepeat or doRepeat
        elif isMatch(i, j):
          dp[i + 1][j + 1] = dp[i][j]

    return dp[m][n]"
"100","class Solution:
  def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:
    if not p or not q:
      return p == q
    return (p.val == q.val and
            self.isSameTree(p.left, q.left) and
            self.isSameTree(p.right, q.right))"
"1000","class Solution {
  public int mergeStones(int[] stones, int K) {
    final int n = stones.length;
    if ((n - 1) % (K - 1) != 0)
      return -1;

    final int kMax = 1_000_000_000;

    // dp[i][j] := the minimum cost to merge stones[i..j]
    int[][] dp = new int[n][n];
    Arrays.stream(dp).forEach(A -> Arrays.fill(A, kMax));
    int[] prefix = new int[n + 1];

    for (int i = 0; i < n; ++i)
      dp[i][i] = 0;

    for (int i = 0; i < n; ++i)
      prefix[i + 1] = prefix[i] + stones[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        final int j = i + d;
        for (int m = i; m < j; m += K - 1)
          dp[i][j] = Math.min(dp[i][j], dp[i][m] + dp[m + 1][j]);
        if (d % (K - 1) == 0)
          dp[i][j] += prefix[j + 1] - prefix[i];
      }

    return dp[0][n - 1];
  }
}"
"1001","class Solution:
  def gridIllumination(
      self,
      n: int,
      lamps: list[list[int]],
      queries: list[list[int]],
  ) -> list[int]:
    ans = []
    rows = collections.Counter()
    cols = collections.Counter()
    diag1 = collections.Counter()
    diag2 = collections.Counter()
    lampsSet = set()

    for i, j in lamps:
      if (i, j) not in lampsSet:
        lampsSet.add((i, j))
        rows[i] += 1
        cols[j] += 1
        diag1[i + j] += 1
        diag2[i - j] += 1

    for i, j in queries:
      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:
        ans.append(1)
        for y in range(max(0, i - 1), min(n, i + 2)):
          for x in range(max(0, j - 1), min(n, j + 2)):
            if (y, x) in lampsSet:
              lampsSet.remove((y, x))
              rows[y] -= 1
              cols[x] -= 1
              diag1[y + x] -= 1
              diag2[y - x] -= 1
      else:
        ans.append(0)

    return ans"
"1002","class Solution:
  def commonChars(self, words: list[str]) -> list[str]:
    return functools.reduce(lambda a, b: a & b,
                            map(collections.Counter, words)).elements()"
"1003","class Solution:
  def isValid(self, s: str) -> bool:
    stack = []

    for c in s:
      if c == 'c':
        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':
          return False
        stack.pop()
        stack.pop()
      else:
        stack.append(c)

    return not stack"
"1004","class Solution:
  def longestOnes(self, nums: list[int], k: int) -> int:
    ans = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        k -= 1
      while k < 0:
        if nums[l] == 0:
          k += 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"1005","class Solution:
  def largestSumAfterKNegations(self, nums: list[int], k: int) -> int:
    nums.sort()

    for i, num in enumerate(nums):
      if num > 0 or k == 0:
        break
      nums[i] = -num
      k -= 1

    return sum(nums) - (k % 2) * min(nums) * 2"
"1006","class Solution:
  def clumsy(self, n: int) -> int:
    if n == 1:
      return 1
    if n == 2:
      return 2
    if n == 3:
      return 6
    if n == 4:
      return 7
    if n % 4 == 1:
      return n + 2
    if n % 4 == 2:
      return n + 2
    if n % 4 == 3:
      return n - 1
    return n + 1"
"1007","class Solution:
  def minDominoRotations(self, tops: list[int], bottoms: list[int]) -> int:
    for num in range(1, 7):
      if all(num in pair for pair in zip(tops, bottoms)):
        return len(tops) - max(tops.count(num), bottoms.count(num))
    return -1"
"1008","class Solution:
  def bstFromPreorder(self, preorder: list[int]) -> TreeNode | None:
    root = TreeNode(preorder[0])
    stack = [root]

    for i in range(1, len(preorder)):
      parent = stack[-1]
      child = TreeNode(preorder[i])
      # Adjust the parent.
      while stack and stack[-1].val < child.val:
        parent = stack.pop()
      # Create parent-child link according to BST property.
      if parent.val > child.val:
        parent.left = child
      else:
        parent.right = child
      stack.append(child)

    return root"
"1009","class Solution:
  def bitwiseComplement(self, n: int) -> int:
    mask = 1
    while mask < n:
      mask = (mask << 1) + 1
    return mask ^ n"
"101","class Solution:
  def isSymmetric(self, root: TreeNode | None) -> bool:
    def isSymmetric(p: TreeNode | None, q: TreeNode | None) -> bool:
      if not p or not q:
        return p == q
      return (p.val == q.val and
              isSymmetric(p.left, q.right) and
              isSymmetric(p.right, q.left))

    return isSymmetric(root, root)"
"1010","class Solution:
  def numPairsDivisibleBy60(self, time: list[int]) -> int:
    ans = 0
    count = [0] * 60

    for t in time:
      t %= 60
      ans += count[(60 - t) % 60]
      count[t] += 1

    return ans"
"1011","class Solution:
  def shipWithinDays(self, weights: list[int], days: int) -> int:
    def canShip(shipCapacity: int) -> bool:
      shipDays = 1
      capacity = 0
      for weight in weights:
        if capacity + weight > shipCapacity:
          shipDays += 1
          capacity = weight
        else:
          capacity += weight
      return shipDays <= days

    l = max(weights)
    r = sum(weights)
    return bisect.bisect_left(range(l, r), True,
                              key=lambda m: canShip(m)) + l"
"1012","class Solution:
  def numDupDigitsAtMostN(self, n: int) -> int:
    return n - self._countSpecialNumbers(n)

  # Same as 2376. Count Special Integers
  def _countSpecialNumbers(self, n: int) -> int:
    s = str(n)

    @functools.lru_cache(None)
    def dp(i: int, used: int, isTight: bool) -> int:
      """"""
      Returns the number of special integers, considering the i-th digit, where
      `used` is the bitmask of the used digits, and `isTight` indicates if the
      current digit is tightly bound.
      """"""
      if i == len(s):
        return 1

      res = 0
      maxDigit = int(s[i]) if isTight else 9

      for d in range(maxDigit + 1):
        # `d` is used.
        if used >> d & 1:
          continue
        # Use `d` now.
        nextIsTight = isTight and (d == maxDigit)
        if used == 0 and d == 0:  # Don't count leading 0s as used.
          res += dp(i + 1, used, nextIsTight)
        else:
          res += dp(i + 1, used | 1 << d, nextIsTight)

      return res

    return dp(0, 0, True) - 1  # - 0"
"1013","class Solution:
  def canThreePartsEqualSum(self, arr: list[int]) -> bool:
    summ = sum(arr)
    if summ % 3 != 0:
      return False

    average = summ // 3
    partCount = 0
    partSum = 0

    for a in arr:
      partSum += a
      if partSum == average:
        partCount += 1
        partSum = 0

    # edge case: arr = [0, 0, 0, 0] . partCount = 4.
    return partCount >= 3"
"1014","class Solution:
  def maxScoreSightseeingPair(self, values: list[int]) -> int:
    ans = 0
    bestPrev = 0

    for value in values:
      ans = max(ans, value + bestPrev)
      bestPrev = max(bestPrev, value) - 1

    return ans"
"1015","class Solution:
  def smallestRepunitDivByK(self, k: int) -> int:
    if k % 10 not in {1, 3, 7, 9}:
      return -1

    seen = set()
    n = 0

    for length in range(1, k + 1):
      n = (n * 10 + 1) % k
      if n == 0:
        return length
      if n in seen:
        return -1
      seen.add(n)

    return -1"
"1016","class Solution:
  def queryString(self, s: str, n: int) -> bool:
    if n > 1511:
      return False

    for i in range(n, n // 2, -1):
      if format(i, 'b') not in s:
        return False

    return True"
"1017","class Solution:
  def baseNeg2(self, n: int) -> str:
    ans = []

    while n != 0:
      ans.append(str(n % 2))
      n = -(n >> 1)

    return ''.join(reversed(ans)) if ans else '0'"
"1018","class Solution:
  def prefixesDivBy5(self, nums: list[int]) -> list[bool]:
    ans = []
    curr = 0

    for num in nums:
      curr = (curr * 2 + num) % 5
      ans.append(curr % 5 == 0)

    return ans"
"1019","class Solution:
  def nextLargerNodes(self, head: ListNode) -> list[int]:
    ans = []
    stack = []

    while head:
      while stack and head.val > ans[stack[-1]]:
        index = stack.pop()
        ans[index] = head.val
      stack.append(len(ans))
      ans.append(head.val)
      head = head.next

    for i in stack:
      ans[i] = 0

    return ans"
"102","class Solution:
  def levelOrder(self, root: TreeNode | None) -> list[list[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      currLevel = []
      for _ in range(len(q)):
        node = q.popleft()
        currLevel.append(node.val)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      ans.append(currLevel)

    return ans"
"1020","class Solution {
  public int numEnclaves(int[][] grid) {
    final int m = grid.length;
    final int n = grid[0].length;

    // Remove the lands connected to the edge.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (grid[i][j] == 1)
            dfs(grid, i, j);

    return Arrays.stream(grid).flatMapToInt(Arrays::stream).sum();
  }

  private void dfs(int[][] grid, int i, int j) {
    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)
      return;
    if (grid[i][j] == 0)
      return;
    grid[i][j] = 0;
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
  }
}"
"1021","class Solution:
  def removeOuterParentheses(self, s: str) -> str:
    ans = []
    opened = 0

    for c in s:
      if c == '(':
        opened += 1
        if opened > 1:
          ans.append(c)
      else:  # c == ')'
        opened -= 1
        if opened > 0:
          ans.append(c)

    return ''.join(ans)"
"1022","class Solution:
  def sumRootToLeaf(self, root: TreeNode | None) -> int:
    ans = 0

    def dfs(root: TreeNode | None, val: int) -> None:
      nonlocal ans
      if not root:
        return
      val = val * 2 + root.val
      if not root.left and not root.right:
        ans += val
      dfs(root.left, val)
      dfs(root.right, val)

    dfs(root, 0)
    return ans"
"1023","class Solution:
  def camelMatch(self, queries: list[str], pattern: str) -> list[bool]:
    def isMatch(query: str) -> bool:
      j = 0
      for c in query:
        if j < len(pattern) and c == pattern[j]:
          j += 1
        elif c.isupper():
          return False
      return j == len(pattern)

    return [isMatch(query) for query in queries]"
"1024","class Solution:
  def videoStitching(self, clips: list[list[int]], time: int) -> int:
    ans = 0
    end = 0
    farthest = 0

    clips.sort()

    i = 0
    while farthest < time:
      while i < len(clips) and clips[i][0] <= end:
        farthest = max(farthest, clips[i][1])
        i += 1
      if end == farthest:
        return -1
      ans += 1
      end = farthest

    return ans"
"1025","class Solution:
  def divisorGame(self, n: int) -> bool:
    return n % 2 == 0"
"1026","class Solution {
  public int maxAncestorDiff(TreeNode root) {
    return maxAncestorDiff(root, root.val, root.val);
  }

  // Returns |the maximum - the minimum| of the tree.
  private int maxAncestorDiff(TreeNode root, int mn, int mx) {
    if (root == null)
      return 0;
    mn = Math.min(mn, root.val);
    mx = Math.max(mx, root.val);
    final int l = maxAncestorDiff(root.left, mn, mx);
    final int r = maxAncestorDiff(root.right, mn, mx);
    return Math.max(mx - mn, Math.max(l, r));
  }
}"
"1027","class Solution:
  def longestArithSeqLength(self, nums: list[int]) -> int:
    n = len(nums)
    ans = 0
    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]
    # with k = diff + 500
    dp = [[0] * 1001 for _ in range(n)]

    for i in range(n):
      for j in range(i):
        k = nums[i] - nums[j] + 500
        dp[i][k] = max(2, dp[j][k] + 1)
        ans = max(ans, dp[i][k])

    return ans"
"1028","class Solution:
  def recoverFromPreorder(self, traversal: str) -> TreeNode | None:
    i = 0

    def recoverFromPreorder(depth: int) -> TreeNode | None:
      nonlocal i
      nDashes = 0
      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':
        nDashes += 1
      if nDashes != depth:
        return None

      i += depth
      start = i
      while i < len(traversal) and traversal[i].isdigit():
        i += 1

      return TreeNode(int(traversal[start:i]),
                      recoverFromPreorder(depth + 1),
                      recoverFromPreorder(depth + 1))

    return recoverFromPreorder(0)"
"1029","class Solution:
  def twoCitySchedCost(self, costs: list[list[int]]) -> int:
    n = len(costs) // 2

    # How much money can we save if we fly a person to A instead of B?
    # To save money, we should
    #   1. Fly the person with the maximum saving to A.
    #   2. Fly the person with the minimum saving to B.

    # Sort `costs` in ascending order by the money saved if we fly a person to
    # B instead of A.
    costs.sort(key=lambda x: x[0] - x[1])
    return sum(costs[i][0] + costs[i + n][1] for i in range(n))"
"103","class Solution:
  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:
    if not root:
      return []

    ans = []
    dq = collections.deque([root])
    isLeftToRight = True

    while dq:
      currLevel = []
      for _ in range(len(dq)):
        if isLeftToRight:
          node = dq.popleft()
          currLevel.append(node.val)
          if node.left:
            dq.append(node.left)
          if node.right:
            dq.append(node.right)
        else:
          node = dq.pop()
          currLevel.append(node.val)
          if node.right:
            dq.appendleft(node.right)
          if node.left:
            dq.appendleft(node.left)
      ans.append(currLevel)
      isLeftToRight = not isLeftToRight

    return ans"
"1030","class Solution:
  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> list[list[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = []
    q = collections.deque([(rCenter, cCenter)])
    seen = {(rCenter, cCenter)}

    while q:
      i, j = q.popleft()
      ans.append([i, j])
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == rows or y < 0 or y == cols:
          continue
        if (x, y) in seen:
          continue
        seen.add((x, y))
        q.append((x, y))

    return ans"
"1031","class Solution:
  def maxSumTwoNoOverlap(
      self,
      nums: list[int],
      firstLen: int,
      secondLen: int,
  ) -> int:
    def helper(l: int, r: int) -> int:
      n = len(nums)
      left = [0] * n
      summ = 0

      for i in range(n):
        summ += nums[i]
        if i >= l:
          summ -= nums[i - l]
        if i >= l - 1:
          left[i] = max(left[i - 1], summ) if i > 0 else summ

      right = [0] * n
      summ = 0

      for i in reversed(range(n)):
        summ += nums[i]
        if i <= n - r - 1:
          summ -= nums[i + r]
        if i <= n - r:
          right[i] = max(right[i + 1], summ) if i < n - 1 else summ

      return max(left[i] + right[i + 1] for i in range(n - 1))

    return max(helper(firstLen, secondLen), helper(secondLen, firstLen))"
"1032","from dataclasses import dataclass


@dataclass
class TrieNode:
  children: dict[str, TrieNode]
  isWord: bool


class StreamChecker:
  def __init__(self, words: list[str]):
    self.root = TrieNode()
    self.letters = []

    for word in words:
      self._insert(word)

  def query(self, letter: str) -> bool:
    self.letters.append(letter)
    node = self.root
    for c in reversed(self.letters):
      if c not in node.children:
        return False
      node = node.children[c]
      if node.isWord:
        return True
    return False

  def _insert(self, word: str) -> None:
    node = self.root
    for c in reversed(word):
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True"
"1033","class Solution:
  def numMovesStones(self, a: int, b: int, c: int) -> list[int]:
    nums = sorted([a, b, c])

    if nums[2] - nums[0] == 2:
      return [0, 0]
    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,
            nums[2] - nums[0] - 2]"
"1034","class Solution:
  def colorBorder(
      self,
      grid: list[list[int]],
      r0: int,
      c0: int,
      color: int
  ) -> list[list[int]]:
    def dfs(i: int, j: int, startColor: int) -> None:
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return
      if grid[i][j] != startColor:
        return

      grid[i][j] = -startColor
      dfs(i + 1, j, startColor)
      dfs(i - 1, j, startColor)
      dfs(i, j + 1, startColor)
      dfs(i, j - 1, startColor)

      # If this cell is already on the boarder, it must be painted later.
      if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:
        return

      if (abs(grid[i + 1][j]) == startColor and
          abs(grid[i - 1][j]) == startColor and
          abs(grid[i][j + 1]) == startColor and
              abs(grid[i][j - 1]) == startColor):
        grid[i][j] = startColor

    dfs(r0, c0, grid[r0][c0])

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num < 0:
          grid[i][j] = color

    return grid"
"1035","class Solution:
  def maxUncrossedLines(self, nums1: list[int], nums2: list[int]) -> int:
    m = len(nums1)
    n = len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        dp[i][j] = (dp[i - 1][j - 1] + 1
                    if nums1[i - 1] == nums2[j - 1]
                    else max(dp[i - 1][j], dp[i][j - 1]))

    return dp[m][n]"
"1036","class Solution:
  def isEscapePossible(
      self,
      blocked: list[list[int]],
      source: list[int],
      target: list[int]
  ) -> bool:
    def dfs(i: int, j: int, target: list[int], seen: set) -> bool:
      if i < 0 or i >= 10**6 or j < 0 or j >= 10**6:
        return False
      if (i, j) in blocked or (i, j) in seen:
        return False
      seen.add((i, j))
      return (len(seen) > (1 + 199) * 199 // 2 or [i, j] == target or
              dfs(i + 1, j, target, seen) or
              dfs(i - 1, j, target, seen) or
              dfs(i, j + 1, target, seen) or
              dfs(i, j - 1, target, seen))

    blocked = set(tuple(b) for b in blocked)
    return (dfs(source[0], source[1], target, set()) and
            dfs(target[0], target[1], source, set()))"
"1037","class Solution:
  def isBoomerang(self, points: list[list[int]]) -> bool:
    return ((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=
            (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]))"
"1038","class Solution {
 public:
  TreeNode* bstToGst(TreeNode* root) {
    int prefix = 0;

    function<void(TreeNode*)> reversedInorder = [&](TreeNode* root) {
      if (root == nullptr)
        return;

      reversedInorder(root->right);

      root->val += prefix;
      prefix = root->val;

      reversedInorder(root->left);
    };

    reversedInorder(root);
    return root;
  }
};"
"1039","class Solution:
  def minScoreTriangulation(self, values: list[int]) -> int:
    n = len(values)
    dp = [[0] * n for _ in range(n)]

    for j in range(2, n):
      for i in range(j - 2, -1, -1):
        dp[i][j] = math.inf
        for k in range(i + 1, j):
          dp[i][j] = min(dp[i][j], dp[i][k] + values[i]
                         * values[k] * values[j] + dp[k][j])

    return dp[0][n - 1]"
"104","class Solution:
  def maxDepth(self, root: TreeNode | None) -> int:
    if not root:
      return 0
    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
"1040","class Solution:
  def numMovesStonesII(self, stones: list[int]) -> list[int]:
    n = len(stones)
    minMoves = n

    stones.sort()

    l = 0
    for r, stone in enumerate(stones):
      while stone - stones[l] + 1 > n:
        l += 1
      alreadyStored = r - l + 1
      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:
        minMoves = 2
      else:
        minMoves = min(minMoves, n - alreadyStored)

    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]"
"1041","class Solution:
  def isRobotBounded(self, instructions: str) -> bool:
    x = 0
    y = 0
    d = 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for instruction in instructions:
      if instruction == 'G':
        x += directions[d][0]
        y += directions[d][1]
      elif instruction == 'L':
        d = (d + 3) % 4
      else:
        d = (d + 1) % 4

    return (x, y) == (0, 0) or d > 0"
"1042","class Solution:
  def gardenNoAdj(self, n: int, paths: list[list[int]]) -> list[int]:
    ans = [0] * n  # ans[i] := 1, 2, 3, or 4
    graph = [[] for _ in range(n)]

    for x, y in paths:
      u = x - 1
      v = y - 1
      graph[u].append(v)
      graph[v].append(u)

    for u in range(n):
      used = functools.reduce(operator.or_, (1 << ans[v] for v in graph[u]), 0)
      ans[u] = next(type_
                    for type_ in range(1, 5)
                    if not (used >> type_ & 1))

    return ans"
"1043","class Solution:
  def maxSumAfterPartitioning(self, arr: list[int], k: int) -> int:
    n = len(arr)
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
      mx = -math.inf
      for j in range(1, min(i, k) + 1):
        mx = max(mx, arr[i - j])
        dp[i] = max(dp[i], dp[i - j] + mx * j)

    return dp[n]"
"1044","class Solution:
  def longestDupSubstring(self, s: str) -> str:
    kBase = 26
    kHash = 1_000_000_007
    bestStart = -1
    l = 1
    r = len(s)

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c)

    # k := the length of the substring to be hashed
    def getStart(k: int) -> int | None:
      maxPow = pow(kBase, k - 1, kHash)
      hashToStart = collections.defaultdict(list)
      h = 0

      # Compute the hash value of s[:k].
      for i in range(k):
        h = (h * kBase + val(s[i])) % kHash
      hashToStart[h].append(0)

      # Compute the rolling hash by Rabin Karp.
      for i in range(k, len(s)):
        startIndex = i - k + 1
        h = (h - maxPow * val(s[i - k])) % kHash
        h = (h * kBase + val(s[i])) % kHash
        if h in hashToStart:
          currSub = s[startIndex:startIndex + k]
          for start in hashToStart[h]:
            if s[start:start + k] == currSub:
              return startIndex
        hashToStart[h].append(startIndex)

    while l < r:
      m = (l + r) // 2
      start: int | None = getStart(m)
      if start:
        bestStart = start
        l = m + 1
      else:
        r = m

    if bestStart == -1:
      return ''
    if getStart(l):
      return s[bestStart:bestStart + l]
    return s[bestStart:bestStart + l - 1]"
"1045","SELECT customer_id
FROM Customer
GROUP BY 1
HAVING COUNT(DISTINCT product_key) = (
    SELECT COUNT(*) FROM Product
  );"
"1046","class Solution:
  def lastStoneWeight(self, stones: list[int]) -> int:
    pq = [-stone for stone in stones]
    heapq.heapify(pq)

    while len(pq) >= 2:
      n1 = -heapq.heappop(pq)
      n2 = -heapq.heappop(pq)
      if n1 != n2:
        heapq.heappush(pq, -(n1 - n2))

    return 0 if not pq else -pq[0]"
"1047","class Solution {
  public String removeDuplicates(final String S) {
    StringBuilder sb = new StringBuilder();

    for (final char c : S.toCharArray()) {
      final int n = sb.length();
      if (n > 0 && sb.charAt(n - 1) == c)
        sb.deleteCharAt(n - 1);
      else
        sb.append(c);
    }

    return sb.toString();
  }
}"
"1048","class Solution:
  def longestStrChain(self, words: list[str]) -> int:
    wordsSet = set(words)

    @functools.lru_cache(None)
    def dp(s: str) -> int:
      """"""Returns the longest chain where s is the last word.""""""
      ans = 1
      for i in range(len(s)):
        pred = s[:i] + s[i + 1:]
        if pred in wordsSet:
          ans = max(ans, dp(pred) + 1)
      return ans

    return max(dp(word) for word in words)"
"1049","class Solution:
  def lastStoneWeightII(self, stones: list[int]) -> int:
    summ = sum(stones)
    s = 0
    dp = [True] + [False] * summ

    for stone in stones:
      for w in range(summ // 2 + 1)[::-1]:
        if w >= stone:
          dp[w] = dp[w] or dp[w - stone]
        if dp[w]:
          s = max(s, w)

    return summ - 2 * s"
"105","class Solution:
  def buildTree(
      self,
      preorder: list[int],
      inorder: list[int],
  ) -> TreeNode | None:
    inToIndex = {num: i for i, num in enumerate(inorder)}

    def build(
        preStart: int,
        preEnd: int,
        inStart: int,
        inEnd: int,
    ) -> TreeNode | None:
      if preStart > preEnd:
        return None

      rootVal = preorder[preStart]
      rootInIndex = inToIndex[rootVal]
      leftSize = rootInIndex - inStart

      root = TreeNode(rootVal)
      root.left = build(preStart + 1, preStart + leftSize,
                        inStart, rootInIndex - 1)
      root.right = build(preStart + leftSize + 1,
                         preEnd, rootInIndex + 1, inEnd)
      return root

    return build(0, len(preorder) - 1, 0, len(inorder) - 1)"
"1050","SELECT actor_id, director_id
FROM ActorDirector
GROUP BY 1, 2
HAVING COUNT(*) >= 3;"
"1051","class Solution:
  def heightChecker(self, heights: list[int]) -> int:
    ans = 0
    currentHeight = 1
    count = [0] * 101

    for height in heights:
      count[height] += 1

    for height in heights:
      while count[currentHeight] == 0:
        currentHeight += 1
      if height != currentHeight:
        ans += 1
      count[currentHeight] -= 1

    return ans"
"1052","class Solution:
  def maxSatisfied(
      self,
      customers: list[int],
      grumpy: list[int],
      X: int,
  ) -> int:
    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)
    madeSatisfied = 0
    windowSatisfied = 0

    for i, customer in enumerate(customers):
      if grumpy[i] == 1:
        windowSatisfied += customer
      if i >= X and grumpy[i - X] == 1:
        windowSatisfied -= customers[i - X]
      madeSatisfied = max(madeSatisfied, windowSatisfied)

    return satisfied + madeSatisfied"
"1053","class Solution:
  def prevPermOpt1(self, arr: list[int]) -> list[int]:
    n = len(arr)
    l = n - 2
    r = n - 1

    while l >= 0 and arr[l] <= arr[l + 1]:
      l -= 1
    if l < 0:
      return arr
    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:
      r -= 1
    arr[l], arr[r] = arr[r], arr[l]

    return arr"
"1054","class Solution:
  def rearrangeBarcodes(self, barcodes: list[int]) -> list[int]:
    ans = [0] * len(barcodes)
    count = collections.Counter(barcodes)
    i = 0  # ans' index
    maxNum = max(count, key=count.get)

    def fillAns(num: int) -> None:
      nonlocal i
      while count[num]:
        ans[i] = num
        i = i + 2 if i + 2 < len(barcodes) else 1
        count[num] -= 1

    fillAns(maxNum)
    for num in count.keys():
      fillAns(num)

    return ans"
"1055","class Solution {
 public:
  int shortestWay(string source, string target) {
    const int m = source.length();
    const int n = target.length();
    // dp[i][c] := the earliest index >= i s.t. source[index] = c
    // dp[i][c] := -1 if c isn't in the source
    vector<vector<int>> dp(m, vector<int>(26, -1));

    dp[m - 1][source[m - 1] - 'a'] = m - 1;
    for (int i = m - 2; i >= 0; --i) {
      dp[i] = dp[i + 1];
      dp[i][source[i] - 'a'] = i;
    }

    int ans = 0;
    int i = 0;  // source's index

    for (const char c : target) {
      if (dp[0][c - 'a'] == -1)
        return -1;
      // If there are no c's left in source that occur more than i times but
      // there are c's from earlier in the subsequence, add 1 to subsequence
      // count and reset source's index to 0.
      if (dp[i][c - 'a'] == -1) {
        ++ans;
        i = 0;
      }
      // Continue taking letters from the subsequence.
      i = dp[i][c - 'a'] + 1;
      if (i == m) {
        ++ans;
        i = 0;
      }
    }

    return ans + (i == 0 ? 0 : 1);
  }
};"
"1056","class Solution:
  def confusingNumber(self, n: int) -> bool:
    s = str(n)
    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    rotatedNum = []

    for c in s[::-1]:
      if c not in rotated:
        return False
      rotatedNum.append(rotated[c])

    return ''.join(rotatedNum) != s"
"1057","class Solution:
  def assignBikes(
      self,
      workers: list[list[int]],
      bikes: list[list[int]],
  ) -> list[int]:
    ans = [-1] * len(workers)
    usedBikes = [False] * len(bikes)
    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])
    buckets = [[] for _ in range(2001)]

    def dist(p1: list[int], p2: list[int]) -> int:
      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    for i, worker in enumerate(workers):
      for j, bike in enumerate(bikes):
        buckets[dist(worker, bike)].append((i, j))

    for k in range(2001):
      for i, j in buckets[k]:
        if ans[i] == -1 and not usedBikes[j]:
          ans[i] = j
          usedBikes[j] = True

    return ans"
"1058","class Solution:
  def minimizeError(self, prices: list[str], target: int) -> str:
    # A[i] := (costCeil - costFloor, costCeil, costFloor)
    # The lower the costCeil - costFloor is, the cheaper to ceil it.
    A = []
    sumFloored = 0
    sumCeiled = 0

    for price in map(float, prices):
      floored = math.floor(price)
      ceiled = math.ceil(price)
      sumFloored += floored
      sumCeiled += ceiled
      costFloor = price - floored
      costCeil = ceiled - price
      A.append((costCeil - costFloor, costCeil, costFloor))

    if not sumFloored <= target <= sumCeiled:
      return '-1'

    A.sort()
    nCeiled = target - sumFloored
    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +
                           sum(a[2] for a in A[nCeiled:]))"
"1059","enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool leadsToDestination(int n, vector<vector<int>>& edges, int source,
                          int destination) {
    vector<vector<int>> graph(n);
    vector<State> states(n);

    for (const vector<int>& edge : edges)
      graph[e[0]].push_back(e[1]);

    return acyclic(graph, source, destination, states);
  }

 private:
  bool acyclic(const vector<vector<int>>& graph, int u, int dest,
               vector<State>& states) {
    if (graph[u].empty())
      return u == dest;
    if (states[u] == State::kVisiting)
      return false;
    if (states[u] == State::kVisited)
      return true;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (!acyclic(graph, v, dest, states))
        return false;
    states[u] = State::kVisited;

    return true;
  }
};"
"106","class Solution:
  def buildTree(
      self,
      inorder: list[int],
      postorder: list[int],
  ) -> TreeNode | None:
    inToIndex = {num: i for i, num in enumerate(inorder)}

    def build(
        inStart: int,
        inEnd: int,
        postStart: int,
        postEnd: int,
    ) -> TreeNode | None:
      if inStart > inEnd:
        return None

      rootVal = postorder[postEnd]
      rootInIndex = inToIndex[rootVal]
      leftSize = rootInIndex - inStart

      root = TreeNode(rootVal)
      root.left = build(inStart, rootInIndex - 1,  postStart,
                        postStart + leftSize - 1)
      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,
                         postEnd - 1)
      return root

    return build(0, len(inorder) - 1, 0, len(postorder) - 1)"
"1060","class Solution {
  public int missingElement(int[] nums, int k) {
    int l = 0;
    int r = nums.length;

    // Find the first index l s.t. nMissing(l) >= k
    while (l < r) {
      final int m = (l + r) / 2;
      if (nMissing(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return nums[l - 1] + (k - nMissing(nums, l - 1));
  }

  // the number of missing numbers in [nums[0], nums[i]]
  private int nMissing(int[] nums, int i) {
    return nums[i] - nums[0] - i;
  }
}"
"1061","class UnionFind {
  public UnionFind(int n) {
    id = new int[n];
    for (int i = 0; i < n; ++i)
      id[i] = i;
  }

  public void union(int u, int v) {
    final int i = find(u);
    final int j = find(v);
    if (i > j)
      id[i] = j;
    else
      id[j] = i;
  }

  public int find(int u) {
    return id[u] == u ? u : (id[u] = find(id[u]));
  }

  private int[] id;
}

class Solution {
  public String smallestEquivalentString(String s1, String s2, String baseStr) {
    StringBuilder sb = new StringBuilder();
    UnionFind uf = new UnionFind(26);

    for (int i = 0; i < s1.length(); ++i)
      uf.union(s1.charAt(i) - 'a', s2.charAt(i) - 'a');

    for (final char c : baseStr.toCharArray())
      sb.append((char) ('a' + uf.find(c - 'a')));

    return sb.toString();
  }
}"
"1062","class Solution:
  def longestRepeatingSubstring(self, s: str) -> int:
    n = len(s)
    ans = 0
    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)
    dp = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
      for j in range(i + 1, n + 1):
        if s[i - 1] == s[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]
          ans = max(ans, dp[i][j])

    return ans"
"1063","class Solution:
  def validSubarrays(self, nums: list[int]) -> int:
    # For each `num` in `nums`, each element x in the stack can be the leftmost
    # element s.t. [x, num] forms a valid subarray, so the size of the stack is
    # the number of valid subarrays ending in the current number.
    #
    # e.g. nums = [1, 3, 2]
    # num = 1, stack = [1] -> valid subarray is [1]
    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]
    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]
    ans = 0
    stack = []

    for num in nums:
      while stack and stack[-1] > num:
        stack.pop()
      stack.append(num)
      ans += len(stack)

    return ans"
"1064","class Solution:
  def fixedPoint(self, arr: list[int]) -> int:
    l = 0
    r = len(arr) - 1

    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.
    # Therefore, binary search `arr` for the first arr[i] - i = 0.
    while l < r:
      m = (l + r) // 2
      if arr[m] - m >= 0:
        r = m
      else:
        l = m + 1

    return l if arr[l] == l else -1"
"1065","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.isWord = False


class Solution:
  def indexPairs(self, text: str, words: list[str]) -> list[list[int]]:
    ans = []
    root = TrieNode()

    for word in words:
      node: TrieNode = root
      for c in word:
        node = node.children.setdefault(c, TrieNode())
      node.isWord = True

    # Scan each text[i..j].
    for i in range(len(text)):
      node: TrieNode = root
      for j in range(i, len(text)):
        c = text[j]
        if c not in node.children:
          break
        node = node.children[c]
        if node.isWord:
          ans.append([i, j])

    return ans"
"1066","class Solution:
  def assignBikes(
      self,
      workers: list[list[int]],
      bikes: list[list[int]],
  ) -> int:
    def dist(p1: list[int], p2: list[int]) -> int:
      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    @functools.lru_cache(None)
    def dp(workerIndex: int, used: int) -> int:
      """"""
      Returns the minimum Manhattan distances to assign bikes to
      workers[workerIndex..n), where `used` is the bitmask of the used bikes.
      """"""
      if workerIndex == len(workers):
        return 0
      return min(
          (dist(workers[workerIndex],
                bike) + dp(workerIndex + 1, used | 1 << i) for i,
           bike in enumerate(bikes) if not used >> i & 1),
          default=math.inf)

    return dp(0, 0)"
"1067","class Solution {
  public int digitsCount(int d, int low, int high) {
    return countDigit(high, d) - countDigit(low - 1, d);
  }

  private int countDigit(int n, int d) {
    int count = 0;

    for (int pow10 = 1; pow10 <= n; pow10 *= 10) {
      final int divisor = pow10 * 10;
      final int quotient = n / divisor;
      final int remainder = n % divisor;
      if (quotient > 0)
        count += quotient * pow10;
      if (d == 0)
        count -= pow10;
      if (remainder >= d * pow10)
        count += Math.min(remainder - d * pow10 + 1, pow10);
    }

    return count;
  }
}"
"1068","SELECT
  Product.product_name,
  Sales.year,
  Sales.price
FROM Sales
INNER JOIN Product
  USING (product_id);"
"1069","SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales
GROUP BY 1;"
"107","class Solution:
  def levelOrderBottom(self, root: TreeNode | None) -> list[list[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      currLevel = []
      for _ in range(len(q)):
        node = q.popleft()
        currLevel.append(node.val)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      ans.append(currLevel)

    return ans[::-1]"
"1070","WITH
  ProductToYear AS (
    SELECT product_id, MIN(year) AS year
    FROM Sales
    GROUP BY 1
  )
SELECT
  Sales.product_id,
  ProductToYear.year AS first_year,
  Sales.quantity,
  Sales.price
FROM Sales
INNER JOIN ProductToYear
  USING (product_id, year);"
"1071","class Solution:
  def gcdOfStrings(self, str1: str, str2: str) -> str:
    def mod(s1: str, s2: str) -> str:
      while s1.startswith(s2):
        s1 = s1[len(s2):]
      return s1

    if len(str1) < len(str2):
      return self.gcdOfStrings(str2, str1)
    if not str1.startswith(str2):
      return ''
    if not str2:
      return str1
    return self.gcdOfStrings(str2, mod(str1, str2))"
"1072","class Solution:
  def maxEqualRowsAfterFlips(self, matrix: list[list[int]]) -> int:
    patterns = [tuple(a ^ row[0] for a in row) for row in matrix]
    return max(Counter(patterns).values())"
"1073","class Solution:
  def addNegabinary(self, arr1: list[int], arr2: list[int]) -> list[int]:
    ans = []
    carry = 0

    while carry != 0 or arr1 or arr2:
      if arr1:
        carry += arr1.pop()
      if arr2:
        carry += arr2.pop()
      ans.append(carry & 1)
      carry = -(carry >> 1)

    while len(ans) > 1 and ans[-1] == 0:
      ans.pop()

    return ans[::-1]"
"1074","class Solution:
  def numSubmatrixSumTarget(self, matrix: list[list[int]], target: int) -> int:
    m = len(matrix)
    n = len(matrix[0])
    ans = 0

    # Transfer each row in the matrix to the prefix sum.
    for row in matrix:
      for i in range(1, n):
        row[i] += row[i - 1]

    for baseCol in range(n):
      for j in range(baseCol, n):
        prefixCount = collections.Counter({0: 1})
        summ = 0
        for i in range(m):
          if baseCol > 0:
            summ -= matrix[i][baseCol - 1]
          summ += matrix[i][j]
          ans += prefixCount[summ - target]
          prefixCount[summ] += 1

    return ans"
"1075","SELECT
  Project.project_id,
  ROUND(AVG(Employee.experience_years), 2) AS average_years
FROM Project
INNER JOIN Employee
  USING (employee_id)
GROUP BY 1;"
"1076","WITH
  RankedProjects AS (
    SELECT project_id, RANK() OVER(ORDER BY COUNT(*) DESC) AS `rank`
    FROM Project
    GROUP BY 1
  )
SELECT project_id
FROM RankedProjects
WHERE `rank` = 1;"
"1077","WITH
  RankedProjectToEmployee AS (
    SELECT
      Project.project_id,
      Project.employee_id,
      RANK() OVER(
        PARTITION BY Project.project_id
        ORDER BY Employee.experience_years DESC
      ) AS `rank`
    FROM Project
    INNER JOIN Employee
      USING (employee_id)
  )
SELECT project_id, employee_id
FROM RankedProjectToEmployee
WHERE `rank` = 1;"
"1078","class Solution:
  def findOcurrences(self, text: str, first: str, second: str) -> list[str]:
    words = text.split()
    return [c for a, b, c in zip(words, words[1:], words[2:]) if a == first and b == second]"
"1079","class Solution:
  def numTilePossibilities(self, tiles: str) -> int:
    count = collections.Counter(tiles)

    def dfs(count: dict[int, int]) -> int:
      possibleSequences = 0

      for k, v in count.items():
        if v == 0:
          continue
        # Put c in the current position. We only care about the number of possible
        # sequences of letters but don't care about the actual combination.
        count[k] -= 1
        possibleSequences += 1 + dfs(count)
        count[k] += 1

      return possibleSequences

    return dfs(count)"
"108","class Solution:
  def sortedArrayToBST(self, nums: list[int]) -> TreeNode | None:
    def build(l: int, r: int) -> TreeNode | None:
      if l > r:
        return None
      m = (l + r) // 2
      return TreeNode(nums[m],
                      build(l, m - 1),
                      build(m + 1, r))

    return build(0, len(nums) - 1)"
"1080","class Solution:
  def sufficientSubset(
      self,
      root: TreeNode | None,
      limit: int
  ) -> TreeNode | None:
    if not root:
      return None
    if not root.left and not root.right:
      return None if root.val < limit else root
    root.left = self.sufficientSubset(root.left, limit - root.val)
    root.right = self.sufficientSubset(root.right, limit - root.val)
    return None if not root.left and not root.right else root"
"1081","class Solution:
  def smallestSubsequence(self, text: str) -> str:
    ans = []
    count = collections.Counter(text)
    used = [False] * 26

    for c in text:
      count[c] -= 1
      if used[string.ascii_lowercase.index(c)]:
        continue
      while ans and ans[-1] > c and count[ans[-1]] > 0:
        used[ord(ans[-1]) - ord('a')] = False
        ans.pop()
      ans.append(c)
      used[ord(ans[-1]) - ord('a')] = True

    return ''.join(ans)"
"1082","WITH
  SellerToPrice AS (
    SELECT seller_id, SUM(price) AS price
    FROM Sales
    GROUP BY 1
  )
SELECT seller_id
FROM SellerToPrice
WHERE price = (
    SELECT MAX(price)
    FROM SellerToPrice
  );"
"1083","SELECT Sales.buyer_id
FROM Sales
INNER JOIN Product
  USING (product_id)
GROUP BY 1
HAVING
  SUM(Product.product_name = 'S8') > 0
  AND SUM(Product.product_name = 'iPhone') = 0;"
"1084","SELECT
  Product.product_id,
  Product.product_name
FROM Product
INNER JOIN Sales
  USING (product_id)
GROUP BY 1, 2
HAVING SUM(
    Sales.sale_date < '2019-01-01'
    OR Sales.sale_date > '2019-03-31'
  ) = 0;"
"1085","class Solution:
  def sumOfDigits(self, nums: list[int]) -> int:
    return sum(int(d) for d in str(min(nums))) & 1 ^ 1"
"1086","class Solution:
  def highFive(self, items: list[list[int]]) -> list[list[int]]:
    idToScores = collections.defaultdict(list)

    for id, score in items:
      heapq.heappush(idToScores[id], score)
      if len(idToScores[id]) > 5:
        heapq.heappop(idToScores[id])

    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]"
"1087","class Solution:
  def expand(self, s: str) -> list[str]:
    ans = []

    def dfs(i: int, path: list[str]) -> None:
      if i == len(s):
        ans.append(''.join(path))
        return
      if s[i] == '{':
        nextRightBraceIndex = s.find('}', i)
        for c in s[i + 1:nextRightBraceIndex].split(','):
          path.append(c)
          dfs(nextRightBraceIndex + 1, path)
          path.pop()
      else:  # s[i] != '{'
        path.append(s[i])
        dfs(i + 1, path)
        path.pop()

    dfs(0, [])
    return sorted(ans)"
"1088","class Solution:
  def confusingNumberII(self, n: int) -> int:
    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]

    def dfs(num: int, rotatedNum: int, unit: int) -> int:
      ans = 0 if num == rotatedNum else 1
      # Add one more digit
      for digit, rotated in digitToRotated:
        if digit == 0 and num == 0:
          continue
        nextNum = num * 10 + digit
        if nextNum > n:
          break
        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)
      return ans

    return dfs(0, 0, 1)"
"1089","class Solution:
  def duplicateZeros(self, arr: list[int]) -> None:
    zeros = arr.count(0)
    i = len(arr) - 1
    j = len(arr) + zeros - 1

    while i < j:
      if j < len(arr):
        arr[j] = arr[i]
      if arr[i] == 0:
        j -= 1
        if j < len(arr):
          arr[j] = arr[i]
      i -= 1
      j -= 1"
"109","class Solution:
  def sortedListToBST(self, head: ListNode) -> TreeNode:
    def findMid(head: ListNode) -> ListNode:
      prev = None
      slow = head
      fast = head

      while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
      prev.next = None

      return slow

    if not head:
      return None
    if not head.next:
      return TreeNode(head.val)

    mid = findMid(head)
    root = TreeNode(mid.val)
    root.left = self.sortedListToBST(head)
    root.right = self.sortedListToBST(mid.next)
    return root"
"1090","class Solution {
 public:
  int largestValsFromLabels(vector<int>& values, vector<int>& labels,
                            int numWanted, int useLimit) {
    const int n = values.size();
    int ans = 0;
    vector<pair<int, int>> items;
    unordered_map<int, int> labelsUsed;

    for (int i = 0; i < n; ++i)
      items.emplace_back(values[i], labels[i]);

    ranges::sort(items, ranges::greater{},
                 [](const pair<int, int>& item) { return item.first; });

    for (const auto& [value, label] : items)
      if (labelsUsed[label] < useLimit) {
        ans += value;
        ++labelsUsed[label];
        if (--numWanted == 0)
          break;
      }

    return ans;
  }
};"
"1091","class Solution {
 public:
  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    const int n = grid.size();
    if (grid[0][0] == 0 && n == 1)
      return 1;
    if (grid[0][0] == 1 || grid.back().back() == 1)
      return -1;

    constexpr int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                {0, 1},   {1, -1}, {1, 0},  {1, 1}};
    queue<pair<int, int>> q{{{0, 0}}};
    vector<vector<bool>> seen(n, vector<bool>(n));
    seen[0][0] = true;

    for (int step = 1; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (grid[x][y] != 0 || seen[x][y])
            continue;
          if (x == n - 1 && y == n - 1)
            return step + 1;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }

    return -1;
  }
};"
"1092","class Solution {
  public String shortestCommonSupersequence(String str1, String str2) {
    StringBuilder sb = new StringBuilder();
    int i = 0; // str1's index
    int j = 0; // str2's index

    for (final char c : lcs(str1, str2).toCharArray()) {
      // Append the letters that are not part of the LCS.
      while (str1.charAt(i) != c)
        sb.append(str1.charAt(i++));
      while (str2.charAt(j) != c)
        sb.append(str2.charAt(j++));
      // Append the letter of the LCS and match it with str1 and str2.
      sb.append(c);
      ++i;
      ++j;
    }

    // Append the remaining letters.
    return sb.toString() + str1.substring(i) + str2.substring(j);
  }

  private String lcs(final String a, final String b) {
    final int m = a.length();
    final int n = b.length();
    // dp[i][j] := the length of LCS(a[0..i), b[0..j))
    StringBuilder[][] dp = new StringBuilder[m + 1][n + 1];

    for (final StringBuilder[] row : dp)
      for (int i = 0; i < row.length; ++i)
        row[i] = new StringBuilder();

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (a.charAt(i - 1) == b.charAt(j - 1))
          dp[i][j].append(dp[i - 1][j - 1]).append(a.charAt(i - 1));
        else
          dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length() ? dp[i - 1][j] : dp[i][j - 1];

    return dp[m][n].toString();
  }
}"
"1093","class Solution:
  def sampleStats(self, count: list[int]) -> list[float]:
    minimum = next((i for i, num in enumerate(count) if num), None)
    maximum = next((i for i, num in reversed(
        list(enumerate(count))) if num), None)
    n = sum(count)
    mean = sum(i * c / n for i, c in enumerate(count))
    mode = count.index(max(count))

    numCount = 0
    leftMedian = 0
    for i, c in enumerate(count):
      numCount += c
      if numCount >= n / 2:
        leftMedian = i
        break

    numCount = 0
    rightMedian = 0
    for i, c in reversed(list(enumerate(count))):
      numCount += c
      if numCount >= n / 2:
        rightMedian = i
        break

    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]"
"1094","class Solution {
  public boolean carPooling(int[][] trips, int capacity) {
    int currentPassengers = 0;
    int[] line = new int[1001];

    for (int[] trip : trips) {
      final int nPassengers = trip[0];
      final int start = trip[1];
      final int end = trip[2];
      line[start] += nPassengers;
      line[end] -= nPassengers;
    }

    for (final int passengerChange : line) {
      currentPassengers += passengerChange;
      if (currentPassengers > capacity)
        return false;
    }

    return true;
  }
}"
"1095","# """"""
# This is MountainArray's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# Class MountainArray:
#   def get(self, index: int) -> int:
#   def length(self) -> int:

class Solution:
  def findInMountainArray(
      self,
      target: int,
      mountain_arr: 'MountainArray',
  ) -> int:
    n = mountain_arr.length()
    peakIndex = self.peakIndexInMountainArray(mountain_arr, 0, n - 1)

    leftIndex = self.searchLeft(mountain_arr, target, 0, peakIndex)
    if mountain_arr.get(leftIndex) == target:
      return leftIndex

    rightIndex = self.searchRight(mountain_arr, target, peakIndex + 1, n - 1)
    if mountain_arr.get(rightIndex) == target:
      return rightIndex

    return -1

  # 852. Peak Index in a Mountain Array
  def peakIndexInMountainArray(self, A: 'MountainArray', l: int, r: int) -> int:
    while l < r:
      m = (l + r) // 2
      if A.get(m) < A.get(m + 1):
        l = m + 1
      else:
        r = m
    return l

  def searchLeft(self, A: 'MountainArray', target: int, l: int, r: int) -> int:
    while l < r:
      m = (l + r) // 2
      if A.get(m) < target:
        l = m + 1
      else:
        r = m
    return l

  def searchRight(self, A: 'MountainArray', target: int, l: int, r: int) -> int:
    while l < r:
      m = (l + r) // 2
      if A.get(m) > target:
        l = m + 1
      else:
        r = m
    return l"
"1096","class Solution:
  def braceExpansionII(self, expression: str) -> list[str]:
    def merge(groups: list[list[str]], group: list[str]) -> None:
      if not groups[-1]:
        groups[-1] = group
        return

      groups[-1] = [word1 + word2 for word1 in groups[-1]
                    for word2 in group]

    def dfs(s: int, e: int) -> list[str]:
      groups = [[]]
      layer = 0

      for i in range(s, e + 1):
        c = expression[i]
        if c == '{':
          layer += 1
          if layer == 1:
            left = i + 1
        elif c == '}':
          layer -= 1
          if layer == 0:
            group = dfs(left, i - 1)
            merge(groups, group)
        elif c == ',' and layer == 0:
          groups.append([])
        elif layer == 0:
          merge(groups, [c])

      return sorted(list({word for group in groups for word in group}))

    return dfs(0, len(expression) - 1)"
"1097","WITH
  PlayerToInstallDate AS (
    SELECT player_id, MIN(event_date) AS install_dt
    FROM Activity
    GROUP BY 1
  )
SELECT PlayerToInstallDate.install_dt,
  COUNT(*) AS installs,
  ROUND(
    SUM(IF(Activity.event_date, 1, 0)) / COUNT(PlayerToInstallDate.install_dt),
    2
  ) AS Day1_retention
FROM PlayerToInstallDate
LEFT JOIN Activity
  ON (
    PlayerToInstallDate.player_id = Activity.player_id
    AND DATEDIFF(Activity.event_date, PlayerToInstallDate.install_dt) = 1)
GROUP BY 1;"
"1098","SELECT
  Books.book_id,
  ANY_VALUE(Books.name) AS name
FROM Books
LEFT JOIN Orders
  ON (
    Books.book_id = Orders.book_id
    AND Orders.dispatch_date BETWEEN '2018-06-23' AND '2019-06-23')
WHERE DATEDIFF('2019-06-23', Books.available_from) > 30
GROUP BY 1
HAVING IFNULL(SUM(Orders.quantity), 0) < 10;"
"1099","class Solution:
  def twoSumLessThanK(self, nums: list[int], k: int) -> int:
    if len(nums) < 2:
      return -1

    ans = -1  # Note the constrathat nums[i] > 0.
    l = 0
    r = len(nums) - 1

    nums.sort()

    while l < r:
      if nums[l] + nums[r] < k:
        ans = max(ans, nums[l] + nums[r])
        l += 1
      else:
        r -= 1

    return ans"
"11","class Solution:
  def maxArea(self, height: list[int]) -> int:
    ans = 0
    l = 0
    r = len(height) - 1

    while l < r:
      minHeight = min(height[l], height[r])
      ans = max(ans, minHeight * (r - l))
      if height[l] < height[r]:
        l += 1
      else:
        r -= 1

    return ans"
"110","class Solution:
  def isBalanced(self, root: TreeNode | None) -> bool:
    def maxDepth(root: TreeNode | None) -> int:
      """"""Returns the height of root if root is balanced; otherwise, returns -1.""""""
      if not root:
        return 0

      left = maxDepth(root.left)
      if left == -1:
        return -1
      right = maxDepth(root.right)
      if right == -1:
        return -1
      if abs(left - right) > 1:
        return -1

      return 1 + max(maxDepth(root.left), maxDepth(root.right))

    return maxDepth(root) != -1"
"1100","class Solution:
  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
    ans = 0
    unique = 0
    count = collections.Counter()

    for i, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        unique += 1
      if i >= k:
        count[s[i - k]] -= 1
        if count[s[i - k]] == 0:
          unique -= 1
        if unique == k:
          ans += 1

    return ans"
"1101","class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1

  def getCount(self) -> int:
    return self.count

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def earliestAcq(self, logs: list[list[int]], n: int) -> int:
    uf = UnionFind(n)

    # Sort `logs` by timestamp.
    logs.sort(key=lambda x: x[0])

    for timestamp, x, y in logs:
      uf.unionByRank(x, y)
      if uf.getCount() == 1:
        return timestamp

    return -1"
"1102","class Solution {
  public int maximumMinimumPath(int[][] grid) {
    record T(int i, int j, int val) {}
    final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    final int m = grid.length;
    final int n = grid[0].length;
    int ans = grid[0][0];
    boolean[][] seen = new boolean[m][n];
    Queue<T> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b.val, a.val)) {
      { offer(new T(0, 0, grid[0][0])); }
    };

    while (!maxHeap.isEmpty()) {
      final int i = maxHeap.peek().i;
      final int j = maxHeap.peek().j;
      final int val = maxHeap.poll().val;
      ans = Math.min(ans, val);
      if (i == m - 1 && j == n - 1)
        return ans;
      seen[i][j] = true;
      for (int[] dir : dirs) {
        final int x = i + dir[0];
        final int y = j + dir[1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        maxHeap.offer(new T(x, y, grid[x][y]));
      }
    }

    throw new IllegalArgumentException();
  }
}"
"1103","class Solution:
  def distributeCandies(self, candies: int, n: int) -> list[int]:
    ans = [0] * n
    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))
    accumN = rows * (rows - 1) * n // 2

    for i in range(n):
      ans[i] = accumN + rows * (i + 1)

    givenCandies = (n**2 * rows**2 + n * rows) // 2
    candies -= givenCandies
    lastGiven = rows * n
    i = 0

    while candies > 0:
      lastGiven += 1
      actualGiven = min(lastGiven, candies)
      candies -= actualGiven
      ans[i] += actualGiven
      i += 1

    return ans"
"1104","class Solution:
  def pathInZigZagTree(self, label: int) -> list[int]:
    def boundarySum(level: int):
      return 2**level + 2**(level + 1) - 1

    ans = []

    for l in range(21):
      if 2**l > label:
        level = l - 1
        break

    if level % 2 == 1:
      label = boundarySum(level) - label

    for l in reversed(range(level + 1)):
      ans.append(label if l % 2 == 0 else boundarySum(l) - label)
      label //= 2

    return ans[::-1]"
"1105","class Solution:
  def minHeightShelves(self, books: list[list[int]], shelfWidth: int) -> int:
    # dp[i] := the minimum height to place the first i books
    dp = [0] + [math.inf] * len(books)

    for i in range(len(books)):
      sumThickness = 0
      maxHeight = 0
      # Place books[j..i] on a new shelf.
      for j in range(i, -1, -1):
        thickness, height = books[j]
        sumThickness += thickness
        if sumThickness > shelfWidth:
          break
        maxHeight = max(maxHeight, height)
        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)

    return dp[-1]"
"1106","class Solution:
  def parseBoolExpr(self, expression: str) -> bool:
    def dfs(s: int, e: int) -> list[str]:
      if s == e:
        return True if expression[s] == 't' else False

      exps = []
      layer = 0

      for i in range(s, e + 1):
        c = expression[i]
        if layer == 0 and c in '!&|':
          op = c
        elif c == '(':
          layer += 1
          if layer == 1:
            left = i + 1
        elif c == ')':
          layer -= 1
          if layer == 0:
            exps.append(dfs(left, i - 1))
        elif c == ',' and layer == 1:
          exps.append(dfs(left, i - 1))
          left = i + 1

      if op == '|':
        return functools.reduce(operator.or_, exps)
      if op == '&':
        return functools.reduce(operator.and_, exps)
      if op == '!':
        return not exps[0]

    return dfs(0, len(expression) - 1)"
"1107","WITH
  UserToLoginDate AS (
    SELECT
      user_id,
      MIN(activity_date) AS login_date
    FROM Traffic
    WHERE activity = 'login'
    GROUP BY 1
  )
SELECT
  login_date,
  COUNT(*) AS user_count
FROM UserToLoginDate
WHERE DATEDIFF('2019-06-30', login_date) <= 90
GROUP BY 1;"
"1108","class Solution:
  def defangIPaddr(self, address: str) -> str:
    return address.replace('.', '[.]')"
"1109","class Solution:
  def corpFlightBookings(self, bookings: list[list[int]], n: int) -> list[int]:
    ans = [0] * n

    for booking in bookings:
      ans[booking[0] - 1] += booking[2]
      if booking[1] < n:
        ans[booking[1]] -= booking[2]

    for i in range(1, n):
      ans[i] += ans[i - 1]

    return ans"
"111","class Solution:
  def minDepth(self, root: TreeNode | None) -> int:
    if not root:
      return 0

    q = collections.deque([root])

    step = 1
    while q:
      for _ in range(len(q)):
        node = q.popleft()
        if not node.left and not node.right:
          return step
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      step += 1"
"1110","class Solution:
  def delNodes(self, root: TreeNode, to_delete: list[int]) -> list[TreeNode]:
    ans = []
    toDeleteSet = set(to_delete)

    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:
      if not root:
        return None

      deleted = root.val in toDeleteSet
      if isRoot and not deleted:
        ans.append(root)

      # If root is deleted, both children have the possibility to be a new root
      root.left = dfs(root.left, deleted)
      root.right = dfs(root.right, deleted)
      return None if deleted else root

    dfs(root, True)
    return ans"
"1111","class Solution:
  def maxDepthAfterSplit(self, seq: str) -> list[int]:
    ans = []
    depth = 1

    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.
    for c in seq:
      if c == '(':
        depth += 1
        ans.append(depth % 2)
      else:
        ans.append(depth % 2)
        depth -= 1

    return ans"
"1112","WITH
  RankedEnrollments AS (
    SELECT
      student_id,
      course_id,
      grade,
      RANK() OVER(
        PARTITION BY student_id
        ORDER BY grade DESC, course_id
      ) AS `rank`
    FROM Enrollments
  )
SELECT
  student_id,
  course_id,
  grade
FROM RankedEnrollments
WHERE `rank` = 1;"
"1113","SELECT
  extra AS report_reason,
  COUNT(DISTINCT post_id) AS report_count
FROM Actions
WHERE
  ACTION = 'report'
  AND DATEDIFF('2019-07-05', action_date) = 1
GROUP BY 1;"
"1114","from threading import Lock


class Foo:
  def __init__(self):
    self.firstDone = Lock()
    self.secondDone = Lock()
    self.firstDone.acquire()
    self.secondDone.acquire()

  def first(self, printFirst: 'Callable[[], None]') -> None:
    printFirst()
    self.firstDone.release()

  def second(self, printSecond: 'Callable[[], None]') -> None:
    self.firstDone.acquire()
    printSecond()
    self.secondDone.release()

  def third(self, printThird: 'Callable[[], None]') -> None:
    self.secondDone.acquire()
    printThird()"
"1115","from threading import Semaphore


class FooBar:
  def __init__(self, n):
    self.n = n
    self.fooSemaphore = Semaphore(1)
    self.barSemaphore = Semaphore(0)

  def foo(self, printFoo: 'Callable[[], None]') -> None:
    for _ in range(self.n):
      self.fooSemaphore.acquire()
      printFoo()
      self.barSemaphore.release()

  def bar(self, printBar: 'Callable[[], None]') -> None:
    for _ in range(self.n):
      self.barSemaphore.acquire()
      printBar()
      self.fooSemaphore.release()"
"1116","from threading import Semaphore


class ZeroEvenOdd:
  def __init__(self, n):
    self.n = n
    self.zeroSemaphore = Semaphore(1)
    self.evenSemaphore = Semaphore(0)
    self.oddSemaphore = Semaphore(0)

  # printNumber(x) outputs ""x"", where x is an integer.
  def zero(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(self.n):
      self.zeroSemaphore.acquire()
      printNumber(0)
      (self.oddSemaphore if i & 2 == 0 else self.evenSemaphore).release()

  def even(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(2, self.n + 1, 2):
      self.evenSemaphore.acquire()
      printNumber(i)
      self.zeroSemaphore.release()

  def odd(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(1, self.n + 1, 2):
      self.oddSemaphore.acquire()
      printNumber(i)
      self.zeroSemaphore.release()"
"1117","// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class H2O {
 public:
  H2O() {
    sem_init(&hSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&oSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~H2O() {
    sem_destroy(&hSemaphore);
    sem_destroy(&oSemaphore);
  }

  void hydrogen(function<void()> releaseHydrogen) {
    sem_wait(&hSemaphore);
    ++h;
    // releaseHydrogen() outputs ""H"". Do not change or remove this line.
    releaseHydrogen();
    if (h % 2 == 0)
      sem_post(&oSemaphore);
    else
      sem_post(&hSemaphore);
  }

  void oxygen(function<void()> releaseOxygen) {
    sem_wait(&oSemaphore);
    // releaseOxygen() outputs ""O"". Do not change or remove this line.
    releaseOxygen();
    sem_post(&hSemaphore);
  }

 private:
  sem_t hSemaphore;
  sem_t oSemaphore;
  int h = 0;
};"
"1118","class Solution:
  def numberOfDays(self, year: int, month: int) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def isLeapYear(year: int) -> bool:
      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0
    return 29 if month == 2 and isLeapYear(year) else days[month]"
"1119","class Solution:
  def removeVowels(self, s: str) -> str:
    return re.sub('a|e|i|o|u', '', s)"
"112","class Solution:
  def hasPathSum(self, root: TreeNode, summ: int) -> bool:
    if not root:
      return False
    if root.val == summ and not root.left and not root.right:
      return True
    return (self.hasPathSum(root.left, summ - root.val) or
            self.hasPathSum(root.right, summ - root.val))"
"1120","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  summ: int
  count: int
  maxAverage: int


class Solution:
  def maximumAverageSubtree(self, root: TreeNode | None) -> float:
    def maximumAverage(root: TreeNode | None) -> T:
      if not root:
        return T(0, 0, 0)

      left = maximumAverage(root.left)
      right = maximumAverage(root.right)

      summ = root.val + left.summ + right.summ
      count = 1 + left.count + right.count
      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)
      return T(summ, count, maxAverage)

    return maximumAverage(root).maxAverage"
"1121","class Solution:
  def canDivideIntoSubsequences(self, nums: list[int], k: int) -> bool:
    # Find the number with the maxFreq, we need at least maxFreq * k elements
    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to
    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x
    # 3 = 6, which is impossible if len(nums) = 5
    return len(nums) >= k * max(Counter(nums).values())"
"1122","class Solution:
  def relativeSortArray(self, arr1: list[int], arr2: list[int]) -> list[int]:
    ans = []
    count = [0] * 1001

    for a in arr1:
      count[a] += 1

    for a in arr2:
      while count[a] > 0:
        ans.append(a)
        count[a] -= 1

    for num in range(1001):
      for _ in range(count[num]):
        ans.append(num)

    return ans"
"1123","class Solution {
  public TreeNode lcaDeepestLeaves(TreeNode root) {
    return dfs(root).lca;
  }

  private record T(TreeNode lca, int depth) {}

  private T dfs(TreeNode root) {
    if (root == null)
      return new T(null, 0);
    T left = dfs(root.left);
    T right = dfs(root.right);
    if (left.depth > right.depth)
      return new T(left.lca, left.depth + 1);
    if (left.depth < right.depth)
      return new T(right.lca, right.depth + 1);
    return new T(root, left.depth + 1);
  }
}"
"1124","class Solution:
  def longestWPI(self, hours: list[int]) -> int:
    ans = 0
    prefix = 0
    dict = {}

    for i in range(len(hours)):
      prefix += 1 if hours[i] > 8 else -1
      if prefix > 0:
        ans = i + 1
      else:
        if prefix not in dict:
          dict[prefix] = i
        if prefix - 1 in dict:
          ans = max(ans, i - dict[prefix - 1])

    return ans"
"1125","class Solution {
  public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {
    final int n = req_skills.length;
    final int nSkills = 1 << n;
    Map<String, Integer> skillToId = new HashMap();
    // dp[i] := the minimum people's indices to cover skillset of mask i
    List<Integer>[] dp = new List[nSkills];
    dp[0] = new ArrayList<>();

    for (int i = 0; i < req_skills.length; ++i)
      skillToId.put(req_skills[i], i);

    for (int i = 0; i < people.size(); ++i) {
      final int currSkill = getSkill(people.get(i), skillToId);
      for (int j = 0; j < nSkills; ++j) {
        if (dp[j] == null)
          continue;
        final int newSkillSet = currSkill | j;
        if (newSkillSet == j) // Adding people[i] doesn't increase skill set
          continue;
        if (dp[newSkillSet] == null || dp[newSkillSet].size() > dp[j].size() + 1) {
          dp[newSkillSet] = new ArrayList<>(dp[j]);
          dp[newSkillSet].add(i);
        }
      }
    }

    return dp[nSkills - 1].stream().mapToInt(Integer::intValue).toArray();
  }

  private int getSkill(List<String> person, Map<String, Integer> skillToId) {
    int mask = 0;
    for (final String skill : person)
      if (skillToId.containsKey(skill))
        mask |= 1 << skillToId.get(skill);
    return mask;
  }
}"
"1126","WITH
  AvgEvents AS (
    SELECT
      business_id,
      AVG(occurences) OVER(PARTITION BY event_type) AS event_avg_occurences,
      occurences
    FROM Events
  )
SELECT business_id
FROM AvgEvents
GROUP BY 1
HAVING SUM(IF(occurences > event_avg_occurences, 1, 0)) > 1;"
"1127","WITH
  UserToAmount AS (
    SELECT
      user_id,
      spend_date,
      CASE
        WHEN COUNT(DISTINCT platform) = 2 THEN 'both'
        ELSE platform
      END AS platform,
      SUM(amount) AS amount
    FROM Spending
    GROUP BY 1, 2
  ),
  DateAndPlatforms AS (
    SELECT DISTINCT(spend_date), 'desktop' AS platform
    FROM Spending
    UNION ALL
    SELECT DISTINCT(spend_date), 'mobile' AS platform
    FROM Spending
    UNION ALL
    SELECT DISTINCT(spend_date), 'both' AS platform
    FROM Spending
  )
SELECT
  DateAndPlatforms.spend_date,
  DateAndPlatforms.platform,
  IFNULL(SUM(UserToAmount.amount), 0) AS total_amount,
  COUNT(DISTINCT UserToAmount.user_id) AS total_users
FROM DateAndPlatforms
LEFT JOIN UserToAmount
  USING (spend_date, platform)
GROUP BY 1, 2;"
"1128","class Solution:
  def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:
    ans = 0
    count = collections.Counter()

    for domino in dominoes:
      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])
      ans += count[key]
      count[key] += 1

    return ans"
"1129","from enum import Enum


class Color(Enum):
  kInit = 0
  kRed = 1
  kBlue = 2


class Solution:
  def shortestAlternatingPaths(
      self,
      n: int,
      redEdges: list[list[int]],
      blueEdges: list[list[int]],
  ) -> list[int]:
    ans = [-1] * n
    graph = [[] for _ in range(n)]  # graph[u] := [(v, edgeColor)]
    q = collections.deque([(0, Color.kInit)])  # [(u, prevColor)]

    for u, v in redEdges:
      graph[u].append((v, Color.kRed))

    for u, v in blueEdges:
      graph[u].append((v, Color.kBlue))

    step = 0
    while q:
      for _ in range(len(q)):
        u, prevColor = q.popleft()
        if ans[u] == -1:
          ans[u] = step
        for i, (v, edgeColor) in enumerate(graph[u]):
          if v == -1 or edgeColor == prevColor:
            continue
          q.append((v, edgeColor))
          graph[u][i] = (-1, edgeColor)  # Mark (u, v) as used.
      step += 1

    return ans"
"113","class Solution:
  def pathSum(self, root: TreeNode, summ: int) -> list[list[int]]:
    ans = []

    def dfs(root: TreeNode, summ: int, path: list[int]) -> None:
      if not root:
        return
      if root.val == summ and not root.left and not root.right:
        ans.append(path + [root.val])
        return

      dfs(root.left, summ - root.val, path + [root.val])
      dfs(root.right, summ - root.val, path + [root.val])

    dfs(root, summ, [])
    return ans"
"1130","class Solution:
  def mctFromLeafValues(self, arr: list[int]) -> int:
    ans = 0
    stack = [math.inf]

    for a in arr:
      while stack and stack[-1] <= a:
        mid = stack.pop()
        # Multiply mid with next greater element in the array,
        # On the left (stack[-1]) or on the right (current number a)
        ans += min(stack[-1], a) * mid
      stack.append(a)

    return ans + sum(a * b for a, b in zip(stack[1:], stack[2:]))"
"1131","class Solution:
  def maxAbsValExpr(self, arr1: list[int], arr2: list[int]) -> int:
    n = len(arr1)
    a = [arr1[i] + arr2[i] + i for i in range(n)]
    b = [arr1[i] + arr2[i] - i for i in range(n)]
    c = [arr1[i] - arr2[i] + i for i in range(n)]
    d = [arr1[i] - arr2[i] - i for i in range(n)]
    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))"
"1132","WITH
  DailyPercents AS (
    SELECT (
        COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT Actions.post_id)
      ) * 100 AS percent
    FROM Actions
    LEFT JOIN Removals
      USING (post_id)
    WHERE Actions.extra = 'spam'
    GROUP BY Actions.action_date
  )
SELECT ROUND(AVG(percent), 2) AS average_daily_percent
FROM DailyPercents;"
"1133","class Solution:
  def largestUniqueNumber(self, nums: list[int]) -> int:
    return max([num for num, freq in collections.Counter(nums).items()
                if freq == 1], default=-1)"
"1134","class Solution:
  def isArmstrong(self, n: int) -> bool:
    s = str(n)
    k = len(s)
    return sum(pow(int(c), k) for c in s) == n"
"1135","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def minimumCost(self, n: int, connections: list[list[int]]) -> int:
    ans = 0
    uf = UnionFind(n + 1)

    # Sort by cost.
    connections.sort(key=lambda x: x[2])

    for u, v, cost in connections:
      if uf.find(u) == uf.find(v):
        continue
      uf.unionByRank(u, v)
      ans += cost

    root = uf.find(1)
    if any(uf.find(i) != root for i in range(1, n + 1)):
      return -1

    return ans"
"1136","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:
    graph = [[] for _ in range(n)]
    states = [State.kInit] * n
    depth = [1] * n

    for u, v in relations:
      graph[u - 1].append(v - 1)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      for v in graph[u]:
        if hasCycle(v):
          return True
        depth[u] = max(depth[u], 1 + depth[v])
      states[u] = State.kVisited

      return False

    if any(hasCycle(i) for i in range(n)):
      return -1
    return max(depth)"
"1137","class Solution:
  def tribonacci(self, n: int) -> int:
    if n < 2:
      return n

    dp = [0, 1, 1]

    for _ in range(3, n + 1):
      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)

    return dp[2]"
"1138","class Solution {
 public:
  string alphabetBoardPath(string target) {
    string ans;
    int x = 0;
    int y = 0;

    for (char c : target) {
      int newX = (c - 'a') % 5;
      int newY = (c - 'a') / 5;
      ans += string(max(0, y - newY), 'U') + string(max(0, newX - x), 'R') +
             string(max(0, x - newX), 'L') + string(max(0, newY - y), 'D') +
             '!';
      x = newX;
      y = newY;
    }

    return ans;
  }
};"
"1139","class Solution:
  def largest1BorderedSquare(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    # leftOnes[i][j] := consecutive 1s in the left of grid[i][j]
    leftOnes = [[0] * n for _ in range(m)]
    # topOnes[i][j] := consecutive 1s in the top of grid[i][j]
    topOnes = [[0] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          leftOnes[i][j] = 1 if j == 0 else 1 + leftOnes[i][j - 1]
          topOnes[i][j] = 1 if i == 0 else 1 + topOnes[i - 1][j]

    for sz in range(min(m, n), 0, -1):
      for i in range(m - sz + 1):
        for j in range(n - sz + 1):
          x = i + sz - 1
          y = j + sz - 1
          # If grid[i..x][j..y] has all 1s on its border.
          if min(
                  leftOnes[i][y],
                  leftOnes[x][y],
                  topOnes[x][j],
                  topOnes[x][y]) >= sz:
            return sz * sz

    return 0"
"114","class Solution:
  def flatten(self, root: TreeNode | None) -> None:
    if not root:
      return

    self.flatten(root.left)
    self.flatten(root.right)

    left = root.left  # flattened left
    right = root.right  # flattened right

    root.left = None
    root.right = left

    # Connect the original right subtree to the end of the new right subtree.
    rightmost = root
    while rightmost.right:
      rightmost = rightmost.right
    rightmost.right = right"
"1140","class Solution {
  public int stoneGameII(int[] piles) {
    final int n = piles.length;
    int[][] mem = new int[n][n];
    int[] suffix = new int[n]; // suffix[i] := sum(piles[i..n))
    Arrays.stream(mem).forEach(A -> Arrays.fill(A, -1));
    suffix[n - 1] = piles[n - 1];
    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] + piles[i];
    return stoneGameII(suffix, 0, 1, mem);
  }

  // Returns the maximum number of stones Alice can get from piles[i..n) with M.
  private int stoneGameII(int[] suffix, int i, int M, int[][] mem) {
    if (i + 2 * M >= suffix.length)
      return suffix[i];
    if (mem[i][M] != -1)
      return mem[i][M];

    int opponent = suffix[i];

    for (int X = 1; X <= 2 * M; ++X)
      opponent = Math.min(opponent, stoneGameII(suffix, i + X, Math.max(M, X), mem));

    return mem[i][M] = suffix[i] - opponent;
  }
}"
"1141","SELECT
  activity_date AS day,
  COUNT(DISTINCT user_id) AS active_users
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27'
GROUP BY 1;"
"1142","SELECT
  IFNULL(
    ROUND(
      COUNT(DISTINCT session_id) / COUNT(DISTINCT user_id),
      2
    ),
    0.00
  ) AS average_sessions_per_user
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27';"
"1143","class Solution:
  def longestCommonSubsequence(self, text1: str, text2: str) -> int:
    m = len(text1)
    n = len(text2)
    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        dp[i + 1][j + 1] = (1 + dp[i][j] if text1[i] == text2[j]
                            else max(dp[i][j + 1], dp[i + 1][j]))

    return dp[m][n]"
"1144","class Solution:
  def movesToMakeZigzag(self, nums: list[int]) -> int:
    decreasing = [0] * 2

    for i, num in enumerate(nums):
      l = nums[i - 1] if i > 0 else 1001
      r = nums[i + 1] if i + 1 < len(nums) else 1001
      decreasing[i % 2] += max(0, num - min(l, r) + 1)

    return min(decreasing[0], decreasing[1])"
"1145","class Solution {
  public boolean btreeGameWinningMove(TreeNode root, int n, int x) {
    count(root, x);
    return Math.max(Math.max(leftCount, rightCount), n - leftCount - rightCount - 1) > n / 2;
  }

  private int leftCount;  // the number of nodes of n's left
  private int rightCount; // the number of nodes of n's right

  private int count(TreeNode root, int x) {
    if (root == null)
      return 0;
    final int l = count(root.left, x);
    final int r = count(root.right, x);
    if (root.val == x) {
      leftCount = l;
      rightCount = r;
    }
    return 1 + l + r;
  }
}"
"1146","class SnapshotArray:
  def __init__(self, length: int):
    self.snaps = [[[0, 0]] for _ in range(length)]
    self.snap_id = 0

  def set(self, index: int, val: int) -> None:
    snap = self.snaps[index][-1]
    if snap[0] == self.snap_id:
      snap[1] = val
    else:
      self.snaps[index].append([self.snap_id, val])

  def snap(self) -> int:
    self.snap_id += 1
    return self.snap_id - 1

  def get(self, index: int, snap_id: int) -> int:
    i = bisect_left(self.snaps[index], [snap_id + 1]) - 1
    return self.snaps[index][i][1]"
"1147","class Solution {
  public int longestDecomposition(String text) {
    final int n = text.length();

    int count = 0;
    int l = 0;

    for (int r = 1; 2 * r <= n; ++r)
      if (text.substring(n - r).startsWith(text.substring(l, r))) {
        count += 2;
        l = r;
      }

    return count + (2 * l < n ? 1 : 0);
  }
}"
"1148","SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY 1;"
"1149","SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY 1;"
"115","class Solution:
  def numDistinct(self, s: str, t: str) -> int:
    m = len(s)
    n = len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
      dp[i][0] = 1

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if s[i - 1] == t[j - 1]:
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
        else:
          dp[i][j] = dp[i - 1][j]

    return dp[m][n]"
"1150","class Solution:
  def isMajorityElement(self, nums: list[int], target: int) -> bool:
    n = len(nums)
    i = bisect.bisect_left(nums, target)
    return i + n // 2 < n and nums[i + n // 2] == target"
"1151","class Solution:
  def minSwaps(self, data: list[int]) -> int:
    k = data.count(1)
    ones = 0  # the number of ones in the window
    maxOnes = 0  # the maximum number of ones in the window

    for i, num in enumerate(data):
      if i >= k and data[i - k]:
        ones -= 1
      if num:
        ones += 1
      maxOnes = max(maxOnes, ones)

    return k - maxOnes"
"1152","class Solution:
  def mostVisitedPattern(
      self,
      username: list[str],
      timestamp: list[int],
      website: list[str],
  ) -> list[str]:
    userToSites = collections.defaultdict(list)

    # Sort websites of each user by timestamp.
    for user, _, site in sorted(
            zip(username, timestamp, website),
            key=lambda x: x[1]):
      userToSites[user].append(site)

    # For each of three websites, count its frequency.
    patternCount = collections.Counter()

    for user, sites in userToSites.items():
      patternCount.update(Counter(set(itertools.combinations(sites, 3))))

    return max(sorted(patternCount), key=patternCount.get)"
"1153","class Solution:
  def canConvert(self, str1: str, str2: str) -> bool:
    if str1 == str2:
      return True

    mappings = {}

    for a, b in zip(str1, str2):
      if mappings.get(a, b) != b:
        return False
      mappings[a] = b

    # No letter in the str1 maps to > 1 letter in the str2 and there is at
    # lest one temporary letter can break any loops.
    return len(set(str2)) < 26"
"1154","class Solution:
  def dayOfYear(self, date: str) -> int:
    def isLeapYear(year: int) -> bool:
      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

    year = int(date[:4])
    month = int(date[5:7])
    day = int(date[8:])
    days = [31, 29 if isLeapYear(
        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    return sum(days[:month - 1]) + day"
"1155","class Solution:
  def numRollsToTarget(self, n: int, k: int, target: int) -> int:
    kMod = 1_000_000_007
    dp = [1] + [0] * target

    for _ in range(n):  # n dices
      newDp = [0] * (target + 1)
      for i in range(1, k + 1):  # numbers 1, 2, ..., f
        for t in range(i, target + 1):  # all the possible targets
          newDp[t] += dp[t - i]
          newDp[t] %= kMod
      dp = newDp

    return dp[target]"
"1156","class Solution:
  def maxRepOpt1(self, text: str) -> int:
    count = collections.Counter(text)
    groups = [[c, len(list(group))]
              for c, group in itertools.groupby(text)]
    ans = max(min(length + 1, count[c]) for c, length in groups)

    for i in range(1, len(groups) - 1):
      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:
        ans = max(
            ans,
            min(groups[i - 1][1] + groups[i + 1][1] + 1, count
                [groups[i - 1][0]]))

    return ans"
"1157","class MajorityChecker:
  def __init__(self, arr: list[int]):
    self.arr = arr
    self.kTimes = 20  # 2^kTimes >> |arr|
    self.numToIndices = collections.defaultdict(list)

    for i, a in enumerate(self.arr):
      self.numToIndices[a].append(i)

  def query(self, left: int, right: int, threshold: int) -> int:
    for _ in range(self.kTimes):
      randIndex = random.randint(left, right)
      num = self.arr[randIndex]
      indices = self.numToIndices[num]
      l = bisect.bisect_left(indices, left)
      r = bisect.bisect_right(indices, right)
      if r - l >= threshold:
        return num

    return -1"
"1158","SELECT
  Users.user_id AS buyer_id,
  Users.join_date,
  COUNT(Orders.order_id) AS orders_in_2019
FROM Users
LEFT JOIN Orders
  ON (Users.user_id = Orders.buyer_id AND YEAR(order_date) = '2019')
GROUP BY 1;"
"1159","WITH
  RankedOrders AS (
    SELECT
      Orders.seller_id,
      RANK() OVER(
        PARTITION BY Orders.seller_id
        ORDER BY Orders.order_date
      ) AS `rank`,
      Items.item_brand
    FROM Orders
    INNER JOIN Items
      USING (item_id)
  )
SELECT
  user_id AS seller_id,
  CASE
    WHEN Users.favorite_brand = RankedOrders.item_brand THEN 'yes'
    ELSE 'no'
  END AS 2nd_item_fav_brand
FROM Users
LEFT JOIN RankedOrders
  ON (Users.user_id = RankedOrders.seller_id AND RankedOrders.`rank` = 2);"
"116","class Solution:
  def connect(self, root: 'Node') -> 'Node':
    node = root  # the node that is above the current needling

    while node and node.left:
      dummy = Node(0)  # a dummy node before needling
      # Needle the children of the node.
      needle = dummy
      while node:
        needle.next = node.left
        needle = needle.next
        needle.next = node.right
        needle = needle.next
        node = node.next
      node = dummy.next  # Move the node to the next level.

    return root"
"1160","class Solution:
  def countCharacters(self, words: list[str], chars: str) -> int:
    ans = 0
    count = collections.Counter(chars)

    for word in words:
      tempCount = count.copy()
      for c in word:
        tempCount[c] -= 1
        if tempCount[c] < 0:
          ans -= len(word)
          break
      ans += len(word)

    return ans"
"1161","class Solution:
  def maxLevelSum(self, root: TreeNode | None) -> int:
    ans = 0
    maxLevelSum = -math.inf
    q = collections.deque([root])

    level = 1
    while q:
      levelSum = 0
      for _ in range(len(q)):
        node = q.popleft()
        levelSum += node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      if levelSum > maxLevelSum:
        maxLevelSum = levelSum
        ans = level
      level += 1

    return ans"
"1162","class Solution:
  def maxDistance(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    q = collections.deque()
    water = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 0:
          water += 1
        else:
          q.append((i, j))

    if water == 0 or water == m * n:
      return -1

    ans = 0
    d = 0

    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        ans = d
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if grid[x][y] > 0:
            continue
          q.append((x, y))
          grid[x][y] = 2  # Mark as visited.
      d += 1

    return ans"
"1163","class Solution:
  def lastSubstring(self, s: str) -> str:
    i = 0
    j = 1
    k = 0  # the number of the same letters of s[i..n) and s[j..n)

    while j + k < len(s):
      if s[i + k] == s[j + k]:
        k += 1
      elif s[i + k] > s[j + k]:
        # s[i..i + k] == s[j..j + k] and s[i + k] > s[j + k] means that we
        # should start from s[j + k] to find a possible larger substring.
        j += k + 1
        k = 0
      else:
        # s[i..i + k] == s[j..j + k] and s[i + k] < s[j + k] means that either
        # starting from s[i + k + 1] or s[j] has a larger substring
        i = max(i + k + 1, j)
        j = i + 1
        k = 0

    return s[i:]"
"1164","WITH
  RankedProducts AS (
    SELECT
      product_id,
      new_price,
      RANK() OVER(
        PARTITION BY product_id
        ORDER BY change_date DESC
      ) AS `rank`
    FROM Products
    WHERE change_date <= '2019-08-16'
  ),
  ProductToLatestPrice AS (
    SELECT product_id, new_price
    FROM RankedProducts
    WHERE `rank` = 1
  )
SELECT
  Products.product_id,
  IFNULL(ProductToLatestPrice.new_price, 10) AS price
FROM Products
LEFT JOIN ProductToLatestPrice
  USING (product_id)
GROUP BY 1;"
"1165","class Solution:
  def calculateTime(self, keyboard: str, word: str) -> int:
    letterToIndex = {c: i for i, c in enumerate(keyboard)}
    return (letterToIndex[word[0]] +
            sum(abs(letterToIndex[a] - letterToIndex[b])
            for a, b in itertools.pairwise(word)))"
"1166","class TrieNode:
  def __init__(self, value: int = 0):
    self.children: dict[str, TrieNode] = {}
    self.value = value


class FileSystem:
  def __init__(self):
    self.root = TrieNode()

  def createPath(self, path: str, value: int) -> bool:
    node: TrieNode = self.root
    subpaths = path.split('/')

    for i in range(1, len(subpaths) - 1):
      if subpaths[i] not in node.children:
        return False
      node = node.children[subpaths[i]]

    if subpaths[-1] in node.children:
      return False
    node.children[subpaths[-1]] = TrieNode(value)
    return True

  def get(self, path: str) -> int:
    node: TrieNode = self.root

    for subpath in path.split('/')[1:]:
      if subpath not in node.children:
        return -1
      node = node.children[subpath]

    return node.value"
"1167","class Solution:
  def connectSticks(self, sticks: list[int]) -> int:
    ans = 0
    heapq.heapify(sticks)

    while len(sticks) > 1:
      x = heapq.heappop(sticks)
      y = heapq.heappop(sticks)
      ans += x + y
      heapq.heappush(sticks, x + y)

    return ans"
"1168","class Solution:
  def minCostToSupplyWater(
      self,
      n: int,
      wells: list[int],
      pipes: list[list[int]],
  ) -> int:
    ans = 0
    graph = [[] for _ in range(n + 1)]
    minHeap = []  # (d, u)

    for u, v, w in pipes:
      graph[u].append((v, w))
      graph[v].append((u, w))

    # Connect virtual 0 with nodes 1 to n.
    for i, well in enumerate(wells):
      graph[0].append((i + 1, well))
      heapq.heappush(minHeap, (well, i + 1))

    mst = {0}

    while len(mst) < n + 1:
      d, u = heapq.heappop(minHeap)
      if u in mst:
        continue
      # Add the new vertex.
      mst.add(u)
      ans += d
      # Expand if possible.
      for v, w in graph[u]:
        if v not in mst:
          heapq.heappush(minHeap, (w, v))

    return ans"
"1169","class Solution:
  def invalidTransactions(self, transactions: list[str]) -> list[str]:
    ans = []
    nameToTrans = collections.defaultdict(list)

    for t in transactions:
      name, time, amount, city = t.split(',')
      time, amount = int(time), int(amount)
      nameToTrans[name].append({'time': time, 'city': city})

    for t in transactions:
      name, time, amount, city = t.split(',')
      time, amount = int(time), int(amount)
      if amount > 1000:
        ans.append(t)
      elif name in nameToTrans:
        for sameName in nameToTrans[name]:
          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:
            ans.append(t)
            break

    return ans"
"117","class Solution:
  def connect(self, root: 'Node') -> 'Node':
    node = root  # the node that is above the current needling

    while node:
      dummy = Node(0)  # a dummy node before needling
      # Needle the children of the node.
      needle = dummy
      while node:
        if node.left:  # Needle the left child.
          needle.next = node.left
          needle = needle.next
        if node.right:  # Needle the right child.
          needle.next = node.right
          needle = needle.next
        node = node.next
      node = dummy.next  # Move the node to the next level.

    return root"
"1170","class Solution:
  def numSmallerByFrequency(
      self,
      queries: list[str],
      words: list[str],
  ) -> list[int]:
    ans = []
    wordsFreq = sorted([word.count(min(word)) for word in words])

    for q in queries:
      count = q.count(min(q))
      index = bisect.bisect(wordsFreq, count)
      ans.append(len(words) - index)

    return ans"
"1171","class Solution:
  def removeZeroSumSublists(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prefix = 0
    prefixToNode = {0: dummy}

    while head:
      prefix += head.val
      prefixToNode[prefix] = head
      head = head.next

    prefix = 0
    head = dummy

    while head:
      prefix += head.val
      head.next = prefixToNode[prefix].next
      head = head.next

    return dummy.next"
"1172","class DinnerPlates:
  def __init__(self, capacity: int):
    self.capacity = capacity
    self.stacks = []
    self.minHeap = [0]  # the minimum indices of the stacks to push

  def push(self, val: int) -> None:
    index = self.minHeap[0]
    # Add a new stack on demand.
    if index == len(self.stacks):
      self.stacks.append([])
    # Push the new value.
    self.stacks[index].append(val)
    # If the stack pushed is full, remove its candidacy from `minHeap`.
    if len(self.stacks[index]) == self.capacity:
      heapq.heappop(self.minHeap)
      # If `minHeap` is empty, the next available stack index is |stacks|.
      if not self.minHeap:
        heapq.heappush(self.minHeap, len(self.stacks))

  def pop(self) -> int:
    # Remove empty stacks from the back.
    while self.stacks and not self.stacks[-1]:
      self.stacks.pop()
    if not self.stacks:
      return -1
    return self.popAtStack(len(self.stacks) - 1)

  def popAtStack(self, index: int) -> int:
    if index >= len(self.stacks) or not self.stacks[index]:
      return -1
    # If the stack is going to have space, add its candiday to `minHeap`.
    if len(self.stacks[index]) == self.capacity:
      heapq.heappush(self.minHeap, index)
    return self.stacks[index].pop()"
"1173","SELECT
  ROUND(
    100 * AVG(order_date = customer_pref_delivery_date),
    2
  ) AS immediate_percentage
FROM Delivery;"
"1174","WITH
  CustomerToIsImmediate AS(
    SELECT
      DISTINCT customer_id,
      FIRST_VALUE(order_date = customer_pref_delivery_date) OVER(
        PARTITION BY customer_id
        ORDER BY order_date
      ) is_immediate
    FROM Delivery
  )
SELECT ROUND(AVG(is_immediate) * 100, 2) immediate_percentage
FROM CustomerToIsImmediate;"
"1175","class Solution:
  def numPrimeArrangements(self, n: int) -> int:
    kMod = 1_000_000_007

    def factorial(n: int) -> int:
      fact = 1
      for i in range(2, n + 1):
        fact = fact * i % kMod
      return fact

    count = self._countPrimes(n)
    return factorial(count) * factorial(n - count) % kMod

  def _countPrimes(self, n: int) -> int:
    isPrime = [False] * 2 + [True] * (n - 1)
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n + 1, i):
          isPrime[j] = False
    return sum(isPrime)"
"1176","class Solution:
  def dietPlanPerformance(
      self,
      calories: list[int],
      k: int,
      lower: int,
      upper: int,
  ) -> int:
    ans = 0
    summ = 0

    for i, calorie in enumerate(calories):
      summ += calorie
      if i < k - 1:
        continue
      if i >= k:
        summ -= calories[i - k]
      if summ < lower:
        ans -= 1
      elif summ > upper:
        ans += 1

    return ans"
"1177","class Solution:
  def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:
    dp = [0] * (len(s) + 1)

    for i in range(1, len(s) + 1):
      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')

    return [
        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k
        for left, right, k in queries
    ]"
"1178","class Solution:
  def findNumOfValidWords(
      self,
      words: list[str],
      puzzles: list[str],
  ) -> list[int]:
    ans = []
    binaryCount = collections.Counter()

    for word in words:
      mask = 0
      for c in word:
        mask |= 1 << string.ascii_lowercase.index(c)
      binaryCount[mask] += 1

    for puzzle in puzzles:
      valid = 0
      n = len(puzzle) - 1
      for i in range(1 << n):
        mask = 1 << ord(puzzle[0]) - ord('a')
        for j in range(n):
          if i >> j & 1:
            mask |= 1 << ord(puzzle[j + 1]) - ord('a')
        if mask in binaryCount:
          valid += binaryCount[mask]
      ans.append(valid)

    return ans"
"1179","SELECT
  id,
  SUM(IF(month = 'Jan', revenue, NULL)) AS Jan_Revenue,
  SUM(IF(month = 'Feb', revenue, NULL)) AS Feb_Revenue,
  SUM(IF(month = 'Mar', revenue, NULL)) AS Mar_Revenue,
  SUM(IF(month = 'Apr', revenue, NULL)) AS Apr_Revenue,
  SUM(IF(month = 'May', revenue, NULL)) AS May_Revenue,
  SUM(IF(month = 'Jun', revenue, NULL)) AS Jun_Revenue,
  SUM(IF(month = 'Jul', revenue, NULL)) AS Jul_Revenue,
  SUM(IF(month = 'Aug', revenue, NULL)) AS Aug_Revenue,
  SUM(IF(month = 'Sep', revenue, NULL)) AS Sep_Revenue,
  SUM(IF(month = 'Oct', revenue, NULL)) AS Oct_Revenue,
  SUM(IF(month = 'Nov', revenue, NULL)) AS Nov_Revenue,
  SUM(IF(month = 'Dec', revenue, NULL)) AS Dec_Revenue
FROM Department
GROUP BY 1;"
"118","class Solution:
  def generate(self, numRows: int) -> list[list[int]]:
    ans = []

    for i in range(numRows):
      ans.append([1] * (i + 1))

    for i in range(2, numRows):
      for j in range(1, len(ans[i]) - 1):
        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]

    return ans"
"1180","class Solution:
  def countLetters(self, s: str) -> int:
    ans = 0
    dp = 0  # the length of the running letter
    letter = '@'  # the running letter

    for c in s:
      if c == letter:
        dp += 1
      else:
        dp = 1
        letter = c
      ans += dp  # Add the number of substrings ending in the current letter.

    return ans"
"1181","class Solution {
 public:
  vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {
    set<string> ans;
    unordered_map<string, set<string>> firstWordToLasts;
    unordered_map<string, set<string>> lastWordToFirsts;

    for (const string& phrase : phrases) {
      const int firstSpaceIndex = phrase.find(' ');
      const int lastSpaceIndex = phrase.rfind(' ');
      // the index after the firstWord
      const int i =
          firstSpaceIndex == string::npos ? phrase.length() : firstSpaceIndex;
      // the index of the lastWord
      const int j = lastSpaceIndex == string::npos ? 0 : lastSpaceIndex + 1;
      const string firstWord = phrase.substr(0, i);
      const string lastWord = phrase.substr(j);

      // Concatenate `phrase` with `last` having the same `firstWord`.
      if (const auto it = firstWordToLasts.find(lastWord);
          it != firstWordToLasts.cend())
        for (const string& last : it->second)
          ans.insert(phrase + last);

      // Concatenate `first` having the same `lastWord` with `phrase`.
      if (const auto it = lastWordToFirsts.find(firstWord);
          it != lastWordToFirsts.cend())
        for (const string& first : it->second)
          ans.insert(first + phrase);

      // e.g. ""a b c"" -> {""a"": "" b c""}
      //          ""a"" -> {""a"": """"}
      firstWordToLasts[firstWord].insert(phrase.substr(i));

      // e.g. ""a b c"" -> {""c"": ""a b ""}
      //          ""a"" -> {""a"": """"}
      lastWordToFirsts[lastWord].insert(phrase.substr(0, j));
    }

    return {ans.begin(), ans.end()};
  }
};"
"1182","class Solution:
  def shortestDistanceColor(
      self,
      colors: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    kNumColor = 3
    n = len(colors)
    ans = []
    # left[i][c] := the closest index of color c in index i to the left
    left = [[0] * (kNumColor + 1) for _ in range(n)]
    # right[i][c] := the closest index of color c in index i to the right
    right = [[0] * (kNumColor + 1) for _ in range(n)]

    colorToLatestIndex = [0, -1, -1, -1]  # 0-indexed, -1 means N//A
    for i, color in enumerate(colors):
      colorToLatestIndex[color] = i
      for c in range(1, kNumColor + 1):
        left[i][c] = colorToLatestIndex[c]

    colorToLatestIndex = [0, -1, -1, -1]  # Reset.
    for i in range(n - 1, -1, -1):
      colorToLatestIndex[colors[i]] = i
      for c in range(1, kNumColor + 1):
        right[i][c] = colorToLatestIndex[c]

    for i, c in queries:
      leftDist = math.inf if left[i][c] == -1 else i - left[i][c]
      rightDist = math.inf if right[i][c] == -1 else right[i][c] - i
      minDist = min(leftDist, rightDist)
      ans.append(-1 if minDist == math.inf else minDist)

    return ans"
"1183","class Solution:
  def maximumNumberOfOnes(
      self,
      width: int,
      height: int,
      sideLength: int,
      maxOnes: int,
  ) -> int:
    submatrix = [[0] * sideLength for _ in range(sideLength)]

    for i in range(width):
      for j in range(height):
        submatrix[i % sideLength][j % sideLength] += 1

    return sum(heapq.nlargest(maxOnes, [a for row in submatrix for a in row]))"
"1184","class Solution:
  def distanceBetweenBusStops(
      self,
      distance: list[int],
      start: int, destination: int,
  ) -> int:
    clockwise = 0
    counterclockwise = 0

    if start > destination:
      start, destination = destination, start

    for i, d in enumerate(distance):
      if i >= start and i < destination:
        clockwise += d
      else:
        counterclockwise += d

    return min(clockwise, counterclockwise)"
"1185","class Solution:
  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
    def isLeapYear(year: int) -> bool:
      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

    week = [""Sunday"", ""Monday"", ""Tuesday"",
            ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""]
    days = [31, 29 if isLeapYear(
        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    count = 0

    for i in range(1971, year):
      count += 366 if i % 4 == 0 else 365
    for i in range(month - 1):
      count += days[i]
    count += day

    return week[(count + 4) % 7]"
"1186","class Solution:
  # Very similar to 53. Maximum Subarray
  def maximumSum(self, arr: list[int]) -> int:
    ans = -math.inf
    zero = -math.inf  # no deletion
    one = -math.inf   # <= 1 deletion

    for a in arr:
      one = max(a, one + a, zero)
      zero = max(a, zero + a)
      ans = max(ans, one)

    return ans"
"1187","class Solution:
  def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:
    # dp[i] := the minimum steps to reach i at previous round
    dp = {-1: 0}

    arr2.sort()

    for a in arr1:
      newDp = collections.defaultdict(lambda: math.inf)
      for val, steps in dp.items():
        # It's possible to use the value in the arr1.
        if a > val:
          newDp[a] = min(newDp[a], steps)
        # Also try the value in the arr2.
        i = bisect_right(arr2, val)
        if i < len(arr2):
          newDp[arr2[i]] = min(newDp[arr2[i]], steps + 1)
      if not newDp:
        return -1
      dp = newDp

    return min(dp.values())"
"1188","from threading import Semaphore


class BoundedBlockingQueue:
  def __init__(self, capacity: int):
    self.q = collections.deque()
    self.enqueueSemaphore = Semaphore(capacity)
    self.dequeueSemaphore = Semaphore(0)

  def enqueue(self, element: int) -> None:
    self.enqueueSemaphore.acquire()
    self.q.append(element)
    self.dequeueSemaphore.release()

  def dequeue(self) -> int:
    self.dequeueSemaphore.acquire()
    element = self.q.popleft()
    self.enqueueSemaphore.release()
    return element

  def size(self) -> int:
    return len(self.q)"
"1189","class Solution:
  def maxNumberOfBalloons(self, text: str) -> int:
    count = collections.Counter(text)
    return min(
        count['b'],
        count['a'],
        count['l'] // 2, count['o'] // 2, count['n'])"
"119","class Solution:
  def getRow(self, rowIndex: int) -> list[int]:
    ans = [1] * (rowIndex + 1)

    for i in range(2, rowIndex + 1):
      for j in range(1, i):
        ans[i - j] += ans[i - j - 1]

    return ans"
"1190","class Solution:
  def reverseParentheses(self, s: str) -> str:
    ans = []
    stack = []
    pair = {}

    for i, c in enumerate(s):
      if c == '(':
        stack.append(i)
      elif c == ')':
        j = stack.pop()
        pair[i] = j
        pair[j] = i

    i = 0
    d = 1
    while i < len(s):
      if s[i] in '()':
        i = pair[i]
        d = -d
      else:
        ans.append(s[i])
      i += d

    return ''.join(ans)"
"1191","class Solution:
  def kConcatenationMaxSum(self, arr: list[int], k: int) -> int:
    kMod = 1_000_000_007
    sz = len(arr) * (1 if k == 1 else 2)
    summ = sum(arr)
    # The concatenated array will be [arr1, arr2, ..., arrk].
    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.
    # Equivalently, maxSubarraySum is from arr1 and arrk.
    if summ > 0 and k > 2:
      return (self.kadane(arr, sz) + summ * (k - 2)) % kMod
    return self.kadane(arr, sz) % kMod

  def kadane(self, A: list[int], sz: int) -> int:
    ans = 0
    summ = 0
    for i in range(sz):
      a = A[i % len(A)]
      summ = max(a, summ + a)
      ans = max(ans, summ)
    return ans"
"1192","class Solution {
  public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer>[] graph = new List[n];

    for (int i = 0; i < n; ++i)
      graph[i] = new ArrayList<>();

    for (List<Integer> connection : connections) {
      final int u = connection.get(0);
      final int v = connection.get(1);
      graph[u].add(v);
      graph[v].add(u);
    }

    // rank[i] := the minimum node that node i can reach with forward edges
    // Initialize with NO_RANK = -2 to indicate not visited.
    int[] rank = new int[n];
    Arrays.fill(rank, NO_RANK);
    getRank(graph, 0, 0, rank, ans);
    return ans;
  }

  private static final int NO_RANK = -2;

  // Gets the minimum rank that u can reach with forward edges.
  private int getRank(List<Integer>[] graph, int u, int myRank, int[] rank,
                      List<List<Integer>> ans) {
    if (rank[u] != NO_RANK) // The rank is already been determined.
      return rank[u];

    rank[u] = myRank;
    int minRank = myRank;

    for (final int v : graph[u]) {
      // visited || parent (that's why NO_RANK = -2 instead of -1)
      if (rank[u] == rank.length || rank[v] == myRank - 1)
        continue;
      final int nextRank = getRank(graph, v, myRank + 1, rank, ans);
      // (u, v) is the only way for u go to v.
      if (nextRank == myRank + 1)
        ans.add(Arrays.asList(u, v));
      minRank = Math.min(minRank, nextRank);
    }

    rank[u] = rank.length; // Mark as visited.
    return minRank;
  }
}"
"1193","SELECT
  DATE_FORMAT(trans_date, '%Y-%m') AS month,
  country,
  COUNT(*) AS trans_count,
  SUM(state = 'approved') AS approved_count,
  SUM(amount) AS trans_total_amount,
  SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY 1, 2;"
"1194","WITH
  PlayerToScore AS (
    (
      SELECT
        Players.player_id,
        Players.group_id,
        Matches.first_score AS score
      FROM Players
      LEFT JOIN Matches
        ON (Players.player_id = Matches.first_player)
    )
    UNION ALL
    (
      SELECT
        Players.player_id,
        Players.group_id,
        Matches.second_score AS score
      FROM Players
      LEFT JOIN Matches
        ON (Players.player_id = Matches.second_player)
    )
  ),
  RankedPlayers AS (
    SELECT
      player_id,
      group_id,
      RANK() OVER(
        PARTITION BY group_id
        ORDER BY SUM(score) DESC,
          player_id
      ) AS `rank`
    FROM PlayerToScore
    GROUP BY 1
  )
SELECT group_id, player_id
FROM RankedPlayers
WHERE `rank` = 1;"
"1195","from threading import Semaphore


class FizzBuzz:
  def __init__(self, n: int):
    self.n = n
    self.fizzSemaphore = Semaphore(0)
    self.buzzSemaphore = Semaphore(0)
    self.fizzbuzzSemaphore = Semaphore(0)
    self.numberSemaphore = Semaphore(1)

  # printFizz() outputs ""fizz""
  def fizz(self, printFizz: 'Callable[[], None]') -> None:
    for i in range(1, self.n + 1):
      if i % 3 == 0 and i % 15 != 0:
        self.fizzSemaphore.acquire()
        printFizz()
        self.numberSemaphore.release()

  # printBuzz() outputs ""buzz""
  def buzz(self, printBuzz: 'Callable[[], None]') -> None:
    for i in range(1, self.n + 1):
      if i % 5 == 0 and i % 15 != 0:
        self.buzzSemaphore.acquire()
        printBuzz()
        self.numberSemaphore.release()

  # printFizzBuzz() outputs ""fizzbuzz""
  def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:
    for i in range(1, self.n + 1):
      if i % 15 == 0:
        self.fizzbuzzSemaphore.acquire()
        printFizzBuzz()
        self.numberSemaphore.release()

  # printNumber(x) outputs ""x"", where x is an integer.
  def number(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(1, self.n + 1):
      self.numberSemaphore.acquire()
      if i % 15 == 0:
        self.fizzbuzzSemaphore.release()
      elif i % 3 == 0:
        self.fizzSemaphore.release()
      elif i % 5 == 0:
        self.buzzSemaphore.release()
      else:
        printNumber(i)
        self.numberSemaphore.release()"
"1196","class Solution:
  def maxNumberOfApples(self, weight: list[int]) -> int:
    summ = 0

    for i, w in enumerate(sorted(weight)):
      summ += w
      if summ > 5000:
        return i

    return len(weight)"
"1197","class Solution {
  public int minKnightMoves(int x, int y) {
    return dp(Math.abs(x), Math.abs(y));
  }

  private Map<Pair<Integer, Integer>, Integer> mem = new HashMap<>();

  private int dp(int x, int y) {
    if (x + y == 0) // (0, 0)
      return 0;
    if (x + y == 2) // (0, 2), (1, 1), (2, 0)
      return 2;
    Pair<Integer, Integer> key = new Pair<>(x, y);
    if (mem.containsKey(key))
      return mem.get(key);

    final int minMove = 1 + Math.min(                                 //
                                dp(Math.abs(x - 2), Math.abs(y - 1)), //
                                dp(Math.abs(x - 1), Math.abs(y - 2)));
    mem.put(key, minMove);
    return minMove;
  }
}"
"1198","class Solution:
  def smallestCommonElement(self, mat: list[list[int]]) -> int:
    kMax = 10000
    count = [0] * (kMax + 1)

    for row in mat:
      for a in row:
        count[a] += 1
        if count[a] == len(mat):
          return a

    return -1"
"1199","class Solution:
  def minBuildTime(self, blocks: list[int], split: int) -> int:
    minHeap = blocks.copy()
    heapify(minHeap)

    while len(minHeap) > 1:
      heapq.heappop(minHeap)  # the minimum
      x = heapq.heappop(minHeap)  # the second minimum
      heapq.heappush(minHeap, x + split)

    return minHeap[0]"
"12","class Solution:
  def intToRoman(self, num: int) -> str:
    M = ['', 'M', 'MM', 'MMM']
    C = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']
    X = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']
    I = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']
    return M[num // 1000] + C[num % 1000 // 100] + X[num % 100 // 10] + I[num % 10]"
"120","class Solution:
  def minimumTotal(self, triangle: list[list[int]]) -> int:
    for i in reversed(range(len(triangle) - 1)):
      for j in range(i + 1):
        triangle[i][j] += min(triangle[i + 1][j],
                              triangle[i + 1][j + 1])

    return triangle[0][0]"
"1200","class Solution:
  def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:
    ans = []
    mn = math.inf

    arr.sort()

    for a, b in itertools.pairwise(arr):
      diff = b - a
      if diff < mn:
        mn = diff
        ans = []
      if diff == mn:
        ans.append([a, b])

    return ans"
"1201","class Solution:
  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
    ab = a * b // math.gcd(a, b)
    ac = a * c // math.gcd(a, c)
    bc = b * c // math.gcd(b, c)
    abc = a * bc // math.gcd(a, bc)
    return bisect.bisect_left(
        range(2 * 10 ** 9),
        n, key=lambda m: m // a + m // b + m // c - m // ab -
        m // ac - m // bc + m // abc)"
"1202","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def smallestStringWithSwaps(self, s: str, pairs: list[list[int]]) -> str:
    uf = UnionFind(len(s))
    indexToLetters = collections.defaultdict(list)

    for a, b in pairs:
      uf.unionByRank(a, b)

    for i, c in enumerate(s):
      indexToLetters[uf.find(i)].append(c)

    for key in indexToLetters.keys():
      indexToLetters[key].sort(reverse=True)

    return ''.join(indexToLetters[uf.find(i)].pop()
                   for i in range(len(s)))"
"1203","class Solution {
 public:
  vector<int> sortItems(int n, int m, vector<int>& group,
                        vector<vector<int>>& beforeItems) {
    vector<vector<int>> graph(n + m);
    vector<int> inDegrees(n + m);

    // Build the graph by remapping the k-th group to k + n imaginary node.
    for (int i = 0; i < group.size(); ++i) {
      if (group[i] == -1)
        continue;
      graph[group[i] + n].push_back(i);
      ++inDegrees[i];
    }

    for (int i = 0; i < beforeItems.size(); ++i)
      for (const int b : beforeItems[i]) {
        const int u = group[b] == -1 ? b : group[b] + n;
        const int v = group[i] == -1 ? i : group[i] + n;
        if (u == v) {  // u and v are already in the same group.
          graph[b].push_back(i);
          ++inDegrees[i];
        } else {
          graph[u].push_back(v);
          ++inDegrees[v];
        }
      }

    // Perform topological sorting.
    vector<int> ans;

    for (int i = 0; i < n + m; ++i)
      if (inDegrees[i] == 0)  // inDegrees[i] == -1 means visited.
        dfs(graph, i, inDegrees, n, ans);

    return ans.size() == n ? ans : vector<int>();
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>& inDegrees,
           int n, vector<int>& ans) {
    if (u < n)
      ans.push_back(u);

    inDegrees[u] = -1;  // Mark as visited.

    for (const int v : graph[u])
      if (--inDegrees[v] == 0)
        dfs(graph, v, inDegrees, n, ans);
  }
};"
"1204","WITH
  AccumulatedQueue AS (
    SELECT
      person_name,
      SUM(weight) OVER(ORDER BY turn) AS accumulated_weight
    FROM Queue
  )
SELECT person_name
FROM AccumulatedQueue
WHERE accumulated_weight <= 1000
ORDER BY accumulated_weight DESC
LIMIT 1;"
"1205","WITH
  ApprovedTransactionsAndChargebacks AS (
    SELECT
      id,
      country,
      state,
      amount,
      DATE_FORMAT(trans_date, '%Y-%m') AS `month`
    FROM Transactions
    WHERE state = 'approved'
    UNION ALL
    SELECT
      trans_id AS id,
      country,
      'chargeback' AS state,
      amount,
      DATE_FORMAT(Chargebacks.trans_date, '%Y-%m') AS `month`
    FROM Chargebacks
    LEFT JOIN Transactions
      ON (Chargebacks.trans_id = Transactions.id)
  )
SELECT
  `month`,
  country,
  SUM(state = 'approved') AS approved_count,
  SUM(IF(state = 'approved', amount, 0)) AS approved_amount,
  SUM(state = 'chargeback') AS chargeback_count,
  SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM ApprovedTransactionsAndChargebacks
GROUP BY 1, 2;"
"1206","from dataclasses import dataclass


@dataclass
class Node:
  val: int = -1
  next: 'Node' = None
  down: 'Node' = None


class Skiplist:
  def __init__(self):
    self.dummy = Node()

  def search(self, target: int) -> bool:
    node = self.dummy
    while node:
      while node.next and node.next.val < target:
        node = node.next
      if node.next and node.next.val == target:
        return True
      # Move to the next level
      node = node.down
    return False

  def add(self, num: int) -> None:
    # Collect nodes that are before the insertion point.
    nodes = []
    node = self.dummy
    while node:
      while node.next and node.next.val < num:
        node = node.next
      nodes.append(node)
      # Move to the next level
      node = node.down

    shouldInsert = True
    down = None
    while shouldInsert and nodes:
      node = nodes.pop()
      node.next = Node(num, node.next, down)
      down = node.next
      shouldInsert = random.getrandbits(1) == 0

    # Create a topmost new level dummy that points to the existing dummy.
    if shouldInsert:
      self.dummy = Node(-1, None, self.dummy)

  def erase(self, num: int) -> bool:
    node = self.dummy
    found = False
    while node:
      while node.next and node.next.val < num:
        node = node.next
      if node.next and node.next.val == num:
        # Delete the node
        node.next = node.next.next
        found = True
      # Move to the next level
      node = node.down
    return found

  # Move to the node s.t. node.next.val >= target
  def _advance(self, node: Node, target: int) -> None:
    while node.next and node.next.val < target:
      node = node.next"
"1207","class Solution:
  def uniqueOccurrences(self, arr: list[int]) -> bool:
    count = collections.Counter(arr)
    occurrences = set()

    for value in count.values():
      if value in occurrences:
        return False
      occurrences.add(value)

    return True"
"1208","class Solution:
  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
    j = 0
    for i in range(len(s)):
      maxCost -= abs(ord(s[i]) - ord(t[i]))
      if maxCost < 0:
        maxCost += abs(ord(s[j]) - ord(t[j]))
        j += 1

    return len(s) - j"
"1209","class Solution:
  def removeDuplicates(self, s: str, k: int) -> str:
    stack = []

    for c in s:
      if not stack or stack[-1][0] != c:
        stack.append([c, 1])
      else:  # stack[-1][0] == c
        stack[-1][1] += 1
        if stack[-1][1] == k:
          stack.pop()

    return ''.join(c * count for c, count in stack)"
"121","class Solution:
  def maxProfit(self, prices: list[int]) -> int:
    sellOne = 0
    holdOne = -math.inf

    for price in prices:
      sellOne = max(sellOne, holdOne + price)
      holdOne = max(holdOne, -price)

    return sellOne"
"1210","from enum import IntEnum


class Pos(IntEnum):
  kHorizontal = 0
  kVertical = 1


class Solution:
  def minimumMoves(self, grid: list[list[int]]) -> int:
    n = len(grid)
    ans = 0
    # the state of (x, y, pos)
    # pos := 0 (horizontal) / 1 (vertical)
    q = collections.deque([(0, 0, Pos.kHorizontal)])
    seen = {(0, 0, Pos.kHorizontal)}

    def canMoveRight(x: int, y: int, pos: Pos) -> bool:
      if pos == Pos.kHorizontal:
        return y + 2 < n and not grid[x][y + 2]
      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]

    def canMoveDown(x: int, y: int, pos: Pos) -> bool:
      if pos == Pos.kVertical:
        return x + 2 < n and not grid[x + 2][y]
      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]

    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:
      return (pos == Pos.kHorizontal and x + 1 < n and
              not grid[x + 1][y + 1] and not grid[x + 1][y])

    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:
      return (pos == Pos.kVertical and y + 1 < n and
              not grid[x + 1][y + 1] and not grid[x][y + 1])

    while q:
      for _ in range(len(q)):
        x, y, pos = q.popleft()
        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:
          return ans
        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:
          q.append((x, y + 1, pos))
          seen.add((x, y + 1, pos))
        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:
          q.append((x + 1, y, pos))
          seen.add((x + 1, y, pos))
        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal
        if ((canRotateClockwise(x, y, pos) or
             canRotateCounterclockwise(x, y, pos)) and
                (x, y, newPos) not in seen):
          q.append((x, y, newPos))
          seen.add((x, y, newPos))
      ans += 1

    return -1"
"1211","SELECT
  query_name,
  ROUND(AVG(rating / position), 2) AS quality,
  ROUND(AVG(rating < 3) * 100, 2) AS poor_query_percentage
FROM Queries
GROUP BY 1;"
"1212","WITH
  TwoWayMatches AS (
    SELECT
      host_team AS team_id,
      host_goals AS goals,
      guest_goals AS opponent_goals
    FROM Matches
    UNION ALL
    SELECT
      guest_team,
      guest_goals,
      host_goals
    FROM Matches
  )
SELECT
  Teams.team_id,
  Teams.team_name,
  SUM(
    CASE
      WHEN goals > opponent_goals THEN 3
      WHEN goals = opponent_goals THEN 1
      ELSE 0
    END
 ) AS num_points
FROM Teams
LEFT JOIN TwoWayMatches
  USING (team_id)
GROUP BY 1
ORDER BY num_points DESC, team_id;"
"1213","class Solution {
 public:
  vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2,
                                 vector<int>& arr3) {
    vector<int> ans;
    int i = 0;
    int j = 0;
    int k = 0;

    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
      const int mn = min({arr1[i], arr2[j], arr3[k]});
      if (arr1[i] == mn && arr2[j] == mn && arr3[k] == mn) {
        ans.push_back(mn);
        ++i;
        ++j;
        ++k;
      } else if (arr1[i] == mn) {
        ++i;
      } else if (arr2[j] == mn) {
        ++j;
      } else {
        ++k;
      }
    }

    return ans;
  }
};"
"1214","class BSTIterator:
  def __init__(self, root: TreeNode | None, leftToRight: bool):
    self.stack = []
    self.leftToRight = leftToRight
    self._pushUntilNone(root)

  def hasNext(self) -> bool:
    return len(self.stack) > 0

  def next(self) -> int:
    node = self.stack.pop()
    if self.leftToRight:
      self._pushUntilNone(node.right)
    else:
      self._pushUntilNone(node.left)
    return node.val

  def _pushUntilNone(self, root: TreeNode | None):
    while root:
      self.stack.append(root)
      root = root.left if self.leftToRight else root.right


class Solution:
  def twoSumBSTs(
      self,
      root1: TreeNode | None,
      root2: TreeNode | None,
      target: int,
  ) -> bool:
    bst1 = BSTIterator(root1, True)
    bst2 = BSTIterator(root2, False)

    l = bst1.next()
    r = bst2.next()
    while True:
      summ = l + r
      if summ == target:
        return True
      if summ < target:
        if not bst1.hasNext():
          return False
        l = bst1.next()
      else:
        if not bst2.hasNext():
          return False
        r = bst2.next()"
"1215","class Solution:
  def countSteppingNumbers(self, low: int, high: int) -> list[int]:
    ans = [0] if low == 0 else []
    q = collections.deque(list(range(1, 10)))

    while q:
      curr = q.popleft()
      if curr > high:
        continue
      if curr >= low:
        ans.append(curr)
      lastDigit = curr % 10
      if lastDigit > 0:
        q.append(curr * 10 + lastDigit - 1)
      if lastDigit < 9:
        q.append(curr * 10 + lastDigit + 1)

    return ans"
"1216","class Solution:
  def isValidPalindrome(self, s: str, k: int) -> bool:
    return len(s) - self._longestPalindromeSubseq(s) <= k

  # Same as 516. Longest Palindromic Subsequence
  def _longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]"
"1217","class Solution:
  def minCostToMoveChips(self, position: list[int]) -> int:
    count = [0, 0]
    for p in position:
      count[p % 2] += 1
    return min(count[0], count[1])"
"1218","class Solution:
  def longestSubsequence(self, arr: list[int], difference: int) -> int:
    ans = 0
    lengthAt = {}

    for a in arr:
      lengthAt[a] = lengthAt.get(a - difference, 0) + 1
      ans = max(ans, lengthAt[a])

    return ans"
"1219","class Solution:
  def getMaximumGold(self, grid: list[list[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):
        return 0
      if grid[i][j] == 0:
        return 0

      gold = grid[i][j]
      grid[i][j] = 0  # Mark as visited.
      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),
                    dfs(i, j + 1), dfs(i, j - 1))
      grid[i][j] = gold
      return gold + maxPath

    return max(dfs(i, j)
               for i in range(len(grid))
               for j in range(len(grid[0])))"
"122","class Solution:
  def maxProfit(self, prices: list[int]) -> int:
    sell = 0
    hold = -math.inf

    for price in prices:
      sell = max(sell, hold + price)
      hold = max(hold, sell - price)

    return sell"
"1220","class Solution:
  def countVowelPermutation(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}

    for _ in range(n - 1):
      newDp = {'a': dp['e'] + dp['i'] + dp['u'],
               'e': dp['a'] + dp['i'],
               'i': dp['e'] + dp['o'],
               'o': dp['i'],
               'u': dp['i'] + dp['o']}
      dp = newDp

    return sum(dp.values()) % kMod"
"1221","class Solution {
 public:
  int balancedStringSplit(string s) {
    int ans = 0;
    int count = 0;

    for (const char c : s) {
      count += c == 'L' ? 1 : -1;
      if (count == 0)
        ++ans;
    }

    return ans;
  }
};"
"1222","class Solution:
  def queensAttacktheKing(self, queens: list[list[int]],
                          king: list[int]) -> list[list[int]]:
    ans = []
    queens = {(i, j) for i, j in queens}

    for d in [
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, -1],
        [0, 1],
        [1, -1],
        [1, 0],
            [1, 1]]:
      i = king[0] + d[0]
      j = king[1] + d[1]
      while 0 <= i < 8 and 0 <= j < 8:
        if (i, j) in queens:
          ans.append([i, j])
          break
        i += d[0]
        j += d[1]

    return ans"
"1223","class Solution:
  def dieSimulator(self, n: int, rollMax: list[int]) -> int:
    kMaxRolls = 15
    kMod = 1_000_000_007

    dp = [[[0] * (kMaxRolls + 1) for j in range(6)] for i in range(n + 1)]

    for num in range(6):
      dp[1][num][1] = 1

    for i in range(2, n + 1):
      for currNum in range(6):
        for prevNum in range(6):
          for k in range(1, 15 + 1):
            if prevNum != currNum:
              dp[i][currNum][1] = (
                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % kMod
            elif k < rollMax[currNum]:
              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]

    ans = 0

    for num in range(6):
      for k in range(1, 15 + 1):
        ans += dp[n][num][k]

    return ans % kMod"
"1224","class Solution:
  def maxEqualFreq(self, nums: list[int]) -> int:
    ans = 0
    maxFreq = 0
    count = collections.Counter()
    freq = collections.Counter()

    for i, num in enumerate(nums):
      freq[count[num]] -= 1
      count[num] += 1
      freq[count[num]] += 1
      maxFreq = max(maxFreq, count[num])
      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (
              freq[maxFreq - 1] + 1) == i:
        ans = i + 1

    return ans"
"1225","WITH
  RankedDatesPerState AS (
    SELECT
      'failed' AS state,
      fail_date AS `date`,
      RANK() OVER(ORDER BY fail_date) AS rank_per_state
    FROM Failed
    WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'
    UNION ALL
    SELECT
      'succeeded' AS state,
      success_date AS `date`,
      RANK() OVER(ORDER BY success_date) AS rank_per_state
    FROM Succeeded
    WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31'
  ),
  RankedDates AS (
    SELECT
      state,
      `date`,
      rank_per_state,
      RANK() OVER(ORDER BY `date`) AS `rank`
    FROM RankedDatesPerState
  )
SELECT
  state AS period_state,
  MIN(`date`) AS start_date,
  MAX(`date`) AS end_date
FROM RankedDates
GROUP BY state, (`rank` - rank_per_state)
ORDER BY start_date"
"1226","class DiningPhilosophers {
  std::mutex mutex;

 public:
  void wantsToEat(int philosopher, function<void()> pickLeftFork,
                  function<void()> pickRightFork, function<void()> eat,
                  function<void()> putLeftFork, function<void()> putRightFork) {
    mutex.lock();
    pickLeftFork();
    pickRightFork();
    eat();
    putLeftFork();
    putRightFork();
    mutex.unlock();
  }
};"
"1227","class Solution:
  def nthPersonGetsNthSeat(self, n: int) -> float:
    return 1 if n == 1 else 0.5"
"1228","class Solution:
  def missingNumber(self, arr: list[int]) -> int:
    n = len(arr)
    delta = (arr[-1] - arr[0]) // n
    l = 0
    r = n - 1

    while l < r:
      m = (l + r) // 2
      if arr[m] == arr[0] + m * delta:
        l = m + 1
      else:
        r = m

    return arr[0] + l * delta"
"1229","class Solution:
  def minAvailableDuration(
      self,
      slots1: list[list[int]],
      slots2: list[list[int]],
      duration: int,
  ) -> list[int]:
    slots1.sort()
    slots2.sort()

    i = 0  # slots1's index
    j = 0  # slots2's index

    while i < len(slots1) and j < len(slots2):
      start = max(slots1[i][0], slots2[j][0])
      end = min(slots1[i][1], slots2[j][1])
      if start + duration <= end:
        return [start, start + duration]
      if slots1[i][1] < slots2[j][1]:
        i += 1
      else:
        j += 1

    return []"
"123","class Solution:
  def maxProfit(self, prices: list[int]) -> int:
    sellTwo = 0
    holdTwo = -math.inf
    sellOne = 0
    holdOne = -math.inf

    for price in prices:
      sellTwo = max(sellTwo, holdTwo + price)
      holdTwo = max(holdTwo, sellOne - price)
      sellOne = max(sellOne, holdOne + price)
      holdOne = max(holdOne, -price)

    return sellTwo"
"1230","class Solution:
  def probabilityOfHeads(self, prob: list[float], target: int) -> float:
    # dp[j] := the probability of tossing the coins so far with j heads
    dp = [1.0] + [0] * len(prob)

    for p in prob:
      for j in range(target, -1, -1):
        dp[j] = (dp[j - 1] * p if j > 0 else 0) + dp[j] * (1 - p)

    return dp[target]"
"1231","class Solution:
  def maximizeSweetness(self, sweetness: list[int], k: int) -> int:
    l = len(sweetness) // (k + 1)
    r = sum(sweetness) // (k + 1)

    def canEat(m: int) -> bool:
      """"""
      Returns True if can eat m sweetness (the minimum sweetness of each piece).
      """"""
      pieces = 0
      summ = 0  # the running sum
      for s in sweetness:
        summ += s
        if summ >= m:
          pieces += 1
          summ = 0
      return pieces > k

    while l < r:
      m = (l + r) // 2
      if canEat(m):
        l = m + 1
      else:
        r = m

    return l if canEat(l) else l - 1"
"1232","class Solution:
  def checkStraightLine(self, coordinates: list[list[int]]) -> bool:
    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]
    dx = x1 - x0
    dy = y1 - y0

    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)"
"1233","class Solution:
  def removeSubfolders(self, folder: list[str]) -> list[str]:
    ans = []
    prev = """"

    folder.sort()

    for f in folder:
      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':
        continue
      ans.append(f)
      prev = f

    return ans"
"1234","class Solution:
  def balancedString(self, s: str) -> int:
    ans = len(s)
    count = collections.Counter(s)
    j = 0

    for i, c in enumerate(s):
      count[c] -= 1
      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):
        ans = min(ans, i - j + 1)
        count[s[j]] += 1
        j += 1

    return ans"
"1235","class Solution:
  def jobScheduling(
      self,
      startTime: list[int],
      endTime: list[int],
      profit: list[int],
  ) -> int:
    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])

    # Will use binary search to find the first available startTime
    for i in range(len(startTime)):
      startTime[i] = jobs[i][0]

    @functools.lru_cache(None)
    def dp(i: int) -> int:
      """"""Returns the maximum profit to schedule jobs[i..n).""""""
      if i == len(startTime):
        return 0
      j = bisect.bisect_left(startTime, jobs[i][1])
      return max(jobs[i][2] + dp(j), dp(i + 1))

    return dp(0)"
"1236","# """"""
# This is HtmlParser's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# Class HtmlParser(object):
#   def getUrls(self, url: str) -> list[str]:

class Solution:
  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> list[str]:
    q = collections.deque([startUrl])
    seen = {startUrl}
    hostname = startUrl.split('/')[2]

    while q:
      currUrl = q.popleft()
      for url in htmlParser.getUrls(currUrl):
        if url in seen:
          continue
        if hostname in url:
          q.append(url)
          seen.add(url)

    return seen"
"1237","class Solution:
  def findSolution(self, customfunction: 'CustomFunction', z: int) -> list[list[int]]:
    ans = []
    x = 1
    y = 1000

    while x <= 1000 and y >= 1:
      f = customfunction.f(x, y)
      if f < z:
        x += 1
      elif f > z:
        y -= 1
      else:
        ans.append([x, y])
        x += 1
        y -= 1

    return ans"
"1238","class Solution:
  def circularPermutation(self, n: int, start: int) -> list[int]:
    return [start ^ i ^ i >> 1 for i in range(1 << n)]"
"1239","class Solution {
 public:
  int maxLength(vector<string>& arr) {
    vector<int> masks;

    for (const string& s : arr) {
      const int mask = getMask(s);
      if (mask != -1)
        masks.push_back(mask);
    }

    return dfs(masks, 0, /*used=*/0);
  }

 private:
  int dfs(const vector<int>& masks, int s, unsigned used) {
    int res = popcount(used);
    for (int i = s; i < masks.size(); ++i)
      if ((used & masks[i]) == 0)
        res = max(res, dfs(masks, i + 1, used | masks[i]));
    return res;
  }

  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s) {
      const int i = c - 'a';
      if ((mask & (1 << i)) != 0)
        return -1;
      mask |= 1 << i;
    }
    return mask;
  }
};"
"124","class Solution:
  def maxPathSum(self, root: TreeNode | None) -> int:
    ans = -math.inf

    def maxPathSumDownFrom(root: TreeNode | None) -> int:
      """"""
      Returns the maximum path sum starting from the current root, where
      root.val is always included.
      """"""
      nonlocal ans
      if not root:
        return 0

      l = max(0, maxPathSumDownFrom(root.left))
      r = max(0, maxPathSumDownFrom(root.right))
      ans = max(ans, root.val + l + r)
      return root.val + max(l, r)

    maxPathSumDownFrom(root)
    return ans"
"1240","class Solution:
  def tilingRectangle(self, n: int, m: int) -> int:
    @functools.lru_cache(None)
    def dp(heights: int) -> int:
      minHeight = min(heights)
      if minHeight == n:  # All filled.
        return 0

      ans = m * n
      heightsList = list(heights)
      start = heightsList.index(minHeight)

      # Try to put square of different size that doesn't exceed the width/height.
      for sz in range(1, min(m - start + 1, n - minHeight + 1)):
        # heights[start..start + sz) must has the same height.
        if heights[start + sz - 1] != minHeight:
          break
        # Put a square of size `sz` to cover heights[start..start + sz).
        heightslist[start:start + sz] = [minHeight + sz] * sz
        ans = min(ans, dp(tuple(heightsList)))

      return 1 + ans

    return dp(tuple([0] * m))"
"1241","WITH
  Posts AS (
    SELECT DISTINCT sub_id AS post_id
    FROM Submissions
    WHERE parent_id IS NULL
  )
SELECT
  Posts.post_id,
  COUNT(DISTINCT Comments.sub_id) AS number_of_comments
FROM Posts
LEFT JOIN Submissions AS Comments
  ON (Posts.post_id = Comments.parent_id)
GROUP BY 1;"
"1242","/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);
    const int nThreads = std::thread::hardware_concurrency();
    vector<thread> threads;
    std::mutex mtx;
    std::condition_variable cv;

    auto t = [&]() {
      while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait_for(lock, 30ms, [&]() { return q.size(); });
        if (q.empty())
          return;
        auto cur = q.front();
        q.pop();
        lock.unlock();
        const vector<string> urls = htmlParser.getUrls(cur);
        lock.lock();
        for (const string& url : urls) {
          if (seen.contains(url))
            continue;
          if (url.find(hostname) != string::npos) {
            q.push(url);
            seen.insert(url);
          }
        }
        lock.unlock();
        cv.notify_all();
      }
    };

    for (int i = 0; i < nThreads; ++i)
      threads.emplace_back(t);

    for (std::thread& t : threads)
      t.join();

    return {seen.begin(), seen.end()};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};"
"1243","class Solution:
  def transformArray(self, arr: list[int]) -> list[int]:
    if len(arr) < 3:
      return arr

    ans = []

    while ans != arr:
      ans = arr[:]
      for i in range(1, len(arr) - 1):
        if ans[i - 1] > ans[i] < ans[i + 1]:
          arr[i] += 1
        elif ans[i - 1] < ans[i] > ans[i + 1]:
          arr[i] -= 1

    return ans"
"1244","class Leaderboard:
  def __init__(self):
    self.idToScore = collections.Counter()

  def addScore(self, playerId: int, score: int) -> None:
    self.idToScore[playerId] += score

  def top(self, K: int) -> int:
    return sum(score for _, score in self.idToScore.most_common(K))

  def reset(self, playerId: int) -> None:
    del self.idToScore[playerId]"
"1245","class Solution {
 public:
  int treeDiameter(vector<vector<int>>& edges) {
    const int n = edges.size();
    int ans = 0;
    vector<vector<int>> tree(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    maxDepth(tree, 0, -1, ans);
    return ans;
  }

 private:
  int maxDepth(const vector<vector<int>>& tree, int u, int prev, int& ans) {
    int maxDepth1 = 0;   // the maximum depth
    int maxDepth2 = -1;  // the second maximum depth

    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      const int depth = maxDepth(tree, v, u, ans);
      if (depth > maxDepth1) {
        maxDepth2 = maxDepth1;
        maxDepth1 = depth;
      } else if (depth > maxDepth2) {
        maxDepth2 = depth;
      }
    }

    ans = max(ans, maxDepth1 + maxDepth2);
    return 1 + maxDepth1;
  }
};"
"1246","class Solution:
  def minimumMoves(self, arr: list[int]) -> int:
    n = len(arr)
    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]
    dp = [[n] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for i in range(n - 1):
      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2

    for d in range(2, n):
      for i in range(n - d):
        j = i + d
        # Remove arr[i] and arr[j] within the move of removing
        # arr[i + 1..j - 1]
        if arr[i] == arr[j]:
          dp[i][j] = dp[i + 1][j - 1]
        # Try all the possible partitions.
        for k in range(i, j):
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])

    return dp[0][n - 1]"
"1247","class Solution:
  def minimumSwap(self, s1: str, s2: str) -> int:
    # ('xx', 'yy') = (2 'xy's) . 1 swap
    # ('yy', 'xx') = (2 'yx's) . 1 swap
    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps
    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'
    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'

    for a, b in zip(s1, s2):
      if a == b:
        continue
      if a == 'x':
        xy += 1
      else:
        yx += 1

    if (xy + yx) % 2 == 1:
      return -1
    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)"
"1248","class Solution:
  def numberOfSubarrays(self, nums: list[int], k: int) -> int:
    def numberOfSubarraysAtMost(k: int) -> int:
      ans = 0
      l = 0
      r = 0

      while r <= len(nums):
        if k >= 0:
          ans += r - l
          if r == len(nums):
            break
          if nums[r] & 1:
            k -= 1
          r += 1
        else:
          if nums[l] & 1:
            k += 1
          l += 1
      return ans

    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)"
"1249","class Solution:
  def minRemoveToMakeValid(self, s: str) -> str:
    stack = []  # unpaired '(' indices
    chars = list(s)

    for i, c in enumerate(chars):
      if c == '(':
        stack.append(i)  # Record the unpaired '(' index.
      elif c == ')':
        if stack:
          stack.pop()  # Find a pair
        else:
          chars[i] = '*'  # Mark the unpaired ')' as '*'.

    # Mark the unpaired '(' as '*'.
    while stack:
      chars[stack.pop()] = '*'

    return ''.join(chars).replace('*', '')"
"125","class Solution:
  def isPalindrome(self, s: str) -> bool:
    l = 0
    r = len(s) - 1

    while l < r:
      while l < r and not s[l].isalnum():
        l += 1
      while l < r and not s[r].isalnum():
        r -= 1
      if s[l].lower() != s[r].lower():
        return False
      l += 1
      r -= 1

    return True"
"1250","class Solution {
 public:
  bool isGoodArray(vector<int>& nums) {
    int g = nums[0];

    for (const int num : nums)
      g = __gcd(g, num);

    return g == 1;
  }
};"
"1251","SELECT
  Prices.product_id,
  IFNULL(
    ROUND(
      SUM(Prices.price * UnitsSold.units) / SUM(UnitsSold.units),
      2
    ),
    0
  ) AS average_price
FROM Prices
LEFT JOIN UnitsSold
  ON (
    Prices.product_id = UnitsSold.product_id
    AND UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date)
GROUP BY 1;"
"1252","class Solution:
  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:
    # rows[i] and cols[i] :=
    #   true (flipped even times) / false (flipped odd times)
    rows = [False] * m
    cols = [False] * n

    for r, c in indices:
      rows[r] ^= True
      cols[c] ^= True

    return sum(rows[i] ^ cols[j]
               for i in range(m)
               for j in range(n))"
"1253","class Solution:
  def reconstructMatrix(self, upper: int, lower: int, colsum: list[int]) -> list[list[int]]:
    if upper + lower != sum(colsum):
      return []
    if min(upper, lower) < colsum.count(2):
      return []

    ans = [[0] * len(colsum) for _ in range(2)]

    for j, c in enumerate(colsum):
      if c == 2:
        ans[0][j] = 1
        ans[1][j] = 1
        upper -= 1
        lower -= 1

    for j, c in enumerate(colsum):
      if c == 1 and upper > 0:
        ans[0][j] = 1
        c -= 1
        upper -= 1
      if c == 1 and lower > 0:
        ans[1][j] = 1
        lower -= 1

    return ans"
"1254","class Solution:
  def closedIsland(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    def dfs(i: int, j: int) -> None:
      if i < 0 or i == m or j < 0 or j == n:
        return
      if grid[i][j] == 1:
        return
      grid[i][j] = 1
      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    # Remove the lands connected to the edge.
    for i in range(m):
      for j in range(n):
        if i * j == 0 or i == m - 1 or j == n - 1:
          if grid[i][j] == 0:
            dfs(i, j)

    ans = 0

    # Reduce to 200. Number of Islands
    for i in range(m):
      for j in range(n):
        if grid[i][j] == 0:
          dfs(i, j)
          ans += 1

    return ans"
"1255","class Solution:
  def maxScoreWords(
      self,
      words: list[str],
      letters: list[str],
      score: list[int],
  ) -> int:
    count = collections.Counter(letters)

    def useWord(i: int) -> int:
      isValid = True
      earned = 0
      for c in words[i]:
        count[c] -= 1
        if count[c] < 0:
          isValid = False
        earned += score[string.ascii_lowercase.index(c)]
      return earned if isValid else -1

    def unuseWord(i: int) -> None:
      for c in words[i]:
        count[c] += 1

    def dfs(s: int) -> int:
      """"""Returns the maximum score you can get from words[s..n).""""""
      ans = 0
      for i in range(s, len(words)):
        earned = useWord(i)
        if earned > 0:
          ans = max(ans, earned + dfs(i + 1))
        unuseWord(i)
      return ans

    return dfs(0)"
"1256","class Solution:
  def encode(self, num: int) -> str:
    return bin(num + 1)[3:]"
"1257","class Solution {
  public String findSmallestRegion(List<List<String>> regions, String region1, String region2) {
    Map<String, String> parent = new HashMap<>();
    Set<String> ancestors = new HashSet<>(); // region1's ancestors

    for (List<String> region : regions)
      for (int i = 1; i < region.size(); ++i)
        parent.put(region.get(i), region.get(0));

    // Add all the region1's ancestors.
    while (region1 != null) {
      ancestors.add(region1);
      region1 = parent.get(region1); // Region1 becomes null in the end.
    }

    // Go up from region2 until meet any of region1's ancestors.
    while (!ancestors.contains(region2))
      region2 = parent.get(region2);

    return region2;
  }
}"
"1258","from sortedcontainers import SortedSet


class Solution:
  def generateSentences(
      self,
      synonyms: list[list[str]],
      text: str,
  ) -> list[str]:
    ans = SortedSet()
    graph = collections.defaultdict(list)
    q = collections.deque([text])

    for s, t in synonyms:
      graph[s].append(t)
      graph[t].append(s)

    while q:
      u = q.popleft()
      ans.add(u)
      words = u.split()
      for i, word in enumerate(words):
        for synonym in graph[word]:
          # Replace words[i] with its synonym.
          words[i] = synonym
          newText = ' '.join(words)
          if newText not in ans:
            q.append(newText)

    return list(ans)"
"1259","class Solution:
  def numberOfWays(self, numPeople: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways i handshakes could occure s.t. none of the
    # handshakes cross
    dp = [1] + [0] * (numPeople // 2)

    for i in range(1, numPeople // 2 + 1):
      for j in range(i):
        dp[i] += dp[j] * dp[i - 1 - j]
        dp[i] %= kMod

    return dp[numPeople // 2]"
"126","class Solution:
  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:
    wordSet = set(wordList)
    if endWord not in wordList:
      return []

    # {""hit"": [""hot""], ""hot"": [""dot"", ""lot""], ...}
    graph: dict[str, list[str]] = collections.defaultdict(list)

    # Build the graph from the beginWord to the endWord.
    if not self._bfs(beginWord, endWord, wordSet, graph):
      return []

    ans = []

    self._dfs(graph, beginWord, endWord, [beginWord], ans)
    return ans

  def _bfs(
      self,
      beginWord: str,
      endWord: str,
      wordSet: set[str],
      graph: dict[str, list[str]],
  ) -> bool:
    q1 = {beginWord}
    q2 = {endWord}
    backward = False

    while q1 and q2:
      for word in q1:
        wordSet.discard(word)
      for word in q2:
        wordSet.discard(word)
      # Always expand the smaller queue.
      if len(q1) > len(q2):
        q1, q2 = q2, q1
        backward = not backward
      q = set()
      reachEndWord = False
      for parent in q1:
        for child in self._getChildren(parent, wordSet, q2):
          if child in wordSet or child in q2:
            q.add(child)
            if backward:
              graph[child].append(parent)
            else:
              graph[parent].append(child)
          if child in q2:
            reachEndWord = True
      if reachEndWord:
        return True
      q1 = q

    return False

  def _getChildren(self, parent: str, wordSet: set[str], q2) -> list[str]:
    children = []
    s = list(parent)

    for i, cache in enumerate(s):
      for c in string.ascii_lowercase:
        if c == cache:
          continue
        s[i] = c
        child = ''.join(s)
        if child in wordSet or child in q2:
          children.append(child)
      s[i] = cache

    return children

  def _dfs(
      self,
      graph: dict[str, list[str]],
      word: str,
      endWord: str,
      path: list[str],
      ans: list[list[str]],
  ) -> None:
    if word == endWord:
      ans.append(path.copy())
      return

    for child in graph.get(word, []):
      path.append(child)
      self._dfs(graph, child, endWord, path, ans)
      path.pop()"
"1260","class Solution:
  def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]

    k %= m * n

    for i in range(m):
      for j in range(n):
        index = (i * n + j + k) % (m * n)
        x = index // n
        y = index % n
        ans[x][y] = grid[i][j]

    return ans"
"1261","class FindElements:
  def __init__(self, root: TreeNode | None):
    self.vals = set()
    self.dfs(root, 0)

  def find(self, target: int) -> bool:
    return target in self.vals

  def dfs(self, root: TreeNode | None, val: int) -> None:
    if not root:
      return

    root.val = val
    self.vals.add(val)
    self.dfs(root.left, val * 2 + 1)
    self.dfs(root.right, val * 2 + 2)"
"1262","class Solution {
 public:
  int maxSumDivThree(vector<int>& nums) {
    vector<int> dp(3);  // dp[i] := the maximum sum so far s.t. sum % 3 == i

    for (const int num : nums)
      for (const int sum : vector<int>(dp))
        dp[(sum + num) % 3] = max(dp[(sum + num) % 3], sum + num);

    return dp[0];
  }
};"
"1263","class Solution:
  def minPushBox(self, grid: list[list[str]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 'B':
          box = (i, j)
        elif grid[i][j] == 'S':
          player = (i, j)
        elif grid[i][j] == 'T':
          target = (i, j)

    def isInvalid(playerX: int, playerY: int) -> bool:
      return (playerX < 0 or playerX == m or playerY < 0 or playerY == n or
              grid[playerX][playerY] == '#')

    def canGoTo(
            playerX: int, playerY: int,
            fromX: int, fromY: int,
            boxX: int, boxY: int) -> bool:
      """"""Returns True if (playerX, playerY) can go to (fromX, fromY).""""""
      q = collections.deque([(playerX, playerY)])
      seen = {(playerX, playerY)}

      while q:
        i, j = q.popleft()
        if i == fromX and j == fromY:
          return True
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if isInvalid(x, y):
            continue
          if (x, y) in seen:
            continue
          if x == boxX and y == boxY:
            continue
          q.append((x, y))
          seen.add((x, y))

      return False

    # (boxX, boxY, playerX, playerY)
    q = collections.deque([(box[0], box[1], player[0], player[1])])
    seen = {(box[0], box[1], player[0], player[1])}

    step = 0
    while q:
      for _ in range(len(q)):
        boxX, boxY, playerX, playerY = q.popleft()
        if boxX == target[0] and boxY == target[1]:
          return step
        for k, (dx, dy) in enumerate(dirs):
          nextBoxX = boxX + dx
          nextBoxY = boxY + dy
          if isInvalid(nextBoxX, nextBoxY):
            continue
          if (nextBoxX, nextBoxY, boxX, boxY) in seen:
            continue
          fromX = boxX + dirs[(k + 2) % 4][0]
          fromY = boxY + dirs[(k + 2) % 4][1]
          if isInvalid(fromX, fromY):
            continue
          if canGoTo(playerX, playerY, fromX, fromY, boxX, boxY):
            q.append((nextBoxX, nextBoxY, boxX, boxY))
            seen.add((nextBoxX, nextBoxY, boxX, boxY))
      step += 1

    return -1"
"1264","WITH
  UserToFriends AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id AS user_id, user1_id AS friend_id FROM friendship
  )
SELECT FriendLikes.page_id AS recommended_page
FROM UserToFriends
LEFT JOIN Likes AS FriendLikes
  ON (UserToFriends.friend_id = FriendLikes.user_id)
LEFT JOIN Likes AS UserLikes
  ON (
    UserToFriends.user_id = UserLikes.user_id
    AND FriendLikes.page_id = UserLikes.page_id)
WHERE
  UserToFriends.user_id = 1
  AND UserLikes.page_id IS NULL
  AND FriendLikes.page_id IS NOT NULL
GROUP BY 1;"
"1265","/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 *  public:
 *   void printValue(); // Print the value of the node.
 *   ImmutableListNode* getNext(); // Returns the next node.
 * };
 */

class Solution {
 public:
  void printLinkedListInReverse(ImmutableListNode* head) {
    if (head == nullptr)
      return;

    printLinkedListInReverse(head->getNext());
    head->printValue();
  }
};"
"1266","class Solution:
  def minTimeToVisitAllPoints(self, points: list[list[int]]) -> int:
    ans = 0

    for i in range(1, len(points)):
      ans += max(abs(points[i][0] - points[i - 1][0]),
                 abs(points[i][1] - points[i - 1][1]))

    return ans"
"1267","class Solution:
  def countServers(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    rows = [0] * m
    cols = [0] * n

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          rows[i] += 1
          cols[j] += 1

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):
          ans += 1

    return ans"
"1268","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.word: str | None = None


class Solution:
  def suggestedProducts(self, products: list[str],
                        searchWord: str) -> list[list[str]]:
    ans = []
    root = TrieNode()

    def insert(word: str) -> None:
      node = root
      for c in word:
        node = node.children.setdefault(c, TrieNode())
      node.word = word

    def search(node: TrieNode | None) -> list[str]:
      res: list[str] = []
      dfs(node, res)
      return res

    def dfs(node: TrieNode | None, res: list[str]) -> None:
      if len(res) == 3:
        return
      if not node:
        return
      if node.word:
        res.append(node.word)
      for c in string.ascii_lowercase:
        if c in node.children:
          dfs(node.children[c], res)

    for product in products:
      insert(product)

    node = root

    for c in searchWord:
      if not node or c not in node.children:
        node = None
        ans.append([])
        continue
      node = node.children[c]
      ans.append(search(node))

    return ans"
"1269","class Solution:
  def numWays(self, steps: int, arrLen: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to stay at index i
    dp = [0] * min(steps // 2 + 1, arrLen)
    dp[0] = 1

    for _ in range(steps):
      newDp = [0] * min(steps // 2 + 1, arrLen)
      for i, ways in enumerate(dp):
        if ways > 0:
          for dx in (-1, 0, 1):
            nextIndex = i + dx
            if 0 <= nextIndex < len(dp):
              newDp[nextIndex] += ways
              newDp[nextIndex] %= kMod
      dp = newDp

    return dp[0]"
"127","class Solution:
  def ladderLength(
      self,
      beginWord: str,
      endWord: str,
      wordList: list[str],
  ) -> int:
    wordSet = set(wordList)
    if endWord not in wordSet:
      return 0

    q = collections.deque([beginWord])

    step = 1
    while q:
      for _ in range(len(q)):
        wordList = list(q.popleft())
        for i, cache in enumerate(wordList):
          for c in string.ascii_lowercase:
            wordList[i] = c
            word = ''.join(wordList)
            if word == endWord:
              return step + 1
            if word in wordSet:
              q.append(word)
              wordSet.remove(word)
          wordList[i] = cache
      step += 1

    return 0"
"1270","SELECT Employee.employee_id
FROM Employees AS Employee
INNER JOIN Employees AS DirectManager
  ON (Employee.manager_id = DirectManager.employee_id)
INNER JOIN Employees AS SkipManager
  ON (DirectManager.manager_id = SkipManager.employee_id)
WHERE
  SkipManager.manager_id = 1
  AND Employee.employee_id != 1;"
"1271","class Solution:
  def toHexspeak(self, num: str) -> str:
    s = hex(int(num)).upper()[2:].translate(str.maketrans('01', 'OI'))
    return 'ERROR' if any(c.isdigit() for c in s) else s"
"1272","class Solution:
  def removeInterval(self, intervals: list[list[int]],
                     toBeRemoved: list[int]) -> list[list[int]]:
    ans = []

    for a, b in intervals:
      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:
        ans.append([a, b])
      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]
        if a < toBeRemoved[0]:
          ans.append([a, toBeRemoved[0]])
        if b > toBeRemoved[1]:
          ans.append([toBeRemoved[1], b])

    return ans"
"1273","struct T {
  int sum;
  int count;
};

class Solution {
 public:
  int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {
    vector<vector<int>> tree(nodes);

    for (int i = 1; i < parent.size(); ++i)
      tree[parent[i]].push_back(i);

    return dfs(tree, 0, value).count;
  }

 private:
  T dfs(const vector<vector<int>>& tree, int u, const vector<int>& value) {
    int sum = value[u];  // the root value
    int count = 1;       // this root

    for (const int v : tree[u]) {
      const T t = dfs(tree, v, value);
      sum += t.sum;
      count += t.count;
    }

    if (sum == 0)     // Delete this root.
      return {0, 0};  // So, its count = 0.
    return {sum, count};
  }
};"
"1274","# """"""
# This is Sea's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# class Sea(object):
#   def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:
#     pass
#
# class Point(object):
# def __init__(self, x: int, y: int):
# self.x = x
# self.y = y

class Solution(object):
  def countShips(
      self,
      sea: 'Sea',
      topRight: 'Point',
      bottomLeft: 'Point',
  ) -> int:
    if topRight.x < bottomLeft.x or topRight.y < bottomLeft.y:
      return 0
    if not sea.hasShips(topRight, bottomLeft):
      return 0

    # sea.hashShips(topRight, bottomLeft) == True
    if topRight.x == bottomLeft.x and topRight.y == bottomLeft.y:
      return 1

    mx = (topRight.x + bottomLeft.x) // 2
    my = (topRight.y + bottomLeft.y) // 2
    ans = 0
    # the top-right
    ans += self.countShips(sea, topRight, Point(mx + 1, my + 1))
    # the bottom-right
    ans += self.countShips(sea, Point(topRight.x, my),
                           Point(mx + 1, bottomLeft.y))
    # the top-left
    ans += self.countShips(sea, Point(mx, topRight.y),
                           Point(bottomLeft.x, my + 1))
    # the bottom-left
    ans += self.countShips(sea, Point(mx, my), bottomLeft)
    return ans"
"1275","class Solution:
  def tictactoe(self, moves: list[list[int]]) -> str:
    row = [[0] * 3 for _ in range(2)]
    col = [[0] * 3 for _ in range(2)]
    diag1 = [0] * 2
    diag2 = [0] * 2
    i = 0

    for r, c in moves:
      row[i][r] += 1
      col[i][c] += 1
      diag1[i] += r == c
      diag2[i] += r + c == 2
      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):
        return 'A' if i == 0 else 'B'
      i ^= 1

    return 'Draw' if len(moves) == 9 else 'Pending'"
"1276","class Solution:
  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> list[int]:
    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:
      return []

    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2

    return [jumboBurgers, cheeseSlices - jumboBurgers]"
"1277","class Solution:
  def countSquares(self, matrix: list[list[int]]) -> int:
    for i in range(len(matrix)):
      for j in range(len(matrix[0])):
        if matrix[i][j] == 1 and i > 0 and j > 0:
          matrix[i][j] += min(matrix[i - 1][j - 1],
                              matrix[i - 1][j], matrix[i][j - 1])
    return sum(map(sum, matrix))"
"1278","class Solution {
  public int palindromePartition(String s, int K) {
    final int n = s.length();
    // dp[i][k] := the minimum cost to make k palindromes by s[0..i)
    int[][] dp = new int[n + 1][K + 1];
    Arrays.stream(dp).forEach(A -> Arrays.fill(A, n));
    // cost[i][j] := the minimum cost to make s[i..j] palindrome
    int[][] cost = new int[n][n];

    for (int d = 1; d < n; ++d)
      for (int i = 0, j = d; j < n; ++i, ++j)
        cost[i][j] = (s.charAt(i) == s.charAt(j) ? 0 : 1) + cost[i + 1][j - 1];

    for (int i = 1; i <= n; ++i)
      dp[i][1] = cost[0][i - 1];

    for (int k = 2; k <= K; ++k)
      for (int i = k; i <= n; ++i)
        for (int j = k - 1; j < i; ++j)
          dp[i][k] = Math.min(dp[i][k], dp[j][k - 1] + cost[j][i - 1]);

    return dp[n][K];
  }
}"
"1279","class TrafficLight:
  def __init__(self):
    self.canPassRoadId = 1  # 1 := road A, 2 := road B

  def carArrived(
      self,
      # ID of the car
      carId: int,
      # ID of the road the car travels on. Can be 1 (road A) or 2 (road B).
      roadId: int,
      # direction of the car
      direction: int,
      # Use turnGreen() to turn light to green on current road.
      turnGreen: Callable[[], None],
      # Use crossCar() to make car cross the intersection.
      crossCar: Callable[[], None]
  ) -> None:
    if roadId != self.canPassRoadId:
      self.canPassRoadId = roadId
      turnGreen()
    crossCar()"
"128","class Solution:
  def longestConsecutive(self, nums: list[int]) -> int:
    ans = 0
    seen = set(nums)

    for num in nums:
      # `num` is the start of a sequence.
      if num - 1 in seen:
        continue
      length = 0
      while num in seen:
        num += 1
        length += 1
      ans = max(ans, length)

    return ans"
"1280","SELECT
  Students.student_id,
  Students.student_name,
  Subjects.subject_name,
  COUNT(Examinations.student_id) AS attended_exams
FROM Students
CROSS JOIN Subjects
LEFT JOIN Examinations
  ON (
    Students.student_id = Examinations.student_id
    AND Subjects.subject_name = Examinations.subject_name)
GROUP BY 1, 2, 3
ORDER BY Students.student_id, Subjects.subject_name;"
"1281","class Solution:
  def subtractProductAndSum(self, n: int) -> int:
    prod = 1
    summ = 0

    while n > 0:
      prod *= n % 10
      summ += n % 10
      n //= 10

    return prod - summ"
"1282","class Solution:
  def groupThePeople(self, groupSizes: list[int]) -> list[list[int]]:
    ans = []
    groupSizeToIndices = defaultdict(list)

    for i, groupSize in enumerate(groupSizes):
      groupSizeToIndices[groupSize].append(i)

    for groupSize, indices in groupSizeToIndices.items():
      groupIndices = []
      for index in indices:
        groupIndices.append(index)
        if len(groupIndices) == groupSize:
          ans.append(groupIndices.copy())
          groupIndices.clear()

    return ans"
"1283","class Solution:
  def smallestDivisor(self, nums: list[int], threshold: int) -> int:
    l = 1
    r = max(nums)

    while l < r:
      m = (l + r) // 2
      if sum((num - 1) // m + 1 for num in nums) <= threshold:
        r = m
      else:
        l = m + 1

    return l"
"1284","class Solution:
  def minFlips(self, mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    hash = self._getHash(mat, m, n)
    if hash == 0:
      return 0

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    step = 0
    q = collections.deque([hash])
    seen = {hash}

    while q:
      step += 1
      for _ in range(len(q)):
        curr = q.popleft()
        for i in range(m):
          for j in range(n):
            next = curr ^ 1 << (i * n + j)
            # Flie the four neighbors.
            for dx, dy in dirs:
              x = i + dx
              y = j + dy
              if x < 0 or x == m or y < 0 or y == n:
                continue
              next ^= 1 << (x * n + y)
            if next == 0:
              return step
            if next in seen:
              continue
            q.append(next)
            seen.add(next)

    return -1

  def _getHash(self, mat: list[list[int]], m: int, n: int) -> int:
    hash = 0
    for i in range(m):
      for j in range(n):
        if mat[i][j]:
          hash |= 1 << (i * n + j)
    return hash"
"1285","WITH
  LogToRowNumber AS (
    SELECT
      log_id,
      ROW_NUMBER() OVER(ORDER BY log_id) AS `row_number`
    FROM Logs
  )
SELECT
  MIN(log_id) AS start_id,
  MAX(log_id) AS end_id
FROM LogToRowNumber
GROUP BY log_id - `row_number`;"
"1286","class CombinationIterator {
  public CombinationIterator(String characters, int combinationLength) {
    final int n = characters.length();
    final int k = combinationLength;

    // Generate bitmasks from 0..00 to 1..11
    for (int mask = 0; mask < 1 << n; mask++) {
      // Use bitmasks with k 1-bits
      if (Integer.bitCount(mask) == k) {
        // Convert bitmask into combination
        // 111 --> ""abc"", 000 --> """"
        // 110 --> ""ab"", 101 --> ""ac"", 011 --> ""bc""
        StringBuilder curr = new StringBuilder();
        for (int j = 0; j < n; j++) {
          if ((mask & (1 << n - j - 1)) != 0) {
            curr.append(characters.charAt(j));
          }
        }
        combinations.push(curr.toString());
      }
    }
  }

  public String next() {
    return combinations.pop();
  }

  public boolean hasNext() {
    return (!combinations.isEmpty());
  }

  private Deque<String> combinations = new ArrayDeque<String>();
}"
"1287","class Solution:
  def findSpecialInteger(self, arr: list[int]) -> int:
    n = len(arr)
    quarter = n // 4

    for i in range(n - quarter):
      if arr[i] == arr[i + quarter]:
        return arr[i]"
"1288","class Solution:
  def removeCoveredIntervals(self, intervals: list[list[int]]) -> int:
    ans = 0
    prevEnd = 0

    # If the two intervals have the same `start`, put the one with a larger
    # `end` first.
    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):
      # Current interval is not covered by the previous one.
      if prevEnd < end:
        ans += 1
        prevEnd = end

    return ans"
"1289","class Solution:
  def minFallingPathSum(self, grid: list[list[int]]) -> int:
    n = len(grid)

    for i in range(1, n):
      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(
          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]
      for j in range(n):
        if j == firstMinIndex:
          grid[i][j] += secondMinNum
        else:
          grid[i][j] += firstMinNum

    return min(grid[-1])"
"129","class Solution:
  def sumNumbers(self, root: TreeNode | None) -> int:
    ans = 0

    def dfs(root: TreeNode | None, path: int) -> None:
      nonlocal ans
      if not root:
        return
      if not root.left and not root.right:
        ans += path * 10 + root.val
        return

      dfs(root.left, path * 10 + root.val)
      dfs(root.right, path * 10 + root.val)

    dfs(root, 0)
    return ans"
"1290","class Solution:
  def getDecimalValue(self, head: ListNode) -> int:
    ans = 0

    while head:
      ans = ans * 2 + head.val
      head = head.next

    return ans"
"1291","class Solution:
  def sequentialDigits(self, low: int, high: int) -> list[int]:
    ans = []
    q = collections.deque([num for num in range(1, 10)])

    while q:
      num = q.popleft()
      if num > high:
        return ans
      if low <= num and num <= high:
        ans.append(num)
      lastDigit = num % 10
      if lastDigit < 9:
        q.append(num * 10 + lastDigit + 1)

    return ans"
"1292","class Solution:
  def maxSideLength(self, mat: list[list[int]], threshold: int) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +
                                prefix[i + 1][j] - prefix[i][j])

    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:
      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]

    for i in range(m):
      for j in range(n):
        for length in range(ans, min(m - i, n - j)):
          if squareSum(i, j, i + length, j + length) > threshold:
            break
          ans = max(ans, length + 1)

    return ans"
"1293","class Solution:
  def shortestPath(self, grid: list[list[int]], k: int) -> int:
    m = len(grid)
    n = len(grid[0])
    if m == 1 and n == 1:
      return 0

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    q = collections.deque([(0, 0, k)])
    seen = {(0, 0, k)}

    step = 0
    while q:
      step += 1
      for _ in range(len(q)):
        i, j, eliminate = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if x == m - 1 and y == n - 1:
            return step
          if grid[x][y] == 1 and eliminate == 0:
            continue
          newEliminate = eliminate - grid[x][y]
          if (x, y, newEliminate) in seen:
            continue
          q.append((x, y, newEliminate))
          seen.add((x, y, newEliminate))

    return -1"
"1294","SELECT
  country_name,
  (
    CASE
      WHEN AVG(Weather.weather_state * 1.0) <= 15.0 THEN 'Cold'
      WHEN AVG(Weather.weather_state * 1.0) >= 25.0 THEN 'Hot'
      ELSE 'Warm'
    END
  ) AS weather_type
FROM Countries
INNER JOIN Weather
  USING (country_id)
WHERE day BETWEEN '2019-11-01' AND '2019-11-30'
GROUP BY 1;"
"1295","class Solution:
  def findNumbers(self, nums: list[int]) -> int:
    ans = 0

    for num in nums:
      if 9 < num < 100 or 999 < num < 10000 or num == 100000:
        ans += 1

    return ans"
"1296","class Solution:
  def isPossibleDivide(self, nums: list[int], k: int) -> bool:
    count = collections.Counter(nums)

    for start in sorted(count):
      value = count[start]
      if value > 0:
        for i in range(start, start + k):
          count[i] -= value
          if count[i] < 0:
            return False

    return True"
"1297","class Solution:
  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
    # Greedily consider strings with `minSize`, so ignore `maxSize`.
    ans = 0
    letters = 0
    count = collections.Counter()
    substringCount = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        letters += 1
      while letters > maxLetters or r - l + 1 > minSize:
        count[s[l]] -= 1
        if count[s[l]] == 0:
          letters -= 1
        l += 1
      if r - l + 1 == minSize:
        sub = s[l:l + minSize]
        substringCount[sub] += 1
        ans = max(ans, substringCount[sub])

    return ans"
"1298","class Solution:
  def maxCandies(
      self,
      status: list[int],
      candies: list[int],
      keys: list[list[int]],
      containedBoxes: list[list[int]],
      initialBoxes: list[int],
  ) -> int:
    ans = 0
    q = collections.deque()
    reachedClosedBoxes = [0] * len(status)

    def pushBoxesIfPossible(boxes: list[int]) -> None:
      for box in boxes:
        if status[box]:
          q.append(box)
        else:
          reachedClosedBoxes[box] = True

    pushBoxesIfPossible(initialBoxes)

    while q:
      currBox = q.popleft()

      # Add the candies.
      ans += candies[currBox]

      # Push `reachedClosedBoxes` by `key` obtained in this turn and change
      # their statuses.
      for key in keys[currBox]:
        if not status[key] and reachedClosedBoxes[key]:
          q.append(key)
        status[key] = 1  # boxes[key] is now open

      # Push the boxes contained in `currBox`.
      pushBoxesIfPossible(containedBoxes[currBox])

    return ans"
"1299","class Solution:
  def replaceElements(self, arr: list[int]) -> list[int]:
    maxOfRight = -1
    for i in reversed(range(len(arr))):
      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])
    return arr"
"13","class Solution:
  def romanToInt(self, s: str) -> int:
    ans = 0
    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,
             'C': 100, 'D': 500, 'M': 1000}

    for a, b in zip(s, s[1:]):
      if roman[a] < roman[b]:
        ans -= roman[a]
      else:
        ans += roman[a]

    return ans + roman[s[-1]]"
"130","class Solution:
  def solve(self, board: list[list[str]]) -> None:
    if not board:
      return

    m = len(board)
    n = len(board[0])

    def dfs(i: int, j: int) -> None:
      """"""Marks the grids with 'O' that stretch from the four sides to '*'.""""""
      if i < 0 or i == m or j < 0 or j == n:
        return
      if board[i][j] != 'O':
        return
      board[i][j] = '*'
      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    for i in range(m):
      for j in range(n):
        if i * j == 0 or i == m - 1 or j == n - 1:
          dfs(i, j)

    for row in board:
      for i, c in enumerate(row):
        row[i] = 'O' if c == '*' else 'X'"
"1300","class Solution:
  def findBestValue(self, arr: list[int], target: int) -> int:
    prefix = 0

    arr.sort()

    for i, a in enumerate(arr):
      ans = round((target - prefix) / (len(arr) - i))
      if ans <= a:
        return ans
      prefix += a

    return arr[-1]"
"1301","class Solution:
  def pathsWithMaxScore(self, board: list[str]) -> list[int]:
    kMod = 1_000_000_007
    dirs = ((0, 1), (1, 0), (1, 1))
    n = len(board)
    # dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)
    dp = [[-1] * (n + 1) for _ in range(n + 1)]
    # count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to
    # (i, j)
    count = [[0] * (n + 1) for _ in range(n + 1)]

    dp[0][0] = 0
    dp[n - 1][n - 1] = 0
    count[n - 1][n - 1] = 1

    for i in reversed(range(n)):
      for j in reversed(range(n)):
        if board[i][j] == 'S' or board[i][j] == 'X':
          continue
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if dp[i][j] < dp[x][y]:
            dp[i][j] = dp[x][y]
            count[i][j] = count[x][y]
          elif dp[i][j] == dp[x][y]:
            count[i][j] += count[x][y]
            count[i][j] %= kMod

        # If there's path(s) from 'S' to (i, j) and the cell is not 'E'.
        if dp[i][j] != -1 and board[i][j] != 'E':
          dp[i][j] += int(board[i][j])
          dp[i][j] %= kMod

    return [dp[0][0], count[0][0]]"
"1302","class Solution {
  public int deepestLeavesSum(TreeNode root) {
    int ans = 0;
    Queue<TreeNode> q = new ArrayDeque<>(List.of(root));

    while (!q.isEmpty()) {
      ans = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode node = q.poll();
        ans += node.val;
        if (node.left != null)
          q.offer(node.left);
        if (node.right != null)
          q.offer(node.right);
      }
    }

    return ans;
  }
}"
"1303","SELECT
  employee_id,
  COUNT(*) OVER(PARTITION BY team_id) AS team_size
FROM Employee;"
"1304","class Solution:
  def sumZero(self, n: int) -> list[int]:
    return list(range(1 - n, n, 2))"
"1305","class BSTIterator {
 public:
  BSTIterator(TreeNode* root) {
    pushLeftsUntilNull(root);
  }

  int peek() {
    return stack.top()->val;
  }

  void next() {
    TreeNode* node = stack.top();
    stack.pop();
    pushLeftsUntilNull(node->right);
  }

  bool hasNext() {
    return !stack.empty();
  }

 private:
  stack<TreeNode*> stack;

  void pushLeftsUntilNull(TreeNode* node) {
    while (node != nullptr) {
      stack.push(node);
      node = node->left;
    }
  }
};

class Solution {
 public:
  vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
    vector<int> ans;
    BSTIterator bstIterator1(root1);
    BSTIterator bstIterator2(root2);

    while (bstIterator1.hasNext() && bstIterator2.hasNext())
      if (bstIterator1.peek() < bstIterator2.peek()) {
        ans.push_back(bstIterator1.peek());
        bstIterator1.next();
      } else {
        ans.push_back(bstIterator2.peek());
        bstIterator2.next();
      }

    while (bstIterator1.hasNext()) {
      ans.push_back(bstIterator1.peek());
      bstIterator1.next();
    }

    while (bstIterator2.hasNext()) {
      ans.push_back(bstIterator2.peek());
      bstIterator2.next();
    }

    return ans;
  }
};"
"1306","class Solution {
 public:
  bool canReach(vector<int>& arr, int start) {
    const int n = arr.size();
    queue<int> q{{start}};
    vector<bool> seen(n);

    while (!q.empty()) {
      const int node = q.front();
      q.pop();
      if (arr[node] == 0)
        return true;
      if (seen[node])
        continue;
      // Check the available next steps.
      if (node - arr[node] >= 0)
        q.push(node - arr[node]);
      if (node + arr[node] < n)
        q.push(node + arr[node]);
      seen[node] = true;
    }

    return false;
  }
};"
"1307","class Solution:
  def isSolvable(self, words: list[str], result: str) -> bool:
    words.append(result)
    rows = len(words)
    cols = max(map(len, words))
    letterToDigit = {}
    usedDigit = [False] * 10

    def dfs(row: int, col: int, summ: int) -> bool:
      if col == cols:
        return summ == 0
      if row == rows:
        return summ % 10 == 0 and dfs(0, col + 1, summ // 10)

      word = words[row]
      if col >= len(word):
        return dfs(row + 1, col, summ)

      letter = word[~col]
      sign = -1 if row == rows - 1 else 1

      if letter in letterToDigit and (
              letterToDigit[letter] > 0 or col < len(word) - 1):
        return dfs(row + 1, col, summ + sign * letterToDigit[letter])

      for digit, used in enumerate(usedDigit):
        if not used and (digit > 0 or col < len(word) - 1):
          letterToDigit[letter] = digit
          usedDigit[digit] = True
          if dfs(row + 1, col, summ + sign * digit):
            return True
          usedDigit[digit] = False
          if letter in letterToDigit:
            del letterToDigit[letter]

      return False

    return dfs(0, 0, 0)"
"1308","SELECT
  gender,
  day,
  SUM(score_points) OVER(
    PARTITION BY gender
    ORDER BY day
  ) AS total
FROM Scores
ORDER BY 1, 2;"
"1309","class Solution:
  def freqAlphabets(self, s: str) -> str:
    ans = ''
    i = 0

    while i < len(s):
      if i + 2 < len(s) and s[i + 2] == '#':
        ans += chr(int(s[i:i + 2]) + ord('a') - 1)
        i += 3
      else:
        ans += chr(int(s[i]) + ord('a') - 1)
        i += 1

    return ans"
"131","class Solution:
  def partition(self, s: str) -> list[list[str]]:
    ans = []

    def isPalindrome(s: str) -> bool:
      return s == s[::-1]

    def dfs(s: str, j: int, path: list[str], ans: list[list[str]]) -> None:
      if j == len(s):
        ans.append(path)
        return

      for i in range(j, len(s)):
        if isPalindrome(s[j: i + 1]):
          dfs(s, i + 1, path + [s[j: i + 1]], ans)

    dfs(s, 0, [], ans)
    return ans"
"1310","class Solution:
  def xorQueries(self, arr: list[int], queries: list[list[int]]) -> list[int]:
    ans = []
    xors = [0] * (len(arr) + 1)

    for i, a in enumerate(arr):
      xors[i + 1] = xors[i] ^ a

    for left, right in queries:
      ans.append(xors[left] ^ xors[right + 1])

    return ans"
"1311","class Solution:
  def watchedVideosByFriends(
      self,
      watchedVideos: list[list[str]],
      friends: list[list[int]],
      id: int,
      level: int,
  ) -> list[str]:
    seen = [False] * 100
    seen[id] = True
    q = collections.deque([id])
    count = collections.Counter()

    for _ in range(level):
      for _ in range(len(q)):
        curr = q.popleft()
        for friend in friends[curr]:
          if not seen[friend]:
            seen[friend] = True
            q.append(friend)

    for friend in q:
      for video in watchedVideos[friend]:
        count[video] += 1

    return sorted(count, key=lambda video: (count[video], video))"
"1312","class Solution:
  def minInsertions(self, s: str) -> int:
    return len(s) - self._longestPalindromeSubseq(s)

  # Same as 516. Longest Palindromic Subsequence
  def _longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]"
"1313","class Solution:
  def decompressRLElist(self, nums: list[int]) -> list[int]:
    ans = []

    for i in range(0, len(nums), 2):
      ans += [nums[i + 1]] * nums[i]

    return ans"
"1314","class Solution:
  def matrixBlockSum(self, mat: list[list[int]], k: int) -> list[list[int]]:
    m = len(mat)
    n = len(mat[0])
    ans = [[0] * n for _ in range(m)]
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +
                                prefix[i + 1][j] - prefix[i][j])

    for i in range(m):
      for j in range(n):
        r1 = max(0, i - k) + 1
        c1 = max(0, j - k) + 1
        r2 = min(m - 1, i + k) + 1
        c2 = min(n - 1, j + k) + 1
        ans[i][j] = (prefix[r2][c2] - prefix[r2][c1 - 1] -
                     prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1])

    return ans"
"1315","class Solution {
  public int sumEvenGrandparent(TreeNode root) {
    return dfs(root, 1, 1); // The parent and the grandparent are odd at first.
  }

  private int dfs(TreeNode root, int p, int gp) {
    if (root == null)
      return 0;
    return (gp % 2 == 0 ? root.val : 0) + //
        dfs(root.left, root.val, p) +     //
        dfs(root.right, root.val, p);
  }
}"
"1316","class Solution:
  def distinctEchoSubstrings(self, text: str) -> int:
    seen = set()

    for k in range(1, len(text) // 2 + 1):  # the target length
      same = 0
      l = 0
      for r in range(k, len(text)):
        if text[l] == text[r]:
          same += 1
        else:
          same = 0
        if same == k:
          seen.add(text[l - k + 1:l + 1])
          # Move the window thus leaving a letter behind, so we need to
          # decrease the counter.
          same -= 1
        l += 1

    return len(seen)"
"1317","class Solution:
  def getNoZeroIntegers(self, n: int) -> list[int]:
    for A in range(n):
      B = n - A
      if '0' not in str(A) and '0' not in str(B):
        return A, B"
"1318","class Solution:
  def minFlips(self, a: int, b: int, c: int) -> int:
    kMaxBit = 30
    ans = 0

    for i in range(kMaxBit):
      if c >> i & 1:
        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0
      else:  # (c >> i & 1) == 0
        ans += (a >> i & 1) + (b >> i & 1)

    return ans"
"1319","class Solution {
  public int makeConnected(int n, int[][] connections) {
    // To connect n nodes, we need at least n - 1 edges
    if (connections.length < n - 1)
      return -1;

    int numOfConnected = 0;
    List<Integer>[] graph = new List[n];
    Set<Integer> seen = new HashSet<>();

    for (int i = 0; i < n; ++i)
      graph[i] = new ArrayList<>();

    for (int[] connection : connections) {
      final int u = connection[0];
      final int v = connection[1];
      graph[u].add(v);
      graph[v].add(u);
    }

    for (int i = 0; i < n; ++i)
      if (seen.add(i)) {
        dfs(graph, i, seen);
        ++numOfConnected;
      }

    return numOfConnected - 1;
  }

  private void dfs(List<Integer>[] graph, int u, Set<Integer> seen) {
    for (final int v : graph[u])
      if (seen.add(v))
        dfs(graph, v, seen);
  }
}"
"132","class Solution:
  def minCut(self, s: str) -> int:
    n = len(s)
    # isPalindrome[i][j] := True if s[i..j] is a palindrome
    isPalindrome = [[True] * n for _ in range(n)]
    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]
    dp = [n] * n

    for l in range(2, n + 1):
      i = 0
      for j in range(l - 1, n):
        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]
        i += 1

    for i in range(n):
      if isPalindrome[0][i]:
        dp[i] = 0
        continue

      # Try all the possible partitions.
      for j in range(i):
        if isPalindrome[j + 1][i]:
          dp[i] = min(dp[i], dp[j] + 1)

    return dp[-1]"
"1320","class Solution:
  def minimumDistance(self, word: str) -> int:
    def dist(a: int, b: int) -> int:
      if a == 26:  # the first hovering state
        return 0
      x1, y1 = a // 6, a % 6
      x2, y2 = b // 6, b % 6
      return abs(x1 - x2) + abs(y1 - y2)

    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """"""
      Returns the minimum distance to type the `word`, where the left finger is
      on the i-th letter, the right finger is on the j-th letter, and the
      words[0..k) have been written.
      """"""
      if k == len(word):
        return 0
      nxt = ord(word[k]) - ord('A')
      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)
      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)
      return min(moveLeft, moveRight)

    return dp(26, 26, 0)"
"1321","WITH
  Dates AS (
    SELECT DISTINCT visited_on
    FROM Customer
    WHERE visited_on >= (
      SELECT DATE_ADD(MIN(visited_on), INTERVAL 6 DAY)
      FROM Customer
    )
  )
SELECT
  Dates.visited_on,
  SUM(Customer.amount) AS amount,
  ROUND(SUM(Customer.amount) / 7, 2) AS average_amount
FROM Dates
LEFT JOIN Customer
  ON (DATEDIFF(Dates.visited_on, Customer.visited_on) BETWEEN 0 AND 6)
GROUP BY 1;"
"1322","SELECT
  ad_id,
  IFNULL(
    ROUND(
      SUM(action = 'Clicked') * 100 /(SUM(action = 'Clicked') + SUM(action = 'Viewed')),
      2
    ),
    0
  ) AS ctr
FROM Ads
GROUP BY 1
ORDER BY ctr DESC, ad_id;"
"1323","class Solution:
  def maximum69Number(self, num: int) -> int:
    return int(str(num).replace('6', '9', 1))"
"1324","class Solution:
  def printVertically(self, s: str) -> list[str]:
    ans = []
    words = s.split()
    maxLength = max(len(word) for word in words)

    for i in range(maxLength):
      row = []
      for word in words:
        row.append(word[i] if i < len(word) else ' ')
      ans.append(''.join(row).rstrip())

    return ans"
"1325","class Solution:
  def removeLeafNodes(
      self,
      root: TreeNode | None,
      target: int,
  ) -> TreeNode | None:
    if not root:
      return None
    root.left = self.removeLeafNodes(root.left, target)
    root.right = self.removeLeafNodes(root.right, target)
    return None if self._isLeaf(root) and root.val == target else root

  def _isLeaf(self, root: TreeNode | None) -> bool:
    return not root.left and not root.right"
"1326","class Solution:
  def minTaps(self, n: int, ranges: list[int]) -> int:
    nums = [0] * (n + 1)

    for i, range_ in enumerate(ranges):
      l = max(0, i - range_)
      r = min(n, range_ + i)
      nums[l] = max(nums[l], r - l)

    ans = 0
    end = 0
    farthest = 0

    for i in range(n):
      farthest = max(farthest, i + nums[i])
      if i == end:
        ans += 1
        end = farthest

    return ans if end == n else -1"
"1327","SELECT
  Products.product_name,
  SUM(Orders.unit) AS unit
FROM Products
INNER JOIN Orders
  USING (product_id)
WHERE DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-02'
GROUP BY product_id
HAVING SUM(Orders.unit) >= 100;"
"1328","class Solution:
  def breakPalindrome(self, palindrome: str) -> str:
    if len(palindrome) == 1:
      return ''

    ans = list(palindrome)

    for i in range(len(palindrome) // 2):
      if palindrome[i] != 'a':
        ans[i] = 'a'
        return ''.join(ans)

    ans[-1] = 'b'
    return ''.join(ans)"
"1329","class Solution:
  def diagonalSort(self, mat: list[list[int]]) -> list[list[int]]:
    m = len(mat)
    n = len(mat[0])

    count = collections.defaultdict(list)

    for i in range(m):
      for j in range(n):
        count[i - j].append(mat[i][j])

    for value in count.values():
      value.sort(reverse=1)

    for i in range(m):
      for j in range(n):
        mat[i][j] = count[i - j].pop()

    return mat"
"133","class Solution:
  def cloneGraph(self, node: 'Node') -> 'Node':
    if not node:
      return None

    q = collections.deque([node])
    map = {node: Node(node.val)}

    while q:
      u = q.popleft()
      for v in u.neighbors:
        if v not in map:
          map[v] = Node(v.val)
          q.append(v)
        map[u].neighbors.append(map[v])

    return map[node]"
"1330","class Solution:
  def maxValueAfterReverse(self, nums: list[int]) -> int:
    mn = math.inf
    mx = -math.inf

    for a, b in zip(nums, nums[1:]):
      mn = min(mn, max(a, b))
      mx = max(mx, min(a, b))
    diff = max(0, (mx - mn) * 2)

    for a, b in zip(nums, nums[1:]):
      headDiff = -abs(a - b) + abs(nums[0] - b)
      tailDiff = -abs(a - b) + abs(nums[-1] - a)
      diff = max(diff, headDiff, tailDiff)

    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff"
"1331","class Solution:
  def arrayRankTransform(self, arr: list[int]) -> list[int]:
    rank = {}

    for a in sorted(arr):
      if a not in rank:
        rank[a] = len(rank) + 1

    return map(rank.get, arr)"
"1332","class Solution:
  def removePalindromeSub(self, s: str) -> int:
    return 1 if s == s[::-1] else 2"
"1333","class Solution:
  def filterRestaurants(
      self,
      restaurants: list[list[int]],
      veganFriendly: int,
      maxPrice: int,
      maxDistance: int,
  ) -> list[int]:
    restaurants.sort(key=lambda x: (-x[1], -x[0]))
    return [i for i, _, v, p, d in restaurants
            if v >= veganFriendly and p <= maxPrice and d <= maxDistance]"
"1334","class Solution:
  def findTheCity(
      self,
      n: int,
      edges: list[list[int]],
      distanceThreshold: int,
  ) -> int:
    ans = -1
    minCitiesCount = n
    dist = self._floydWarshall(n, edges, distanceThreshold)

    for i in range(n):
      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))
      if citiesCount <= minCitiesCount:
        ans = i
        minCitiesCount = citiesCount

    return ans

  def _floydWarshall(
      self,
      n: int,
      edges: list[list[int]],
      distanceThreshold: int,
  ) -> list[list[int]]:
    dist = [[distanceThreshold + 1] * n for _ in range(n)]

    for i in range(n):
      dist[i][i] = 0

    for u, v, w in edges:
      dist[u][v] = w
      dist[v][u] = w

    for k in range(n):
      for i in range(n):
        for j in range(n):
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist"
"1335","class Solution:
  def minDifficulty(self, jobDifficulty: list[int], d: int) -> int:
    n = len(jobDifficulty)
    if d > n:
      return -1

    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days
    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(1, n + 1):
      for k in range(1, d + 1):
        maxDifficulty = 0  # max(job[j + 1..i])
        for j in range(i - 1, k - 2, -1):  # 1-based
          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based
          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)

    return dp[n][d]"
"1336","WITH
  Users AS (
    SELECT
      Visits.user_id,
      Visits.visit_date,
      COUNT(Transactions.transaction_date) AS transaction_count
    FROM Visits
    LEFT JOIN Transactions
      ON (
        Visits.user_id = Transactions.user_id
        AND Visits.visit_date = Transactions.transaction_date)
    GROUP BY 1, 2
  ),
  RowNumbers AS (
    SELECT ROW_NUMBER() OVER() AS `row_number`
    FROM Transactions
    UNION ALL
    SELECT 0
  )
SELECT
  RowNumbers.`row_number` AS transactions_count,
  COUNT(Users.user_id) AS visits_count
FROM RowNumbers
LEFT JOIN Users
  ON (RowNumbers.`row_number` = Users.transaction_count)
WHERE RowNumbers.`row_number` <= (
    SELECT MAX(transaction_count) FROM Users
  )
GROUP BY 1
ORDER BY 1;"
"1337","class Solution:
  def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:
    rowSums = [(sum(row), i) for i, row in enumerate(mat)]
    rowSums.sort(key=lambda x: (x[0], x[1]))
    return [i for _, i in rowSums[:k]]"
"1338","class Solution:
  def minSetSize(self, arr: list[int]) -> int:
    count = collections.Counter(arr).most_common()
    count.sort(key=lambda x: -x[1])

    summ = 0
    for i, (_, freq) in enumerate(count):
      summ += freq
      if summ >= len(arr) // 2:
        return i + 1"
"1339","class Solution {
  public int maxProduct(TreeNode root) {
    final int kMod = 1_000_000_007;
    long ans = 0;
    List<Integer> allSums = new ArrayList<>();
    final long totalSum = treeSum(root, allSums);

    for (final long sum : allSums)
      ans = Math.max(ans, sum * (totalSum - sum));

    return (int) (ans % kMod);
  }

  private int treeSum(TreeNode root, List<Integer> allSums) {
    if (root == null)
      return 0;

    final int leftSum = treeSum(root.left, allSums);
    final int rightSum = treeSum(root.right, allSums);
    final int sum = root.val + leftSum + rightSum;
    allSums.add(sum);
    return sum;
  }
}"
"134","class Solution:
  def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:
    ans = 0
    net = 0
    summ = 0

    # Try to start from each index.
    for i in range(len(gas)):
      net += gas[i] - cost[i]
      summ += gas[i] - cost[i]
      if summ < 0:
        summ = 0
        ans = i + 1  # Start from the next index.

    return -1 if net < 0 else ans"
"1340","class Solution:
  def maxJumps(self, arr: list[int], d: int) -> int:
    n = len(arr)
    # dp[i] := the maximum jumps starting from arr[i]
    dp = [1] * n
    # a dcreasing stack that stores indices
    stack = []

    for i in range(n + 1):
      while stack and (i == n or arr[stack[-1]] < arr[i]):
        indices = [stack.pop()]
        while stack and arr[stack[-1]] == arr[indices[0]]:
          indices.append(stack.pop())
        for j in indices:
          if i < n and i - j <= d:
            # Can jump from i to j.
            dp[i] = max(dp[i], dp[j] + 1)
          if stack and j - stack[-1] <= d:
            # Can jump from stack[-1] to j
            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)
      stack.append(i)

    return max(dp)"
"1341","(
  SELECT Users.name AS results
  FROM MovieRating
  INNER JOIN Users
    USING (user_id)
  GROUP BY user_id
  ORDER BY COUNT(MovieRating.movie_id) DESC, Users.name
  LIMIT 1
)
UNION ALL
(
  SELECT Movies.title AS results
  FROM MovieRating
  INNER JOIN Movies
    USING (movie_id)
  WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02'
  GROUP BY movie_id
  ORDER BY AVG(MovieRating.rating) DESC, Movies.title
  LIMIT 1
);"
"1342","class Solution:
  def numberOfSteps(self, num: int) -> int:
    if num == 0:
      return 0
    subtractSteps = num.bit_count()
    divideSteps = num.bit_length() - 1
    return subtractSteps + divideSteps"
"1343","class Solution:
  def numOfSubarrays(self, arr: list[int], k: int, threshold: int) -> int:
    ans = 0
    windowSum = 0

    for i in range(len(arr)):
      windowSum += arr[i]
      if i >= k:
        windowSum -= arr[i - k]
      if i >= k - 1 and windowSum // k >= threshold:
        ans += 1

    return ans"
"1344","class Solution:
  def angleClock(self, hour: int, minutes: int) -> float:
    hourAngle = (hour % 12) * 30 + minutes * 0.5
    minuteAngle = minutes * 6
    ans = abs(hourAngle - minuteAngle)

    return min(ans, 360 - ans)"
"1345","class Solution:
  def minJumps(self, arr: list[int]) -> int:
    n = len(arr)
    # {num: indices}
    graph = collections.defaultdict(list)
    step = 0
    q = collections.deque([0])
    seen = {0}

    for i, a in enumerate(arr):
      graph[a].append(i)

    while q:
      for _ in range(len(q)):
        i = q.popleft()
        if i == n - 1:
          return step
        seen.add(i)
        u = arr[i]
        if i + 1 < n:
          graph[u].append(i + 1)
        if i - 1 >= 0:
          graph[u].append(i - 1)
        for v in graph[u]:
          if v in seen:
            continue
          q.append(v)
        graph[u].clear()
      step += 1"
"1346","class Solution:
  def checkIfExist(self, arr: list[int]) -> bool:
    seen = set()

    for a in arr:
      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:
        return True
      seen.add(a)

    return False"
"1347","class Solution:
  def minSteps(self, s: str, t: str) -> int:
    count = collections.Counter(s)
    count.subtract(collections.Counter(t))
    return sum(abs(value) for value in count.values()) // 2"
"1348","from sortedcontainers import SortedList


class TweetCounts:
  def __init__(self):
    self.tweetNameToTimes = collections.defaultdict(SortedList)

  def recordTweet(self, tweetName: str, time: int) -> None:
    self.tweetNameToTimes[tweetName].add(time)

  def getTweetCountsPerFrequency(self, freq: str, tweetName: str,
                                 startTime: int, endTime: int) -> list[int]:
    counts = []
    times = self.tweetNameToTimes[tweetName]
    chunk = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400

    # I := startTime of each chunk
    for i in range(startTime, endTime + 1, chunk):
      j = min(i + chunk, endTime + 1)  # EndTime of each chunk
      counts.append(bisect_left(times, j) - bisect_left(times, i))

    return counts"
"1349","class Solution:
  def maxStudents(self, seats: list[list[str]]) -> int:
    m = len(seats)
    n = len(seats[0])
    dirs = ((-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1))
    seen = [[0] * n for _ in range(m)]
    match = [[-1] * n for _ in range(m)]

    def dfs(i: int, j: int, sessionId: int) -> int:
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if seats[x][y] != '.' or seen[x][y] == sessionId:
          continue
        seen[x][y] = sessionId
        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):
          match[x][y] = i * n + j
          match[i][j] = x * n + y
          return 1
      return 0

    def hungarian() -> int:
      count = 0
      for i in range(m):
        for j in range(n):
          if seats[i][j] == '.' and match[i][j] == -1:
            sessionId = i * n + j
            seen[i][j] = sessionId
            count += dfs(i, j, sessionId)
      return count

    return sum(seats[i][j] == '.'
               for i in range(m)
               for j in range(n)) - hungarian()"
"135","class Solution:
  def candy(self, ratings: list[int]) -> int:
    n = len(ratings)

    ans = 0
    l = [1] * n
    r = [1] * n

    for i in range(1, n):
      if ratings[i] > ratings[i - 1]:
        l[i] = l[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if ratings[i] > ratings[i + 1]:
        r[i] = r[i + 1] + 1

    for a, b in zip(l, r):
      ans += max(a, b)

    return ans"
"1350","SELECT
  Students.id,
  Students.name
FROM Students
LEFT JOIN Departments
  ON (Students.department_id = Departments.id)
WHERE Departments.id IS NULL;"
"1351","class Solution:
  def countNegatives(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    i = m - 1
    j = 0

    while i >= 0 and j < n:
      if grid[i][j] < 0:
        ans += n - j
        i -= 1
      else:
        j += 1

    return ans"
"1352","class ProductOfNumbers:
  def __init__(self):
    self.prefix = [1]

  def add(self, num: int) -> None:
    if num == 0:
      self.prefix = [1]
    else:
      self.prefix.append(self.prefix[-1] * num)

  def getProduct(self, k: int) -> int:
    return 0 if k >= len(self.prefix) else self.prefix[-1] // self.prefix[len(self.prefix) - k - 1]"
"1353","class Solution:
  def maxEvents(self, events: list[list[int]]) -> int:
    ans = 0
    minHeap = []
    i = 0  # events' index

    events.sort(key=lambda x: x[0])

    while minHeap or i < len(events):
      # If no events are available to attend today, let time flies to the next
      # available event.
      if not minHeap:
        d = events[i][0]
      # All the events starting from today are newly available.
      while i < len(events) and events[i][0] == d:
        heapq.heappush(minHeap, events[i][1])
        i += 1
      # Greedily attend the event that'll end the earliest since it has higher
      # chance can't be attended in the future.
      heapq.heappop(minHeap)
      ans += 1
      d += 1
      # Pop the events that can't be attended.
      while minHeap and minHeap[0] < d:
        heapq.heappop(minHeap)

    return ans"
"1354","class Solution:
  def isPossible(self, target: list[int]) -> bool:
    if len(target) == 1:
      return target[0] == 1

    summ = sum(target)
    maxHeap = [-num for num in target]
    heapq.heapify(maxHeap)

    while -maxHeap[0] > 1:
      mx = -heapq.heappop(maxHeap)
      restSum = summ - mx
      # Only occurs if n == 2.
      if restSum == 1:
        return True
      updated = mx % restSum
      # updated == 0 (invalid) or didn't change.
      if updated == 0 or updated == mx:
        return False
      heapq.heappush(maxHeap, -updated)
      summ = summ - mx + updated

    return True"
"1355","WITH
  RankedFriends AS (
    SELECT
      activity,
      RANK() OVER(ORDER BY COUNT(id) ASC) AS rank_asc,
      RANK() OVER(ORDER BY COUNT(id) DESC) AS rank_desc
    FROM Friends
    GROUP BY 1
  )
SELECT activity
FROM RankedFriends
WHERE rank_asc > 1 AND rank_desc > 1;"
"1356","class Solution {
  public int[] sortByBits(int[] arr) {
    Integer[] A = Arrays.stream(arr).boxed().toArray(Integer[] ::new);
    Arrays.sort(A,
                (a, b)
                    -> Integer.bitCount(a) == Integer.bitCount(b)
                           ? a - b
                           : Integer.bitCount(a) - Integer.bitCount(b));
    return Arrays.stream(A).mapToInt(Integer::intValue).toArray();
  }
}"
"1357","class Cashier:
  def __init__(
      self,
      n: int,
      discount: int,
      products: list[int],
      prices: list[int],
  ):
    self.n = n
    self.discount = discount
    self.productToPrice = dict(zip(products, prices))
    self.count = 0

  def getBill(self, product: list[int], amount: list[int]) -> float:
    self.count += 1
    total = sum(self.productToPrice[p] * amount[i]
                for i, p in enumerate(product))
    if self.count % self.n == 0:
      return total * (1 - self.discount / 100)
    return total"
"1358","class Solution:
  # Similar to 3. Longest SubWithout Repeating Characters
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    # lastSeen[c] := the index of the last time c appeared
    lastSeen = {c: -1 for c in 'abc'}

    for i, c in enumerate(s):
      lastSeen[c] = i
      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.
      ans += 1 + min(lastSeen.values())

    return ans"
"1359","class Solution:
  def countOrders(self, n: int) -> int:
    kMod = 1_000_000_007
    ans = 1

    for i in range(1, n + 1):
      ans = ans * i * (i * 2 - 1) % kMod

    return ans"
"136","class Solution:
  def singleNumber(self, nums: list[int]) -> int:
    return functools.reduce(operator.xor, nums, 0)"
"1360","class Solution:
  def daysBetweenDates(self, date1: str, date2: str) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def isLeapYear(year: int) -> bool:
      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0

    def daysFrom1971(date: str) -> int:
      year, month, day = map(int, date.split('-'))
      return (365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) +
              sum(days[:month]) + day + (month > 2 and isLeapYear(year)))

    return abs(daysFrom1971(date1) - daysFrom1971(date2))"
"1361","class Solution {
 public:
  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,
                               vector<int>& rightChild) {
    vector<int> inDegrees(n);
    int root = -1;

    // If the in-degree of any node > 1, return false.
    for (const int child : leftChild)
      if (child != -1 && ++inDegrees[child] == 2)
        return false;

    for (const int child : rightChild)
      if (child != -1 && ++inDegrees[child] == 2)
        return false;

    // Find the root (the node with in-degree == 0).
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        if (root == -1)
          root = i;
        else
          return false;  // There're multiple roots.

    // Didn't find the root.
    if (root == -1)
      return false;

    return countNodes(root, leftChild, rightChild) == n;
  }

 private:
  int countNodes(int root, const vector<int>& leftChild,
                 const vector<int>& rightChild) {
    if (root == -1)
      return 0;
    return 1 +  //
           countNodes(leftChild[root], leftChild, rightChild) +
           countNodes(rightChild[root], leftChild, rightChild);
  }
};"
"1362","class Solution:
  def closestDivisors(self, num: int) -> list[int]:
    for root in reversed(range(math.isqrt(num + 2) + 1)):
      for cand in [num + 1, num + 2]:
        if cand % root == 0:
          return [root, cand // root]"
"1363","class Solution:
  def largestMultipleOfThree(self, digits: list[int]) -> str:
    ans = ''
    mod1 = [1, 4, 7, 2, 5, 8]
    mod2 = [2, 5, 8, 1, 4, 7]
    count = collections.Counter(digits)
    summ = sum(digits)

    while summ % 3 != 0:
      for digit in (mod1 if summ % 3 == 1 else mod2):
        if count[digit]:
          count[digit] -= 1
          summ -= digit
          break

    for digit in reversed(range(10)):
      ans += str(digit) * count[digit]

    return '0' if len(ans) and ans[0] == '0' else ans"
"1364","SELECT
  Invoices.invoice_id,
  Customers.customer_name,
  Invoices.price,
  COUNT(Contacts.user_id) AS contacts_cnt,
  COUNT(CustomerEmails.email) AS trusted_contacts_cnt
FROM Invoices
INNER JOIN Customers
  ON (Invoices.user_id = Customers.customer_id)
LEFT JOIN Contacts
  ON (Customers.customer_id = Contacts.user_id)
LEFT JOIN Customers AS CustomerEmails
  ON (Contacts.contact_email = CustomerEmails.email)
GROUP BY 1
ORDER BY 1;"
"1365","class Solution:
  def smallerNumbersThanCurrent(self, nums: list[int]) -> list[int]:
    kMax = 100
    count = collections.Counter(nums)

    for i in range(1, kMax + 1):
      count[i] += count[i - 1]

    return [0 if num == 0 else count[num - 1]
            for num in nums]"
"1366","from dataclasses import dataclass


@dataclass
class Team:
  name: str
  rank: list[int]

  def __init__(self, name: str, teamSize: int):
    self.name = name
    self.rank = [0] * teamSize


class Solution:
  def rankTeams(self, votes: list[str]) -> str:
    teamSize = len(votes[0])
    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]

    for vote in votes:
      for i in range(teamSize):
        teams[ord(vote[i]) - ord('A')].rank[i] += 1

    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)
    return ''.join(team.name for team in teams[:teamSize])"
"1367","class Solution:
  def isSubPath(self, head: ListNode | None, root: TreeNode | None) -> bool:
    if not root:
      return False
    return (self._isContinuousSubPath(head, root) or
            self.isSubPath(head, root.left) or
            self.isSubPath(head, root.right))

  def _isContinuousSubPath(
      self,
      head: ListNode | None,
      root: TreeNode | None,
  ) -> bool:
    if not head:
      return True
    if not root:
      return False
    return (head.val == root.val and
            (self._isContinuousSubPath(head.next, root.left) or
             self._isContinuousSubPath(head.next, root.right)))"
"1368","class Solution:
  def minCost(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))
    dp = [[-1] * n for _ in range(m)]
    q = collections.deque()

    def dfs(i: int, j: int, cost: int) -> None:
      if i < 0 or i == m or j < 0 or j == n:
        return
      if dp[i][j] != -1:
        return

      dp[i][j] = cost
      q.append((i, j))
      dx, dy = dirs[grid[i][j] - 1]
      dfs(i + dx, j + dy, cost)

    dfs(0, 0, 0)

    cost = 0
    while q:
      cost += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          dfs(i + dx, j + dy, cost)

    return dp[-1][-1]"
"1369","WITH
  RankedUserActivity AS (
    SELECT
      *,
      COUNT(*) OVER(PARTITION BY username) AS `count`,
      RANK() OVER(
        PARTITION BY username
        ORDER BY endDate DESC
      ) AS `rank`
    FROM UserActivity
  )
SELECT
  username,
  activity,
  startDate,
  endDate
FROM RankedUserActivity
WHERE `count` = 1 OR `rank` = 2;"
"137","class Solution:
  def singleNumber(self, nums: list[int]) -> int:
    ones = 0
    twos = 0

    for num in nums:
      ones ^= (num & ~twos)
      twos ^= (num & ~ones)

    return ones"
"1370","class Solution:
  def sortString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)

    while count:
      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):
        ans += [c for c in chars if c in count]
        count -= dict.fromkeys(count, 1)

    return ''.join(ans)"
"1371","class Solution:
  def findTheLongestSubstring(self, s: str) -> int:
    kVowels = 'aeiou'
    ans = 0
    prefix = 0  # the binary prefix
    prefixToIndex = {0: -1}

    for i, c in enumerate(s):
      index = kVowels.find(c)
      if index != -1:
        prefix ^= 1 << index
      prefixToIndex.setdefault(prefix, i)
      ans = max(ans, i - prefixToIndex[prefix])

    return ans"
"1372","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  leftMax: int
  rightMax: int
  subtreeMax: int


class Solution:
  def longestZigZag(self, root: TreeNode | None) -> int:
    def dfs(root: TreeNode | None) -> T:
      if not root:
        return T(-1, -1, -1)
      left = dfs(root.left)
      right = dfs(root.right)
      leftZigZag = left.rightMax + 1
      rightZigZag = right.leftMax + 1
      subtreeMax = max(leftZigZag, rightZigZag,
                       left.subtreeMax, right.subtreeMax)
      return T(leftZigZag, rightZigZag, subtreeMax)

    return dfs(root).subtreeMax"
"1373","from dataclasses import dataclass


@dataclass
class T:
  isBST: bool | None = False
  mx: int | None = None
  mn: int | None = None
  summ: int | None = None


class Solution:
  def maxSumBST(self, root: TreeNode | None) -> int:
    self.ans = 0

    def traverse(root: TreeNode | None) -> T:
      if not root:
        return T(True, -math.inf, math.inf, 0)

      left: T = traverse(root.left)
      right: T = traverse(root.right)

      if not left.isBST or not right.isBST:
        return T()
      if root.val <= left.mx or root.val >= right.mn:
        return T()

      # The `root` is a valid BST.
      summ = root.val + left.summ + right.summ
      self.ans = max(self.ans, summ)
      return T(True, max(root.val, right.mx), min(root.val, left.mn), summ)

    traverse(root)
    return self.ans"
"1374","class Solution:
  def generateTheString(self, n: int) -> str:
    s = 'a' * n
    if n % 2 == 0:
      s = s[:-1] + 'b'
    return s"
"1375","class Solution:
  def numTimesAllBlue(self, flips: list[int]) -> int:
    ans = 0
    rightmost = 0

    for i, flip in enumerate(flips):
      rightmost = max(rightmost, flip)
      # max(flips[0..i]) = rightmost = i + 1,
      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.
      if rightmost == i + 1:
        ans += 1

    return ans"
"1376","class Solution {
 public:
  int numOfMinutes(int n, int headID, vector<int>& manager,
                   vector<int>& informTime) {
    int ans = 0;

    for (int i = 0; i < n; ++i)
      ans = max(ans, dfs(i, headID, manager, informTime, {}));

    return ans;
  }

 private:
  int dfs(int i, int headID, const vector<int>& manager,
          const vector<int>& informTime, unordered_map<int, int>&& mem) {
    if (const auto it = mem.find(i); it != mem.cend())
      return it->second;
    if (i == headID)
      return 0;

    const int parent = manager[i];
    return mem[i] = informTime[parent] +
                    dfs(parent, headID, manager, informTime, std::move(mem));
  }
};"
"1377","class Solution:
  def frogPosition(
      self,
      n: int,
      edges: list[list[int]],
      t: int,
      target: int,
  ) -> float:
    tree = [[] for _ in range(n + 1)]
    q = collections.deque([1])
    seen = [False] * (n + 1)
    prob = [0] * (n + 1)

    prob[1] = 1
    seen[1] = True

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    for _ in range(t):
      for _ in range(len(q)):
        a = q.popleft()
        nChildren = sum(not seen[b] for b in tree[a])
        for b in tree[a]:
          if seen[b]:
            continue
          seen[b] = True
          prob[b] = prob[a] / nChildren
          q.append(b)
        if nChildren > 0:
          prob[a] = 0

    return prob[target]"
"1378","SELECT
  EmployeeUNI.unique_id,
  Employees.name
FROM Employees
LEFT JOIN EmployeeUNI
  USING (id);"
"1379","class Solution:
  def getTargetCopy(
      self,
      original: TreeNode,
      cloned: TreeNode,
      target: TreeNode,
  ) -> TreeNode:
    ans = None

    def dfs(original: TreeNode, cloned: TreeNode) -> None:
      nonlocal ans
      if ans:
        return
      if not original:
        return
      if original == target:
        ans = cloned
        return

      dfs(original.left, cloned.left)
      dfs(original.right, cloned.right)

    dfs(original, cloned)
    return ans"
"138","class Solution:
  def copyRandomList(self, head: 'Node') -> 'Node':
    if not head:
      return None
    if head in self.map:
      return self.map[head]

    newNode = Node(head.val)
    self.map[head] = newNode
    newNode.next = self.copyRandomList(head.next)
    newNode.random = self.copyRandomList(head.random)
    return newNode

  map = {}"
"1380","class Solution:
  def luckyNumbers(self, matrix: list[list[int]]) -> list[int]:
    for row in matrix:
      minIndex = row.index(min(row))
      if row[minIndex] == max(list(zip(*matrix))[minIndex]):
        return [row[minIndex]]
    return []"
"1381","class CustomStack:
  def __init__(self, maxSize: int):
    self.maxSize = maxSize
    self.stack = []
    # pendingIncrements[i] := the pending increment for stack[0..i].
    self.pendingIncrements = []

  def push(self, x: int) -> None:
    if len(self.stack) == self.maxSize:
      return
    self.stack.append(x)
    self.pendingIncrements.append(0)

  def pop(self) -> int:
    if not self.stack:
      return -1
    if len(self.stack) > 1:
      self.pendingIncrements[-2] += self.pendingIncrements[-1]
    return self.stack.pop() + self.pendingIncrements.pop()

  def increment(self, k: int, val: int) -> None:
    if not self.stack:
      return
    i = min(k - 1, len(self.stack) - 1)
    self.pendingIncrements[i] += val"
"1382","class Solution:
  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:
    nums = []

    def inorder(root: TreeNode | None) -> None:
      if not root:
        return
      inorder(root.left)
      nums.append(root.val)
      inorder(root.right)

    inorder(root)

    # Same as 108. Convert Sorted Array to Binary Search Tree
    def build(l: int, r: int) -> TreeNode | None:
      if l > r:
        return None
      m = (l + r) // 2
      return TreeNode(nums[m],
                      build(l, m - 1),
                      build(m + 1, r))

    return build(0, len(nums) - 1)"
"1383","class Solution:
  # Similar to 857. Minimum Cost to Hire K Workers
  def maxPerformance(
      self,
      n: int,
      speed: list[int],
      efficiency: list[int],
      k: int,
  ) -> int:
    kMod = 1_000_000_007
    ans = 0
    speedSum = 0
    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order
    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)
    minHeap = []

    for e, s in A:
      heapq.heappush(minHeap, s)
      speedSum += s
      if len(minHeap) > k:
        speedSum -= heapq.heappop(minHeap)
      ans = max(ans, speedSum * e)

    return ans % kMod"
"1384","WITH
  Calendar AS (
    # We should be given a calendar in hand. Otherwise, assume we are oracle
    # and already know the testcase.
    SELECT '2018' AS year, '2018-01-01' AS start, '2018-12-31' AS end
    UNION ALL
    SELECT '2019' AS year, '2019-01-01' AS start, '2019-12-31' AS end
    UNION ALL
    SELECT '2020' AS year, '2020-01-01' AS start, '2020-12-31' AS end
  )
SELECT
  Product.product_id,
  Product.product_name,
  Calendar.year AS report_year,
  (
    DATEDIFF(
      LEAST(Sales.period_end, Calendar.end),
      GREATEST(Sales.period_start, Calendar.start)
    ) + 1
  ) * Sales.average_daily_sales AS total_amount
FROM Sales
INNER JOIN Calendar
  ON (Calendar.year BETWEEN YEAR(Sales.period_start) AND year(Sales.period_end))
INNER JOIN Product
  USING (product_id)
ORDER BY 1, 3;"
"1385","class Solution:
  def findTheDistanceValue(
      self,
      arr1: list[int],
      arr2: list[int],
      d: int,
  ) -> int:
    ans = 0

    arr2.sort()

    for a in arr1:
      i = bisect.bisect_left(arr2, a)
      if ((i == len(arr2) or arr2[i] - a > d) and
              (i == 0 or a - arr2[i - 1] > d)):
        ans += 1

    return ans"
"1386","class Solution:
  def maxNumberOfFamilies(self, n: int, reservedSeats: list[list[int]]) -> int:
    ans = 0
    rowToSeats = collections.Counter()

    for row, seat in reservedSeats:
      rowToSeats[row] |= 1 << (seat - 1)

    for seats in rowToSeats.values():
      if (seats & 0b0111111110) == 0:
        # Can fit 2 four-person groups.
        ans += 2
      elif ((seats & 0b0111100000) == 0 or
            (seats & 0b0001111000) == 0 or
            (seats & 0b0000011110) == 0):
        # Can fit 1 four-person group.
        ans += 1

    # Any empty row can fit 2 four-person groups.
    return ans + (n - len(rowToSeats)) * 2"
"1387","class Solution:
  def getKth(self, lo: int, hi: int, k: int) -> int:
    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]

  def _getPow(self, n: int) -> int:
    if n == 1:
      return 0
    if n % 2 == 0:
      return 1 + self._getPow(n // 2)
    return 1 + self._getPow(n * 3 + 1)"
"1388","class Solution:
  def maxSizeSlices(self, slices: list[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """"""
      Returns the maximum the sum of slices if you can pick k slices from
      slices[i..j).
      """"""
      if k == 1:
        return max(slices[i:j])
      # Note that j - i is not the number of all the left slices. Since you
      # Might have chosen not to take a slice in a previous step, there would be
      # Leftovers outside [i:j]. If you take slices[i], one of the slices your
      # Friends take will be outside of [i:j], so the length of [i:j] is reduced
      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only
      # Requires one slice).
      if j - i < 2 * k - 1:
        return -math.inf
      return max(slices[i] + dp(i + 2, j, k - 1),
                 dp(i + 1, j, k))

    k = len(slices) // 3
    return max(dp(0, len(slices) - 1, k),
               dp(1, len(slices), k))"
"1389","class Solution:
  def createTargetArray(self, nums, index):
    ans = []
    for num, i in zip(nums, index):
      ans.insert(i, num)
    return ans"
"139","class Solution:
  def wordBreak(self, s: str, wordDict: list[str]) -> bool:
    wordSet = set(wordDict)

    @functools.lru_cache(None)
    def wordBreak(s: str) -> bool:
      """"""Returns True if s can be segmented.""""""
      if s in wordSet:
        return True
      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))

    return wordBreak(s)"
"1390","class Solution:
  def sumFourDivisors(self, nums: list[int]) -> int:
    ans = 0

    for num in nums:
      divisor = 0
      for i in range(2, math.isqrt(num) + 1):
        if num % i == 0:
          if divisor == 0:
            divisor = i
          else:
            divisor = 0
            break
      if divisor > 0 and divisor * divisor < num:
        ans += 1 + num + divisor + num // divisor

    return ans"
"1391","class Solution {
  public boolean hasValidPath(int[][] grid) {
    final int m = grid.length;
    final int n = grid[0].length;
    // g := upscaled grid
    boolean[][] g = new boolean[m * 3][n * 3];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        switch (grid[i][j]) {
          case 1:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
          case 2:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 3:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 4:
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 5:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            break;
          case 6:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
        }

    return dfs(g, 1, 1);
  }

  private boolean dfs(boolean[][] g, int i, int j) {
    if (i < 0 || i == g.length || j < 0 || j == g[0].length)
      return false;
    if (!g[i][j]) // There's no path here.
      return false;
    if (i == g.length - 2 && j == g[0].length - 2)
      return true;

    g[i][j] = false; // Mark as visited.
    return dfs(g, i + 1, j) || dfs(g, i - 1, j) || dfs(g, i, j + 1) || dfs(g, i, j - 1);
  }
}"
"1392","class Solution:
  def longestPrefix(self, s: str) -> str:
    kBase = 26
    kHash = 8_417_508_174_513
    n = len(s)
    maxLength = 0
    pow = 1
    prefixHash = 0  # the hash of s[0..i]
    suffixHash = 0  # the hash of s[j..n)

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c)

    j = n - 1
    for i in range(n - 1):
      prefixHash = (prefixHash * kBase + val(s[i])) % kHash
      suffixHash = (val(s[j]) * pow + suffixHash) % kHash
      pow = pow * kBase % kHash
      if prefixHash == suffixHash:
        maxLength = i + 1
      j -= 1

    return s[:maxLength]"
"1393","SELECT
  stock_name,
  SUM(IF(operation = 'Buy', -price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY 1;"
"1394","class Solution:
  def findLucky(self, arr: list[int]) -> int:
    count = [0] * (len(arr) + 1)

    for a in arr:
      if a <= len(arr):
        count[a] += 1

    for i in range(len(arr), 0, -1):
      if count[i] == i:
        return i

    return -1"
"1395","class Solution:
  def numTeams(self, rating: list[int]) -> int:
    ans = 0

    for i in range(1, len(rating) - 1):
      # Calculate soldiers on the left with less//greater ratings.
      leftLess = 0
      leftGreater = 0
      for j in range(i):
        if rating[j] < rating[i]:
          leftLess += 1
        elif rating[j] > rating[i]:
          leftGreater += 1
      # Calculate soldiers on the right with less//greater ratings.
      rightLess = 0
      rightGreater = 0
      for j in range(i + 1, len(rating)):
        if rating[j] < rating[i]:
          rightLess += 1
        elif rating[j] > rating[i]:
          rightGreater += 1
      ans += leftLess * rightGreater + leftGreater * rightLess

    return ans"
"1396","class UndergroundSystem:
  def __init__(self):
    # {id: (stationName, time)}
    self.checkIns = {}
    # {route: (numTrips, totalTime)}
    self.checkOuts = collections.defaultdict(lambda: [0, 0])

  def checkIn(self, id: int, stationName: str, t: int) -> None:
    self.checkIns[id] = (stationName, t)

  def checkOut(self, id: int, stationName: str, t: int) -> None:
    startStation, startTime = self.checkIns.pop(id)
    route = (startStation, stationName)
    self.checkOuts[route][0] += 1
    self.checkOuts[route][1] += t - startTime

  def getAverageTime(self, startStation: str, endStation: str) -> float:
    numTrips, totalTime = self.checkOuts[(startStation, endStation)]
    return totalTime / numTrips"
"1397","class Solution:
  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
    kMod = 1_000_000_007
    evilLPS = self._getLPS(evil)

    @functools.lru_cache(None)
    def getNextMatchedEvilCount(j: int, currChar: str) -> int:
      """"""
      Returns the number of next matched evil count, where there're j matches
      with `evil` and the current letter is ('a' + j).
      """"""
      while j > 0 and evil[j] != currChar:
        j = evilLPS[j - 1]
      return j + 1 if evil[j] == currChar else j

    @functools.lru_cache(None)
    def dp(i: int, matchedEvilCount: int, isS1Prefix: bool, isS2Prefix: bool) -> int:
      """"""
      Returns the number of good strings for s[i..n), where there're j matches
      with `evil`, `isS1Prefix` indicates if the current letter is tightly bound
      for `s1` and `isS2Prefix` indicates if the current letter is tightly bound
      for `s2`.
      """"""
      # s[0..i) contains `evil`, so don't consider any ongoing strings.
      if matchedEvilCount == len(evil):
        return 0
      # Run out of strings, so contribute one.
      if i == n:
        return 1
      ans = 0
      minCharIndex = ord(s1[i]) if isS1Prefix else ord('a')
      maxCharIndex = ord(s2[i]) if isS2Prefix else ord('z')
      for charIndex in range(minCharIndex, maxCharIndex + 1):
        c = chr(charIndex)
        nextMatchedEvilCount = getNextMatchedEvilCount(matchedEvilCount, c)
        ans += dp(i + 1, nextMatchedEvilCount,
                  isS1Prefix and c == s1[i],
                  isS2Prefix and c == s2[i])
        ans %= kMod
      return ans

    return dp(0, 0, True, True)

  def _getLPS(self, pattern: str) -> list[int]:
    """"""
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """"""
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        lps[i] = j + 1
        j += 1
    return lps"
"1398","SELECT
  customer_id,
  customer_name
FROM Customers
INNER JOIN Orders
  USING (customer_id)
GROUP BY 1
HAVING
  SUM(Orders.product_name = 'A') > 0
  AND SUM(Orders.product_name = 'B') > 0
  AND SUM(Orders.product_name = 'C') = 0;"
"1399","class Solution:
  def countLargestGroup(self, n: int) -> int:
    count = [0] * (9 * 4 + 1)
    for i in range(1, n + 1):
      count[self._getDigitSum(i)] += 1
    return count.count(max(count))

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"14","class Solution:
  def longestCommonPrefix(self, strs: list[str]) -> str:
    if not strs:
      return ''

    for i in range(len(strs[0])):
      for j in range(1, len(strs)):
        if i == len(strs[j]) or strs[j][i] != strs[0][i]:
          return strs[0][:i]

    return strs[0]"
"140","class Solution:
  def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:
    wordSet = set(wordDict)

    @functools.lru_cache(None)
    def wordBreak(s: str) -> list[str]:
      ans = []

      # 1 <= len(prefix) < len(s)
      for i in range(1, len(s)):
        prefix = s[0:i]
        suffix = s[i:]
        if prefix in wordSet:
          for word in wordBreak(suffix):
            ans.append(prefix + ' ' + word)

      # `wordSet` contains the whole string s, so don't add any space.
      if s in wordSet:
        ans.append(s)

      return ans

    return wordBreak(s)"
"1400","class Solution:
  def canConstruct(self, s: str, k: int) -> bool:
    # If |s| < k, we cannot construct k strings from the s.
    # If the number of letters that have odd counts > k, the minimum number of
    # palindromic strings we can construct is > k.
    return sum(freq & 1
               for freq in collections.Counter(s).values()) <= k <= len(s)"
"1401","class Solution {
 public:
  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,
                    int x2, int y2) {
    auto clamp = [&](int center, int mn, int mx) {
      return max(mn, min(mx, center));
    };

    // the closest point to the circle within the rectangle
    int closestX = clamp(x_center, x1, x2);
    int closestY = clamp(y_center, y1, y2);

    // the distance between the circle's center and its closest point
    int distanceX = x_center - closestX;
    int distanceY = y_center - closestY;

    // If the distance < the circle's radius, an intersection occurs.
    return (distanceX * distanceX) + (distanceY * distanceY) <=
           (radius * radius);
  }
};"
"1402","class Solution:
  def maxSatisfaction(self, satisfaction: list[int]) -> int:
    ans = 0
    sumSatisfaction = 0

    for s in sorted(satisfaction, reverse=True):
      sumSatisfaction += s
      if sumSatisfaction <= 0:
        return ans
      ans += sumSatisfaction

    return ans"
"1403","class Solution:
  def minSubsequence(self, nums: list[int]) -> list[int]:
    ans = []
    maxHeap = [-num for num in nums]
    heapq.heapify(maxHeap)
    half = sum(nums) // 2

    while half >= 0:
      ans.append(-maxHeap[0])
      half += heapq.heappop(maxHeap)

    return ans"
"1404","class Solution:
  def numSteps(self, s: str) -> int:
    ans = 0
    chars = list(s)

    # All the trailing 0s can be popped by 1 step.
    while chars[-1] == '0':
      chars.pop()
      ans += 1

    if ''.join(chars) == '1':
      return ans

    # `s` is now odd, so add 1 to `s` and cost 1 step.
    # All the 1s will become 0s and can be popped by 1 step.
    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then
    # dividing by 2).
    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)"
"1405","class Solution {
 public:
  string longestDiverseString(int a, int b, int c, char A = 'a', char B = 'b',
                              char C = 'c') {
    if (a < b)
      return longestDiverseString(b, a, c, B, A, C);
    if (b < c)
      return longestDiverseString(a, c, b, A, C, B);
    if (b == 0)
      return string(min(a, 2), A);

    const int useA = min(a, 2);
    const int useB = (a - useA >= b) ? 1 : 0;
    return string(useA, A) + string(useB, B) +
           longestDiverseString(a - useA, b - useB, c, A, B, C);
  }
};"
"1406","class Solution:
  def stoneGameIII(self, stoneValue: list[int]) -> str:
    n = len(stoneValue)
    # dp[i] := the maximum relative score Alice can make with stoneValue[i..n)
    dp = [-math.inf] * n + [0]

    for i in reversed(range(n)):
      summ = 0
      for j in range(i, i + 3):
        if j == n:
          break
        summ += stoneValue[j]
        dp[i] = max(dp[i], summ - dp[j + 1])

    score = dp[0]
    if score == 0:
      return 'Tie'
    return 'Alice' if score > 0 else 'Bob'"
"1407","SELECT
  Users.name,
  IFNULL(SUM(Rides.distance), 0) AS travelled_distance
FROM Users
LEFT JOIN Rides
  ON (Users.id = Rides.user_id)
GROUP BY Users.id
ORDER BY 2 DESC, 1;"
"1408","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
      node.count += 1

  def search(self, word: str) -> bool:
    node: TrieNode = self.root
    for c in word:
      if c not in node.children:
        return False
      node = node.children[c]
    return node.count > 1


class Solution:
  def stringMatching(self, words: list[str]) -> list[str]:
    trie = Trie()

    for word in words:
      for i in range(len(word)):
        trie.insert(word[i:])

    return [word for word in words if trie.search(word)]"
"1409","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def processQueries(self, queries: list[int], m: int) -> list[int]:
    ans = []
    # Map [-m, m] to [0, 2 * m].
    tree = FenwickTree(2 * m + 1)
    numToIndex = {num: num + m for num in range(1, m + 1)}

    for num in range(1, m + 1):
      tree.add(num + m, 1)

    nextEmptyIndex = m  # Map 0 to m.

    for query in queries:
      index = numToIndex[query]
      ans.append(tree.get(index - 1))
      # Move `query` from `index` to `nextEmptyIndex`.
      tree.add(index, -1)
      tree.add(nextEmptyIndex, 1)
      numToIndex[query] = nextEmptyIndex
      nextEmptyIndex -= 1

    return ans"
"141","class Solution:
  def hasCycle(self, head: ListNode) -> bool:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow == fast:
        return True

    return False"
"1410","class Solution:
  def entityParser(self, text: str) -> str:
    entityToChar = {'&quot;': '""', '&apos;': '\'',
                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}

    for entity, c in entityToChar.items():
      text = text.replace(entity, c)

    # Process '&' in last.
    return text.replace('&amp;', '&')"
"1411","class Solution {
 public:
  int numOfWays(int n) {
    constexpr int kMod = 1'000'000'007;
    long color2 = 6;  // 121, 131, 212, 232, 313, 323
    long color3 = 6;  // 123, 132, 213, 231, 312, 321

    for (int i = 1; i < n; ++i) {
      const long nextColor2 = color2 * 3 + color3 * 2;
      const long nextColor3 = color2 * 2 + color3 * 2;
      color2 = nextColor2 % kMod;
      color3 = nextColor3 % kMod;
    }

    return (color2 + color3) % kMod;
  }
};"
"1412","WITH
  RankedStudents AS (
    SELECT
      student_id,
      RANK() OVER(PARTITION BY exam_id ORDER BY score ASC) rank_asc,
      RANK() OVER(PARTITION BY exam_id ORDER BY score DESC) rank_desc
    FROM Exam
  )
SELECT * FROM Student
WHERE student_id IN (
  SELECT student_id FROM RankedStudents
  GROUP BY 1
  HAVING MIN(rank_asc) > 1 AND MIN(rank_desc) > 1
)
ORDER BY student_id;"
"1413","class Solution:
  def minStartValue(self, nums: list[int]) -> int:
    summ = 0
    minSum = 0

    for num in nums:
      summ += num
      minSum = min(minSum, summ)

    return 1 - minSum"
"1414","class Solution:
  def findMinFibonacciNumbers(self, k: int) -> int:
    if k < 2:  # k == 0 or k == 1
      return k

    a = 1  # F_1
    b = 1  # F_2

    while b <= k:
      #    a, b = F_{i + 1}, F_{i + 2}
      # -> a, b = F_{i + 2}, F_{i + 3}
      a, b = b, a + b

    return 1 + self.findMinFibonacciNumbers(k - a)"
"1415","class Solution:
  def getHappyString(self, n: int, k: int) -> str:
    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}
    q = collections.deque(['a', 'b', 'c'])

    while len(q[0]) != n:
      u = q.popleft()
      for nextLetter in nextLetters[u[-1]]:
        q.append(u + nextLetter)

    return '' if len(q) < k else q[k - 1]"
"1416","class Solution {
 public:
  int numberOfArrays(string s, int k) {
    vector<int> mem(s.length(), -1);
    return numberOfArrays(s, 0, k, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of arrays to restore s[i..n) with k.
  int numberOfArrays(const string& s, int i, int k, vector<int>& mem) {
    if (i == s.length())
      return 1;  // an empty string """"
    if (s[i] == '0')
      return 0;  // a leading zero
    if (mem[i] != -1)
      return mem[i];

    int res = 0;
    long num = 0;

    for (int j = i; j < s.length(); ++j) {
      num = num * 10 + (s[j] - '0');
      if (num > k)
        break;
      res = (res + numberOfArrays(s, j + 1, k, mem)) % kMod;
    }

    return mem[i] = res;
  }
};"
"1417","class Solution:
  def reformat(self, s: str) -> str:
    A = [c for c in s if c.isalpha()]
    B = [c for c in s if c.isdigit()]

    if len(A) < len(B):
      A, B = B, A
    if len(A) - len(B) > 1:
      return ''

    ans = []

    for i in range(len(B)):
      ans.append(A[i])
      ans.append(B[i])

    if len(A) == len(B) + 1:
      ans.append(A[-1])
    return ''.join(ans)"
"1418","class Solution {
 public:
  vector<vector<string>> displayTable(vector<vector<string>>& orders) {
    vector<vector<string>> ans{{""Table""}};
    unordered_map<string, int> tableNumberToRowIndex;
    unordered_map<string, int> foodItemToColIndex;

    // Create the first row and column of ans.
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      // Initialize indices with 0s.
      tableNumberToRowIndex[tableNumber] = 0;
      foodItemToColIndex[foodItem] = 0;
    }
    for (const auto& [tableNumber, _] : tableNumberToRowIndex)
      ans.push_back({tableNumber});
    for (const auto& [foodItem, _] : foodItemToColIndex)
      ans[0].push_back(foodItem);

    // Sort the first row and the column, except ans[0][0].
    sort(ans[0].begin() + 1, ans[0].end());
    ranges::sort(ans.begin() + 1, ans.end(), ranges::less{},
                 [](const vector<string>& cols) { return stoi(cols[0]); });

    // Set the indices after sorting.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      tableNumberToRowIndex[ans[i + 1][0]] = i;
    for (int i = 0; i < foodItemToColIndex.size(); ++i)
      foodItemToColIndex[ans[0][i + 1]] = i;

    // Get all the counts of each food item in each table.
    vector<vector<int>> count;
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      count.push_back(vector<int>(foodItemToColIndex.size()));
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      const int rowIndex = tableNumberToRowIndex[tableNumber];
      const int colIndex = foodItemToColIndex[foodItem];
      ++count[rowIndex][colIndex];
    }

    // Set the counts to `ans`.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      for (int j = 0; j < foodItemToColIndex.size(); ++j)
        ans[i + 1].push_back(to_string(count[i][j]));

    return ans;
  }
};"
"1419","class Solution:
  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
    kCroak = 'croak'
    ans = 0
    frogs = 0
    count = [0] * 5

    for c in croakOfFrogs:
      count[kCroak.index(c)] += 1
      if any(count[i] > count[i - 1] for i in range(1, 5)):
        return -1
      if c == 'c':
        frogs += 1
      elif c == 'k':
        frogs -= 1
      ans = max(ans, frogs)

    return ans if frogs == 0 else -1"
"142","class Solution:
  def detectCycle(self, head: ListNode) -> ListNode:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow == fast:
        slow = head
        while slow != fast:
          slow = slow.next
          fast = fast.next
        return slow

    return None"
"1420","class Solution:
  def numOfArrays(self, n: int, m: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of ways to build an array of length i, where j
    # is the maximum number and k is `search_cost`
    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]

    for j in range(1, m + 1):
      dp[1][j][1] = 1

    for i in range(2, n + 1):  # for each length
      for j in range(1, m + 1):  # for each max value
        for cost in range(1, k + 1):  # for each cost
          # 1. Appending any of [1, j] in the i-th position doesn't change the
          #    maximum and cost.
          dp[i][j][cost] = j * dp[i - 1][j][cost] % kMod
          # 2. Appending j in the i-th position makes j the new max and cost 1.
          for prevMax in range(1, j):
            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1]
            dp[i][j][cost] %= kMod

    return sum(dp[n][j][k] for j in range(1, m + 1)) % kMod"
"1421","SELECT
  Queries.id,
  Queries.year,
  IFNULL(NPV.npv, 0) AS npv
FROM Queries
LEFT JOIN NPV
  USING (id, year);"
"1422","class Solution:
  def maxScore(self, s: str) -> int:
    ans = 0
    zeros = 0
    ones = s.count('1')

    for i in range(len(s) - 1):
      if s[i] == '0':
        zeros += 1
      else:
        ones -= 1
      ans = max(ans, zeros + ones)

    return ans"
"1423","class Solution:
  def maxScore(self, cardPoints: list[int], k: int) -> int:
    n = len(cardPoints)
    summ = sum(cardPoints)
    windowSum = sum(cardPoints[:n - k])
    ans = summ - windowSum

    for i in range(k):
      windowSum -= cardPoints[i]
      windowSum += cardPoints[i + n - k]
      ans = max(ans, summ - windowSum)

    return ans"
"1424","class Solution {
  public int[] findDiagonalOrder(List<List<Integer>> nums) {
    List<Integer> ans = new ArrayList<>();
    Map<Integer, List<Integer>> keyToNums = new HashMap<>(); // key := row + column
    int maxKey = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j < nums.get(i).size(); ++j) {
        final int key = i + j;
        keyToNums.putIfAbsent(key, new ArrayList<>());
        keyToNums.get(key).add(nums.get(i).get(j));
        maxKey = Math.max(key, maxKey);
      }

    for (int i = 0; i <= maxKey; ++i)
      for (int j = keyToNums.get(i).size() - 1; j >= 0; --j)
        ans.add(keyToNums.get(i).get(j));

    return ans.stream().mapToInt(Integer::intValue).toArray();
  }
}"
"1425","class Solution:
  def constrainedSubsetSum(self, nums: list[int], k: int) -> int:
    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]
    dp = [0] * len(nums)
    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0
    # in decreasing order.
    dq = collections.deque()

    for i, num in enumerate(nums):
      if dq:
        dp[i] = max(dq[0], 0) + num
      else:
        dp[i] = num
      while dq and dq[-1] < dp[i]:
        dq.pop()
      dq.append(dp[i])
      if i >= k and dp[i - k] == dq[0]:
        dq.popleft()

    return max(dp)"
"1426","class Solution:
  def countElements(self, arr: list[int]) -> int:
    count = collections.Counter(arr)
    return sum(freq
               for a, freq in count.items()
               if count[a + 1] > 0)"
"1427","class Solution:
  def stringShift(self, s: str, shift: list[list[int]]) -> str:
    move = 0

    for direction, amount in shift:
      if direction == 0:
        move -= amount
      else:
        move += amount

    move %= len(s)
    return s[-move:] + s[:-move]"
"1428","# """"""
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# Class BinaryMatrix(object):
#   def get(self, row: int, col: int) -> int:
#   def dimensions(self) -> list[int]:

class Solution:
  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
    m, n = binaryMatrix.dimensions()
    ans = -1
    l = 0
    r = n - 1

    while l <= r:
      mid = (l + r) // 2
      if any(binaryMatrix.get(i, mid) for i in range(m)):
        ans = mid
        r = mid - 1
      else:
        l = mid + 1

    return ans"
"1429","class FirstUnique:
  def __init__(self, nums: list[int]):
    self.seen = set()
    self.unique = {}
    for num in nums:
      self.add(num)

  def showFirstUnique(self) -> int:
    return next(iter(self.unique), -1)

  def add(self, value: int) -> None:
    if value not in self.seen:
      self.seen.add(value)
      self.unique[value] = 1
    elif value in self.unique:
      # We have added this value before, and this is the second time we're
      # adding it. So, erase the value from `unique`.
      self.unique.pop(value)"
"143","class Solution:
  def reorderList(self, head: ListNode) -> None:
    def findMid(head: ListNode):
      prev = None
      slow = head
      fast = head

      while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
      prev.next = None

      return slow

    def reverse(head: ListNode) -> ListNode:
      prev = None
      curr = head

      while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next

      return prev

    def merge(l1: ListNode, l2: ListNode) -> None:
      while l2:
        next = l1.next
        l1.next = l2
        l1 = l2
        l2 = next

    if not head or not head.next:
      return

    mid = findMid(head)
    reversed = reverse(mid)
    merge(head, reversed)"
"1430","class Solution:
  def isValidSequence(self, root: TreeNode | None, arr: list[int]) -> bool:
    def isValidSequence(root: TreeNode | None, i: int) -> bool:
      if not root:
        return False
      if i == len(arr) - 1:
        return root.val == arr[i] and not root.left and not root.right
      return root.val == arr[i] and (
          isValidSequence(root.left, i + 1) or
          isValidSequence(root.right, i + 1))

    return isValidSequence(root, 0)"
"1431","class Solution:
  def kidsWithCandies(
      self,
      candies: list[int],
      extraCandies: int,
  ) -> list[bool]:
    maxCandy = max(candies)
    return [candy + extraCandies >= maxCandy for candy in candies]"
"1432","class Solution:
  def maxDiff(self, num: int) -> int:
    s = str(num)

    def firstNot(s: str, t: str) -> int:
      for i, c in enumerate(s):
        if all(c != d for d in t):
          return i
      return 0

    firstNot9 = firstNot(s, '9')
    firstNot01 = firstNot(s, '01')
    a = s.replace(s[firstNot9], '9')
    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')
    return int(a) - int(b)"
"1433","class Solution:
  def checkIfCanBreak(self, s1: str, s2: str) -> bool:
    count = collections.Counter(s1)
    count.subtract(collections.Counter(s2))

    for a, b in itertools.pairwise(string.ascii_lowercase):
      count[b] += count[a]

    return (all(value <= 0 for value in count.values()) or
            all(value >= 0 for value in count.values()))"
"1434","class Solution {
  public int numberWays(List<List<Integer>> hats) {
    final int kMod = 1_000_000_007;
    final int nHats = 40;
    final int nPeople = hats.size();
    final int nAssignments = 1 << nPeople;
    List<Integer>[] hatToPeople = new List[nHats + 1];
    // dp[i] := the number of ways to assign the hats so far to people, where i
    // is the bitmask of the current assignment
    int[] dp = new int[nAssignments];
    dp[0] = 1;

    for (int i = 1; i <= nHats; ++i)
      hatToPeople[i] = new ArrayList<>();

    for (int i = 0; i < nPeople; ++i)
      for (final int hat : hats.get(i))
        hatToPeople[hat].add(i);

    for (int h = 1; h <= nHats; ++h)
      for (int j = nAssignments - 1; j >= 0; --j)
        for (final int p : hatToPeople[h])
          if ((j >> p & 1) == 1) {
            dp[j] += dp[j ^ 1 << p];
            dp[j] %= kMod;
          }

    return dp[nAssignments - 1];
  }
}"
"1435","SELECT '[0-5>' AS bin,
  SUM(duration <= 300) AS total
FROM Sessions
UNION ALL
SELECT '[5-10>' AS bin,
  SUM(
    duration > 300
    AND duration <= 600
  ) AS total
FROM Sessions
UNION ALL
SELECT '[10-15>' AS bin,
  SUM(
    duration > 600
    AND duration <= 900
  ) AS total
FROM Sessions
UNION ALL
SELECT '15 or more' AS bin,
  SUM(duration > 900) AS total
FROM Sessions"
"1436","class Solution:
  def destCity(self, paths: list[list[str]]) -> str:
    count = collections.Counter()

    for a, b in paths:
      count[a] += 1

    for a, b in paths:
      if b in count:
        count[b] -= 1
        if count[b] == 0:
          del count[b]
      else:
        return b"
"1437","class Solution:
  def kLengthApart(self, nums: list[int], k: int) -> bool:
    if k == 0:
      return True

    n = len(nums)
    curr = 0
    next = 1

    while curr < n and next < n:
      if nums[next] == 1:
        if nums[curr] == 1 and next - curr <= k:
          return False
        curr = next
      next += 1

    return True"
"1438","class Solution {
 public:
  int longestSubarray(vector<int>& nums, int limit) {
    int ans = 1;
    deque<int> minQ;
    deque<int> maxQ;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (!minQ.empty() && minQ.back() > nums[r])
        minQ.pop_back();
      minQ.push_back(nums[r]);
      while (!maxQ.empty() && maxQ.back() < nums[r])
        maxQ.pop_back();
      maxQ.push_back(nums[r]);
      while (maxQ.front() - minQ.front() > limit) {
        if (minQ.front() == nums[l])
          minQ.pop_front();
        if (maxQ.front() == nums[l])
          maxQ.pop_front();
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};"
"1439","struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& mat, int k) {
    vector<int> row = mat[0];

    for (int i = 1; i < mat.size(); ++i)
      row = kSmallestPairSums(row, mat[i], k);

    return row.back();
  }

 private:
  // Similar to 373. Find K Pairs with Smallest Sums
  vector<int> kSmallestPairSums(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back(nums1[i] + nums2[j]);
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};"
"144","class Solution:
  def preorderTraversal(self, root: TreeNode | None) -> list[int]:
    if not root:
      return []

    ans = []
    stack = [root]

    while stack:
      node = stack.pop()
      ans.append(node.val)
      if node.right:
        stack.append(node.right)
      if node.left:
        stack.append(node.left)

    return ans"
"1440","SELECT Expressions.*,
  (
    CASE
      WHEN Expressions.operator = '<'
      AND LeftOperand.value < RightOperand.value THEN 'true'
      WHEN Expressions.operator = '>'
      AND LeftOperand.value > RightOperand.value THEN 'true'
      WHEN Expressions.operator = '='
      AND LeftOperand.value = RightOperand.value THEN 'true'
      ELSE 'false'
    END
  ) AS value
FROM Expressions
INNER JOIN VARIABLES AS LeftOperand
  ON (Expressions.left_operand = LeftOperand.name)
INNER JOIN VARIABLES AS RightOperand
  ON (Expressions.right_operand = RightOperand.name);"
"1441","class Solution:
  def buildArray(self, target: list[int], n: int) -> list[str]:
    ans = []
    i = 0  # Target pointer
    num = 1  # Curr num

    while i < len(target):
      t = target[i]
      if t == num:
        ans.append('Push')
        i += 1
      else:
        ans.append('Push')
        ans.append('Pop')
      num += 1

    return ans"
"1442","class Solution:
  def countTriplets(self, arr: list[int]) -> int:
    ans = 0
    xors = [0]
    prefix = 0

    for i, a in enumerate(arr):
      prefix ^= a
      xors.append(prefix)

    for j in range(1, len(arr)):
      for i in range(0, j):
        xors_i = xors[j] ^ xors[i]
        for k in range(j, len(arr)):
          xors_k = xors[k + 1] ^ xors[j]
          if xors_i == xors_k:
            ans += 1

    return ans"
"1443","class Solution {
 public:
  int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    return dfs(graph, 0, vector<bool>(n), hasApple);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, vector<bool>&& seen,
          const vector<bool>& hasApple) {
    seen[u] = true;
    int totalCost = 0;

    for (const int v : graph[u]) {
      if (seen[v])
        continue;
      const int cost = dfs(graph, v, std::move(seen), hasApple);
      if (cost > 0 || hasApple[v])
        totalCost += cost + 2;
    }

    return totalCost;
  }
};"
"1444","class Solution:
  def ways(self, pizza: list[str], k: int) -> int:
    kMod = 1_000_000_007
    M = len(pizza)
    N = len(pizza[0])
    prefix = [[0] * (N + 1) for _ in range(M + 1)]

    for i in range(M):
      for j in range(N):
        prefix[i + 1][j + 1] = ((pizza[i][j] == 'A') + prefix[i][j + 1] +
                                prefix[i + 1][j] - prefix[i][j])

    def hasApple(row1: int, row2: int, col1: int, col2: int) -> bool:
      """"""Returns True if pizza[row1..row2)[col1..col2) has apple.""""""
      return (prefix[row2][col2] - prefix[row1][col2] -
              prefix[row2][col1] + prefix[row1][col1]) > 0

    @functools.lru_cache(None)
    def dp(m: int, n: int, k: int) -> int:
      """"""Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.""""""
      if k == 0:
        return 1 if hasApple(m, M, n, N) else 0

      res = 0

      for i in range(m + 1, M):  # Cut horizontally.
        if hasApple(m, i, n, N) and hasApple(i, M, n, N):
          res += dp(i, n, k - 1)

      for j in range(n + 1, N):  # Cut vertically.
        if hasApple(m, M, n, j) and hasApple(m, M, j, N):
          res += dp(m, j, k - 1)

      return res % kMod

    return dp(0, 0, k - 1)"
"1445","SELECT
  sale_date,
  SUM(IF(fruit = 'apples', sold_num, -sold_num)) AS diff
FROM Sales
GROUP BY 1;"
"1446","class Solution:
  def maxPower(self, s: str) -> int:
    ans = 1
    count = 1

    for i in range(1, len(s)):
      count = count + 1 if s[i] == s[i - 1] else 1
      ans = max(ans, count)

    return ans"
"1447","class Solution:
  def simplifiedFractions(self, n: int) -> list[str]:
    ans = []
    for denominator in range(2, n + 1):
      for numerator in range(1, denominator):
        if math.gcd(denominator, numerator) == 1:
          ans.append(str(numerator) + '/' + str(denominator))
    return ans"
"1448","class Solution {
 public:
  int goodNodes(TreeNode* root, int mx = INT_MIN) {
    if (root == nullptr)
      return 0;
    const int newMax = max(mx, root->val);
    return (root->val >= mx) +              //
           goodNodes(root->left, newMax) +  //
           goodNodes(root->right, newMax);
  }
};"
"1449","class Solution {
 public:
  string largestNumber(vector<int>& cost, int target) {
    // dp[i] := the maximum length that cost i can achieve
    vector<int> dp(target + 1, INT_MIN);
    dp[0] = 0;  // If cost = 0, the best choice is the empty string """".

    for (int i = 1; i <= target; ++i)
      for (int d = 0; d < 9; ++d)
        if (i >= cost[d])
          dp[i] = max(dp[i], dp[i - cost[d]] + 1);

    if (dp[target] < 0)
      return ""0"";

    string ans;

    // Greedily build the ans string.
    for (int d = 8; d >= 0; --d)
      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {
        target -= cost[d];
        ans += '1' + d;
      }

    return ans;
  }
};"
"145","class Solution:
  def postorderTraversal(self, root: TreeNode | None) -> list[int]:
    if not root:
      return []

    ans = []
    stack = [root]

    while stack:
      node = stack.pop()
      ans.append(node.val)
      if node.left:
        stack.append(node.left)
      if node.right:
        stack.append(node.right)

    return ans[::-1]"
"1450","class Solution {
 public:
  int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
    const int n = startTime.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (startTime[i] <= queryTime && queryTime <= endTime[i])
        ++ans;

    return ans;
  }
};"
"1451","class Solution:
  def arrangeWords(self, text: str) -> str:
    words = text.split()
    count = collections.defaultdict(list)

    for word in words:
      count[len(word)].append(word.lower())

    c2 = OrderedDict(sorted(count.items()))

    ans = []

    for l in c2:
      for word in c2[l]:
        ans.append(word)

    ans[0] = ans[0].capitalize()

    return ' '.join(ans)"
"1452","class Solution:
  def peopleIndexes(self, favoriteCompanies: list[list[str]]) -> list[int]:
    ans = []
    n = len(favoriteCompanies)
    companies = [set(comp) for comp in favoriteCompanies]

    for i in range(n):
      find = False
      for j in range(n):
        if i == j:
          continue
        if companies[i].issubset(companies[j]):
          find = True
          break
      if not find:
        ans.append(i)

    return ans"
"1453","class Point:
  def __init__(self, x: float, y: float):
    self.x = x
    self.y = y


class Solution:
  def numPoints(self, darts: list[list[int]], r: int) -> int:
    kErr = 1e-6
    ans = 1
    points = [Point(x, y) for x, y in darts]

    def dist(p: Point, q: Point) -> float:
      return ((p.x - q.x)**2 + (p.y - q.y)**2)**0.5

    def getCircles(p: Point, q: Point) -> list[Point]:
      if dist(p, q) - 2.0 * r > kErr:
        return []
      m = Point((p.x + q.x) / 2, (p.y + q.y) / 2)
      distCM = (r**2 - (dist(p, q) / 2)**2)**0.5
      alpha = math.atan2(p.y - q.y, q.x - p.x)
      return [Point(m.x - distCM * math.sin(alpha), m.y - distCM * math.cos(alpha)),
              Point(m.x + distCM * math.sin(alpha), m.y + distCM * math.cos(alpha))]

    for i in range(len(points)):
      for j in range(i + 1, len(points)):
        for c in getCircles(points[i], points[j]):
          count = 0
          for point in points:
            if dist(c, point) - r <= kErr:
              count += 1
          ans = max(ans, count)

    return ans"
"1454","WITH
  DistinctLogins AS (
    SELECT DISTINCT * FROM Logins
  ),
  RankedLogins AS (
    SELECT
      *,
      DENSE_RANK() OVER(
        PARTITION BY id
        ORDER BY login_date
      ) AS `rank`
    FROM DistinctLogins
  ),
  RankedLoginsWithGroupId AS (
    SELECT
      *,
      DATE_ADD(login_date, INTERVAL -`rank` DAY) AS group_id
    FROM RankedLogins
  )
SELECT DISTINCT
  id,
  Accounts.name
FROM RankedLoginsWithGroupId
INNER JOIN Accounts
  USING (id)
GROUP BY Accounts.id, RankedLoginsWithGroupId.group_id
HAVING COUNT(*) >= 5
ORDER BY 1;"
"1455","class Solution:
  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
    words = sentence.split()

    for i, word in enumerate(words):
      if word.startswith(searchWord):
        return i + 1

    return -1"
"1456","class Solution:
  def maxVowels(self, s: str, k: int) -> int:
    ans = 0
    mx = 0
    kVowels = 'aeiou'

    for i, c in enumerate(s):
      if c in kVowels:
        mx += 1
      if i >= k and s[i - k] in kVowels:
        mx -= 1
      ans = max(ans, mx)

    return ans"
"1457","class Solution:
  def pseudoPalindromicPaths(self, root: TreeNode | None) -> int:
    ans = 0

    def dfs(root: TreeNode | None, path: int) -> None:
      nonlocal ans
      if not root:
        return
      if not root.left and not root.right:
        path ^= 1 << root.val
        if path & (path - 1) == 0:
          ans += 1
        return

      dfs(root.left, path ^ 1 << root.val)
      dfs(root.right, path ^ 1 << root.val)

    dfs(root, 0)
    return ans"
"1458","class Solution:
  def maxDotProduct(self, A: list[int], B: list[int]) -> int:
    m = len(A)
    n = len(B)
    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)
    # and nums2[0..j)
    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],
                               max(0, dp[i][j]) + A[i] * B[j])

    return dp[m][n]"
"1459","SELECT
  P1.id AS p1,
  P2.id AS p2,
  ABS(p1.x_value - p2.x_value) * ABS(p1.y_value - p2.y_value) AS area
FROM Points AS P1, Points AS P2
WHERE
  P1.id < P2.id
  AND P1.x_value != P2.x_value
  AND P1.y_value != P2.y_value
ORDER BY area DESC, p1, p2;"
"146","class Node:
  def __init__(self, key: int, value: int):
    self.key = key
    self.value = value
    self.prev = None
    self.next = None


class LRUCache:
  def __init__(self, capacity: int):
    self.capacity = capacity
    self.keyToNode = {}
    self.head = Node(-1, -1)
    self.tail = Node(-1, -1)
    self.join(self.head, self.tail)

  def get(self, key: int) -> int:
    if key not in self.keyToNode:
      return -1

    node = self.keyToNode[key]
    self.remove(node)
    self.moveToHead(node)
    return node.value

  def put(self, key: int, value: int) -> None:
    if key in self.keyToNode:
      node = self.keyToNode[key]
      node.value = value
      self.remove(node)
      self.moveToHead(node)
      return

    if len(self.keyToNode) == self.capacity:
      lastNode = self.tail.prev
      del self.keyToNode[lastNode.key]
      self.remove(lastNode)

    self.moveToHead(Node(key, value))
    self.keyToNode[key] = self.head.next

  def join(self, node1: Node, node2: Node):
    node1.next = node2
    node2.prev = node1

  def moveToHead(self, node: Node):
    self.join(node, self.head.next)
    self.join(self.head, node)

  def remove(self, node: Node):
    self.join(node.prev, node.next)"
"1460","class Solution:
  def canBeEqual(self, target: list[int], arr: list[int]) -> bool:
    return collections.Counter(arr) == collections.Counter(target)"
"1461","class Solution:
  def hasAllCodes(self, s: str, k: int) -> bool:
    n = 1 << k
    if len(s) < n:
      return False

    # used[i] := True if i is a substring of `s`
    used = [0] * n

    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)
    for i in range(k - 1, len(s)):
      # Include the s[i].
      windowStr = (windowStr << 1) + int(s[i])
      # Discard the s[i - k].
      windowStr &= n - 1
      used[windowStr] = True

    return all(u for u in used)"
"1462","class Solution:
  def checkIfPrerequisite(
      self,
      numCourses: int,
      prerequisites: list[list[int]],
      queries: list[list[int]],
  ) -> list[bool]:
    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.
    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]

    for u, v in prerequisites:
      isPrerequisite[u][v] = True

    for k in range(numCourses):
      for i in range(numCourses):
        for j in range(numCourses):
          isPrerequisite[i][j] = (isPrerequisite[i][j] or (
              isPrerequisite[i][k] and isPrerequisite[k][j]))

    return [isPrerequisite[u][v] for u, v in queries]"
"1463","class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<vector<int>>> mem(m,
                                    vector<vector<int>>(n, vector<int>(n, -1)));
    return cherryPickup(grid, 0, 0, n - 1, mem);
  }

 private:
  // Returns the maximum cherries we can collect, where the robot #1 is on
  // (x, y1) and the robot #2 is on (x, y2).
  int cherryPickup(const vector<vector<int>>& grid, int x, int y1, int y2,
                   vector<vector<vector<int>>>& mem) {
    if (x == grid.size())
      return 0;
    if (y1 < 0 || y1 == grid[0].size() || y2 < 0 || y2 == grid[0].size())
      return 0;
    if (mem[x][y1][y2] != -1)
      return mem[x][y1][y2];

    const int currRow = grid[x][y1] + (y1 == y2 ? 0 : 1) * grid[x][y2];

    for (int d1 = -1; d1 <= 1; ++d1)
      for (int d2 = -1; d2 <= 1; ++d2)
        mem[x][y1][y2] =
            max(mem[x][y1][y2],
                currRow + cherryPickup(grid, x + 1, y1 + d1, y2 + d2, mem));

    return mem[x][y1][y2];
  }
};"
"1464","class Solution:
  def maxProduct(self, nums: list[int]) -> int:
    max1 = 0
    max2 = 0

    for num in nums:
      if num > max1:
        max2, max1 = max1, num
      elif num > max2:
        max2 = num

    return (max1 - 1) * (max2 - 1)"
"1465","class Solution:
  def maxArea(
      self,
      h: int,
      w: int,
      horizontalCuts: list[int],
      verticalCuts: list[int],
  ) -> int:
    kMod = 1_000_000_007
    # the maximum gap of each direction
    maxGapX = max(b - a
                  for a, b in itertools.pairwise(
                      [0] + sorted(horizontalCuts) + [h]))
    maxGapY = max(b - a
                  for a, b in itertools.pairwise(
                      [0] + sorted(verticalCuts) + [w]))
    return maxGapX * maxGapY % kMod"
"1466","class Solution {
  public int minReorder(int n, int[][] connections) {
    List<Integer>[] graph = new List[n];

    for (int i = 0; i < n; ++i)
      graph[i] = new ArrayList<>();

    for (int[] connection : connections) {
      final int u = connection[0];
      final int v = connection[1];
      graph[u].add(v);
      graph[v].add(-u); // - := u -> v
    }

    return dfs(graph, 0, -1);
  }

  private int dfs(List<Integer>[] graph, int u, int prev) {
    int change = 0;

    for (final int v : graph[u]) {
      if (Math.abs(v) == prev)
        continue;
      if (v > 0)
        ++change;
      change += dfs(graph, Math.abs(v), u);
    }

    return change;
  }
}"
"1467","from enum import Enum


class BoxCase(Enum):
  kEqualDistantBalls = 0
  kEqualBalls = 1


class Solution:
  def getProbability(self, balls: list[int]) -> float:
    n = sum(balls) // 2
    fact = [1, 1, 2, 6, 24, 120, 720]

    def cases(
            i: int,
            ballsCountA: int,
            ballsCountB: int,
            colorsCountA: int,
            colorsCountB,
            boxCase: BoxCase) -> float:
      if ballsCountA > n or ballsCountB > n:
        return 0
      if i == len(balls):
        return (1 if boxCase == BoxCase.kEqualBalls
                else colorsCountA == colorsCountB)

      ans = 0.0

      # balls taken from A for `balls[i]`
      for ballsTakenA in range(balls[i] + 1):
        ballsTakenB = balls[i] - ballsTakenA
        newcolorsCountA = colorsCountA + (ballsTakenA > 0)
        newcolorsCountB = colorsCountB + (ballsTakenB > 0)
        ans += (cases(i + 1,
                      ballsCountA + ballsTakenA,
                      ballsCountB + ballsTakenB,
                      newcolorsCountA, newcolorsCountB, boxCase) /
                (fact[ballsTakenA] * fact[ballsTakenB]))

      return ans

    return (cases(0, 0, 0, 0, 0, BoxCase.kEqualDistantBalls) /
            cases(0, 0, 0, 0, 0, BoxCase.kEqualBalls))"
"1468","WITH
  SalariesWithMaxSalary AS (
    SELECT
      *,
      MAX(salary) OVER(PARTITION BY company_id) AS max_salary
    FROM Salaries
  )
SELECT
  company_id,
  employee_id,
  employee_name,
  ROUND(
    CASE
      WHEN max_salary < 1000 THEN salary
      WHEN max_salary BETWEEN 1000 AND 10000 THEN salary * 0.76
      ELSE salary * 0.51
    END
  ) AS salary
FROM SalariesWithMaxSalary;"
"1469","class Solution {
  public List<Integer> getLonelyNodes(TreeNode root) {
    List<Integer> ans = new ArrayList<>();

    dfs(root, false, ans);

    return ans;
  }

  private void dfs(TreeNode root, boolean isLonely, List<Integer> ans) {
    if (root == null)
      return;
    if (isLonely)
      ans.add(root.val);

    dfs(root.left, root.right == null, ans);
    dfs(root.right, root.left == null, ans);
  }
}"
"147","class Solution:
  def insertionSortList(self, head: ListNode | None) -> ListNode | None:
    dummy = ListNode(0)
    prev = dummy  # the last and thus largest of the sorted list

    while head:  # the current inserting node
      next = head.next  # Cache the next inserting node.
      if prev.val >= head.val:
        prev = dummy  # Move `prev` to the front.
      while prev.next and prev.next.val < head.val:
        prev = prev.next
      head.next = prev.next
      prev.next = head
      head = next  # Update the current inserting node.

    return dummy.next"
"1470","class Solution:
  def shuffle(self, nums: list[int], n: int) -> list[int]:
    ans = []
    for a, b in zip(nums[:n], nums[n:]):
      ans.append(a)
      ans.append(b)
    return ans"
"1471","class Solution:
  def getStrongest(self, arr: list[int], k: int) -> list[int]:
    arr.sort()

    ans = []
    median = arr[(len(arr) - 1) // 2]
    l = 0
    r = len(arr) - 1

    for _ in range(k):
      if median - arr[l] > arr[r] - median:
        ans.append(arr[l])
        l -= 1
      else:
        ans.append(arr[r])
        r += 1

    return ans"
"1472","class BrowserHistory:
  def __init__(self, homepage: str):
    self.history = []
    self.visit(homepage)

  def visit(self, url: str) -> None:
    self.history.append(url)
    self.future = []

  def back(self, steps: int) -> str:
    while len(self.history) > 1 and steps > 0:
      self.future.append(self.history.pop())
      steps -= 1
    return self.history[-1]

  def forward(self, steps: int) -> str:
    while self.future and steps > 0:
      self.history.append(self.future.pop())
      steps -= 1
    return self.history[-1]"
"1473","class Solution {
 public:
  int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n,
              int target) {
    vector<vector<vector<int>>> mem(target + 1,
                                    vector<vector<int>>(m, vector<int>(n + 1)));
    // Initialize `prevColor` to 0 (the virtual neighbor).
    const int c = minCost(houses, cost, m, n, target, 0, 0, mem);
    return c == kMax ? -1 : c;
  }

 private:
  static constexpr int kMax = 1'000'001;

  // Returns the minimum cost to paint houses[i..m) into k neighborhoods, where
  // there are houses[i - 1] colors = prevColor.
  int minCost(const vector<int>& houses, const vector<vector<int>>& cost,
              const int& m, const int& n, int k, int i, int prevColor,
              vector<vector<vector<int>>>& mem) {
    if (i == m || k < 0)
      return k == 0 ? 0 : kMax;
    if (mem[k][i][prevColor] > 0)
      return mem[k][i][prevColor];
    if (houses[i] > 0)  // The house was painted last year.
      return minCost(houses, cost, m, n, k - (prevColor != houses[i]), i + 1,
                     houses[i], mem);

    int res = kMax;

    // Try to paint the houses[i] with each color in 1..n.
    for (int color = 1; color <= n; ++color)
      res = min(res, cost[i][color - 1] + minCost(houses, cost, m, n,
                                                  k - (prevColor != color),
                                                  i + 1, color, mem));

    return mem[k][i][prevColor] = res;
  }
};"
"1474","class Solution:
  def deleteNodes(
      self,
      head: ListNode | None,
      m: int,
      n: int,
  ) -> ListNode | None:
    curr = head
    prev = None  # prev.next == curr

    while curr:
      # Set the m-th node as `prev`.
      for _ in range(m):
        if not curr:
          break
        prev = curr
        curr = curr.next
      # Set the (m + n + 1)-th node as `curr`.
      for _ in range(n):
        if not curr:
          break
        curr = curr.next
      # Delete the nodes [m + 1..n - 1].
      prev.next = curr

    return head"
"1475","class Solution:
  def finalPrices(self, prices: list[int]) -> list[int]:
    ans = prices.copy()
    stack = []

    for i, price in enumerate(prices):
      # stack[-1] := i in the problem description.
      while stack and prices[stack[-1]] >= price:
        ans[stack.pop()] -= price
      stack.append(i)

    return ans"
"1476","class SubrectangleQueries:
  def __init__(self, rectangle: list[list[int]]):
    self.rectangle = rectangle
    self.updates = []

  def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int,
                         newValue: int) -> None:
    self.updates.append((row1, col1, row2, col2, newValue))

  def getValue(self, row: int, col: int) -> int:
    for r1, c1, r2, c2, v in reversed(self.updates):
      if r1 <= row <= r2 and c1 <= col <= c2:
        return v
    return self.rectangle[row][col]"
"1477","class Solution {
  public int minSumOfLengths(int[] arr, int target) {
    int ans = Integer.MAX_VALUE;
    int leftLength = Integer.MAX_VALUE;
    int prefix = 0;
    Map<Integer, Integer> prefixToIndex = new HashMap<>();
    prefixToIndex.put(0, -1);

    for (int i = 0; i < arr.length; ++i) {
      prefix += arr[i];
      prefixToIndex.put(prefix, i);
    }

    prefix = 0;

    for (int i = 0; i < arr.length; ++i) {
      prefix += arr[i];
      if (prefixToIndex.containsKey(prefix - target))
        leftLength = Math.min(leftLength, i - prefixToIndex.get(prefix - target));
      if (leftLength < Integer.MAX_VALUE)
        if (prefixToIndex.containsKey(prefix + target))
          ans = Math.min(ans, leftLength + prefixToIndex.get(prefix + target) - i);
    }

    return ans == Integer.MAX_VALUE ? -1 : ans;
  }
}"
"1478","class Solution {
 public:
  int minDistance(vector<int>& houses, int k) {
    const int n = houses.size();
    vector<vector<int>> mem(n, vector<int>(k + 1, INT_MAX));
    // cost[i][j] := the minimum cost to allocate mailboxes between houses[i]
    // and houses[j]
    vector<vector<int>> cost(n, vector<int>(n));

    ranges::sort(houses);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        const int median = houses[(i + j) / 2];
        for (int x = i; x <= j; ++x)
          cost[i][j] += abs(houses[x] - median);
      }

    return minDistance(houses, 0, k, cost, mem);
  }

 private:
  static constexpr int kMax = 1'000'000;

  // Returns the minimum distance to allocate k mailboxes for houses[i..n).
  int minDistance(const vector<int>& houses, int i, int k,
                  const vector<vector<int>>& cost, vector<vector<int>>& mem) {
    if (i == houses.size() && k == 0)
      return 0;
    if (i == houses.size() || k == 0)
      return kMax;
    if (mem[i][k] != INT_MAX)
      return mem[i][k];

    for (int j = i; j < houses.size(); ++j)
      mem[i][k] = min(
          mem[i][k], cost[i][j] + minDistance(houses, j + 1, k - 1, cost, mem));

    return mem[i][k];
  }
};"
"1479","SELECT
  Items.item_category AS Category,
  SUM(IF(WEEKDAY(Orders.order_date) = 0, Orders.quantity, 0)) AS Monday,
  SUM(IF(WEEKDAY(Orders.order_date) = 1, Orders.quantity, 0)) AS Tuesday,
  SUM(IF(WEEKDAY(Orders.order_date) = 2, Orders.quantity, 0)) AS Wednesday,
  SUM(IF(WEEKDAY(Orders.order_date) = 3, Orders.quantity, 0)) AS Thursday,
  SUM(IF(WEEKDAY(Orders.order_date) = 4, Orders.quantity, 0)) AS Friday,
  SUM(IF(WEEKDAY(Orders.order_date) = 5, Orders.quantity, 0)) AS Saturday,
  SUM(IF(WEEKDAY(Orders.order_date) = 6, Orders.quantity, 0)) AS Sunday
FROM Items
LEFT JOIN Orders
  USING (item_id)
GROUP BY 1
ORDER BY 1;"
"148","class Solution:
  def sortList(self, head: ListNode) -> ListNode:
    def split(head: ListNode, k: int) -> ListNode:
      while k > 1 and head:
        head = head.next
        k -= 1
      rest = head.next if head else None
      if head:
        head.next = None
      return rest

    def merge(l1: ListNode, l2: ListNode) -> tuple:
      dummy = ListNode(0)
      tail = dummy

      while l1 and l2:
        if l1.val > l2.val:
          l1, l2 = l2, l1
        tail.next = l1
        l1 = l1.next
        tail = tail.next
      tail.next = l1 if l1 else l2
      while tail.next:
        tail = tail.next

      return dummy.next, tail

    length = 0
    curr = head
    while curr:
      length += 1
      curr = curr.next

    dummy = ListNode(0, head)

    k = 1
    while k < length:
      curr = dummy.next
      tail = dummy
      while curr:
        l = curr
        r = split(l, k)
        curr = split(r, k)
        mergedHead, mergedTail = merge(l, r)
        tail.next = mergedHead
        tail = mergedTail
      k *= 2

    return dummy.next"
"1480","class Solution:
  def runningSum(self, nums: list[int]) -> list[int]:
    return itertools.accumulate(nums)"
"1481","class Solution:
  def findLeastNumOfUniqueInts(self, arr: list[int], k: int) -> int:
    minHeap = list(collections.Counter(arr).values())
    heapq.heapify(minHeap)

    # Greedily remove the k least frequent numbers to have the least number of unique integers.
    while k > 0:
      k -= heapq.heappop(minHeap)

    return len(minHeap) + (1 if k < 0 else 0)"
"1482","class Solution:
  def minDays(self, bloomDay: list[int], m: int, k: int) -> int:
    if len(bloomDay) < m * k:
      return -1

    def getBouquetCount(waitingDays: int) -> int:
      """"""
      Returns the number of bouquets (k flowers needed) can be made after the
      `waitingDays`.
      """"""
      bouquetCount = 0
      requiredFlowers = k
      for day in bloomDay:
        if day > waitingDays:
          # Reset `requiredFlowers` since there was not enough adjacent flowers.
          requiredFlowers = k
        else:
          requiredFlowers -= 1
          if requiredFlowers == 0:
            # Use k adjacent flowers to make a bouquet.
            bouquetCount += 1
            requiredFlowers = k
      return bouquetCount

    l = min(bloomDay)
    r = max(bloomDay)

    while l < r:
      mid = (l + r) // 2
      if getBouquetCount(mid) >= m:
        r = mid
      else:
        l = mid + 1

    return l"
"1483","class TreeAncestor:
  def __init__(self, n: int, parent: list[int]):
    self.maxLevel = n.bit_length()
    # dp[i][j] := node i's 2^j-th ancestor
    self.dp = [[0] * self.maxLevel for _ in range(n)]

    # Node i's 2^0 ancestor is its direct parent
    for i in range(n):
      self.dp[i][0] = parent[i]

    for j in range(1, self.maxLevel):
      for i in range(n):
        if self.dp[i][j - 1] == -1:  # There's no such ancestor
          self.dp[i][j] = -1
        else:  # A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})
          self.dp[i][j] = self.dp[self.dp[i][j - 1]][j - 1]

  def getKthAncestor(self, node: int, k: int) -> int:
    for j in range(self.maxLevel):
      if node == -1:
        break
      if k >> j & 1:
        node = self.dp[node][j]
    return node"
"1484","SELECT
  sell_date,
  COUNT(DISTINCT product) AS num_sold,
  GROUP_CONCAT(DISTINCT product ORDER BY product) AS products
FROM Activities
GROUP BY 1;"
"1485","class Solution {
  public NodeCopy copyRandomBinaryTree(Node root) {
    if (root == null)
      return null;
    if (map.containsKey(root))
      return map.get(root);

    NodeCopy newNode = new NodeCopy(root.val);
    map.put(root, newNode);

    newNode.left = copyRandomBinaryTree(root.left);
    newNode.right = copyRandomBinaryTree(root.right);
    newNode.random = copyRandomBinaryTree(root.random);
    return newNode;
  }

  private Map<Node, NodeCopy> map = new HashMap<>();
}"
"1486","class Solution:
  def xorOperation(self, n: int, start: int) -> int:
    return functools.reduce(operator.xor,
                            [start + 2 * i for i in range(n)])"
"1487","class Solution:
  def getFolderNames(self, names: list[str]) -> list[str]:
    ans = []
    nameToSuffix = {}

    for name in names:
      if name in nameToSuffix:
        suffix = nameToSuffix[name] + 1
        newName = self._getName(name, suffix)
        while newName in nameToSuffix:
          suffix += 1
          newName = self._getName(name, suffix)
        nameToSuffix[name] = suffix
        nameToSuffix[newName] = 0
        ans.append(newName)
      else:
        nameToSuffix[name] = 0
        ans.append(name)

    return ans

  def _getName(self, name: str, suffix: int) -> str:
    return name + '(' + str(suffix) + ')'"
"1488","from sortedcontainers import SortedSet


class Solution:
  def avoidFlood(self, rains: list[int]) -> list[int]:
    ans = [-1] * len(rains)
    lakeIdToFullDay = {}
    emptyDays = SortedSet()  # indices of rains[i] == 0

    for i, lakeId in enumerate(rains):
      if lakeId == 0:
        emptyDays.add(i)
        continue
        # The lake was full in a previous day. Greedily find the closest day
        # to make the lake empty.
      if lakeId in lakeIdToFullDay:
        fullDay = lakeIdToFullDay[lakeId]
        emptyDayIndex = emptyDays.bisect_right(fullDay)
        if emptyDayIndex == len(emptyDays):  # Not found.
          return []
        # Empty the lake at this day.
        emptyDay = emptyDays[emptyDayIndex]
        ans[emptyDay] = lakeId
        emptyDays.discard(emptyDay)
      # The lake with `lakeId` becomes full at the day `i`.
      lakeIdToFullDay[lakeId] = i

    # Empty an arbitrary lake if there are remaining empty days.
    for emptyDay in emptyDays:
      ans[emptyDay] = 1

    return ans"
"1489","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: list[list[int]]) -> list[list[int]]:
    criticalEdges = []
    pseudoCriticalEdges = []

    # Record the index information, so edges[i] := (u, v, weight, index).
    for i in range(len(edges)):
      edges[i].append(i)

    # Sort by the weight.
    edges.sort(key=lambda x: x[2])

    def getMSTWeight(
            firstEdge: list[int],
            deletedEdgeIndex: int) -> int | float:
      mstWeight = 0
      uf = UnionFind(n)

      if firstEdge:
        uf.unionByRank(firstEdge[0], firstEdge[1])
        mstWeight += firstEdge[2]

      for u, v, weight, index in edges:
        if index == deletedEdgeIndex:
          continue
        if uf.find(u) == uf.find(v):
          continue
        uf.unionByRank(u, v)
        mstWeight += weight

      root = uf.find(0)
      if any(uf.find(i) != root for i in range(n)):
        return math.inf

      return mstWeight

    mstWeight = getMSTWeight([], -1)

    for edge in edges:
      index = edge[3]
      # Deleting the `edge` increases the weight of the MST or makes the MST
      # invalid.
      if getMSTWeight([], index) > mstWeight:
        criticalEdges.append(index)
      # If an edge can be in any MST, we can always add `edge` to the edge set.
      elif getMSTWeight(edge, -1) == mstWeight:
        pseudoCriticalEdges.append(index)

    return [criticalEdges, pseudoCriticalEdges]"
"149","class Solution:
  def maxPoints(self, points: list[list[int]]) -> int:
    ans = 0

    def gcd(a: int, b: int) -> int:
      return a if b == 0 else gcd(b, a % b)

    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:
      dx = p[0] - q[0]
      dy = p[1] - q[1]
      if dx == 0:
        return (0, p[0])
      if dy == 0:
        return (p[1], 0)
      d = gcd(dx, dy)
      return (dx // d, dy // d)

    for i, p in enumerate(points):
      slopeCount = collections.defaultdict(int)
      samePoints = 1
      maxPoints = 0  # the maximum number of points with the same slope
      for j in range(i + 1, len(points)):
        q = points[j]
        if p == q:
          samePoints += 1
        else:
          slope = getSlope(p, q)
          slopeCount[slope] += 1
          maxPoints = max(maxPoints, slopeCount[slope])
      ans = max(ans, samePoints + maxPoints)

    return ans"
"1490","class Solution {
  public Node cloneTree(Node root) {
    if (root == null)
      return null;
    if (map.containsKey(root))
      return map.get(root);

    Node newNode = new Node(root.val);
    map.put(root, newNode);

    for (Node child : root.children)
      newNode.children.add(cloneTree(child));

    return newNode;
  }

  private Map<Node, Node> map = new HashMap<>();
}"
"1491","class Solution:
  def average(self, salary: list[int]) -> float:
    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)"
"1492","class Solution:
  def kthFactor(self, n: int, k: int) -> int:
    # If i is a divisor of n, then n // i is also a divisor of n. So, we can
    # find all the divisors of n by processing the numbers <= sqrt(n).
    factor = 1
    i = 0  # the i-th factor

    while factor < math.isqrt(n):
      if n % factor == 0:
        i += 1
        if i == k:
          return factor
      factor += 1

    factor = n // factor
    while factor >= 1:
      if n % factor == 0:
        i += 1
        if i == k:
          return n // factor
      factor -= 1

    return -1"
"1493","class Solution:
  def longestSubarray(self, nums: list[int]) -> int:
    ans = 0
    zeros = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        zeros += 1
      while zeros == 2:
        if nums[l] == 0:
          zeros -= 1
        l += 1
      ans = max(ans, r - l)

    return ans"
"1494","class Solution:
  def minNumberOfSemesters(
      self,
      n: int,
      relations: list[list[int]],
      k: int,
  ) -> int:
    # dp[i] := the minimum number of semesters to take the courses, where i is
    # the bitmask of the taken courses
    dp = [n] * (1 << n)
    # prereq[i] := bitmask of all dependencies of course i
    prereq = [0] * n

    for prevCourse, nextCourse in relations:
      prereq[nextCourse - 1] |= 1 << prevCourse - 1

    dp[0] = 0  # Don't need time to finish 0 course.

    for i in range(1 << n):
      # the bitmask of all the courses can be taken
      coursesCanBeTaken = 0
      # Can take the j-th course if i contains all of j's prerequisites.
      for j in range(n):
        if (i & prereq[j]) == prereq[j]:
          coursesCanBeTaken |= 1 << j
      # Don't take any course which is already taken.
      # (i represents set of courses that are already taken)
      coursesCanBeTaken &= ~i
      # Enumerate every bitmask subset of `coursesCanBeTaken`.
      s = coursesCanBeTaken
      while s:
        if s.bit_count() <= k:
          # Any combination of courses (if <= k) can be taken now.
          # i | s := combining courses taken with courses can be taken.
          dp[i | s] = min(dp[i | s], dp[i] + 1)
        s = (s - 1) & coursesCanBeTaken

    return dp[-1]"
"1495","SELECT DISTINCT Content.title
FROM Content
INNER JOIN TVProgram
  USING (content_id)
WHERE
  Content.kids_content = 'Y'
  AND Content.content_type = 'Movies'
  AND DATE_FORMAT(TVProgram.program_date, '%Y-%m') = '2020-06';"
"1496","class Solution {
 public:
  bool isPathCrossing(string path) {
    set<int> seen;

    seen.insert(0);

    int x = 0;
    int y = 0;

    for (const char c : path) {
      switch (c) {
        case 'N':
          ++y;
          break;
        case 'S':
          --y;
          break;
        case 'E':
          ++x;
          break;
        case 'W':
          --x;
          break;
      }
      const int key = x * 20001 + y;
      if (seen.contains(key))
        return true;
      seen.insert(key);
    }

    return false;
  }
};"
"1497","class Solution:
  def canArrange(self, arr: list[int], k: int) -> bool:
    count = [0] * k

    for a in arr:
      a %= k
      count[a if a >= 0 else a + k] += 1

    return (count[0] % 2 == 0 and
            all(count[i] == count[k - i]
                for i in range(1, k // 2 + 1)))"
"1498","class Solution:
  def numSubseq(self, nums: list[int], target: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0

    nums.sort()

    l = 0
    r = n - 1
    while l <= r:
      if nums[l] + nums[r] <= target:
        ans += pow(2, r - l, kMod)
        l += 1
      else:
        r -= 1

    return ans % kMod"
"1499","class Solution:
  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:
    ans = -math.inf
    maxQ = collections.deque()  # (y - x, x)

    for x, y in points:
      # Remove the invalid points, xj - xi > k
      while maxQ and x - maxQ[0][1] > k:
        maxQ.popleft()
      if maxQ:
        ans = max(ans, x + y + maxQ[0][0])
      # Remove the points that contribute less value and have a bigger x.
      while maxQ and y - x >= maxQ[-1][0]:
        maxQ.pop()
      maxQ.append((y - x, x))

    return ans"
"15","class Solution:
  def threeSum(self, nums: list[int]) -> list[list[int]]:
    if len(nums) < 3:
      return []

    ans = []

    nums.sort()

    for i in range(len(nums) - 2):
      if i > 0 and nums[i] == nums[i - 1]:
        continue
      # Choose nums[i] as the first number in the triplet, then search the
      # remaining numbers in [i + 1, n - 1].
      l = i + 1
      r = len(nums) - 1
      while l < r:
        summ = nums[i] + nums[l] + nums[r]
        if summ == 0:
          ans.append((nums[i], nums[l], nums[r]))
          l += 1
          r -= 1
          while nums[l] == nums[l - 1] and l < r:
            l += 1
          while nums[r] == nums[r + 1] and l < r:
            r -= 1
        elif summ < 0:
          l += 1
        else:
          r -= 1

    return ans"
"150","class Solution:
  def evalRPN(self, tokens: list[str]) -> int:
    stack = []
    op = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: int(a / b),
    }

    for token in tokens:
      if token in op:
        b = stack.pop()
        a = stack.pop()
        stack.append(op[token](a, b))
      else:
        stack.append(int(token))

    return stack.pop()"
"1500","from sortedcontainers import SortedSet


class FileSharing:
  def __init__(self, m: int):
    self.userToChunks: dict[int, SortedSet[int]] = {}
    self.chunkToUsers: dict[int, SortedSet[int]] = {}
    self.availableUserIds: list[int] = []

  def join(self, ownedChunks: list[int]) -> int:
    userId = (heapq.heappop(self.availableUserIds) if self.availableUserIds
              else len(self.userToChunks) + 1)
    self.userToChunks[userId] = SortedSet(ownedChunks)
    for chunk in ownedChunks:
      self.chunkToUsers.setdefault(chunk, SortedSet()).add(userId)
    return userId

  def leave(self, userID: int) -> None:
    if userID not in self.userToChunks:
      return
    for chunk in self.userToChunks[userID]:
      self.chunkToUsers[chunk].discard(userID)
      if not self.chunkToUsers[chunk]:
        del self.chunkToUsers[chunk]
    del self.userToChunks[userID]
    heapq.heappush(self.availableUserIds, userID)

  def request(self, userID: int, chunkID: int) -> list[int]:
    if chunkID not in self.chunkToUsers:
      return []
    userIds = list(self.chunkToUsers[chunkID])
    self.userToChunks[userID].add(chunkID)
    self.chunkToUsers[chunkID].add(userID)
    return userIds"
"1501","SELECT Country.name AS country
FROM Person
INNER JOIN Country
  ON (SUBSTRING(Person.phone_number, 1, 3) = Country.country_code)
INNER JOIN Calls
  ON (Person.id IN (Calls.caller_id, Calls.callee_id))
GROUP BY 1
HAVING AVG(Calls.duration) > (
    SELECT AVG(duration) FROM Calls
  );"
"1502","class Solution {
 public:
  bool canMakeArithmeticProgression(vector<int>& arr) {
    const int n = arr.size();
    const int mx = ranges::max(arr);
    const int mn = ranges::min(arr);
    const int range = mx - mn;
    if (range % (n - 1) != 0)
      return false;
    const int diff = range / (n - 1);
    if (diff == 0)
      return true;

    for (int i = 0; i < n;) {
      const int gap = arr[i] - mn;
      if (gap % diff != 0)
        return false;
      if (gap == i * diff) {
        ++i;
      } else {
        const int rightIndex = gap / diff;
        swap(arr[i], arr[rightIndex]);
      }
    }

    return true;
  }
};"
"1503","class Solution {
 public:
  int getLastMoment(int n, vector<int>& left, vector<int>& right) {
    const int maxLeft = left.empty() ? 0 : ranges::max(left);
    const int minRight = right.empty() ? n : ranges::min(right);
    return max(maxLeft, n - minRight);
  }
};"
"1504","class Solution:
  def numSubmat(self, mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0

    for baseRow in range(m):
      row = [1] * n
      for i in range(baseRow, m):
        for j in range(n):
          row[j] &= mat[i][j]
        ans += self._count(row)

    return ans

  def _count(self, row: list[int]) -> int:
    res = 0
    length = 0
    for num in row:
      length = 0 if num == 0 else length + 1
      res += length
    return res"
"1505","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void add(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  string minInteger(string num, int k) {
    const int n = num.length();
    string ans;
    FenwickTree tree(n);
    vector<bool> used(n);
    vector<queue<int>> numToIndices(10);

    for (int i = 0; i < n; ++i)
      numToIndices[num[i] - '0'].push(i);

    while (k > 0 && ans.length() < n)
      for (int d = 0; d < 10; ++d) {
        if (numToIndices[d].empty())
          continue;
        const int i = numToIndices[d].front();
        const int cost = i - tree.get(i);
        if (cost > k)
          continue;
        k -= cost;
        ans += '0' + d;
        used[i] = true;
        tree.add(i + 1, 1);
        numToIndices[d].pop();
        break;  // Scan from 0 -> 9 again.
      }

    for (int i = 0; i < n; ++i)
      if (!used[i])
        ans += num[i];

    return ans;
  }
};"
"1506","class Solution:
  def findRoot(self, tree: list['Node']) -> 'Node':
    sum = 0

    for node in tree:
      sum ^= node.val
      for child in node.children:
        sum ^= child.val

    for node in tree:
      if node.val == sum:
        return node"
"1507","class Solution:
  def reformatDate(self, date: str) -> str:
    monthToNumString = {
        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',
    }
    day, month, year = date.split()
    day = day[:-2] if len(day) == 4 else '0' + day[:-2]
    return f'{year}-{monthToNumString[month]}-{day}'"
"1508","class Solution {
 public:
  int rangeSum(vector<int>& nums, int n, int left, int right) {
    constexpr int kMod = 1'000'000'007;

    auto subarraysAndSumNoGreaterThan = [&](int m) -> pair<int, long> {
      int count = 0;   // the number of subarrays <= m
      long total = 0;  // sum(subarrays)
      int sum = 0;     // the current sum
      int window = 0;  // the window sum

      for (int i = 0, j = 0; j < n; ++j) {
        sum += nums[j] * (j - i + 1);
        window += nums[j];  // Extend each subarray that ends in j.
        while (window > m) {
          sum -= window;
          window -= nums[i++];  // Shrink the window.
        }
        count += j - i + 1;
        total += sum;
      }

      return {count, total};
    };

    // [L, R] is the possible range of the sum of any subarray.
    const int L = ranges::min(nums);
    const int R = accumulate(nums.begin(), nums.end(), 0);

    auto firstKSubarraysSum = [&](int k) -> long {
      int l = L;
      int r = R;

      while (l < r) {
        const int m = l + (r - l) / 2;
        if (subarraysAndSumNoGreaterThan(m).first < k)
          l = m + 1;
        else
          r = m;
      }

      const auto& [count, total] = subarraysAndSumNoGreaterThan(l);
      // If count != k, there're subarray(s) have the same sum as l.
      return total - l * (count - k);
    };

    return (firstKSubarraysSum(right) - firstKSubarraysSum(left - 1)) % kMod;
  }
};"
"1509","class Solution:
  def minDifference(self, nums: list[int]) -> int:
    n = len(nums)
    if n < 5:
      return 0

    ans = math.inf

    nums.sort()

    # 1. Change nums[0..i) to nums[i].
    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].
    for i in range(4):
      ans = min(ans, nums[n - 4 + i] - nums[i])

    return ans"
"151","class Solution:
  def reverseWords(self, s: str) -> str:
    return ' '.join(reversed(s.split()))"
"1510","class Solution {
 public:
  bool winnerSquareGame(int n) {
    // dp[i] := the winning result for n = i
    vector<bool> dp(n + 1);

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        if (!dp[i - j * j]) {  // Removing j^2 stones make the opponent lose.
          dp[i] = true;        // So, we win.
          break;
        }

    return dp[n];
  }
};"
"1511","SELECT
  Customers.customer_id,
  Customers.name
FROM Customers
INNER JOIN Orders
  USING (customer_id)
INNER JOIN Product
  USING (product_id)
GROUP BY 1
HAVING
  SUM(
    IF(
      DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-06',
      Orders.quantity * price,
      0
    )
  ) >= 100
  AND SUM(
    IF(
      DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-07',
      Orders.quantity * price,
      0
    )
  ) >= 100;"
"1512","class Solution {
 public:
  int numIdenticalPairs(vector<int>& nums) {
    int ans = 0;
    vector<int> count(101);

    for (const int num : nums)
      ans += count[num]++;

    return ans;
  }
};"
"1513","class Solution {
 public:
  int numSub(string s) {
    constexpr int kMod = 1'000'000'007;

    int ans = 0;
    int l = -1;

    for (int i = 0; i < s.length(); ++i) {
      if (s[i] == '0')
        l = i;  // Handle the reset value.
      ans = (ans + i - l) % kMod;
    }

    return ans;
  }
};"
"1514","class Solution:
  def maxProbability(
      self,
      n: int,
      edges: list[list[int]],
      succProb: list[float],
      start: int,
      end: int,
  ) -> float:
    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}
    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)
    seen = [False] * n

    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):
      graph[u].append((v, prob))
      graph[v].append((u, prob))

    while maxHeap:
      prob, u = heapq.heappop(maxHeap)
      prob *= -1
      if u == end:
        return prob
      if seen[u]:
        continue
      seen[u] = True
      for nextNode, edgeProb in graph[u]:
        if seen[nextNode]:
          continue
        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))

    return 0"
"1515","class Solution:
  def getMinDistSum(self, positions: list[list[int]]) -> float:
    def distSum(a: float, b: float) -> float:
      return sum(math.sqrt((a - x)**2 + (b - y)**2)
                 for x, y in positions)

    kErr = 1e-6
    currX = 50
    currY = 50
    ans = distSum(currX, currY)
    step = 1

    while step > kErr:
      shouldDecreaseStep = True
      for dx, dy in [(0, step), (0, -step), (step, 0), (-step, 0)]:
        x = currX + dx
        y = currY + dy
        newDistSum = distSum(x, y)
        if newDistSum < ans:
          ans = newDistSum
          currX = x
          currY = y
          shouldDecreaseStep = False
      if shouldDecreaseStep:
        step /= 10

    return ans"
"1516","class Solution:
  def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
    if p in q.children:
      return root

    # Create a dummy Node for the case when root == p
    dummy = Node(None, [root])

    # Get each parent of p and q
    pParent = self._getParent(dummy, p)
    qParent = self._getParent(p, q)

    # Get p's original index in p's parent
    pIndex = pParent.children.index(p)
    pParent.children.pop(pIndex)

    q.children.append(p)

    # If q is in the p's subtree, qParent != None
    if qParent:
      qParent.children.remove(q)
      pParent.children.insert(pIndex, q)

    return dummy.children[0]

  def _getParent(self, root: 'Node', target: 'Node') -> Optional['Node']:
    for child in root.children:
      if child == target:
        return root
      res = self._getParent(child, target)
      if res:
        return res
    return None"
"1517","SELECT *
FROM Users
WHERE REGEXP_LIKE(mail, '^[A-Za-z]+[A-Za-z0-9\_\.\-]*@leetcode\\.com$');"
"1518","class Solution {
 public:
  int numWaterBottles(int numBottles, int numExchange) {
    return numBottles + (numBottles - 1) / (numExchange - 1);
  }
};"
"1519","class Solution {
  public int[] countSubTrees(int n, int[][] edges, String labels) {
    int[] ans = new int[n];
    List<Integer>[] graph = new List[n];

    for (int i = 0; i < n; ++i)
      graph[i] = new ArrayList<>();

    for (int[] edge : edges) {
      final int u = edge[0];
      final int v = edge[1];
      graph[u].add(v);
      graph[v].add(u);
    }

    dfs(graph, 0, -1, labels, ans);
    return ans;
  }

  private int[] dfs(List<Integer>[] graph, int u, int prev, final String labels, int[] ans) {
    // count[i] := the number of letters down from ('a' + i)
    int[] count = new int[26];

    for (final int v : graph[u]) {
      if (v == prev)
        continue;
      int[] childCount = dfs(graph, v, u, labels, ans);
      for (int i = 0; i < 26; ++i)
        count[i] += childCount[i];
    }

    ans[u] = ++count[labels.charAt(u) - 'a']; // the u itself
    return count;
  }
}"
"152","class Solution:
  def maxProduct(self, nums: list[int]) -> int:
    ans = nums[0]
    dpMin = nums[0]  # the minimum so far
    dpMax = nums[0]  # the maximum so far

    for i in range(1, len(nums)):
      num = nums[i]
      prevMin = dpMin  # dpMin[i - 1]
      prevMax = dpMax  # dpMax[i - 1]
      if num < 0:
        dpMin = min(prevMax * num, num)
        dpMax = max(prevMin * num, num)
      else:
        dpMin = min(prevMin * num, num)
        dpMax = max(prevMax * num, num)

      ans = max(ans, dpMax)

    return ans"
"1520","class Solution {
 public:
  vector<string> maxNumOfSubstrings(string s) {
    const int n = s.length();
    vector<string> ans;
    // leftmost[i] := the leftmost index of ('a' + i)
    vector<int> leftmost(26, n);
    // rightmost[i] := the rightmost index of ('a' + i)
    vector<int> rightmost(26, -1);

    for (int i = 0; i < n; ++i) {
      leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);
      rightmost[s[i] - 'a'] = i;
    }

    auto getNewRight = [&](int i) {
      int right = rightmost[s[i] - 'a'];
      for (int j = i; j <= right; ++j) {
        if (leftmost[s[j] - 'a'] < i)  // Find a letter's leftmost index < i.
          return -1;
        // Expand the right dynamically.
        right = max(right, rightmost[s[j] - 'a']);
      }
      return right;
    };

    int right = -1;  // the rightmost index of the last substring
    for (int i = 0; i < n; ++i) {
      // the current index is the first appearance
      if (i == leftmost[s[i] - 'a']) {
        const int newRight = getNewRight(i);
        if (newRight == -1)
          continue;  // Find a letter's leftmost index < i.
        if (i <= right && !ans.empty())
          ans.back() = s.substr(i, newRight - i + 1);
        else
          ans.push_back(s.substr(i, newRight - i + 1));
        right = newRight;
      }
    }

    return ans;
  }
};"
"1521","class Solution:
  def closestToTarget(self, arr: list[int], target: int) -> int:
    ans = math.inf
    dp = set()  # all the values of subarrays that end in the current number

    for num in arr:
      # Extend each subarray that ends in the dpious number. Due to
      # monotonicity of the AND operation, the size of `dp` will be at most
      # num.bit_count() + 1.
      dp = {num} | {val & num for val in dp}
      ans = min(ans, min(abs(target - val) for val in dp))

    return ans"
"1522","class Solution:
  def diameter(self, root: 'Node') -> int:
    ans = 0

    def maxDepth(root: 'Node') -> int:
      """"""Returns the maximum depth of the subtree rooted at `root`.""""""
      nonlocal ans
      maxSubDepth1 = 0
      maxSubDepth2 = 0
      for child in root.children:
        maxSubDepth = maxDepth(child)
        if maxSubDepth > maxSubDepth1:
          maxSubDepth2 = maxSubDepth1
          maxSubDepth1 = maxSubDepth
        elif maxSubDepth > maxSubDepth2:
          maxSubDepth2 = maxSubDepth
      ans = max(ans, maxSubDepth1 + maxSubDepth2)
      return 1 + maxSubDepth1

    maxDepth(root)
    return ans"
"1523","class Solution {
 public:
  int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
  }
};"
"1524","class Solution {
 public:
  int numOfSubarrays(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    long dp0 = 0;
    long dp1 = 0;

    for (const int a : arr) {
      if (a % 2 == 1) {
        const int cache = dp0;
        dp0 = dp1;
        dp1 = cache + 1;
      } else {
        ++dp0;
      }
      ans = (ans + dp1) % kMod;
    }

    return ans;
  }
};"
"1525","class Solution:
  def numSplits(self, s: str) -> int:
    n = len(s)
    ans = 0
    seen = set()
    prefix = [0] * n
    suffix = [0] * n

    for i in range(n):
      seen.add(s[i])
      prefix[i] = len(seen)

    seen.clear()

    for i in reversed(range(n)):
      seen.add(s[i])
      suffix[i] = len(seen)

    for i in range(n - 1):
      if prefix[i] == suffix[i + 1]:
        ans += 1

    return ans"
"1526","class Solution:
  def minNumberOperations(self, target: list[int]) -> int:
    ans = target[0]

    for a, b in zip(target, target[1:]):
      if a < b:
        ans += b - a

    return ans"
"1527","SELECT *
FROM Patients
WHERE
  conditions LIKE 'DIAB1%'
  OR conditions LIKE '% DIAB1%';"
"1528","class Solution {
 public:
  string restoreString(string s, vector<int>& indices) {
    string ans(s.length(), '.');

    for (int i = 0; i < indices.size(); ++i)
      ans[indices[i]] = s[i];

    return ans;
  }
};"
"1529","class Solution {
  public int minFlips(String target) {
    int ans = 0;
    int state = 0;

    for (final char c : target.toCharArray())
      if (c - '0' != state) {
        state = c - '0';
        ++ans;
      }

    return ans;
  }
}"
"153","class Solution:
  def findMin(self, nums: list[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] < nums[r]:
        r = m
      else:
        l = m + 1

    return nums[l]"
"1530","class Solution {
 public:
  int countPairs(TreeNode* root, int distance) {
    int ans = 0;

    dfs(root, distance, ans);

    return ans;
  }

 private:
  vector<int> dfs(TreeNode* root, int distance, int& ans) {
    vector<int> d(distance + 1);  // {distance: the number of leaf nodes}
    if (root == nullptr)
      return d;
    if (root->left == nullptr && root->right == nullptr) {
      d[0] = 1;
      return d;
    }

    const vector<int> dl = dfs(root->left, distance, ans);
    const vector<int> dr = dfs(root->right, distance, ans);

    for (int i = 0; i < distance; ++i)
      for (int j = 0; j < distance; ++j)
        if (i + j + 2 <= distance)
          ans += dl[i] * dr[j];

    for (int i = 0; i < distance; ++i)
      d[i + 1] = dl[i] + dr[i];

    return d;
  }
};"
"1531","class Solution:
  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
    def getLength(maxFreq: int) -> int:
      """"""Returns the length to compress `maxFreq`.""""""
      if maxFreq == 1:
        return 1  # c
      if maxFreq < 10:
        return 2  # [1-9]c
      if maxFreq < 100:
        return 3  # [1-9][0-9]c
      return 4    # [1-9][0-9][0-9]c

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""Returns the length of optimal dp of s[i..n) with at most k deletion.""""""
      if k < 0:
        return math.inf
      if i == len(s) or len(s) - i <= k:
        return 0

      ans = math.inf
      maxFreq = 0  # the maximum frequency in s[i..j]
      count = collections.Counter()

      # Make letters in s[i..j] be the same.
      # Keep the letter that has the maximum frequency in this range and remove
      # the other letters.
      for j in range(i, len(s)):
        count[s[j]] += 1
        maxFreq = max(maxFreq, count[s[j]])
        ans = min(ans, getLength(maxFreq) +
                  dp(j + 1, k - (j - i + 1 - maxFreq)))

      return ans

    return dp(0, k)"
"1532","WITH
  OrdersWithRowNumber AS (
    SELECT
      order_id,
      order_date,
      customer_id,
      ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY order_date DESC
      ) AS `row_number`
    FROM Orders
  )
SELECT
  Customers.name AS customer_name,
  Customers.customer_id,
  OrdersWithRowNumber.order_id,
  OrdersWithRowNumber.order_date
FROM OrdersWithRowNumber
INNER JOIN Customers
  USING (customer_id)
WHERE `row_number` <= 3
ORDER BY customer_name, customer_id, order_date DESC;"
"1533","# """"""
# This is ArrayReader's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# class ArrayReader(object):
# # Compares the sum of arr[l..r] with the sum of arr[x..y]
# # return 1 if sum(arr[l..r]) > sum(arr[x..y])
# # return 0 if sum(arr[l..r]) == sum(arr[x..y])
# # return -1 if sum(arr[l..r]) < sum(arr[x..y])
#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:
#
# # Returns the length of the array
#   def length(self) -> int:
#


class Solution:
  def getIndex(self, reader: 'ArrayReader') -> int:
    l = 0
    r = reader.length() - 1

    while l < r:
      m = (l + r) // 2
      res = (reader.compareSub(l, m, m + 1, r) if (r - l + 1) % 2 == 0
             else reader.compareSub(l, m, m, r))
      if res == -1:
        l = m + 1
      else:  # res == 1 or res == 0
        r = m

    return l"
"1534","class Solution:
  def countGoodTriplets(self, arr: list[int], a: int, b: int, c: int) -> int:
    return sum(abs(arr[i] - arr[j]) <= a and
               abs(arr[j] - arr[k]) <= b and
               abs(arr[i] - arr[k]) <= c
               for i in range(len(arr))
               for j in range(i + 1, len(arr))
               for k in range(j + 1, len(arr)))"
"1535","class Solution:
  def getWinner(self, arr: list[int], k: int) -> int:
    ans = arr[0]
    wins = 0

    i = 1
    while i < len(arr) and wins < k:
      if arr[i] > ans:
        ans = arr[i]
        wins = 1
      else:
        wins += 1
      i += 1

    return ans"
"1536","class Solution:
  def minSwaps(self, grid: list[list[int]]) -> int:
    n = len(grid)
    ans = 0
    # suffixZeros[i] := the number of suffix zeros in the i-th row
    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]

    for i in range(n):
      neededZeros = n - 1 - i
      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).
      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)
      if j == -1:
        return -1
      # Move the rows[j] to the rows[i].
      for k in range(j, i, -1):
        suffixZeros[k] = suffixZeros[k - 1]
      ans += j - i

    return ans"
"1537","class Solution:
  def maxSum(self, nums1: list[int], nums2: list[int]) -> int:
    # Keep the running the sum of `nums1` and `nums2` before the next rendezvous.
    # Since `nums1` and `nums2` are increasing, move forward on the smaller one
    # to ensure we don't miss any rendezvous. When meet rendezvous, choose the
    # better path.
    ans = 0
    sum1 = 0  # sum(nums1) in (the prevoious rendezvous, the next rendezvous)
    sum2 = 0  # sum(nums2) in (the prevoious rendezvous, the next rendezvous)
    i = 0  # nums1's index
    j = 0  # nums2's index

    while i < len(nums1) and j < len(nums2):
      if nums1[i] < nums2[j]:
        sum1 += nums1[i]
        i += 1
      elif nums1[i] > nums2[j]:
        sum2 += nums2[j]
        j += 1
      else:  # An rendezvous happens.
        ans += max(sum1, sum2) + nums1[i]
        sum1 = 0
        sum2 = 0
        i += 1
        j += 1

    while i < len(nums1):
      sum1 += nums1[i]
      i += 1

    while j < len(nums2):
      sum2 += nums2[j]
      j += 1

    return (ans + max(sum1, sum2)) % (10**9 + 7)"
"1538","# """"""
# This is the ArrayReader's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# class ArrayReader(object):
#   # Compares 4 different elements in the array
#   # Returns 4 if the values of the 4 elements are the same (0 or 1).
#   # Returns 2 if three elements have a value equal to 0 and one element has
#   #           value equal to 1 or vice versa.
#   # Returns 0 if two element have a value equal to 0 and two elements have a
#   #           value equal to 1.
#   def query(self, a: int, b: int, c: int, d: int) -> int:
#
#   # Returns the length of the array
#   def length(self) -> int:
#

class Solution:
  def guessMajority(self, reader: 'ArrayReader') -> int:
    n = reader.length()
    query0123 = reader.query(0, 1, 2, 3)
    query1234 = reader.query(1, 2, 3, 4)
    zeros = 1  # the number of numbers that are same as `nums[0]`
    nonZeros = 0  # the number of numbers that are different from `nums[0]`
    indexNot0 = -1  # any index i s.t. nums[i] != nums[0]

    # Find which group nums[1..3] belong to.
    for i in range(1, 4):
      abcd = [0] + [num for num in [1, 2, 3] if num != i] + [4]
      if reader.query(*abcd) == query1234:  # nums[i] == nums[0]
        zeros += 1
      else:
        nonZeros += 1
        indexNot0 = i

    # Find which group nums[4..n) belong to.
    for i in range(4, n):
      if reader.query(1, 2, 3, i) == query0123:  # nums[i] == nums[0]
        zeros += 1
      else:
        nonZeros += 1
        indexNot0 = i

    if zeros == nonZeros:
      return -1
    if zeros > nonZeros:
      return 0
    return indexNot0"
"1539","class Solution {
  public int findKthPositive(int[] arr, int k) {
    int l = 0;
    int r = arr.length;

    // Find the first index l s.t. nMissing(l) = A[l] - l - 1 >= k.
    while (l < r) {
      final int m = (l + r) / 2;
      if (arr[m] - m - 1 >= k)
        r = m;
      else
        l = m + 1;
    }

    // The k-th missing positive
    // = A[l - 1] + k - nMissing(l - 1)
    // = A[l - 1] + k - (A[l - 1] - (l - 1) - 1)
    // = A[l - 1] + k - (A[l - 1] - l)
    // = l + k
    return l + k;
  }
}"
"154","class Solution:
  def findMin(self, nums: list[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] == nums[r]:
        r -= 1
      elif nums[m] < nums[r]:
        r = m
      else:
        l = m + 1

    return nums[l]"
"1540","class Solution:
  def canConvertString(self, s: str, t: str, k: int) -> bool:
    if len(s) != len(t):
      return False

    # e.g. s = ""aab"", t = ""bbc"", so shiftCount[1] = 3
    # 1. a -> b, need 1 move.
    # 2. a -> b, need 1 + 26 moves.
    # 3. b -> c, need 1 + 26 * 2 moves.
    shiftCount = [0] * 26

    for a, b in zip(s, t):
      shiftCount[(ord(b) - ord(a) + 26) % 26] += 1

    for shift in range(1, 26):
      if shift + 26 * (shiftCount[shift] - 1) > k:
        return False

    return True"
"1541","class Solution:
  def minInsertions(self, s: str) -> int:
    neededRight = 0   # Increment by 2 for each '('.
    missingLeft = 0   # Increment by 1 for each missing '('.
    missingRight = 0  # Increment by 1 for each missing ')'.

    for c in s:
      if c == '(':
        if neededRight % 2 == 1:
          # e.g. '()(...'
          missingRight += 1
          neededRight -= 1
        neededRight += 2
      else:  # c == ')'
        neededRight -= 1
        if neededRight < 0:
          # e.g. '()))...'
          missingLeft += 1
          neededRight += 2

    return neededRight + missingLeft + missingRight"
"1542","class Solution:
  def longestAwesome(self, s: str) -> int:
    ans = 0
    prefix = 0  # the binary prefix
    prefixToIndex = [len(s)] * 1024
    prefixToIndex[0] = -1

    for i, c in enumerate(s):
      prefix ^= 1 << int(c)
      ans = max(ans, i - prefixToIndex[prefix])
      for j in range(10):
        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])
      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)

    return ans"
"1543","SELECT
  LOWER(TRIM(product_name)) AS product_name,
  DATE_FORMAT(sale_date, '%Y-%m') AS sale_date,
  COUNT(*) AS total
FROM Sales
GROUP BY 1, 2
ORDER BY 1, 2;"
"1544","class Solution:
  def makeGood(self, s: str) -> str:
    ans = []
    for c in s:
      if ans and self._is_bad_pair(ans[-1], c):
        ans.pop()
      else:
        ans.append(c)
    return ''.join(ans)

  def _is_bad_pair(self, a: str, b: str) -> bool:
    return a != b and a.lower() == b.lower()"
"1545","class Solution:
  def findKthBit(self, n: int, k: int) -> str:
    if n == 1:
      return '0'
    midIndex = pow(2, n - 1)  # 1-indexed
    if k == midIndex:
      return '1'
    if k < midIndex:
      return self.findKthBit(n - 1, k)
    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'"
"1546","class Solution:
  def maxNonOverlapping(self, nums: list[int], target: int) -> int:
    # Ending the subarray ASAP always has a better result.
    ans = 0
    prefix = 0
    prefixes = {0}

    # Greedily find the subarrays that equal to the target.
    for num in nums:
      # Check if there is a subarray ends in here and equals to the target.
      prefix += num
      if prefix - target in prefixes:
        # Find one and discard all the prefixes that have been used.
        ans += 1
        prefix = 0
        prefixes = {0}
      else:
        prefixes.add(prefix)

    return ans"
"1547","class Solution:
  def minCost(self, n: int, cuts: list[int]) -> int:
    A = sorted([0] + cuts + [n])

    dp = [[0] * len(A) for _ in range(len(A))]

    for d in range(2, len(A)):
      for i in range(len(A) - d):
        j = i + d
        dp[i][j] = math.inf
        for k in range(i + 1, j):
          dp[i][j] = min(dp[i][j], A[j] - A[i] + dp[i][k] + dp[k][j])

    return dp[0][len(A) - 1]"
"1548","class Solution:
  def mostSimilar(self, n: int, roads: list[list[int]], names: list[str],
                  targetPath: list[str]) -> list[int]:
    # cost[i][j] := the minimum cost to start from names[i] in path[j]
    cost = [[-1] * len(targetPath) for _ in range(len(names))]
    # next[i][j] := the best next of names[i] in path[j]
    next = [[0] * len(targetPath) for _ in range(len(names))]
    graph = [[] for _ in range(n)]

    for u, v in roads:
      graph[u].append(v)
      graph[v].append(u)

    minDist = math.inf
    start = 0

    def dfs(nameIndex: int, pathIndex: int) -> int:
      if cost[nameIndex][pathIndex] != -1:
        return cost[nameIndex][pathIndex]

      editDist = names[nameIndex] != targetPath[pathIndex]
      if pathIndex == len(targetPath) - 1:
        return editDist

      minDist = math.inf

      for v in graph[nameIndex]:
        dist = dfs(v, pathIndex + 1)
        if dist < minDist:
          minDist = dist
          next[nameIndex][pathIndex] = v

      cost[nameIndex][pathIndex] = editDist + minDist
      return editDist + minDist

    for i in range(n):
      dist = dfs(i, 0)
      if dist < minDist:
        minDist = dist
        start = i

    ans = []

    while len(ans) < len(targetPath):
      ans.append(start)
      start = next[start][len(ans) - 1]

    return ans"
"1549","WITH
  RankedProducts AS (
    SELECT
      Products.product_name,
      Products.product_id,
      Orders.order_id,
      Orders.order_date,
      RANK() OVER(
        PARTITION BY Products.product_name
        ORDER BY Orders.order_date DESC
      ) `rank`
    FROM Products
    INNER JOIN Orders
      USING (product_id)
  )
SELECT
  RankedProducts.product_name,
  RankedProducts.product_id,
  RankedProducts.order_id,
  RankedProducts.order_date
FROM RankedProducts
WHERE `rank` = 1
ORDER BY 1, 2, 3;"
"155","class MinStack:
  def __init__(self):
    self.stack = []

  def push(self, x: int) -> None:
    mn = x if not self.stack else min(self.stack[-1][1], x)
    self.stack.append([x, mn])

  def pop(self) -> None:
    self.stack.pop()

  def top(self) -> int:
    return self.stack[-1][0]

  def getMin(self) -> int:
    return self.stack[-1][1]"
"1550","class Solution:
  def threeConsecutiveOdds(self, arr: list[int]) -> bool:
    count = 0
    for a in arr:
      count = 0 if a % 2 == 0 else count + 1
      if count == 3:
        return True
    return False"
"1551","class Solution:
  def minOperations(self, n: int) -> int:
    def arr(self, i: int) -> int:
      """"""Returns the i-th element of `arr`, where 1 <= i <= n.""""""
      return (i - 1) * 2 + 1

    #     median := median of arr
    #   diffs[i] := median - arr[i] where i <= i <= n // 2
    #        ans := sum(diffs)
    # e.g.
    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]
    #        ans = (4 + 2) * 2 // 2 = 6
    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]
    #        ans = (5 + 1) * 3 // 2 = 9
    halfSize = n // 2
    median = (arr(n) + arr(1)) // 2
    firstDiff = median - arr(1)
    lastDiff = median - arr(halfSize)
    return (firstDiff + lastDiff) * halfSize // 2"
"1552","class Solution:
  def maxDistance(self, position: list[int], m: int) -> int:
    position.sort()

    l = 1
    r = position[-1] - position[0]

    def numBalls(force: int) -> int:
      balls = 0
      prevPosition = -force
      for pos in position:
        if pos - prevPosition >= force:
          balls += 1
          prevPosition = pos
      return balls

    while l < r:
      mid = r - (r - l) // 2
      if numBalls(mid) >= m:
        l = mid
      else:
        r = mid - 1

    return l"
"1553","class Solution:
  @functools.lru_cache(None)
  def minDays(self, n: int) -> int:
    if n <= 1:
      return n
    return 1 + min(self.minDays(n // 3) + n % 3,
                   self.minDays(n // 2) + n % 2)"
"1554","class Solution:
  def differByOne(self, dict: list[str]) -> bool:
    kBase = 26
    kHash = 1_000_000_007
    m = len(dict[0])

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c)

    def getHash(s: str) -> int:
      """"""Returns the hash of `s`. Assume the length of `s` is m.

      e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].
      """"""
      hash = 0
      for c in s:
        hash = (hash * kBase + val(c))
      return hash

    wordToHash = [getHash(word) for word in dict]

    # Compute the hash without each letter.
    # e.g. hash of ""abc"" = 26^2 * 'a' + 26 * 'b' + 'c'
    #   newHash of ""a*c"" = hash - 26 * 'b'
    coefficient = 1
    for j in range(m - 1, -1, -1):
      newHashToIndices = collections.defaultdict(list)
      for i, (word, hash) in enumerate(zip(dict, wordToHash)):
        newHash = (hash - coefficient * val(word[j]) % kHash + kHash) % kHash
        if any(word[: j] == dict[index][: j] and word[j + 1:] ==
               dict[index][j + 1:] for index in newHashToIndices[newHash]):
          return True
        newHashToIndices[newHash].append(i)
      coefficient = coefficient * kBase % kHash

    return False"
"1555","WITH
  UpdatedUsers AS (
    SELECT
      Users.user_id,
      Users.user_name,
      Users.credit + SUM(
        CASE
          WHEN Users.user_id = Transactions.paid_by THEN -Transactions.amount
          WHEN Users.user_id = Transactions.paid_to THEN Transactions.amount
          ELSE 0
        END
      ) AS credit
    FROM Users
    LEFT JOIN Transactions
      ON (Users.user_id IN (Transactions.paid_by, Transactions.paid_to))
    GROUP BY 1
  )
SELECT
  *,
  IF(credit < 0, 'Yes', 'No') AS credit_limit_breached
FROM UpdatedUsers;"
"1556","class Solution:
  def thousandSeparator(self, n: int) -> str:
    return f'{n:,}'.replace(',', '.')"
"1557","class Solution:
  def findSmallestSetOfVertices(
      self,
      n: int,
      edges: list[list[int]],
  ) -> list[int]:
    inDegrees = [0] * n

    for _, v in edges:
      inDegrees[v] += 1

    return [i for i, d in enumerate(inDegrees) if d == 0]"
"1558","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    mx = max(nums)
    return (sum(num.bit_count() for num in nums) +
            (0 if mx == 0 else mx.bit_length() - 1))"
"1559","class Solution {
 public:
  bool containsCycle(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (seen[i][j])
          continue;
        if (dfs(grid, i, j, -1, -1, grid[i][j], seen))
          return true;
      }

    return false;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  bool dfs(const vector<vector<char>>& grid, int i, int j, int prevI, int prevJ,
           char c, vector<vector<bool>>& seen) {
    seen[i][j] = true;

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (x == prevI && y == prevJ)
        continue;
      if (grid[x][y] != c)
        continue;
      if (seen[x][y])
        return true;
      if (dfs(grid, x, y, i, j, c, seen))
        return true;
    }

    return false;
  }
};"
"156","class Solution:
  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:
    prevRoot = None
    prevRightChild = None

    while root:
      nextRoot = root.left  # Cache the next root.
      root.left = prevRightChild
      prevRightChild = root.right
      root.right = prevRoot
      prevRoot = root  # Record the previous root.
      root = nextRoot  # Update the root.

    return prevRoot"
"1560","class Solution:
  def mostVisited(self, n: int, rounds: list[int]) -> list[int]:
    # 1. if start <= end, [start, end] is the most visited.
    #
    #      s --------- n
    # 1 -------------- n
    # 1 ------ e
    #
    # 2. if start > end, [1, end] and [start, n] are the most visited.
    #
    #             s -- n
    # 1 -------------- n
    # 1 ------ e
    start = rounds[0]
    end = rounds[-1]
    if start <= end:
      return range(start, end + 1)
    return list(range(1, end + 1)) + list(range(start, n + 1))"
"1561","class Solution:
  def maxCoins(self, piles: list[int]) -> int:
    return sum(sorted(piles)[len(piles) // 3::2])"
"1562","class Solution:
  def findLatestStep(self, arr: list[int], m: int) -> int:
    if len(arr) == m:
      return len(arr)

    ans = -1
    step = 0
    # sizes[i] := the size of the group starting from i or ending in i
    # (1-indexed)
    sizes = [0] * (len(arr) + 2)

    for i in arr:
      step += 1
      # In the previous step, there exists a group with a size of m.
      if sizes[i - 1] == m or sizes[i + 1] == m:
        ans = step - 1
      head = i - sizes[i - 1]
      tail = i + sizes[i + 1]
      sizes[head] = tail - head + 1
      sizes[tail] = tail - head + 1

    return ans"
"1563","class Solution {
 public:
  int stoneGameV(vector<int>& stoneValue) {
    const int n = stoneValue.size();
    vector<vector<int>> mem(n, vector<int>(n, INT_MIN));
    vector<int> prefix(n + 1);
    partial_sum(stoneValue.begin(), stoneValue.end(), prefix.begin() + 1);
    return stoneGameV(stoneValue, 0, n - 1, prefix, mem);
  }

 private:
  // Returns the maximum score that Alice can obtain from stoneValue[i..j].
  int stoneGameV(const vector<int>& stoneValue, int i, int j,
                 const vector<int>& prefix, vector<vector<int>>& mem) {
    if (i == j)
      return 0;
    if (mem[i][j] > 0)
      return mem[i][j];

    // Try all the possible partitions.
    for (int p = i; p < j; ++p) {
      // sum(stoneValue[i..p])
      const int leftSum = prefix[p + 1] - prefix[i];
      const int throwRight =
          leftSum + stoneGameV(stoneValue, i, p, prefix, mem);
      // sum(stoneValue[p + 1..j])
      const int rightSum = prefix[j + 1] - prefix[p + 1];
      const int throwLeft =
          rightSum + stoneGameV(stoneValue, p + 1, j, prefix, mem);
      if (leftSum < rightSum)  // Bob throws the right row.
        mem[i][j] = max(mem[i][j], throwRight);
      else if (leftSum > rightSum)  // Bob throws the left row.
        mem[i][j] = max(mem[i][j], throwLeft);
      else  // Alice decides which row to throw.
        mem[i][j] = max({mem[i][j], throwLeft, throwRight});
    }

    return mem[i][j];
  }
};"
"1564","class Solution:
  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:
    realWarehouse = [warehouse[0]]

    for i in range(1, len(warehouse)):
      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))

    boxes.sort()
    i = 0  # boxes' index
    for height in reversed(realWarehouse):
      if i < len(boxes) and boxes[i] <= height:
        i += 1

    return i"
"1565","SELECT
  DATE_FORMAT(order_date, '%Y-%m') AS month,
  COUNT(order_id) AS order_count,
  COUNT(DISTINCT customer_id) AS customer_count
FROM Orders
WHERE invoice > 20
GROUP BY 1;"
"1566","class Solution:
  def containsPattern(self, arr: list[int], m: int, k: int) -> bool:
    count = 0
    for i in range(m, len(arr)):
      count = count + 1 if arr[i] == arr[i - m] else 0
      if count == m * k - m:
        return True
    return False"
"1567","class Solution:
  def getMaxLen(self, nums: list[int]) -> int:
    ans = 0
    # the maximum length of subarrays ending in `num` with a negative product
    neg = 0
    # the maximum length of subarrays ending in `num` with a positive product
    pos = 0

    for num in nums:
      pos = 0 if num == 0 else pos + 1
      neg = 0 if num == 0 or neg == 0 else neg + 1
      if num < 0:
        pos, neg = neg, pos
      ans = max(ans, pos)

    return ans"
"1568","class Solution:
  def minDays(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    def dfs(grid: list[list[int]], i: int, j: int, seen: set[tuple[int, int]]):
      seen.add((i, j))
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if grid[x][y] == 0 or (x, y) in seen:
          continue
        dfs(grid, x, y, seen)

    def disconnected(grid: list[list[int]]) -> bool:
      islandsCount = 0
      seen = set()
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 0 or (i, j) in seen:
            continue
          if islandsCount > 1:
            return True
          islandsCount += 1
          dfs(grid, i, j, seen)
      return islandsCount != 1

    if disconnected(grid):
      return 0

    # Try to remove 1 land.
    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          grid[i][j] = 0
          if disconnected(grid):
            return 1
          grid[i][j] = 1

    # Remove 2 lands.
    return 2"
"1569","class Solution {
  public int numOfWays(int[] nums) {
    comb = generate(nums.length + 1);
    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;
  }

  private static final int kMod = 1_000_000_007;
  // comb[n][k] := C(n, k)
  private List<List<Integer>> comb;

  private int ways(List<Integer> nums) {
    if (nums.size() <= 2)
      return 1;

    List<Integer> left = new ArrayList<>();
    List<Integer> right = new ArrayList<>();

    for (int i = 1; i < nums.size(); ++i)
      if (nums.get(i) < nums.get(0))
        left.add(nums.get(i));
      else
        right.add(nums.get(i));

    long ans = comb.get(nums.size() - 1).get(left.size());
    ans = (ans * ways(left)) % kMod;
    ans = (ans * ways(right)) % kMod;
    return (int) ans;
  }

  // Same as 118. Pascal's Triangle
  public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> comb = new ArrayList<>();

    for (int i = 0; i < numRows; ++i) {
      Integer[] temp = new Integer[i + 1];
      Arrays.fill(temp, 1);
      comb.add(Arrays.asList(temp));
    }

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < comb.get(i).size() - 1; ++j)
        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);

    return comb;
  }
}"
"157","""""""
The read4 API is already defined for you.
  def read4(buf4: list[str]) -> int:

# Below is an example of how the read4 API can be called.
file = File(""abcdefghijk"") # File is ""abcdefghijk"", initially file pointer (fp) points to 'a'
buf4 = [' '] * 4 # Create buffer with enough space to store characters
read4(buf4) # Read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'
read4(buf4) # Read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'
read4(buf4) # Read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file
""""""


class Solution:
  def read(self, buf: list[str], n: int) -> int:
    buf4 = [' '] * 4
    i4 = 0  # buf4's index
    n4 = 0  # buf4's size
    i = 0  # buf's index

    while i < n:
      if i4 == n4:  # All the characters in the buf4 are consumed.
        i4 = 0  # Reset the buf4's index.
        n4 = read4(buf4)  # Read <= 4 characters from the file to the buf4.
        if n4 == 0:  # Reach the EOF.
          return i
      buf[i] = buf4[i4]
      i += 1
      i4 += 1

    return i"
"1570","class SparseVector {
  SparseVector(int[] nums) {
    for (int i = 0; i < nums.length; ++i)
      if (nums[i] != 0)
        v.add(new T(i, nums[i]));
  }

  // Returns the dot product of the two sparse vectors.
  public int dotProduct(SparseVector vec) {
    int ans = 0;

    for (int i = 0, j = 0; i < v.size() && j < vec.v.size();)
      if (v.get(i).index == vec.v.get(j).index)
        ans += v.get(i++).num * vec.v.get(j++).num;
      else if (v.get(i).index < vec.v.get(j).index)
        ++i;
      else
        ++j;

    return ans;
  }

  private record T(int index, int num) {}
  private List<T> v = new ArrayList<>(); // [(index, num)]
}"
"1571","SELECT
  Warehouse.name AS warehouse_name,
  SUM(
    Warehouse.units * Products.width * Products.length * Products.height
  ) AS volume
FROM Warehouse
INNER JOIN Products
  USING (product_id)
GROUP BY 1;"
"1572","class Solution:
  def diagonalSum(self, mat: list[list[int]]) -> int:
    n = len(mat)
    ans = 0

    for i in range(n):
      ans += mat[i][i]
      ans += mat[n - 1 - i][i]

    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]"
"1573","class Solution:
  def numWays(self, s: str) -> int:
    kMod = 1_000_000_007
    ones = s.count('1')
    if ones % 3 != 0:
      return 0
    if ones == 0:
      n = len(s)
      return (n - 1) * (n - 2) // 2 % kMod

    s1End = -1
    s2Start = -1
    s2End = -1
    s3Start = -1
    onesSoFar = 0

    for i, c in enumerate(s):
      if c == '1':
        onesSoFar += 1
      if s1End == -1 and onesSoFar == ones // 3:
        s1End = i
      elif s2Start == -1 and onesSoFar == ones // 3 + 1:
        s2Start = i
      if s2End == -1 and onesSoFar == ones // 3 * 2:
        s2End = i
      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:
        s3Start = i

    return (s2Start - s1End) * (s3Start - s2End) % kMod"
"1574","class Solution:
  def findLengthOfShortestSubarray(self, arr: list[int]) -> int:
    n = len(arr)
    l = 0
    r = n - 1

    # arr[0..l] is non-decreasing.
    while l < n - 1 and arr[l + 1] >= arr[l]:
      l += 1
    # arr[r..n - 1] is non-decreasing.
    while r > 0 and arr[r - 1] <= arr[r]:
      r -= 1
    # Remove arr[l + 1..n - 1] or arr[0..r - 1].
    ans = min(n - 1 - l, r)

    # Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers
    # at the rightmost indices, l and n - 1, and greedily shrink them toward
    # the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],
    # we ensure that `arr` becomes non-decreasing.
    i = l
    j = n - 1
    while i >= 0 and j >= r and j > i:
      if arr[i] <= arr[j]:
        j -= 1
      else:
        i -= 1
      ans = min(ans, j - i)

    return ans"
"1575","class Solution:
  def countRoutes(
      self,
      locations: list[int],
      start: int,
      finish: int,
      fuel: int,
  ) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, fuel: int) -> int:
      """"""
      Returns the number of ways to reach the `finish` city from the i-th city
      with `fuel` fuel.
      """"""
      if fuel < 0:
        return 0

      res = 1 if i == finish else 0
      for j in range(len(locations)):
        if j == i:
          continue
        res += dp(j, fuel - abs(locations[i] - locations[j]))
        res %= kMod

      return res

    return dp(start, fuel)"
"1576","class Solution:
  def modifyString(self, s: str) -> str:
    ans = []

    def nextAvailable(ans: list[int], s: str, i: int) -> str:
      c = 'a'
      while ((i > 0 and ans[i - 1] == c) or
             (i + 1 < len(s) and c == s[i + 1])):
        c = chr(ord(c) + 1)
      return c

    for i, c in enumerate(s):
      if c == '?':
        ans.append(nextAvailable(ans, s, i))
      else:
        ans.append(c)

    return ''.join(ans)"
"1577","class Solution:
  def numTriplets(self, nums1: list[int], nums2: list[int]) -> int:
    def countTriplets(A: list[int], B: list[int]):
      """"""Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].""""""
      res = 0
      count = collections.Counter(B)

      for a in A:
        target = a * a
        for b, freq in count.items():
          if target % b > 0 or target // b not in count:
            continue
          if target // b == b:
            res += freq * (freq - 1)
          else:
            res += freq * count[target // b]

      return res // 2

    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)"
"1578","class Solution:
  def minCost(self, colors: str, neededTime: list[int]) -> int:
    ans = 0
    maxNeededTime = neededTime[0]

    for i in range(1, len(colors)):
      if colors[i] == colors[i - 1]:
        ans += min(maxNeededTime, neededTime[i])
        # For each continuous group, Bob needs to remove every balloon except
        # the one with the maximum `neededTime`. So, he should hold the balloon
        # with the highest `neededTime` in his hand.
        maxNeededTime = max(maxNeededTime, neededTime[i])
      else:
        # If the current balloon is different from the previous one, discard
        # the balloon from the previous group and hold the new one in hand.
        maxNeededTime = neededTime[i]

    return ans"
"1579","class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:
    alice = UnionFind(n)
    bob = UnionFind(n)
    requiredEdges = 0

    # Greedily put type 3 edges in the front.
    for type_, u, v in sorted(edges, reverse=True):
      u -= 1
      v -= 1
      if type_ == 3:  # Can be traversed by Alice and Bob.
          # Note that we should use | instead of or because if the first
          # expression is True, short-circuiting will skip the second
          # expression.
        if alice.unionByRank(u, v) | bob.unionByRank(u, v):
          requiredEdges += 1
      elif type_ == 2:  # Can be traversed by Bob.
        if bob.unionByRank(u, v):
          requiredEdges += 1
      else:  # type == 1 Can be traversed by Alice.
        if alice.unionByRank(u, v):
          requiredEdges += 1

    return (len(edges) - requiredEdges
            if alice.count == 1 and bob.count == 1
            else -1)"
"158","# The read4 API is already defined for you.
# Def read4(buf4: list[str]) -> int:

class Solution:
  def read(self, buf: list[str], n: int) -> int:
    i = 0  # buf's index

    while i < n:
      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.
        self.i4 = 0  # Reset the buf4's index.
        # Read <= 4 characters from the file to the buf4.
        self.n4 = read4(self.buf4)
        if self.n4 == 0:  # Reach the EOF.
          return i
      buf[i] = self.buf4[self.i4]
      i += 1
      self.i4 += 1

    return i

  buf4 = [' '] * 4
  i4 = 0  # buf4's index
  n4 = 0  # buf4's size"
"1580","class Solution:
  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:
    l = 0
    r = len(warehouse) - 1

    for box in sorted(boxes, reverse=True):
      if l > r:
        return len(warehouse)
      if box <= warehouse[l]:
        l += 1
      elif box <= warehouse[r]:
        r -= 1

    return l + (len(warehouse) - r - 1)"
"1581","SELECT
  Visits.customer_id,
  COUNT(Visits.visit_id) AS count_no_trans
FROM Visits
LEFT JOIN Transactions
  USING (visit_id)
WHERE Transactions.transaction_id IS NULL
GROUP BY 1;"
"1582","class Solution:
  def numSpecial(self, mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    rowOnes = [0] * m
    colOnes = [0] * n

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1:
          rowOnes[i] += 1
          colOnes[j] += 1

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:
          ans += 1

    return ans"
"1583","class Solution:
  def unhappyFriends(
      self,
      n: int,
      preferences: list[list[int]],
      pairs: list[list[int]],
  ) -> int:
    ans = 0
    matches = [0] * n
    prefer = [{} for _ in range(n)]

    for x, y in pairs:
      matches[x] = y
      matches[y] = x

    for i in range(n):
      for j in range(n - 1):
        prefer[i][preferences[i][j]] = j

    for x in range(n):
      for u in prefer[x].keys():
        y = matches[x]
        v = matches[u]
        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:
          ans += 1
          break

    return ans"
"1584","class Solution:
  def minCostConnectPoints(self, points: list[int]) -> int:
    # dist[i] := the minimum distance to connect the points[i]
    dist = [math.inf] * len(points)
    ans = 0

    for i in range(len(points) - 1):
      for j in range(i + 1, len(points)):
        # Try to connect the points[i] with the points[j].
        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +
                      abs(points[i][1] - points[j][1]))
        # Swap the points[j] (the point with the mnimum distance) with the
        # points[i + 1].
        if dist[j] < dist[i + 1]:
          points[j], points[i + 1] = points[i + 1], points[j]
          dist[j], dist[i + 1] = dist[i + 1], dist[j]
      ans += dist[i + 1]

    return ans"
"1585","class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    if collections.Counter(s) != collections.Counter(t):
      return False

    positions = [collections.deque() for _ in range(10)]

    for i, c in enumerate(s):
      positions[int(c)].append(i)

    # For each digit in `t`, check if we can put this digit in `s` at the same
    # position as `t`. Ensure that all the left digits are equal to or greater
    # than it. This is because the only operation we can perform is sorting in
    # ascending order. If there is a digit to the left that is smaller than it,
    # we can never move it to the same position as in `t`. However, if all the
    # digits to its left are equal to or greater than it, we can move it one
    # position to the left until it reaches the same position as in `t`.
    for c in t:
      d = int(c)
      front = positions[d].popleft()
      for smaller in range(d):
        if positions[smaller] and positions[smaller][0] < front:
          return False

    return True"
"1586","class BSTIterator:
  def __init__(self, root: TreeNode | None):
    self.prevsAndCurr = []
    self.nexts = []
    self._pushLeftsUntilNull(root)

  def hasNext(self) -> bool:
    return len(self.nexts) > 0

  def next(self) -> int:
    root, fromNext = self.nexts.pop()
    if fromNext:
      self._pushLeftsUntilNull(root.right)
    self.prevsAndCurr.append(root)
    return root.val

  def hasPrev(self) -> bool:
    return len(self.prevsAndCurr) > 1

  def prev(self) -> int:
    self.nexts.append((self.prevsAndCurr.pop(), False))
    return self.prevsAndCurr[-1].val

  def _pushLeftsUntilNull(self, root):
    while root:
      self.nexts.append((root, True))
      root = root.left"
"1587","SELECT
  Users.name,
  SUM(amount) AS balance
FROM Users
INNER JOIN Transactions
  USING (account)
GROUP BY 1
HAVING balance > 10000;"
"1588","class Solution:
  def sumOddLengthSubarrays(self, arr: list[int]) -> int:
    ans = 0
    # Maintain two sums of subarrays ending in the previous index.
    # Each time we meet a new number, we'll consider 'how many times' it should
    # contribute to the newly built subarrays by calculating the number of
    # previous even/odd-length subarrays.
    prevEvenSum = 0  # the sum of even-length subarrays
    prevOddSum = 0  # the sum of odd-length subarrays

    for i, a in enumerate(arr):
      # (i + 1) // 2 := the number of previous odd-length subarrays.
      currEvenSum = prevOddSum + ((i + 1) // 2) * a
      # i // 2 + 1 := the number of previous even-length subarrays
      # (including 0).
      currOddSum = prevEvenSum + (i // 2 + 1) * a
      ans += currOddSum
      prevEvenSum = currEvenSum
      prevOddSum = currOddSum

    return ans"
"1589","class Solution:
  def maxSumRangeQuery(self, nums: list[int], requests: list[list[int]]) -> int:
    kMod = 1_000_000_007
    ans = 0
    # count[i] := the number of times nums[i] has been requested
    count = [0] * len(nums)

    for start, end in requests:
      count[start] += 1
      if end + 1 < len(nums):
        count[end + 1] -= 1

    for i in range(1, len(nums)):
      count[i] += count[i - 1]

    for num, c in zip(sorted(nums), sorted(count)):
      ans += num * c
      ans %= kMod

    return ans"
"159","class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    ans = 0
    distinct = 0
    count = [0] * 128

    l = 0
    for r, c in enumerate(s):
      count[ord(c)] += 1
      if count[ord(c)] == 1:
        distinct += 1
      while distinct == 3:
        count[ord(s[l])] -= 1
        if count[ord(s[l])] == 0:
          distinct -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"1590","class Solution:
  def minSubarray(self, nums: list[int], p: int) -> int:
    summ = sum(nums)
    remainder = summ % p
    if remainder == 0:
      return 0

    ans = len(nums)
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      prefix %= p
      target = (prefix - remainder + p) % p
      if target in prefixToIndex:
        ans = min(ans, i - prefixToIndex[target])
      prefixToIndex[prefix] = i

    return -1 if ans == len(nums) else ans"
"1591","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def isPrintable(self, targetGrid: list[list[int]]) -> bool:
    kMaxColor = 60
    m = len(targetGrid)
    n = len(targetGrid[0])

    # graph[u] := {v1, v2} means v1 and v2 cover u
    graph = [set() for _ in range(kMaxColor + 1)]

    for color in range(1, kMaxColor + 1):
      # Get the rectangle of the current color.
      minI = m
      minJ = n
      maxI = -1
      maxJ = -1
      for i in range(m):
        for j in range(n):
          if targetGrid[i][j] == color:
            minI = min(minI, i)
            minJ = min(minJ, j)
            maxI = max(maxI, i)
            maxJ = max(maxJ, j)

      # Add any color covering the current as the children.
      for i in range(minI, maxI + 1):
        for j in range(minJ, maxJ + 1):
          if targetGrid[i][j] != color:
            graph[color].add(targetGrid[i][j])

    states = [State.kInit] * (kMaxColor + 1)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited

      return False

    return not (any(hasCycle(i) for i in range(1, kMaxColor + 1)))"
"1592","class Solution {
  public String reorderSpaces(String text) {
    final String[] words = text.trim().split(""\\s+"");
    final int spaces = (int) text.chars().filter(c -> c == ' ').count();
    final int n = words.length;
    final int gapSize = n == 1 ? 0 : spaces / (n - 1);
    final int remains = n == 1 ? spaces : spaces % (n - 1);
    return String.join("" "".repeat(gapSize), words) + "" "".repeat(remains);
  }
}"
"1593","class Solution {
 public:
  int maxUniqueSplit(string s) {
    size_t ans = 0;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, unordered_set<string>&& seen,
           size_t& ans) {
    if (start == s.length()) {
      ans = max(ans, seen.size());
      return;
    }

    for (int i = 1; start + i <= s.length(); ++i) {
      const string cand = s.substr(start, i);
      if (seen.contains(cand))
        continue;
      seen.insert(cand);
      dfs(s, start + i, std::move(seen), ans);
      seen.erase(cand);
    }
  }
};"
"1594","class Solution {
  public int maxProductPath(int[][] grid) {
    final int kMod = 1_000_000_007;
    final int m = grid.length;
    final int n = grid[0].length;
    // dpMin[i][j] := the minimum product from (0, 0) to (i, j)
    // dpMax[i][j] := the maximum product from (0, 0) to (i, j)
    long[][] dpMin = new long[m][n];
    long[][] dpMax = new long[m][n];

    dpMin[0][0] = dpMax[0][0] = grid[0][0];

    for (int i = 1; i < m; ++i)
      dpMin[i][0] = dpMax[i][0] = dpMin[i - 1][0] * grid[i][0];

    for (int j = 1; j < n; ++j)
      dpMin[0][j] = dpMax[0][j] = dpMin[0][j - 1] * grid[0][j];

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (grid[i][j] < 0) {
          dpMin[i][j] = Math.max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
          dpMax[i][j] = Math.min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
        } else {
          dpMin[i][j] = Math.min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
          dpMax[i][j] = Math.max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
        }

    final long mx = Math.max(dpMin[m - 1][n - 1], dpMax[m - 1][n - 1]);
    return mx < 0 ? -1 : (int) (mx % kMod);
  }
}"
"1595","class Solution:
  def connectTwoGroups(self, cost: list[list[int]]) -> int:
    # minCosts[j] := the minimum cost of connecting group2's point j
    minCosts = [min(col) for col in zip(*cost)]

    @functools.lru_cache(None)
    def dp(i: int, mask: int) -> int:
      """"""
      Returns the minimum cost to connect group1's points[i..n) with group2's
      points, where `mask` is the bitmask of the connected points in group2.
      """"""
      if i == len(cost):
        # All the points in group 1 are connected, so greedily assign the
        # minimum cost for the unconnected points of group2.
        return sum(minCost for j, minCost in enumerate(minCosts)
                   if (mask >> j & 1) == 0)
      return min(cost[i][j] + dp(i + 1, mask | 1 << j)
                 for j in range(len(cost[0])))

    return dp(0, 0)"
"1596","WITH
  RankedOrders AS (
    SELECT
      Orders.customer_id,
      Orders.product_id,
      Products.product_name,
      RANK() OVER(
        PARTITION BY Orders.customer_id
        ORDER BY COUNT(Orders.product_id) DESC
      ) AS `rank`
    FROM Orders
    INNER JOIN Products
      USING (product_id)
    GROUP BY 1, 2
  )
SELECT
  customer_id,
  product_id,
  product_name
FROM RankedOrders
WHERE `rank` = 1;"
"1597","class Solution {
  public Node expTree(String s) {
    Deque<Node> nodes = new ArrayDeque<>();
    Deque<Character> ops = new ArrayDeque<>(); // [operators | parentheses]

    for (final char c : s.toCharArray())
      if (Character.isDigit(c)) {
        nodes.push(new Node(c));
      } else if (c == '(') {
        ops.push(c);
      } else if (c == ')') {
        while (ops.peek() != '(')
          nodes.push(buildNode(ops.pop(), nodes.pop(), nodes.pop()));
        ops.pop(); // Remove '('.
      } else {     // c == '+' || c == '-' || c == '*' || c == '/'
        while (!ops.isEmpty() && compare(ops.peek(), c))
          nodes.push(buildNode(ops.pop(), nodes.pop(), nodes.pop()));
        ops.push(c);
      }

    while (!ops.isEmpty())
      nodes.push(buildNode(ops.pop(), nodes.pop(), nodes.pop()));

    return nodes.peek();
  }

  private Node buildNode(char op, Node right, Node left) {
    return new Node(op, left, right);
  }

  // Returns true if op1 is a operator and priority(op1) >= priority(op2).
  boolean compare(char op1, char op2) {
    if (op1 == '(' || op1 == ')')
      return false;
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }
}"
"1598","class Solution {
 public:
  int minOperations(vector<string>& logs) {
    int ans = 0;

    for (const string& log : logs) {
      if (log == ""./"")
        continue;
      if (log == ""../"")
        ans = max(0, ans - 1);
      else
        ++ans;
    }

    return ans;
  }
};"
"1599","class Solution {
 public:
  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,
                             int runningCost) {
    int waiting = 0;
    int profit = 0;
    int maxProfit = 0;
    int rotate = 0;
    int maxRotate = -1;
    int i = 0;

    while (waiting > 0 || i < customers.size()) {
      if (i < customers.size())
        waiting += customers[i++];
      // Onboard new customers.
      const int newOnboard = min(waiting, 4);
      waiting -= newOnboard;
      profit += newOnboard * boardingCost - runningCost;
      ++rotate;
      if (profit > maxProfit) {
        maxProfit = profit;
        maxRotate = rotate;
      }
    }

    return maxRotate;
  }
};"
"16","class Solution:
  def threeSumClosest(self, nums: list[int], target: int) -> int:
    ans = nums[0] + nums[1] + nums[2]

    nums.sort()

    for i in range(len(nums) - 2):
      if i > 0 and nums[i] == nums[i - 1]:
        continue
      # Choose nums[i] as the first number in the triplet, then search the
      # remaining numbers in [i + 1, n - 1].
      l = i + 1
      r = len(nums) - 1
      while l < r:
        summ = nums[i] + nums[l] + nums[r]
        if summ == target:
          return summ
        if abs(summ - target) < abs(ans - target):
          ans = summ
        if summ < target:
          l += 1
        else:
          r -= 1

    return ans"
"160","class Solution:
  def getIntersectionNode(
      self,
      headA: ListNode,
      headB: ListNode,
  ) -> ListNode | None:
    a = headA
    b = headB

    while a != b:
      a = a.next if a else headB
      b = b.next if b else headA

    return a"
"1600","class ThroneInheritance {
 public:
  ThroneInheritance(string kingName) : kingName(kingName) {}

  void birth(string parentName, string childName) {
    family[parentName].push_back(childName);
  }

  void death(string name) {
    dead.insert(name);
  }

  vector<string> getInheritanceOrder() {
    vector<string> ans;
    dfs(kingName, ans);
    return ans;
  }

 private:
  unordered_set<string> dead;
  unordered_map<string, vector<string>> family;
  string kingName;

  void dfs(const string& name, vector<string>& ans) {
    if (!dead.contains(name))
      ans.push_back(name);
    if (!family.contains(name))
      return;

    for (const string& child : family[name])
      dfs(child, ans);
  }
};"
"1601","class Solution {
 public:
  int maximumRequests(int n, vector<vector<int>>& requests) {
    int ans = 0;
    vector<int> degrees(n);  // degrees[i] := degrees of the i-th building

    function<void(int, int)> dfs = [&](int i, int processedReqs) {
      if (i == requests.size()) {
        if (ranges::all_of(degrees, [](int d) { return d == 0; }))
          ans = max(ans, processedReqs);
        return;
      }

      // Skip the requests[i].
      dfs(i + 1, processedReqs);

      // Process the requests[i].
      --degrees[requests[i][0]];
      ++degrees[requests[i][1]];
      dfs(i + 1, processedReqs + 1);
      --degrees[requests[i][1]];
      ++degrees[requests[i][0]];
    };

    dfs(0, 0);

    return ans;
  }
};"
"1602","class Solution:
  def findNearestRightNode(
      self,
      root: TreeNode,
      u: TreeNode,
  ) -> TreeNode | None:
    ans = None
    targetDepth = -1

    def dfs(root: TreeNode, depth: int) -> None:
      nonlocal ans
      nonlocal targetDepth
      if not root:
        return
      if root == u:
        targetDepth = depth
        return
      if depth == targetDepth and not ans:
        ans = root
        return
      dfs(root.left, depth + 1)
      dfs(root.right, depth + 1)

    dfs(root, 0)
    return ans"
"1603","class ParkingSystem:
  def __init__(self, big: int, medium: int, small: int):
    self.count = [big, medium, small]

  def addCar(self, carType: int) -> bool:
    self.count[carType - 1] -= 1
    return self.count[carType - 1] >= 0"
"1604","class Solution:
  def alertNames(self, keyName: list[str], keyTime: list[str]) -> list[str]:
    nameToMinutes = collections.defaultdict(list)

    for name, time in zip(keyName, keyTime):
      minutes = self._getMinutes(time)
      nameToMinutes[name].append(minutes)

    return sorted([name for name, minutes in nameToMinutes.items()
                   if self._hasAlert(minutes)])

  def _hasAlert(self, minutes: list[int]) -> bool:
    if len(minutes) > 70:
      return True
    minutes.sort()
    for i in range(2, len(minutes)):
      if minutes[i - 2] + 60 >= minutes[i]:
        return True
    return False

  def _getMinutes(self, time: str) -> int:
    h, m = map(int, time.split(':'))
    return 60 * h + m"
"1605","class Solution:
  def restoreMatrix(self, rowSum: list[int],
                    colSum: list[int]) -> list[list[int]]:
    m = len(rowSum)
    n = len(colSum)
    ans = [[0] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        ans[i][j] = min(rowSum[i], colSum[j])
        rowSum[i] -= ans[i][j]
        colSum[j] -= ans[i][j]

    return ans"
"1606","class Solution {
 public:
  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
    vector<int> ans;
    vector<int> times(k);
    set<int> idleServers;
    // (endTime, server)
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;

    for (int i = 0; i < k; ++i)
      idleServers.insert(i);

    for (int i = 0; i < arrival.size(); ++i) {
      // Pop all the servers that are available now.
      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {
        idleServers.insert(minHeap.top().second);
        minHeap.pop();
      }
      // Get the next available server.
      const int server = getNextAvailableServer(idleServers, i, k);
      if (server == -1)
        continue;
      ++times[server];
      minHeap.emplace(arrival[i] + load[i], server);
      idleServers.erase(server);
    }

    const int busiest = ranges::max(times);
    for (int i = 0; i < k; ++i)
      if (times[i] == busiest)
        ans.push_back(i);
    return ans;
  }

 private:
  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,
                             int k) {
    if (idleServers.empty())
      return -1;
    const auto it = idleServers.lower_bound(ithRequest % k);
    return it == idleServers.cend() ? *idleServers.begin() : *it;
  }
};"
"1607","SELECT Seller.seller_name
FROM Seller
LEFT JOIN Orders
  ON (
    Seller.seller_id = Orders.seller_id
    AND YEAR(Orders.sale_date) = 2020)
WHERE Orders.order_id IS NULL
ORDER BY 1;"
"1608","class Solution:
  def specialArray(self, nums: list[int]) -> int:
    nums.sort()

    if nums[0] >= len(nums):
      return len(nums)

    for i, (a, b) in enumerate(itertools.pairwise(nums)):
      count = len(nums) - i - 1
      if a < count and b >= count:
        return count

    return -1"
"1609","class Solution:
  def isEvenOddTree(self, root: TreeNode | None) -> bool:
    q = collections.deque([root])
    isEven = True

    while q:
      prevVal = -math.inf if isEven else math.inf
      for _ in range(sz):
        node = q.popleft()
        if isEven and (node.val % 2 == 0 or node.val <= prevVal):
          return False  # invalid case on even level
        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):
          return False  # invalid case on odd level
        prevVal = node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      isEven = not isEven

    return True"
"161","class Solution:
  def isOneEditDistance(self, s: str, t: str) -> bool:
    m = len(s)
    n = len(t)
    if m > n:  # Make sure that |s| <= |t|.
      return self.isOneEditDistance(t, s)

    for i in range(m):
      if s[i] != t[i]:
        if m == n:
          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].
        return s[i:] == t[i + 1:]  # Delete t[i].

    return m + 1 == n  # Delete t[-1]."
"1610","class Solution:
  def visiblePoints(
      self,
      points: list[list[int]],
      angle: int,
      location: list[int],
  ) -> int:
    posX, posY = location
    maxVisible = 0
    same = 0
    A = []

    for x, y in points:
      if x == posX and y == posY:
        same += 1
      else:
        A.append(math.atan2(y - posY, x - posX))

    A.sort()
    A = A + [a + 2.0 * math.pi for a in A]

    angleInRadians = math.pi * (angle / 180)

    l = 0
    for r in range(len(A)):
      while A[r] - A[l] > angleInRadians:
        l += 1
      maxVisible = max(maxVisible, r - l + 1)

    return maxVisible + same"
"1611","class Solution:
  def minimumOneBitOperations(self, n: int) -> int:
    # Observation: e.g. n = 2^2
    #        100 (2^2 needs 2^3 - 1 ops)
    # op1 -> 101
    # op2 -> 111
    # op1 -> 110
    # op2 -> 010 (2^1 needs 2^2 - 1 ops)
    # op1 -> 011
    # op2 -> 001 (2^0 needs 2^1 - 1 ops)
    # op1 -> 000
    #
    # So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k
    # also takes 2^(k + 1) - 1 ops.

    # e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.
    #   - If the second bit is 1, you only need to consider the cost of turning
    #     the last 2 bits to 0.
    #   - If the second bit is 0, you need to add up the cost of flipping the
    #     second bit from 0 to 1.
    # XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.
    # Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.
    if n == 0:
      return 0
    # x is the largest 2^k <= n.
    # x | x >> 1 -> x >> 1 needs 1 op.
    #     x >> 1 -> 0      needs x = 2^k - 1 ops.
    x = 1 << n.bit_length() - 1
    return self.minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1"
"1612","class Solution:
  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:
    count = collections.Counter()

    def dfs(root: 'Node', add: int) -> None:
      if not root:
        return
      if 'a' <= root.val <= 'z':
        count[root.val] += add
      dfs(root.left, add)
      dfs(root.right, add)

    dfs(root1, 1)
    dfs(root2, -1)
    return all(value == 0 for value in count.values())"
"1613","WITH
  RECURSIVE Ids AS (
    SELECT 1 AS id
    UNION ALL
    SELECT id + 1
    FROM Ids
    WHERE id < (
        SELECT MAX(customer_id)
        FROM Customers
      )
  )
SELECT Ids.id AS ids
FROM Ids
LEFT JOIN Customers
  ON (Ids.id = Customers.customer_id)
WHERE Customers.customer_id IS NULL
ORDER BY 1;"
"1614","class Solution:
  def maxDepth(self, s: str) -> int:
    ans = 0
    opened = 0

    for c in s:
      if c == '(':
        opened += 1
        ans = max(ans, opened)
      elif c == ')':
        opened -= 1

    return ans"
"1615","class Solution:
  def maximalNetworkRank(self, n: int, roads: list[list[int]]) -> int:
    degrees = [0] * n

    for u, v in roads:
      degrees[u] += 1
      degrees[v] += 1

    # Find the first maximum and the second maximum degrees.
    maxDegree1 = 0
    maxDegree2 = 0
    for degree in degrees:
      if degree > maxDegree1:
        maxDegree2 = maxDegree1
        maxDegree1 = degree
      elif degree > maxDegree2:
        maxDegree2 = degree

    # There can be multiple nodes with `maxDegree1` or `maxDegree2`.
    # Find the counts of such nodes.
    countMaxDegree1 = 0
    countMaxDegree2 = 0
    for degree in degrees:
      if degree == maxDegree1:
        countMaxDegree1 += 1
      elif degree == maxDegree2:
        countMaxDegree2 += 1

    if countMaxDegree1 == 1:
      # 1. If there is only one node with degree = `maxDegree1`, then we'll
      # need to use the node with degree = `maxDegree2`. The answer in general
      # will be (maxDegree1 + maxDegree2), but if the two nodes that we're
      # considering are connected, then we'll have to subtract 1.
      edgeCount = (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +
                   self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1))
      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)
    else:
      # 2. If there are more than one node with degree = `maxDegree1`, then we
      # can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.
      # The answer in general will be 2 * maxDegree1, but if the two nodes that
      # we're considering are connected, then we'll have to subtract 1.
      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)
      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2
      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)

  def _getEdgeCount(
      self,
      roads: list[list[int]],
      degrees: list[int],
      degreeU: int, degreeV: int,
  ) -> int:
    """"""
    Returns the number of edges (u, v) where degress[u] == degreeU and
    degrees[v] == degreeV.
    """"""
    edgeCount = 0
    for u, v in roads:
      if degrees[u] == degreeU and degrees[v] == degreeV:
        edgeCount += 1
    return edgeCount"
"1616","class Solution:
  def checkPalindromeFormation(self, a: str, b: str) -> bool:
    return self._check(a, b) or self._check(b, a)

  def _check(self, a: str, b: str) -> bool:
    i, j = 0, len(a) - 1
    while i < j:
      if a[i] != b[j]:
        # a[0:i] + a[i..j] + b[j + 1:] or
        # a[0:i] + b[i..j] + b[j + 1:]
        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)
      i += 1
      j -= 1
    return True

  def _isPalindrome(self, s: str, i: int, j: int) -> bool:
    while i < j:
      if s[i] != s[j]:
        return False
      i += 1
      j -= 1
    return True"
"1617","class Solution:
  def countSubgraphsForEachDiameter(
      self,
      n: int,
      edges: list[list[int]],
  ) -> list[int]:
    maxMask = 1 << n
    dist = self._floydWarshall(n, edges)
    ans = [0] * (n - 1)

    # mask := the subset of the cities
    for mask in range(maxMask):
      maxDist = self._getMaxDist(mask, dist, n)
      if maxDist > 0:
        ans[maxDist - 1] += 1

    return ans

  def _floydWarshall(self, n: int, edges: list[list[int]]) -> list[list[int]]:
    dist = [[n] * n for _ in range(n)]

    for i in range(n):
      dist[i][i] = 0

    for u, v in edges:
      dist[u - 1][v - 1] = 1
      dist[v - 1][u - 1] = 1

    for k in range(n):
      for i in range(n):
        for j in range(n):
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist

  def _getMaxDist(self, mask: int, dist: list[list[int]], n: int) -> int:
    maxDist = 0
    edgeCount = 0
    cityCount = 0
    for u in range(n):
      if (mask >> u) & 1 == 0:  # u is not in the subset.
        continue
      cityCount += 1
      for v in range(u + 1, n):
        if (mask >> v) & 1 == 0:  # v is not in the subset.
          continue
        if dist[u][v] == 1:  # u and v are connected.
          edgeCount += 1
        maxDist = max(maxDist, dist[u][v])

    return maxDist if edgeCount == cityCount - 1 else 0"
"1618","# """"""
# This is FontInfo's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# class FontInfo(object):
#   Return the width of char ch when fontSize is used.
#   def getWidth(self, fontSize: int, ch: str) -> int:
#     pass
#
#   def getHeight(self, fontSize: int) -> int:
#     pass
class Solution:
  def maxFont(
      self,
      text: str,
      w: int,
      h: int,
      fonts: list[int],
      fontInfo: 'FontInfo',
  ) -> int:
    count = collections.Counter(text)
    l = 0
    r = len(fonts) - 1

    while l < r:
      m = (l + r + 1) // 2
      if fontInfo.getHeight(
              fonts[m]) <= h and self._getWidthSum(
              count, fonts[m],
              fontInfo) <= w:
        l = m
      else:
        r = m - 1

    return fonts[l] if self._getWidthSum(count, fonts[l], fontInfo) <= w else -1

  def _getWidthSum(
      self,
      count: list[int],
      font: int,
      fontInfo: 'FontInfo',
  ) -> int:
    width = 0
    for c in string.ascii_lowercase:
      width += count[c] * fontInfo.getWidth(font, c)
    return width"
"1619","class Solution:
  def trimMean(self, arr: list[int]) -> float:
    arr.sort()
    offset = len(arr) // 20
    return mean(arr[offset:-offset])"
"162","class Solution:
  def findPeakElement(self, nums: list[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] >= nums[m + 1]:
        r = m
      else:
        l = m + 1

    return l"
"1620","class Solution:
  def bestCoordinate(self, towers: list[list[int]], radius: int) -> list[int]:
    kMax = 50
    n = len(towers)
    ans = [0] * 2
    maxQuality = 0

    def dist(tower: list[int], i: int, j: int) -> float:
      """"""Returns the distance between the tower and the coordinate.""""""
      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)

    for i in range(kMax + 1):
      for j in range(kMax + 1):
        qualitySum = 0
        for tower in towers:
          q = tower[2]
          d = dist(tower, i, j)
          if d <= radius:
            qualitySum += int(q / (1 + d))
        if qualitySum > maxQuality:
          maxQuality = qualitySum
          ans = [i, j]

    return ans"
"1621","class Solution:
  def numberOfSets(self, n: int, k: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, k: int, drawing: bool) -> int:
      if k == 0:  # Find a way to draw k segments.
        return 1
      if i == n:  # Reach the end.
        return 0
      if drawing:
        # 1. Keep drawing at i and move to i + 1.
        # 2. Stop at i so decrease k. We can start from i for the next segment.
        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % kMod
      # 1. Skip i and move to i + 1.
      # 2. Start at i and move to i + 1.
      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % kMod

    return dp(0, k, False)"
"1622","class Fancy:
  def __init__(self):
    self.kMod = 1_000_000_007
    # For each `val` in `vals`, it actually represents a * val + b.
    self.vals = []
    self.a = 1
    self.b = 0

  # To undo a * val + b and get the original value, we append (val - b) // a.
  # By Fermat's little theorem:
  #   a^(p - 1) ≡ 1 (mod p)
  #   a^(p - 2) ≡ a^(-1) (mod p)
  # So, (val - b) / a ≡ (val - b) * a^(p - 2) (mod p)
  def append(self, val: int) -> None:
    x = (val - self.b + self.kMod) % self.kMod
    self.vals.append(x * pow(self.a, self.kMod - 2, self.kMod))

  # If the value is a * val + b, then the value after adding by `inc` will be
  # a * val + b + inc. So, we adjust b to b + inc.
  def addAll(self, inc: int) -> None:
    self.b = (self.b + inc) % self.kMod

  # If the value is a * val + b, then the value after multiplying by `m` will
  # be a * m * val + b * m. So, we adjust a to a * m and b to b * m.
  def multAll(self, m: int) -> None:
    self.a = (self.a * m) % self.kMod
    self.b = (self.b * m) % self.kMod

  def getIndex(self, idx: int) -> int:
    return (-1 if idx >= len(self.vals)
            else (self.a * self.vals[idx] + self.b) % self.kMod)"
"1623","SELECT
  SchoolA.student_name AS member_A,
  SchoolB.student_name AS member_B,
  SchoolC.student_name AS member_C
FROM SchoolA, SchoolB, SchoolC
WHERE
  SchoolA.student_id != SchoolB.student_id
  AND SchoolA.student_id != SchoolC.student_id
  AND SchoolB.student_id != SchoolC.student_id
  AND SchoolA.student_name != SchoolB.student_name
  AND SchoolA.student_name != SchoolC.student_name
  AND SchoolB.student_name != SchoolC.student_name;"
"1624","class Solution:
  def maxLengthBetweenEqualCharacters(self, s: str) -> int:
    ans = -1
    lastSeen = {}

    for i, c in enumerate(s):
      if c not in lastSeen:
        lastSeen[c] = i
      else:
        ans = max(ans, i - lastSeen[c] - 1)

    return ans"
"1625","class Solution {
  public String findLexSmallestString(String s, int a, int b) {
    ans = s;

    dfs(s, a, b, new HashSet<>());

    return ans;
  }

  private String ans;

  private void dfs(String s, int a, int b, Set<String> seen) {
    if (seen.contains(s))
      return;

    seen.add(s);
    if (ans.compareTo(s) > 0)
      ans = s;

    dfs(add(s, a), a, b, seen);
    dfs(rotate(s, b), a, b, seen);
  }

  private String add(final String s, int a) {
    StringBuilder sb = new StringBuilder(s);
    for (int i = 1; i < sb.length(); i += 2)
      sb.setCharAt(i, (char) ('0' + (s.charAt(i) - '0' + a) % 10));
    return sb.toString();
  }

  private String rotate(final String s, int b) {
    final int n = s.length();
    return s.substring(n - b, n) + s.substring(0, n - b);
  }
}"
"1626","class Solution {
  public int bestTeamScore(int[] scores, int[] ages) {
    record Player(int age, int score) {}
    final int n = scores.length;
    Player[] players = new Player[n];
    // dp[i] := the maximum score of choosing the players[0..i] with the players[i] being selected
    int[] dp = new int[n];

    for (int i = 0; i < n; ++i)
      players[i] = new Player(ages[i], scores[i]);

    Arrays.sort(players,
                (a, b) //
                -> a.age == b.age ? Integer.compare(b.score, a.score)
                                  : Integer.compare(b.age, a.age));

    for (int i = 0; i < n; ++i) {
      // For each player, choose it first.
      dp[i] = players[i].score;
      // players[j].age >= players[i].age since we sort in descending order.
      // So, we only have to check that players[j].score >= players[i].score.
      for (int j = 0; j < i; ++j)
        if (players[j].score >= players[i].score)
          dp[i] = Math.max(dp[i], dp[j] + players[i].score);
    }

    return Arrays.stream(dp).max().getAsInt();
  }
}"
"1627","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def areConnected(
      self,
      n: int,
      threshold: int,
      queries: list[list[int]],
  ) -> list[bool]:
    uf = UnionFind(n + 1)

    for z in range(threshold + 1, n + 1):
      for x in range(z * 2, n + 1, z):
        uf.unionByRank(z, x)

    return [uf.find(a) == uf.find(b) for a, b in queries]"
"1628","from abc import ABC, abstractmethod

""""""
This is the interface for the expression tree Node.
You should not remove it, and you can define some classes to implement it.
""""""


class Node(ABC):
  @abstractmethod
  # define your fields here
  def evaluate(self) -> int:
    pass


class ExpNode(Node):
  op = {
      '+': lambda a, b: a + b,
      '-': lambda a, b: a - b,
      '*': lambda a, b: a * b,
      '/': lambda a, b: int(a / b),
  }

  def __init__(
      self,
      val: str,
      left: Optional['ExpNode'],
      right: Optional['ExpNode'],
  ):
    self.val = val
    self.left = left
    self.right = right

  def evaluate(self) -> int:
    if not self.left and not self.right:
      return int(self.val)
    return ExpNode.op[self.val](self.left.evaluate(), self.right.evaluate())


""""""
This is the TreeBuilder class.
You can treat it as the driver code that takes the postinfix input
and returns the expression tree represnting it as a Node.
""""""


class TreeBuilder(object):
  def buildTree(self, postfix: list[str]) -> 'Node':
    stack: list[ExpNode | None] = []

    for val in postfix:
      if val in '+-*/':
        right = stack.pop()
        left = stack.pop()
        stack.append(ExpNode(val, left, right))
      else:
        stack.append(ExpNode(val, None, None))

    return stack.pop()"
"1629","class Solution:
  def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:
    ans = keysPressed[0]
    maxDuration = releaseTimes[0]

    for i in range(1, len(keysPressed)):
      duration = releaseTimes[i] - releaseTimes[i-1]
      if duration > maxDuration or (
              duration == maxDuration and keysPressed[i] > ans):
        ans = keysPressed[i]
        maxDuration = duration

    return ans"
"163","class Solution:
  def findMissingRanges(
      self,
      nums: list[int],
      lower: int,
      upper: int,
  ) -> list[list[int]]:
    def getRange(lo: int, hi: int) -> list[int]:
      if lo == hi:
        return [lo, lo]
      return [lo, hi]

    if not nums:
      return [getRange(lower, upper)]

    ans = []

    if nums[0] > lower:
      ans.append(getRange(lower, nums[0] - 1))

    for prev, curr in zip(nums, nums[1:]):
      if curr > prev + 1:
        ans.append(getRange(prev + 1, curr - 1))

    if nums[-1] < upper:
      ans.append(getRange(nums[-1] + 1, upper))

    return ans"
"1630","class Solution:
  def checkArithmeticSubarrays(
      self,
      nums: list[int],
      l: list[int],
      r: list[int],
  ) -> list[bool]:
    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]

  def _isArithmetic(self, nums: list[int], l: int, r: int) -> bool:
    if r - l < 2:
      return True

    numsSet = set()
    mn = math.inf
    mx = -math.inf

    for i in range(l, r+1):
      mn = min(mn, nums[i])
      mx = max(mx, nums[i])
      numsSet.add(nums[i])

    if (mx - mn) % (r - l) != 0:
      return False

    interval = (mx - mn) // (r - l)
    return all(mn + k * interval in numsSet
               for k in range(1, r - l + 1))"
"1631","class Solution:
  def minimumEffortPath(self, heights: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(heights)
    n = len(heights[0])
    # diff[i][j] := the maximum absolute difference to reach (i, j)
    diff = [[math.inf] * n for _ in range(m)]
    seen = set()

    minHeap = [(0, 0, 0)]  # (d, i, j)
    diff[0][0] = 0

    while minHeap:
      d, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return d
      seen.add((i, j))
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        newDiff = abs(heights[i][j] - heights[x][y])
        maxDiff = max(diff[i][j], newDiff)
        if diff[x][y] > maxDiff:
          diff[x][y] = maxDiff
          heapq.heappush(minHeap, (diff[x][y], x, y))"
"1632","class UnionFind:
  def __init__(self):
    self.id = {}

  def union(self, u: int, v: int) -> None:
    self.id.setdefault(u, u)
    self.id.setdefault(v, v)
    i = self._find(u)
    j = self._find(v)
    if i != j:
      self.id[i] = j

  def getGroupIdToValues(self) -> dict[int, list[int]]:
    groupIdToValues = collections.defaultdict(list)
    for u in self.id.keys():
      groupIdToValues[self._find(u)].append(u)
    return groupIdToValues

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def matrixRankTransform(self, matrix: list[list[int]]) -> list[list[int]]:
    m = len(matrix)
    n = len(matrix[0])
    ans = [[0] * n for _ in range(m)]
    # {val: [(i, j)]}
    valToGrids = collections.defaultdict(list)
    # rank[i] := the maximum rank of the row or column so far
    maxRankSoFar = [0] * (m + n)

    for i, row in enumerate(matrix):
      for j, val in enumerate(row):
        valToGrids[val].append((i, j))

    for _, grids in sorted(valToGrids.items()):
      uf = UnionFind()
      for i, j in grids:
        # Union i-th row with j-th col.
        uf.union(i, j + m)
      for values in uf.getGroupIdToValues().values():
        # Get the maximum rank of all the included rows and columns.
        maxRank = max(maxRankSoFar[i] for i in values)
        for i in values:
          # Update all the rows and columns to maxRank + 1.
          maxRankSoFar[i] = maxRank + 1
      for i, j in grids:
        ans[i][j] = maxRankSoFar[i]

    return ans"
"1633","SELECT
  contest_id,
  ROUND(
    COUNT(user_id) * 100 / (
      SELECT COUNT(*)
      FROM Users
    ),
    2
  ) AS percentage
FROM Register
GROUP BY 1
ORDER BY percentage DESC, contest_id;"
"1634","# Definition for polynomial singly-linked list.
# class PolyNode:
#   def __init__(self, x=0, y=0, next=None):
#     self.coefficient = x
#     self.power = y
#     self.next = next

class Solution:
  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':
    dummy = PolyNode()
    curr = dummy
    p = poly1  # poly1's pointer
    q = poly2  # poly2's pointer

    while p and q:
      if p.power > q.power:
        curr.next = PolyNode(p.coefficient, p.power)
        curr = curr.next
        p = p.next
      elif p.power < q.power:
        curr.next = PolyNode(q.coefficient, q.power)
        curr = curr.next
        q = q.next
      else:  # p.power == q.power
        sumCoefficient = p.coefficient + q.coefficient
        if sumCoefficient != 0:
          curr.next = PolyNode(sumCoefficient, p.power)
          curr = curr.next
        p = p.next
        q = q.next

    while p:
      curr.next = PolyNode(p.coefficient, p.power)
      curr = curr.next
      p = p.next

    while q:
      curr.next = PolyNode(q.coefficient, q.power)
      curr = curr.next
      q = q.next

    return dummy.next"
"1635","WITH
  RECURSIVE Calendar AS (
    SELECT 1 AS month
    UNION ALL
    SELECT month + 1
    FROM Calendar
    WHERE month < 12
  )
SELECT
  Calendar.month,
  (
    SELECT COUNT(*)
    FROM Drivers
    WHERE
      YEAR(Drivers.join_date) < '2020'
      OR (
        YEAR(Drivers.join_date) = '2020'
        AND MONTH(Drivers.join_date) <= Calendar.month)
  ) AS active_drivers,
  (
    SELECT COUNT(*)
    FROM AcceptedRides
    INNER JOIN Rides
      USING (ride_id)
    WHERE
      YEAR(Rides.requested_at) = '2020'
      AND MONTH(Rides.requested_at) = Calendar.month
  ) AS accepted_rides
FROM Calendar;"
"1636","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  num: int
  freq: int

  def __lt__(self, other):
    if self.freq == other.freq:
      return self.num > other.num
    return self.freq < other.freq


class Solution:
  def frequencySort(self, nums: list[int]) -> list[int]:
    ans = []
    heap = []

    for num, freq in collections.Counter(nums).items():
      heapq.heappush(heap, T(num, freq))

    while len(heap) > 0:
      num = heap[0].num
      freq = heapq.heappop(heap).freq
      ans.extend([num] * freq)

    return ans"
"1637","class Solution:
  def maxWidthOfVerticalArea(self, points: list[list[int]]) -> int:
    xs = sorted([x for x, _ in points])
    return max(b - a for a, b in itertools.pairwise(xs))"
"1638","class Solution:
  def countSubstrings(self, s: str, t: str) -> int:
    ans = 0

    for i in range(len(s)):
      ans += self._count(s, t, i, 0)

    for j in range(1, len(t)):
      ans += self._count(s, t, 0, j)

    return ans

  def _count(self, s: str, t: str, i: int, j: int) -> int:
    """"""Returns the number of substrings of s[i..n) and t[j:] that differ by one char.""""""
    res = 0
    # the number of substrings starting at s[i] and t[j] ending in the current
    # index with zero different letter
    dp0 = 0
    # the number of substrings starting at s[i] and t[j] ending in the current
    # index with one different letter
    dp1 = 0

    while i < len(s) and j < len(t):
      if s[i] == t[j]:
        dp0 += 1
      else:
        dp0, dp1 = 0, dp0 + 1
      res += dp1
      i += 1
      j += 1

    return res"
"1639","class Solution:
  def numWays(self, words: list[str], target: str) -> int:
    kMod = 1_000_000_007
    wordLength = len(words[0])
    # counts[j] := the count map of words[i][j], where 0 <= i < |words|
    counts = [collections.Counter() for _ in range(wordLength)]

    for i in range(wordLength):
      for word in words:
        counts[i][word[i]] += 1

    @functools.lru_cache(None)
    def dp(i: int, j: int):
      """"""Returns the number of ways to form target[i..n) using word[j..n).""""""
      if i == len(target):
        return 1
      if j == wordLength:
        return 0
      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % kMod

    return dp(0, 0)"
"164","class Bucket:
  def __init__(self, mn: int, mx: int):
    self.mn = mn
    self.mx = mx


class Solution:
  def maximumGap(self, nums: list[int]) -> int:
    if len(nums) < 2:
      return 0

    mn = min(nums)
    mx = max(nums)
    if mn == mx:
      return 0

    gap = math.ceil((mx - mn) / (len(nums) - 1))
    bucketSize = (mx - mn) // gap + 1
    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]

    for num in nums:
      i = (num - mn) // gap
      buckets[i].mn = min(buckets[i].mn, num)
      buckets[i].mx = max(buckets[i].mx, num)

    ans = 0
    prevMax = mn

    for bucket in buckets:
      if bucket.mn == math.inf:
        continue  # empty bucket
      ans = max(ans, bucket.mn - prevMax)
      prevMax = bucket.mx

    return ans"
"1640","class Solution:
  def canFormArray(self, arr: list[int], pieces: list[list[int]]) -> bool:
    concatenated = []
    startToPiece = {piece[0]: piece for piece in pieces}

    for a in arr:
      concatenated += startToPiece.get(a, [])

    return concatenated == arr"
"1641","class Solution {
  public int countVowelStrings(int n) {
    // dp[0] := the number of lexicographically sorted string that end in 'a'
    // dp[1] := the number of lexicographically sorted string that end in 'e'
    // dp[2] := the number of lexicographically sorted string that end in 'i'
    // dp[3] := the number of lexicographically sorted string that end in 'o'
    // dp[4] := the number of lexicographically sorted string that end in 'u'
    int[] dp = new int[5];
    Arrays.fill(dp, 1);

    for (int i = 2; i <= n; ++i) {
      int[] newDp = new int[5];
      for (int j = 0; j < 5; ++j)
        for (int k = 0; k <= j; ++k)
          newDp[j] += dp[k];
      dp = newDp;
    }

    return Arrays.stream(dp).sum();
  }
}"
"1642","class Solution:
  def furthestBuilding(
      self,
      heights: list[int],
      bricks: int,
      ladders: int,
  ) -> int:
    minHeap = []

    for i, (a, b) in enumerate(itertools.pairwise(heights)):
      diff = b - a
      if diff <= 0:
        continue
      heapq.heappush(minHeap, diff)
      # If we run out of ladders, greedily use as less bricks as possible.
      if len(minHeap) > ladders:
        bricks -= heapq.heappop(minHeap)
      if bricks < 0:
        return i

    return len(heights) - 1"
"1643","class Solution:
  def kthSmallestPath(self, destination: list[int], k: int) -> str:
    ans = []
    v, h = destination

    for _ in range(h + v):
      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.
      availableRank = math.comb(h + v - 1, v)
      if availableRank >= k:  # Should pick 'H'.
        ans.append('H')
        h -= 1
      else:  # Should pick 'V'.
        k -= availableRank
        ans.append('V')
        v -= 1

    return ''.join(ans)"
"1644","class Solution:
  def lowestCommonAncestor(
      self,
      root: 'TreeNode',
      p: 'TreeNode',
      q: 'TreeNode',
  ) -> 'TreeNode':
    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      if not root or root == p or root == q:
        return root
      left = getLCA(root.left, p, q)
      right = getLCA(root.right, p, q)
      if left and right:
        return root
      return left or right

    ans = getLCA(root, p, q)
    if ans == p:  # Search q in the subtree rooted at p.
      return ans if getLCA(p, q, q) else None
    if ans == q:  # Search p in the subtree rooted at q.
      return ans if getLCA(q, p, p) else None
    return ans  # (ans != p and ans != q) or ans is None"
"1645","WITH
  RECURSIVE Calendar AS (
    SELECT 1 AS month
    UNION ALL
    SELECT month + 1
    FROM Calendar
    WHERE month < 12
  )
SELECT
  Calendar.month,
  IFNULL(
    ROUND(
      (
        SELECT COUNT(DISTINCT AcceptedRides.driver_id)
        FROM AcceptedRides
        INNER JOIN Rides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) = Calendar.month
      ) / (
        SELECT COUNT(*)
        FROM Drivers
        WHERE YEAR(Drivers.join_date) < '2020'
          OR (
            YEAR(Drivers.join_date) = '2020'
            AND MONTH(Drivers.join_date) <= Calendar.month)
      ) * 100,
      2
    ),
    0
  ) AS working_percentage
FROM Calendar;"
"1646","class Solution:
  def getMaximumGenerated(self, n: int) -> int:
    if n == 0:
      return 0
    if n == 1:
      return 1

    nums = [0] * (n + 1)
    nums[1] = 1

    i = 1
    while 2 * i + 1 <= n:
      nums[2 * i] = nums[i]
      nums[2 * i + 1] = nums[i] + nums[i + 1]
      i += 1

    return max(nums)"
"1647","class Solution:
  def minDeletions(self, s: str) -> int:
    ans = 0
    count = collections.Counter(s)
    usedFreq = set()

    for freq in count.values():
      while freq > 0 and freq in usedFreq:
        freq -= 1  # Delete ('a' + i).
        ans += 1
      usedFreq.add(freq)

    return ans"
"1648","class Solution:
  def maxProfit(self, inventory: list[int], orders: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    largestCount = 1

    def trapezoid(a: int, b: int) -> int:
      return (a + b) * (a - b + 1) // 2

    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):
      if a > b:
        # If we are at the last inventory, or inventory[i] > inventory[i + 1].
        # In either case, we will pick inventory[i - largestCount + 1..i].
        pick = a - b
        # We have run out of orders, so we need to recalculate the number of
        # balls that we actually pick for inventory[i - largestCount + 1..i].
        if largestCount * pick >= orders:
          actualPick, remaining = divmod(orders, largestCount)
          return (ans +
                  largestCount * trapezoid(a, a - actualPick + 1) +
                  remaining * (a - actualPick)) % kMod
        ans += largestCount * trapezoid(a, a - pick + 1)
        ans %= kMod
        orders -= largestCount * pick
      largestCount += 1"
"1649","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void add(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int createSortedArray(vector<int>& instructions) {
    constexpr int kMod = 1'000'000'007;
    const int mx = ranges::max(instructions);
    int ans = 0;
    FenwickTree tree(mx);

    for (int i = 0; i < instructions.size(); ++i) {
      ans += min(tree.get(instructions[i] - 1), i - tree.get(instructions[i]));
      ans %= kMod;
      tree.add(instructions[i], 1);
    }

    return ans;
  }
};"
"165","class Solution:
  def compareVersion(self, version1: str, version2: str) -> int:
    levels1 = version1.split('.')
    levels2 = version2.split('.')
    length = max(len(levels1), len(levels2))

    for i in range(length):
      v1 = int(levels1[i]) if i < len(levels1) else 0
      v2 = int(levels2[i]) if i < len(levels2) else 0
      if v1 < v2:
        return -1
      if v1 > v2:
        return 1

    return 0"
"1650","class Solution:
  # Same as 160. Intersection of Two Linked Lists
  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
    a = p
    b = q

    while a != b:
      a = a.parent if a else q
      b = b.parent if b else p

    return a"
"1651","WITH
  RECURSIVE Calendar AS (
    SELECT 2 AS MONTH
    UNION ALL
    SELECT MONTH + 1
    FROM Calendar
    WHERE MONTH < 11
  )
SELECT
  Calendar.month - 1 AS MONTH,
  IFNULL(
    ROUND(
      (
        SELECT SUM(AcceptedRides.ride_distance)
        FROM Rides
        INNER JOIN AcceptedRides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) IN (
            Calendar.month - 1,
            Calendar.month,
            Calendar.month + 1
          )
      ) / 3,
      2
    ),
    0
  ) AS average_ride_distance,
  IFNULL(
    ROUND(
      (
        SELECT SUM(AcceptedRides.ride_duration)
        FROM Rides
        INNER JOIN AcceptedRides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) IN (
            Calendar.month - 1,
            Calendar.month,
            Calendar.month + 1
          )
      ) / 3,
      2
    ),
    0
  ) AS average_ride_duration
FROM Calendar;"
"1652","class Solution:
  def decrypt(self, code: list[int], k: int) -> list[int]:
    n = len(code)
    ans = [0] * n
    if k == 0:
      return ans

    summ = 0
    start = 1 if k > 0 else n + k  # the start of the next k numbers
    end = k if k > 0 else n - 1  # the end of the next k numbers

    for i in range(start, end + 1):
      summ += code[i]

    for i in range(n):
      ans[i] = summ
      summ -= code[start % n]
      start += 1
      end += 1
      summ += code[end % n]

    return ans"
"1653","class Solution:
  # Same as 926. Flip String to Monotone Increasing
  def minimumDeletions(self, s: str) -> int:
    dp = 0  # the number of characters to be deleted to make subso far balanced
    countB = 0

    for c in s:
      if c == 'a':
        # 1. Delete 'a'.
        # 2. Keep 'a' and delete the previous 'b's.
        dp = min(dp + 1, countB)
      else:
        countB += 1

    return dp"
"1654","from enum import Enum


class Direction(Enum):
  kForward = 0
  kBackward = 1


class Solution:
  def minimumJumps(self, forbidden: list[int], a: int, b: int, x: int) -> int:
    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))
    seenForward = {pos for pos in forbidden}
    seenBackward = {pos for pos in forbidden}

    # (direction, position)
    q = collections.deque([(Direction.kForward, 0)])

    ans = 0
    while q:
      for _ in range(len(q)):
        dir, pos = q.popleft()
        if pos == x:
          return ans
        forward = pos + a
        backward = pos - b
        if forward <= furthest and forward not in seenForward:
          seenForward.add(forward)
          q.append((Direction.kForward, forward))
        # It cannot jump backward twice in a row.
        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:
          seenBackward.add(backward)
          q.append((Direction.kBackward, backward))
      ans += 1

    return -1"
"1655","class Solution:
  def canDistribute(self, nums: list[int], quantity: list[int]) -> bool:
    freqs = list(collections.Counter(nums).values())
    # validDistribution[i][j] := True if it's possible to distribute the i-th
    # freq into a subset of quantity represented by the bitmask j
    validDistribution = self._getValidDistribution(freqs, quantity)
    n = len(freqs)
    m = len(quantity)
    maxMask = 1 << m
    # dp[i][j] := true if it's possible to distribute freqs[i..n), where j is
    # the bitmask of the selected quantity
    dp = [[False] * maxMask for _ in range(n + 1)]
    dp[n][maxMask - 1] = True

    for i in range(n - 1, -1, -1):
      for mask in range(maxMask):
        dp[i][mask] = dp[i + 1][mask]
        availableMask = ~mask & (maxMask - 1)
        submask = availableMask
        while submask > 0:
          if validDistribution[i][submask]:
            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]
          submask = (submask - 1) & availableMask

    return dp[0][0]

  def _getValidDistribution(self, freqs: list[int],
                            quantity: list[int]) -> list[list[bool]]:
    maxMask = 1 << len(quantity)
    validDistribution = [[False] * maxMask for _ in range(len(freqs))]
    for i, freq in enumerate(freqs):
      for mask in range(maxMask):
        if freq >= self._getQuantitySum(quantity, mask):
          validDistribution[i][mask] = True
    return validDistribution

  def _getQuantitySum(self, quantity: list[int], mask: int) -> int:
    """"""Returns the sum of the selected quantity represented by `mask`.""""""
    return sum(q for i, q in enumerate(quantity) if mask >> i & 1)"
"1656","class OrderedStream:
  def __init__(self, n: int):
    self.values = [''] * n
    self.i = 0  # self.values' index (0-indexed)

  def insert(self, idKey: int, value: str) -> list[str]:
    idKey -= 1  # Converts to 0-indexed.
    self.values[idKey] = value
    if idKey > self.i:
      return []
    while self.i < len(self.values) and self.values[self.i]:
      self.i += 1
    return self.values[idKey:self.i]"
"1657","class Solution:
  def closeStrings(self, word1: str, word2: str) -> bool:
    if len(word1) != len(word2):
      return False

    count1 = collections.Counter(word1)
    count2 = collections.Counter(word2)
    if count1.keys() != count2.keys():
      return False

    return sorted(count1.values()) == sorted(count2.values())"
"1658","class Solution:
  def minOperations(self, nums: list[int], x: int) -> int:
    targetSum = sum(nums) - x
    if targetSum == 0:
      return len(nums)
    maxLen = self._maxSubArrayLen(nums, targetSum)
    return -1 if maxLen == -1 else len(nums) - maxLen

  # Same as 325. Maximum Size Subarray Sum Equals k
  def _maxSubArrayLen(self, nums: list[int], k: int) -> int:
    res = -1
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      target = prefix - k
      if target in prefixToIndex:
        res = max(res, i - prefixToIndex[target])
      # No need to check the existence of the prefix since it's unique.
      prefixToIndex[prefix] = i

    return res"
"1659","class Solution:
  def getMaxGridHappiness(
      self,
      m: int,
      n: int,
      introvertsCount: int,
      extrovertsCount: int,
  ) -> int:
    def getPlacementCost(
        i: int,
        j: int,
        inMask: int,
        exMask: int,
        diff: int,
    ) -> int:
      """"""Calculates the cost based on left and up neighbors.

      The `diff` parameter represents the happiness change due to the current
      placed person in (i, j). We add `diff` each time we encounter a neighbor
      (left or up) who is already placed.

      1. If the neighbor is an introvert, we subtract 30 from cost.
      2. If the neighbor is an extrovert, we add 20 to from cost.
      """"""
      cost = 0
      if i > 0:
        if (1 << (n - 1)) & inMask:
          cost += diff - 30
        if (1 << (n - 1)) & exMask:
          cost += diff + 20
      if j > 0:
        if 1 & inMask:
          cost += diff - 30
        if 1 & exMask:
          cost += diff + 20
      return cost

    @functools.lru_cache(None)
    def dp(
        pos: int, inMask: int, exMask: int, inCount: int, exCount: int
    ) -> int:
      # `inMask` is the placement of introvert people in the last n cells.
      # e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means
      #
      # ? 1 0
      # 1 x ? (x := current position)
      i, j = divmod(pos, n)
      if i == m:
        return 0

      shiftedInMask = (inMask << 1) & ((1 << n) - 1)
      shiftedExMask = (exMask << 1) & ((1 << n) - 1)

      skip = dp(pos + 1, shiftedInMask, shiftedExMask, inCount, exCount)
      placeIntrovert = (
          120 + getPlacementCost(i, j, inMask, exMask, -30) +
          dp(pos + 1, shiftedInMask + 1, shiftedExMask, inCount - 1, exCount)
          if inCount > 0
          else -math.inf)
      placeExtrovert = (
          40 + getPlacementCost(i, j, inMask, exMask, 20) +
          dp(pos + 1, shiftedInMask, shiftedExMask + 1, inCount, exCount - 1)
          if exCount > 0
          else -math.inf)
      return max(skip, placeIntrovert, placeExtrovert)

    return dp(0, 0, 0, introvertsCount, extrovertsCount)"
"166","class Solution:
  def fractionToDecimal(self, numerator: int, denominator: int) -> str:
    if numerator == 0:
      return '0'

    ans = ''

    if (numerator < 0) ^ (denominator < 0):
      ans += '-'

    numerator = abs(numerator)
    denominator = abs(denominator)
    ans += str(numerator // denominator)

    if numerator % denominator == 0:
      return ans

    ans += '.'
    dict = {}

    remainder = numerator % denominator
    while remainder:
      if remainder in dict:
        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'
        break
      dict[remainder] = len(ans)
      remainder *= 10
      ans += str(remainder // denominator)
      remainder %= denominator

    return ans"
"1660","class Solution:
  def __init__(self):
    self.seen = set()

  def correctBinaryTree(self, root: TreeNode | None) -> TreeNode | None:
    if root == None:
      return None
    if root.right and root.right.val in self.seen:
      return None
    self.seen.add(root.val)
    root.right = self.correctBinaryTree(root.right)
    root.left = self.correctBinaryTree(root.left)
    return root"
"1661","SELECT
  StartActivity.machine_id,
  ROUND(
    AVG(EndActivity.timestamp - StartActivity.timestamp),
    3
  ) AS processing_time
FROM Activity AS StartActivity
INNER JOIN Activity AS EndActivity
  USING (machine_id, process_id)
WHERE
  StartActivity.activity_type = 'start'
  AND EndActivity.activity_type = 'end'
GROUP BY 1;"
"1662","class Solution:
  def arrayStringsAreEqual(self, word1: list[str], word2: list[str]) -> bool:
    i = 0  # word1's index
    j = 0  # word2's index
    a = 0  # word1[i]'s index
    b = 0  # word2[j]'s index

    while i < len(word1) and j < len(word2):
      if word1[i][a] != word2[j][b]:
        return False
      a += 1
      if a == len(word1[i]):
        i += 1
        a = 0
      b += 1
      if b == len(word2[j]):
        j += 1
        b = 0

    return i == len(word1) and j == len(word2)"
"1663","class Solution:
  def getSmallestString(self, n: int, k: int) -> str:
    ans = []

    for i in range(n):
      remainingLetters = n - 1 - i
      rank = max(1, k - remainingLetters * 26)
      ans.append(chr(ord('a') + rank - 1))
      k -= rank

    return ''.join(ans)"
"1664","class Solution {
 public:
  int waysToMakeFair(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // l[0] := the sum of even-indexed nums[0..i)
    // l[1] := the sum of odd-indexed nums[0..i)
    // r[0] := the sum of even-indexed nums[i + 1..n)
    // r[1] := the sum of odd-indexed nums[i + 1..n)
    vector<int> l(2);
    vector<int> r(2);

    for (int i = 0; i < n; ++i)
      r[i % 2] += nums[i];

    for (int i = 0; i < n; ++i) {
      r[i % 2] -= nums[i];
      if (l[0] + r[1] == l[1] + r[0])
        ++ans;
      l[i % 2] += nums[i];
    }

    return ans;
  }
};"
"1665","class Solution:
  def minimumEffort(self, tasks: list[list[int]]) -> int:
    ans = 0
    prevSaved = 0

    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):
      if prevSaved < minimum:
        ans += minimum - prevSaved
        prevSaved = minimum - actual
      else:
        prevSaved -= actual

    return ans"
"1666","class Solution {
  public Node flipBinaryTree(Node root, Node leaf) {
    return reroot(root, leaf, null);
  }

  private Node reroot(Node root, Node node, Node newParent) {
    Node oldParent = node.parent;
    node.parent = newParent;

    // Clean up the child if it's the new parent.
    if (node.left == newParent)
      node.left = null;
    if (node.right == newParent)
      node.right = null;

    // We meet the original root, so we're done.
    if (node == root)
      return node;

    if (node.left != null)
      node.right = node.left;
    node.left = reroot(root, oldParent, node);

    return node;
  }
}"
"1667","SELECT
  user_id,
  CONCAT(
    UPPER(SUBSTRING(name, 1, 1)),
    LOWER(SUBSTRING(name, 2))
  ) AS name
FROM Users
ORDER BY 1;"
"1668","class Solution:
  def maxRepeating(self, sequence: str, word: str) -> int:
    ans = 1
    while word * ans in sequence:
      ans += 1
    return ans - 1"
"1669","class Solution:
  def mergeInBetween(
      self,
      list1: ListNode,
      a: int,
      b: int,
      list2: ListNode,
  ) -> ListNode:
    nodeBeforeA = list1
    for i in range(a - 1):
      nodeBeforeA = nodeBeforeA.next

    nodeB = nodeBeforeA.next
    for i in range(b - a):
      nodeB = nodeB.next

    nodeBeforeA.next = list2
    lastNodeInList2 = list2

    while lastNodeInList2.next:
      lastNodeInList2 = lastNodeInList2.next

    lastNodeInList2.next = nodeB.next
    nodeB.next = None
    return list1"
"167","class Solution:
  def twoSum(self, numbers: list[int], target: int) -> list[int]:
    l = 0
    r = len(numbers) - 1

    while l < r:
      summ = numbers[l] + numbers[r]
      if summ == target:
        return [l + 1, r + 1]
      if summ < target:
        l += 1
      else:
        r -= 1"
"1670","class FrontMiddleBackQueue:
  def __init__(self):
    self.frontQueue = collections.deque()
    self.backQueue = collections.deque()

  def pushFront(self, val: int) -> None:
    self.frontQueue.appendleft(val)
    self._moveFrontToBackIfNeeded()

  def pushMiddle(self, val: int) -> None:
    if len(self.frontQueue) == len(self.backQueue):
      self.backQueue.appendleft(val)
    else:
      self.frontQueue.append(val)

  def pushBack(self, val: int) -> None:
    self.backQueue.append(val)
    self._moveBackToFrontIfNeeded()

  def popFront(self) -> int:
    if self.frontQueue:
      x = self.frontQueue.popleft()
      self._moveBackToFrontIfNeeded()
      return x
    if self.backQueue:
      return self.backQueue.popleft()
    return -1

  def popMiddle(self) -> int:
    if not self.frontQueue and not self.backQueue:
      return -1
    if len(self.frontQueue) + 1 == len(self.backQueue):
      return self.backQueue.popleft()
    return self.frontQueue.pop()

  def popBack(self) -> int:
    if self.backQueue:
      x = self.backQueue.pop()
      self._moveFrontToBackIfNeeded()
      return x
    return -1

  def _moveFrontToBackIfNeeded(self) -> None:
    if len(self.frontQueue) - 1 == len(self.backQueue):
      self.backQueue.appendleft(self.frontQueue.pop())

  def _moveBackToFrontIfNeeded(self) -> None:
    if len(self.frontQueue) + 2 == len(self.backQueue):
      self.frontQueue.append(self.backQueue.popleft())"
"1671","class Solution:
  def minimumMountainRemovals(self, nums: list[int]) -> int:
    left = self._lengthOfLIS(nums)
    right = self._lengthOfLIS(nums[::-1])[::-1]
    maxMountainSeq = 0

    for l, r in zip(left, right):
      if l > 1 and r > 1:
        maxMountainSeq = max(maxMountainSeq, l + r - 1)

    return len(nums) - maxMountainSeq

  # Similar to 300. Longest Increasing Subsequence
  def _lengthOfLIS(self, nums: list[int]) -> list[int]:
    # tails[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tails = []
    # dp[i] := the length of LIS ending in nums[i]
    dp = []
    for num in nums:
      if not tails or num > tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_left(tails, num)] = num
      dp.append(len(tails))
    return dp"
"1672","class Solution:
  def maximumWealth(self, accounts: list[list[int]]) -> int:
    return max(map(sum, accounts))"
"1673","class Solution:
  def mostCompetitive(self, nums: list[int], k: int) -> list[int]:
    ans = []

    for i, num in enumerate(nums):
      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough
      # numbers, and we can safely pop an element from ans.
      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:
        ans.pop()
      if len(ans) < k:
        ans.append(nums[i])

    return ans"
"1674","class Solution:
  def minMoves(self, nums: list[int], limit: int) -> int:
    n = len(nums)
    ans = n
    # delta[i] := the number of moves needed when target goes from i - 1 to i
    delta = [0] * (limit * 2 + 2)

    for i in range(n // 2):
      a = nums[i]
      b = nums[n - 1 - i]
      delta[min(a, b) + 1] -= 1
      delta[a + b] -= 1
      delta[a + b + 1] += 1
      delta[max(a, b) + limit + 1] += 1

    # Initially, we need `moves` when the target is 2.
    moves = n
    for i in range(2, limit * 2 + 1):
      moves += delta[i]
      ans = min(ans, moves)

    return ans"
"1675","class Solution:
  def minimumDeviation(self, nums: list[int]) -> int:
    ans = math.inf
    mn = math.inf
    maxHeap = []

    for num in nums:
      evenNum = num if num % 2 == 0 else num * 2
      heapq.heappush(maxHeap, -evenNum)
      mn = min(mn, evenNum)

    while maxHeap[0] % 2 == 0:
      mx = -heapq.heappop(maxHeap)
      ans = min(ans, mx - mn)
      mn = min(mn, mx // 2)
      heapq.heappush(maxHeap, -mx // 2)

    return min(ans, -maxHeap[0] - mn)"
"1676","class Solution:
  def lowestCommonAncestor(
      self,
      root: 'TreeNode',
      nodes: 'list[TreeNode]',
  ) -> 'TreeNode':
    nodes = set(nodes)

    def lca(root: 'TreeNode') -> 'TreeNode':
      if not root:
        return None
      if root in nodes:
        return root
      left = lca(root.left)
      right = lca(root.right)
      if left and right:
        return root
      return left or right

    return lca(root)"
"1677","SELECT
  Product.name,
  IFNULL(SUM(Invoice.rest), 0) AS rest,
  IFNULL(SUM(Invoice.paid), 0) AS paid,
  IFNULL(SUM(Invoice.canceled), 0) AS canceled,
  IFNULL(SUM(Invoice.refunded), 0) AS refunded
FROM Product
LEFT JOIN Invoice
  USING (product_id)
GROUP BY 1
ORDER BY 1;"
"1678","class Solution:
  def interpret(self, command: str) -> str:
    return command.replace('()', 'o').replace('(al)', 'al')"
"1679","class Solution:
  def maxOperations(self, nums: list[int], k: int) -> int:
    count = collections.Counter(nums)
    return sum(min(count[num], count[k - num])
               for num in count) // 2"
"168","class Solution:
  def convertToTitle(self, n: int) -> str:
    return (self.convertToTitle((n - 1) // 26) + chr(ord('A') + (n - 1) % 26)
            if n
            else '')"
"1680","class Solution:
  def concatenatedBinary(self, n: int) -> int:
    kMod = 1_000_000_007
    ans = 0

    def numberOfBits(n: int) -> int:
      return int(math.log2(n)) + 1

    for i in range(1, n + 1):
      ans = ((ans << numberOfBits(i)) + i) % kMod

    return ans"
"1681","class Solution:
  def __init__(self):
    self.kMaxNum = 16

  def minimumIncompatibility(self, nums: list[int], k: int) -> int:
    kMaxCompatibility = (16 - 1) * (16 // 2)
    n = len(nums)
    subsetSize = n // k
    maxMask = 1 << n
    incompatibilities = self._getIncompatibilities(nums, subsetSize)

    # dp[i] := the minimum possible sum of incompatibilities of the subset
    # of numbers represented by the bitmask i
    dp = [kMaxCompatibility] * maxMask
    dp[0] = 0

    for mask in range(1, maxMask):
      # The number of 1s in `mask` isn't a multiple of `subsetSize`.
      if mask.bit_count() % subsetSize != 0:
        continue
      # https://cp-algorithms.com/algebra/all-submasks.html
      submask = mask
      while submask > 0:
        if incompatibilities[submask] != -1:  # valid submask
          dp[mask] = min(dp[mask], dp[mask - submask] +
                         incompatibilities[submask])
        submask = (submask - 1) & mask

    return dp[-1] if dp[-1] != kMaxCompatibility else -1

  def _getIncompatibilities(
      self,
      nums: list[int],
      subsetSize: int,
  ) -> list[int]:
    """"""
    Returns an incompatibilities array where
    * incompatibilities[i] := the incompatibility of the subset of numbers
      represented by the bitmask i
    * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not
      `subsetSize`
    """"""
    maxMask = 1 << len(nums)
    incompatibilities = [-1] * maxMask
    for mask in range(maxMask):
      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):
        incompatibilities[mask] = self._getIncompatibility(nums, mask)
    return incompatibilities

  def _isUnique(self, nums: list[int], mask: int, subsetSize: int) -> bool:
    """"""Returns True if the numbers selected by `mask` are unique.""""""
    used = 0
    for i, num in enumerate(nums):
      if mask >> i & 1:
        used |= 1 << num
    return used.bit_count() == subsetSize

  def _getIncompatibility(self, nums: list[int], mask: int) -> int:
    """"""
    Returns the incompatibility of the selected numbers represented by the
    `mask`.
    """"""
    mn = self.kMaxNum
    mx = 0
    for i, num in enumerate(nums):
      if mask >> i & 1:
        mx = max(mx, num)
        mn = min(mn, num)
    return mx - mn"
"1682","class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is
    # ('a' + k).
    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]

    for d in range(1, n):
      for i in range(n - d):
        for k in range(27):
          j = i + d
          if s[i] == s[j] and s[i] != chr(ord('a') + k):
            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2
          else:
            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])

    return dp[0][n - 1][26]"
"1683","SELECT tweet_id
FROM Tweets
WHERE CHAR_LENGTH(content) > 15;"
"1684","class Solution:
  def countConsistentStrings(self, allowed: str, words: list[str]) -> int:
    return sum(all(c in allowed for c in word)
               for word in words)"
"1685","class Solution:
  def getSumAbsoluteDifferences(self, nums: list[int]) -> list[int]:
    prefix = list(itertools.accumulate(nums))
    suffix = list(itertools.accumulate(nums[::-1]))[::-1]
    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)
            for i, num in enumerate(nums)]"
"1686","class Solution {
 public:
  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
    const int n = aliceValues.size();
    vector<vector<int>> values;
    int a = 0;
    int b = 0;

    for (int i = 0; i < n; ++i)
      values.push_back({aliceValues[i], bobValues[i]});

    ranges::sort(values, ranges::greater{},
                 [](const vector<int>& value) { return value[0] + value[1]; });

    for (int i = 0; i < n; ++i)
      if (i % 2 == 0)
        a += values[i][0];
      else
        b += values[i][1];

    return a > b ? 1 : a < b ? -1 : 0;
  }
};"
"1687","class Solution:
  def boxDelivering(
      self,
      boxes: list[list[int]],
      portsCount: int,
      maxBoxes: int,
      maxWeight: int,
  ) -> int:
    n = len(boxes)
    # dp[i] := the minimum trips to deliver boxes[0..i) and return to the
    # storage
    dp = [0] * (n + 1)
    trips = 2
    weight = 0

    l = 0
    for r in range(n):
      weight += boxes[r][1]

      # The current box is different from the previous one, need to make one
      # more trip.
      if r > 0 and boxes[r][0] != boxes[r - 1][0]:
        trips += 1

      # Loading boxes[l] in the previous turn is always no bad than loading it
      # in this turn
      while r - l + 1 > maxBoxes or weight > maxWeight or (
              l < r and dp[l + 1] == dp[l]):
        weight -= boxes[l][1]
        if boxes[l][0] != boxes[l + 1][0]:
          trips -= 1
        l += 1

      #   min trips to deliver boxes[0..r]
      # = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]
      dp[r + 1] = dp[l] + trips

    return dp[n]"
"1688","class Solution:
  def numberOfMatches(self, n: int) -> int:
    return n - 1"
"1689","class Solution:
  def minPartitions(self, n: str) -> int:
    return int(max(n))"
"169","class Solution:
  def majorityElement(self, nums: list[int]) -> int:
    ans = None
    count = 0

    for num in nums:
      if count == 0:
        ans = num
      count += (1 if num == ans else -1)

    return ans"
"1690","class Solution {
  public int stoneGameVII(int[] stones) {
    final int n = stones.length;
    // dp[i][j] := the maximum score you can get more than your opponent in stones[i..j]
    int[][] dp = new int[n][n];
    int[] prefix = new int[n + 1];

    for (int i = 0; i < n; ++i)
      prefix[i + 1] = stones[i] + prefix[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        final int j = i + d;
        dp[i][j] = Math.max(prefix[j + 1] - prefix[i + 1] - dp[i + 1][j],
                            prefix[j] - prefix[i] - dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
}"
"1691","class Solution {
  public int maxHeight(int[][] cuboids) {
    // For each cuboid, sort it so that c[0] <= c[1] <= c[2].
    for (int[] cuboid : cuboids)
      Arrays.sort(cuboid);

    Arrays.sort(cuboids, new Comparator<int[]>() {
      @Override
      public int compare(int[] a, int[] b) {
        if (a[0] != b[0])
          return a[0] - b[0];
        if (a[1] != b[1])
          return a[1] - b[1];
        return a[2] - b[2];
      }
    });

    // dp[i] := the maximum height with cuboids[i] in the bottom
    int[] dp = new int[cuboids.length];

    for (int i = 0; i < cuboids.length; ++i)
      dp[i] = cuboids[i][2];

    for (int i = 1; i < cuboids.length; ++i)
      for (int j = 0; j < i; ++j)
        if (cuboids[j][0] <= cuboids[i][0] && //
            cuboids[j][1] <= cuboids[i][1] && //
            cuboids[j][2] <= cuboids[i][2])
          dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);

    return Arrays.stream(dp).max().getAsInt();
  }
}"
"1692","class Solution {
  public int waysToDistribute(int n, int k) {
    final int kMod = 1_000_000_007;
    long[][] dp = new long[k + 1][n + 1];

    for (int i = 0; i <= k; ++i)
      dp[i][i] = 1;

    for (int i = 1; i <= k; ++i)
      for (int j = i + 1; j <= n; ++j)
        dp[i][j] = (dp[i - 1][j - 1] + i * dp[i][j - 1]) % kMod;

    return (int) dp[k][n];
  }
}"
"1693","SELECT
  date_id,
  make_name,
  COUNT(DISTINCT lead_id) AS unique_leads,
  COUNT(DISTINCT partner_id) AS unique_partners
FROM DailySales
GROUP BY 1, 2;"
"1694","class Solution:
  def reformatNumber(self, number: str) -> str:
    ans = []

    number = number.replace(""-"", """").replace("" "", """")

    i = 0  # number's index
    while i + 4 < len(number):
      ans.append(number[i:i + 3] + '-')
      i += 3

    countFinalDigits = len(number) - i
    if countFinalDigits < 4:
      ans.append(number[i:])
    else:  # countFinalDigits == 4
      ans.append(number[i:i + 2] + '-' + number[i + 2:])

    return ''.join(ans)"
"1695","class Solution:
  def maximumUniqueSubarray(self, nums: list[int]) -> int:
    ans = 0
    score = 0
    seen = set()

    l = 0
    for r, num in enumerate(nums):
      while num in seen:
        score -= nums[l]
        seen.remove(nums[l])
        l += 1
      seen.add(nums[r])
      score += nums[r]
      ans = max(ans, score)

    return ans"
"1696","class Solution:
  def maxResult(self, nums: list[int], k: int) -> int:
    # Stores dp[i] within the bounds.
    maxQ = collections.deque([0])
    # dp[i] := the maximum score to consider nums[0..i]
    dp = [0] * len(nums)
    dp[0] = nums[0]

    for i in range(1, len(nums)):
      # Pop the index if it's out-of-bounds.
      if maxQ[0] + k < i:
        maxQ.popleft()
      dp[i] = dp[maxQ[0]] + nums[i]
      # Pop indices that won't be chosen in the future.
      while maxQ and dp[maxQ[-1]] <= dp[i]:
        maxQ.pop()
      maxQ.append(i)

    return dp[-1]"
"1697","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,
                                         vector<vector<int>>& queries) {
    vector<bool> ans(queries.size());
    UnionFind uf(n);

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    ranges::sort(queries, ranges::less{},
                 [](const vector<int>& query) { return query[2]; });
    ranges::sort(edgeList, ranges::less{},
                 [](const vector<int>& edge) { return edge[2]; });

    int i = 0;  // i := edgeList's index
    for (const vector<int>& query : queries) {
      const int p = query[0];
      const int q = query[1];
      const int limit = query[2];
      // Union edges whose distances < limit.
      while (i < edgeList.size() && edgeList[i][2] < limit)
        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);
      if (uf.find(p) == uf.find(q))
        ans[query.back()] = true;
    }

    return ans;
  }
};"
"1698","class Solution:
  def countDistinct(self, s: str) -> int:
    kBase = 26
    kHash = 1_000_000_007

    n = len(s)
    ans = 0
    pow = [1] + [0] * n     # pow[i] := kBase^i
    hashes = [0] * (n + 1)  # hashes[i] := the hash of s[0..i)

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c)

    for i in range(1, n + 1):
      pow[i] = pow[i - 1] * kBase % kHash
      hashes[i] = (hashes[i - 1] * kBase + val(s[i - 1])) % kHash

    def getHash(l: int, r: int) -> int:
      """"""Returns the hash of s[l..r).""""""
      hash = (hashes[r] - hashes[l] * pow[r - l]) % kHash
      return hash + kHash if hash < 0 else hash

    for length in range(1, n + 1):
      seen = set()
      for i in range(n - length + 1):
        seen.add(getHash(i, i + length))
      ans += len(seen)

    return ans"
"1699","SELECT
  LEAST(from_id, to_id) AS person1,
  GREATEST(from_id, to_id) AS person2,
  COUNT(*) AS call_count,
  SUM(duration) AS total_duration
FROM Calls
GROUP BY 1, 2;"
"17","class Solution:
  def letterCombinations(self, digits: str) -> list[str]:
    if not digits:
      return []

    digitToLetters = ['', '', 'abc', 'def', 'ghi',
                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
    ans = []

    def dfs(i: int, path: list[str]) -> None:
      if i == len(digits):
        ans.append(''.join(path))
        return

      for letter in digitToLetters[int(digits[i])]:
        path.append(letter)
        dfs(i + 1, path)
        path.pop()

    dfs(0, [])
    return ans"
"170","class TwoSum:
  def __init__(self):
    self.count = collections.Counter()

  def add(self, number: int) -> None:
    self.count[number] += 1

  def find(self, value: int) -> bool:
    for key, freq in self.count.items():
      remain = value - key
      if key == remain and freq > 1:
        return True
      if key != remain and remain in self.count:
        return True

    return False"
"1700","class Solution:
  def countStudents(self, students: list[int], sandwiches: list[int]) -> int:
    count = collections.Counter(students)

    for i, sandwich in enumerate(sandwiches):
      if count[sandwich] == 0:
        return len(sandwiches) - i
      count[sandwich] -= 1

    return 0"
"1701","class Solution {
 public:
  double averageWaitingTime(vector<vector<int>>& customers) {
    double wait = 0;
    double curr = 0;

    for (const vector<int>& c : customers) {
      curr = max(curr, 1.0 * c[0]) + c[1];
      wait += curr - c[0];
    }

    return 1.0 * wait / customers.size();
  }
};"
"1702","class Solution:
  def maximumBinaryString(self, binary: str) -> str:
    #     e.g. binary = '100110'
    # Do Operation 2 -> '100011'
    # Do Operation 1 -> '111011'
    # So, the index of the only '0' is prefixOnes + zeros - 1.
    zeros = binary.count('0')
    prefixOnes = binary.find('0')

    # Make the entire string as 1s.
    ans = ['1'] * len(binary)

    # Make the only '0' if necessary.
    if prefixOnes != -1:
      ans[prefixOnes + zeros - 1] = '0'
    return ''.join(ans)"
"1703","class Solution {
 public:
  int minMoves(vector<int>& nums, int k) {
    vector<int> ones;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1)
        ones.push_back(i);

    // Returns the median index of [i..i + k).
    auto getMedIndex = [&](int i) { return (i + (i + k - 1)) / 2; };

    // Calculate the first group: window[0] = A[0..k).
    const int median = ones[getMedIndex(0)];
    int moves = 0;
    for (int i = 0; i < k; ++i)
      moves += abs(ones[i] - median);

    int ans = moves;

    for (int i = 1; i <= ones.size() - k; ++i) {
      const int oldMedianIndex = ones[getMedIndex(i - 1)];
      const int newMedianIndex = ones[getMedIndex(i)];
      if (k % 2 == 1)
        moves += newMedianIndex - oldMedianIndex;
      moves -= newMedianIndex - ones[i - 1];
      moves += ones[i + k - 1] - newMedianIndex;
      ans = min(ans, moves);
    }

    auto nThSum = [&](int n) { return n * (n + 1) / 2; };
    return ans - nThSum((k - 1) / 2) - nThSum(k / 2);
  }
};"
"1704","class Solution:
  def halvesAreAlike(self, s: str) -> bool:
    kVowels = 'aeiouAEIOU'
    aVowelsCount = sum(c in kVowels for c in s[:len(s) // 2])
    bVowelsCount = sum(c in kVowels for c in s[len(s) // 2:])
    return aVowelsCount == bVowelsCount"
"1705","class Solution:
  def eatenApples(self, apples: list[int], days: list[int]) -> int:
    n = len(apples)
    ans = 0
    minHeap = []  # (the rotten day, the number of apples)

    i = 0
    while i < n or minHeap:
      # Remove the rotten apples.
      while minHeap and minHeap[0][0] <= i:
        heapq.heappop(minHeap)
      # Add today's apples.
      if i < n and apples[i] > 0:
        heapq.heappush(minHeap, (i + days[i], apples[i]))
      # Eat one apple today.
      if minHeap:
        rottenDay, numApples = heapq.heappop(minHeap)
        if numApples > 1:
          heapq.heappush(minHeap, (rottenDay, numApples - 1))
        ans += 1
      i += 1

    return ans"
"1706","class Solution:
  def findBall(self, grid: list[list[int]]) -> list[int]:
    m = len(grid)
    n = len(grid[0])
    # dp[i] := status of the i-th column
    # -1 := empty, 0 := b0, 1 := b1, ...
    dp = [i for i in range(n)]
    # ans[i] := the i-th ball's final positio
    ans = [-1] * n

    for i in range(m):
      newDp = [-1] * n
      for j in range(n):
        # out-of-bounds
        if j + grid[i][j] < 0 or j + grid[i][j] == n:
          continue
        if (grid[i][j] == 1 and grid[i][j + 1] == -1 or
                grid[i][j] == -1 and grid[i][j - 1] == 1):
          continue
        newDp[j + grid[i][j]] = dp[j]
      dp = newDp

    for i, ball in enumerate(dp):
      if ball != -1:
        ans[ball] = i

    return ans"
"1707","from dataclasses import dataclass


class TrieNode:
  def __init__(self):
    self.children: list[TrieNode | None] = [None] * 2


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]

  def getMaxXor(self, num: int) -> int:
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      toggleBit = bit ^ 1
      if node.children[toggleBit]:
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:  # There's nothing in the Bit Trie.
        return 0
    return maxXor


@dataclass(frozen=True)
class IndexedQuery:
  queryIndex: int
  x: int
  m: int

  def __iter__(self):
    yield self.queryIndex
    yield self.x
    yield self.m


class Solution:
  def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:
    ans = [-1] * len(queries)
    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))
    bitTrie = BitTrie(maxBit)

    nums.sort()

    i = 0  # nums' index
    for queryIndex, x, m in sorted([IndexedQuery(i, x, m)
                                    for i, (x, m) in enumerate(queries)],
                                   key=lambda x: x.m):
      while i < len(nums) and nums[i] <= m:
        bitTrie.insert(nums[i])
        i += 1
      if i > 0 and nums[i - 1] <= m:
        ans[queryIndex] = bitTrie.getMaxXor(x)

    return ans"
"1708","class Solution:
  def largestSubarray(self, nums: list[int], k: int) -> list[int]:
    mx = max(nums[:len(nums) - k + 1])
    i = nums.index(mx)
    return nums[i:i + k]"
"1709","WITH
  UserToWindow AS (
    SELECT
      user_id,
      DATEDIFF(
        LEAD(visit_date, 1, '2021-01-01') OVER(
          PARTITION BY user_id
          ORDER BY visit_date
        ),
        visit_date
      ) AS `window`
    FROM userVisits
  )
SELECT
  user_id,
  MAX(`window`) AS biggest_window
FROM UserToWindow
GROUP BY user_id;"
"171","class Solution:
  def titleToNumber(self, columnTitle: str) -> int:
    return functools.reduce(lambda subtotal, c:
                            subtotal * 26 + ord(c) - ord('@'), columnTitle, 0)"
"1710","class Solution:
  def maximumUnits(self, boxTypes: list[list[int]], truckSize: int) -> int:
    ans = 0

    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):
      if boxes >= truckSize:
        return ans + truckSize * units
      ans += boxes * units
      truckSize -= boxes

    return ans"
"1711","class Solution:
  def countPairs(self, deliciousness: list[int]) -> int:
    kMod = 10**9 + 7
    kMaxBit = 20 + 1
    ans = 0
    count = collections.Counter()

    for d in deliciousness:
      for i in range(kMaxBit + 1):
        power = 1 << i
        ans += count[power - d]
        ans %= kMod
      count[d] += 1

    return ans"
"1712","class Solution:
  def waysToSplit(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0
    prefix = list(itertools.accumulate(nums))

    j = 0
    k = 0
    for i in range(n - 2):
      # Find the first index j s.t.
      # left = prefix[i] <= mid = prefix[j] - prefix[i]
      j = max(j, i + 1)
      while j < n - 1 and prefix[i] > prefix[j] - prefix[i]:
        j += 1
      # Find the first index k s.t.
      # mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]
      k = max(k, j)
      while k < n - 1 and prefix[k] - prefix[i] <= prefix[-1] - prefix[k]:
        k += 1
      ans += k - j
      ans %= kMod

    return ans"
"1713","class Solution:
  def minOperations(self, target: list[int], arr: list[int]) -> int:
    indices = []
    numToIndex = {num: i for i, num in enumerate(target)}

    for a in arr:
      if a in numToIndex:
        indices.append(numToIndex[a])

    return len(target) - self._lengthOfLIS(indices)

  # Same as 300. Longest Increasing Subsequence
  def _lengthOfLIS(self, nums: list[int]) -> int:
    # tails[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tails = []
    for num in nums:
      if not tails or num > tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_left(tails, num)] = num
    return len(tails)"
"1714","class Solution:
  def solve(self, nums: list[int], queries: list[list[int]]) -> list[int]:
    kMod = 10**9 + 7
    n = len(nums)
    sqrtN = int(n**0.5)
    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n
    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].
    prefix = [[num] * sqrtN for num in nums]

    for x in range(n - 1, -1, -1):
      for y in range(1, sqrtN):
        if x + y < n:
          prefix[x][y] += prefix[x + y][y]
          prefix[x][y] %= kMod

    return [prefix[x][y] if y < sqrtN
            else sum(nums[x::y]) % kMod
            for x, y in queries]"
"1715","SELECT
  SUM(Boxes.apple_count + IFNULL(Chests.apple_count, 0)) AS apple_count,
  SUM(Boxes.orange_count + IFNULL(Chests.orange_count, 0)) AS orange_count
FROM Boxes
LEFT JOIN Chests
  USING (chest_id);"
"1716","class Solution:
  def totalMoney(self, n: int) -> int:
    def trapezoid(a: int, b: int) -> int:
      """"""Returns sum(a..b).""""""
      return (a + b) * (b - a + 1) // 2

    weeks = n // 7
    firstWeek = trapezoid(1, 7)
    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)
    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)
    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays"
"1717","class Solution:
  def maximumGain(self, s: str, x: int, y: int) -> int:
    # The assumption that gain('ab') > gain('ba') while removing 'ba' first is
    # optimal is contradicted. Only 'b(ab)a' satisfies the condition of
    # preventing two 'ba' removals, but after removing 'ab', we can still
    # remove one 'ba', resulting in a higher gain. Thus, removing 'ba' first is
    # not optimal.
    return (self._gain(s, 'ab', x, 'ba', y) if x > y else
            self._gain(s, 'ba', y, 'ab', x))

  # Returns the points gained by first removing sub1 ('ab' | 'ba') from s with
  # point1, then removing sub2 ('ab' | 'ba') from s with point2.
  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:
    points = 0
    stack1 = []
    stack2 = []

    # Remove 'sub1' from s with point1 gain.
    for c in s:
      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:
        stack1.pop()
        points += point1
      else:
        stack1.append(c)

    # Remove 'sub2' from s with point2 gain.
    for c in stack1:
      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:
        stack2.pop()
        points += point2
      else:
        stack2.append(c)

    return points"
"1718","class Solution:
  def constructDistancedSequence(self, n: int) -> list[int]:
    ans = [0] * (2 * n - 1)

    def dfs(i: int, mask: int) -> bool:
      if i == len(ans):
        return True
      if ans[i] > 0:
        return dfs(i + 1, mask)

      # Greedily fill in `ans` in descending order.
      for num in range(n, 0, -1):
        if (mask >> num & 1) == 1:
          continue
        if num == 1:
          ans[i] = num
          if dfs(i + 1, mask | 1 << num):
            return True
          ans[i] = 0
        else:  # num in [2, n]
          if i + num >= len(ans) or ans[i + num] > 0:
            continue
          ans[i] = num
          ans[i + num] = num
          if dfs(i + 1, mask | 1 << num):
            return True
          ans[i + num] = 0
          ans[i] = 0

      return False

    dfs(0, 0)
    return ans"
"1719","class Solution:
  def checkWays(self, pairs: list[list[int]]) -> int:
    kMax = 501
    graph = collections.defaultdict(list)
    degrees = [0] * kMax
    connected = [[False] * kMax for _ in range(kMax)]

    for u, v in pairs:
      graph[u].append(v)
      graph[v].append(u)
      degrees[u] += 1
      degrees[v] += 1
      connected[u][v] = True
      connected[v][u] = True

    # For each node, sort its children by degrees in descending order.
    for _, children in graph.items():
      children.sort(key=lambda x: -degrees[x])

    # Find the root with a degree that equals to n - 1.
    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)
    if root == -1:
      return 0

    hasMoreThanOneWay = False

    def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:
      """"""
      Returns True if each node rooted at u is connected to all of its
      ancestors.
      """"""
      nonlocal hasMoreThanOneWay
      seen[u] = True
      for ancestor in ancestors:
        if not connected[u][ancestor]:
          return False
      ancestors.append(u)
      for v in graph[u]:
        if seen[v]:
          continue
        if degrees[v] == degrees[u]:
          hasMoreThanOneWay = True
        if not dfs(v, ancestors, seen):
          return False
      ancestors.pop()
      return True

    if not dfs(root, [], [False] * kMax):
      return 0
    return 2 if hasMoreThanOneWay else 1"
"172","class Solution:
  def trailingZeroes(self, n: int) -> int:
    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)"
"1720","class Solution:
  def decode(self, encoded: list[int], first: int) -> list[int]:
    ans = [first]

    for e in encoded:
      ans.append(e ^ ans[-1])

    return ans"
"1721","class Solution:
  def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:
    p = None  # Points the k-th node from the beginning.
    q = None  # Points the k-th node from the end.

    curr = head
    while curr:
      if q:
        q = q.next
      k -= 1
      if k == 0:
        p = curr
        q = head
      curr = curr.next

    p.val, q.val = q.val, p.val
    return head"
"1722","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def minimumHammingDistance(
      self,
      source: list[int],
      target: list[int],
      allowedSwaps: list[list[int]],
  ) -> int:
    n = len(source)
    ans = 0
    uf = UnionFind(n)
    groupIdToCount = [collections.Counter() for _ in range(n)]

    for a, b in allowedSwaps:
      uf.unionByRank(a, b)

    for i in range(n):
      groupIdToCount[uf.find(i)][source[i]] += 1

    for i in range(n):
      groupId = uf.find(i)
      count = groupIdToCount[groupId]
      if target[i] not in count:
        ans += 1
      else:
        count[target[i]] -= 1
        if count[target[i]] == 0:
          del count[target[i]]

    return ans"
"1723","class Solution:
  def minimumTimeRequired(self, jobs: list[int], k: int) -> int:
    ans = sum(jobs)
    times = [0] * k  # times[i] := accumulate time of workers[i]

    # Assign the most time-consuming job first.
    jobs.sort(reverse=True)

    def dfs(s: int) -> None:
      nonlocal ans
      if s == len(jobs):
        ans = min(ans, max(times))
        return
      for i in range(k):
        # There is no need to explore assigning jobs[s] to workers[i] further as
        # it would not yield better results.
        if times[i] + jobs[s] >= ans:
          continue
        times[i] += jobs[s]
        dfs(s + 1)
        times[i] -= jobs[s]
        # It's always non-optimal to have a worker with no jobs.
        if times[i] == 0:
          return

    dfs(0)
    return ans"
"1724","class UnionFind {
  public UnionFind(int n) {
    id = new TreeMap[n];
    for (int i = 0; i < n; ++i) {
      id[i] = new TreeMap<>();
      id[i].put(0, i);
    }
  }

  public void union(int u, int v, int limit) {
    final int i = find(u, limit);
    final int j = find(v, limit);
    if (i == j)
      return;
    id[i].put(limit, j);
  }

  public int find(int u, int limit) {
    // the maximum key of id[u] <= limit
    final int floorKey = id[u].floorKey(limit);
    final int i = id[u].get(floorKey);
    if (i == u)
      return u;
    // Recursively find i's id.
    final int j = find(i, limit);
    id[u].put(limit, j);
    return j;
  }

  // id[i]'s (key, value) := (limit, id of node i <= limit)
  private TreeMap<Integer, Integer>[] id;
}

class DistanceLimitedPathsExist {
  public DistanceLimitedPathsExist(int n, int[][] edgeList) {
    uf = new UnionFind(n);

    Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));

    for (int[] edge : edgeList) {
      final int u = edge[0];
      final int v = edge[1];
      final int d = edge[2];
      uf.union(u, v, d);
    }
  }

  public boolean query(int p, int q, int limit) {
    return uf.find(p, limit - 1) == uf.find(q, limit - 1);
  }

  private UnionFind uf;
}"
"1725","class Solution:
  def countGoodRectangles(self, rectangles: list[list[int]]) -> int:
    minSides = [min(x, y) for x, y in rectangles]
    return minSides.count(max(minSides))"
"1726","class Solution:
  def tupleSameProduct(self, nums: list[int]) -> int:
    # nums of ways to arrange (a, b) = 2
    # nums of ways to arrange (c, d) = 2
    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8
    ans = 0
    count = collections.Counter()

    for i in range(len(nums)):
      for j in range(i):
        prod = nums[i] * nums[j]
        ans += count[prod] * 8
        count[prod] += 1

    return ans"
"1727","class Solution:
  def largestSubmatrix(self, matrix: list[list[int]]) -> int:
    ans = 0
    hist = [0] * len(matrix[0])

    for row in matrix:
      # Accumulate the histogram if possible.
      for i, num in enumerate(row):
        hist[i] = 0 if num == 0 else hist[i] + 1

      # Get the sorted histogram.
      sortedHist = sorted(hist)

      # Greedily calculate the answer.
      for i, h in enumerate(sortedHist):
        ans = max(ans, h * (len(row) - i))

    return ans"
"1728","class Solution:
  def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    nFloors = 0
    cat = 0  # cat's position
    mouse = 0  # mouse's position

    def hash(i: int, j: int) -> int:
      return i * n + j

    for i in range(m):
      for j in range(n):
        if grid[i][j] != '#':
          nFloors += 1
        if grid[i][j] == 'C':
          cat = hash(i, j)
        elif grid[i][j] == 'M':
          mouse = hash(i, j)

    @functools.lru_cache(None)
    def dp(cat: int, mouse: int, turn: int) -> bool:
      """"""
      Returns True if the mouse can win, where the cat is on (i / 8, i % 8), the
      mouse is on (j / 8, j % 8), and the turns is k.
      """"""
      # We already search the whole touchable grid.
      if turn == nFloors * 2:
        return False

      if turn % 2 == 0:
        # the mouse's turn
        i = mouse // n
        j = mouse % n
        for dx, dy in dirs:
          for jump in range(mouseJump + 1):
            x = i + dx * jump
            y = j + dy * jump
            if x < 0 or x == m or y < 0 or y == n:
              break
            if grid[x][y] == '#':
              break
            # The mouse eats the food, so the mouse wins.
            if grid[x][y] == 'F':
              return True
            if dp(cat, hash(x, y), turn + 1):
              return True
        # The mouse can't win, so the mouse loses.
        return False
      else:
        # the cat's turn
        i = cat // n
        j = cat % n
        for dx, dy in dirs:
          for jump in range(catJump + 1):
            x = i + dx * jump
            y = j + dy * jump
            if x < 0 or x == m or y < 0 or y == n:
              break
            if grid[x][y] == '#':
              break
            # The cat eats the food, so the mouse loses.
            if grid[x][y] == 'F':
              return False
            nextCat = hash(x, y)
            # The cat catches the mouse, so the mouse loses.
            if nextCat == mouse:
              return False
            if not dp(nextCat, mouse, turn + 1):
              return False
        # The cat can't win, so the mouse wins.
        return True

    return dp(cat, mouse, 0)"
"1729","SELECT
  user_id,
  COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY 1
ORDER BY 1;"
"173","class BSTIterator:
  def __init__(self, root: TreeNode | None):
    self.i = 0
    self.vals = []
    self._inorder(root)

  def next(self) -> int:
    self.i += 1
    return self.vals[self.i - 1]

  def hasNext(self) -> bool:
    return self.i < len(self.vals)

  def _inorder(self, root: TreeNode | None) -> None:
    if not root:
      return
    self._inorder(root.left)
    self.vals.append(root.val)
    self._inorder(root.right)"
"1730","class Solution:
  def getFood(self, grid: list[list[str]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    ans = 0
    q = collections.deque([self._getStartLocation(grid)])

    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if grid[x][y] == 'X':
            continue
          if grid[x][y] == '#':
            return ans + 1
          q.append((x, y))
          grid[x][y] = 'X'  # Mark as visited.
      ans += 1

    return -1

  def _getStartLocation(self, grid: list[list[str]]) -> tuple[int, int]:
    for i, row in enumerate(grid):
      for j, cell in enumerate(row):
        if cell == '*':
          return (i, j)"
"1731","SELECT
  Manager.employee_id,
  Manager.name,
  COUNT(Employee.employee_id) AS reports_count,
  ROUND(AVG(Employee.age)) AS average_age
FROM Employees AS Manager
INNER JOIN Employees AS Employee
  ON (Employee.reports_to = Manager.employee_id)
GROUP BY 1
ORDER BY 1;"
"1732","class Solution:
  def largestAltitude(self, gain: list[int]) -> int:
    ans = 0
    currAltitude = 0
    for g in gain:
      currAltitude += g
      ans = max(ans, currAltitude)
    return ans"
"1733","class Solution:
  def minimumTeachings(
      self,
      n: int,
      languages: list[list[int]],
      friendships: list[list[int]],
  ) -> int:
    languageSets = [set(languages) for languages in languages]
    needTeach = set()
    languageCount = collections.Counter()

    # Find friends that can't communicate.
    for u, v in friendships:
      if not languageSets[u - 1] & languageSets[v - 1]:
        needTeach.add(u - 1)
        needTeach.add(v - 1)

    # Find the most popular language.
    for u in needTeach:
      for language in languageSets[u]:
        languageCount[language] += 1

    # Teach the most popular language to people don't understand.
    return len(needTeach) - max(languageCount.values(), default=0)"
"1734","class Solution:
  def decode(self, encoded: list[int]) -> list[int]:
    # Our goal is to find the value of a1, which will allow us to decode a2, a3,
    # ..., an. This can be achieved by performing XOR operation between each
    # element in `encoded` and a1.
    #
    # e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3].
    #               encoded = [a1^a2, a2^a3]
    #    accumulatedEncoded = [a1^a2, a1^a3]
    #    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)
    #    a2 = a1^(a1^a2)
    #    a3 = a2^(a2^a3)
    n = len(encoded) + 1
    nXors = functools.reduce(operator.xor, [i for i in range(1, n + 1)])

    # Instead of constructing the array, we can track of the running XOR value
    # of `accumulatedEncoded`.
    xors = 0  # xors(accumulatedEncoded)

    for encode in encoded:
      runningXors ^= encode
      xors ^= runningXors

    ans = [xors ^ nXors]

    for encode in encoded:
      ans.append(ans[-1] ^ encode)

    return ans"
"1735","class Solution:
  def waysToFillArray(self, queries: list[list[int]]) -> list[int]:
    kMod = 1_000_000_007
    kMax = 10_000
    minPrimeFactors = self._sieveEratosthenes(kMax + 1)

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    @functools.lru_cache(None)
    def nCk(n: int, k: int) -> int:
      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod

    ans = []

    for n, k in queries:
      res = 1
      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():
        res = res * nCk(n - 1 + freq, freq) % kMod
      ans.append(res)

    return ans

  def _sieveEratosthenes(self, n: int) -> list[int]:
    """"""Gets the minimum prime factor of i, where 1 < i <= n.""""""
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:  # `i` is prime.
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: list[int]) -> dict[int, int]:
    count = collections.Counter()
    while num > 1:
      divisor = minPrimeFactors[num]
      while num % divisor == 0:
        num //= divisor
        count[divisor] += 1
    return count"
"1736","class Solution:
  def maximumTime(self, time: str) -> str:
    ans = list(time)
    if time[0] == '?':
      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'
    if time[1] == '?':
      ans[1] = '3' if ans[0] == '2' else '9'
    if time[3] == '?':
      ans[3] = '5'
    if time[4] == '?':
      ans[4] = '9'
    return ''.join(ans)"
"1737","class Solution {
 public:
  int minCharacters(string a, string b) {
    const int m = a.length();
    const int n = b.length();
    vector<int> countA(26);
    vector<int> countB(26);

    for (const char c : a)
      ++countA[c - 'a'];

    for (const char c : b)
      ++countB[c - 'a'];

    int ans = INT_MAX;
    int prevA = 0;  // the number of characters in a <= c
    int prevB = 0;  // the number of characters in b <= c

    for (char c = 'a'; c <= 'z'; ++c) {
      // the condition 3
      ans = min(ans, m + n - countA[c - 'a'] - countB[c - 'a']);
      // the conditions 1 and 2
      if (c > 'a')
        ans = min({ans, m - prevA + prevB, n - prevB + prevA});
      prevA += countA[c - 'a'];
      prevB += countB[c - 'a'];
    }

    return ans;
  }
};"
"1738","class Solution {
 public:
  int kthLargestValue(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> xors(m + 1, vector<int>(n + 1));
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j) {
        xors[i][j] = xors[i - 1][j] ^ xors[i][j - 1] ^ xors[i - 1][j - 1] ^
                     matrix[i - 1][j - 1];
        minHeap.push(xors[i][j]);
        if (minHeap.size() > k)
          minHeap.pop();
      }

    return minHeap.top();
  }
};"
"1739","class Solution:
  def minimumBoxes(self, n: int) -> int:
    nBoxes = 0
    nextTouchings = 0  # j
    currLevelBoxes = 0  # 1 + 2 + ... + j

    # Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)
    # >= n
    while nBoxes < n:
      nextTouchings += 1
      currLevelBoxes += nextTouchings
      nBoxes += currLevelBoxes

    # If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.
    if nBoxes == n:
      return currLevelBoxes

    # Otherwise, need to remove the boxes in the current level and rebuild it.
    nBoxes -= currLevelBoxes
    currLevelBoxes -= nextTouchings
    nextTouchings = 0

    while nBoxes < n:
      nextTouchings += 1
      nBoxes += nextTouchings

    return currLevelBoxes + nextTouchings"
"174","class Solution:
  def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:
    m = len(dungeon)
    n = len(dungeon[0])
    dp = [math.inf] * (n + 1)
    dp[n - 1] = 1

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]
        dp[j] = max(dp[j], 1)

    return dp[0]"
"1740","class Solution:
  def findDistance(self, root: TreeNode, p: int, q: int) -> int:
    def getLCA(root, p, q):
      if not root or root.val == p or root.val == q:
        return root

      l = getLCA(root.left, p, q)
      r = getLCA(root.right, p, q)

      if l and r:
        return root
      return l or r

    def dist(lca, target):
      if not lca:
        return 10000
      if lca.val == target:
        return 0
      return 1 + min(dist(lca.left, target), dist(lca.right, target))

    lca = getLCA(root, p, q)
    return dist(lca, p) + dist(lca, q)"
"1741","SELECT
  event_day AS day,
  emp_id,
  SUM(out_time - in_time) AS total_time
FROM Employees
GROUP BY 1, 2;"
"1742","class Solution:
  def countBalls(self, lowLimit: int, highLimit: int) -> int:
    maxDigitSum = 9 * 5  # 99999
    ans = 0
    count = [0] * (maxDigitSum + 1)

    for num in range(lowLimit, highLimit + 1):
      digitSum = self._getDigitSum(num)
      count[digitSum] += 1
      ans = max(ans, count[digitSum])

    return ans

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"1743","class Solution:
  def restoreArray(self, adjacentPairs: list[list[int]]) -> list[int]:
    ans = []
    numToAdjs = collections.defaultdict(list)

    for a, b in adjacentPairs:
      numToAdjs[a].append(b)
      numToAdjs[b].append(a)

    for num, adjs in numToAdjs.items():
      if len(adjs) == 1:
        ans.append(num)
        ans.append(adjs[0])
        break

    while len(ans) < len(adjacentPairs) + 1:
      tail = ans[-1]
      prev = ans[-2]
      adjs = numToAdjs[tail]
      if adjs[0] == prev:  # adjs[0] is already used
        ans.append(adjs[1])
      else:
        ans.append(adjs[0])

    return ans"
"1744","class Solution:
  def canEat(
      self,
      candiesCount: list[int],
      queries: list[list[int]]
  ) -> list[bool]:
    prefix = list(itertools.accumulate(candiesCount, initial=0))
    return [prefix[t] // c <= d < prefix[t + 1] for t, d, c in queries]"
"1745","class Solution:
  def checkPartitioning(self, s: str) -> bool:
    n = len(s)
    # dp[i][j] := true if s[i..j] is a palindrome
    dp = [[False] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = True

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]

    for i in range(n):
      for j in range(i + 1, n):
        if dp[0][i] and dp[i + 1][j] and dp[j + 1][n - 1]:
          return True

    return False"
"1746","class Solution:
  def maxSumAfterOperation(self, nums: list[int]) -> int:
    ans = -math.inf
    regular = 0
    squared = 0

    for num in nums:
      squared = max(num**2, regular + num**2, squared + num)
      regular = max(num, regular + num)
      ans = max(ans, squared)

    return ans"
"1747","WITH
  LogInfoNeighbors AS (
    SELECT
      *,
      LEAD(ip_address) OVER(
        PARTITION BY account_id
        ORDER BY login
      ) AS next_ip_address,
      LEAD(login) OVER(
        PARTITION BY account_id
        ORDER BY login
      ) next_login
    FROM LogInfo
  )
SELECT DISTINCT account_id
FROM LogInfoNeighbors
WHERE
  next_login <= logout
  AND ip_address != next_ip_address;"
"1748","class Solution:
  def sumOfUnique(self, nums: list[int]) -> int:
    return sum(num
               for num, freq in collections.Counter(nums).items()
               if freq == 1)"
"1749","class Solution:
  def maxAbsoluteSum(self, nums):
    summ = 0
    maxPrefix = 0
    minPrefix = 0

    for num in nums:
      summ += num
      maxPrefix = max(maxPrefix, summ)
      minPrefix = min(minPrefix, summ)

    return maxPrefix - minPrefix"
"175","SELECT
  Person.firstName,
  Person.lastName,
  Address.city,
  Address.state
FROM Person
LEFT JOIN Address
  USING (personId);"
"1750","class Solution:
  def minimumLength(self, s: str) -> int:
    i = 0
    j = len(s) - 1

    while i < j and s[i] == s[j]:
      c = s[i]
      while i <= j and s[i] == c:
        i += 1
      while i <= j and s[j] == c:
        j -= 1

    return j - i + 1"
"1751","class Solution:
  def maxValue(self, events: list[list[int]], k: int) -> int:
    events.sort()

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""
      Returns the maximum sum of values that you can receive by attending
      events[i..n), where k is the maximum number of attendance.
      """"""
      if k == 0 or i == len(events):
        return 0

      # Binary search `events` to find the first index j
      # s.t. events[j][0] > events[i][1].
      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)
      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))

    return dp(0, k)"
"1752","class Solution {
  public boolean check(int[] nums) {
    final int n = nums.length;
    int rotates = 0;

    for (int i = 0; i < n; ++i)
      if (nums[i] > nums[(i + 1) % n] && ++rotates > 1)
        return false;

    return true;
  }
}"
"1753","class Solution {
  public int maximumScore(int a, int b, int c) {
    // the maximum <= the minimum + the middle
    final int x = (a + b + c) / 2;
    // the maximum > the minimum + the middle
    final int y = a + b + c - Math.max(a, Math.max(b, c));
    return Math.min(x, y);
  }
}"
"1754","class Solution:
  def largestMerge(self, word1: str, word2: str) -> str:
    if not word1:
      return word2
    if not word2:
      return word1
    if word1 > word2:
      return word1[0] + self.largestMerge(word1[1:], word2)
    return word2[0] + self.largestMerge(word1, word2[1:])"
"1755","class Solution:
  def minAbsDifference(self, nums: list[int], goal: int) -> int:
    n = len(nums) // 2
    ans = math.inf
    lSums = []
    rSums = []

    def dfs(A: list[int], i: int, path: int, sums: list[int]) -> None:
      if i == len(A):
        sums.append(path)
        return
      dfs(A, i + 1, path + A[i], sums)
      dfs(A, i + 1, path, sums)

    dfs(nums[:n], 0, 0, lSums)
    dfs(nums[n:], 0, 0, rSums)
    rSums.sort()

    for lSum in lSums:
      i = bisect_left(rSums, goal - lSum)
      if i < len(rSums):  # 2^n
        ans = min(ans, abs(goal - lSum - rSums[i]))
      if i > 0:
        ans = min(ans, abs(goal - lSum - rSums[i - 1]))

    return ans"
"1756","from sortedcontainers import SortedList


class MRUQueue:
  def __init__(self, n: int):
    # [(priority value, actual value)]
    self.q = SortedList((i, i) for i in range(1, n + 1))

  def fetch(self, k: int) -> int:
    _, num = self.q.pop(k - 1)
    if self.q:
      maxPriority = self.q[-1][0]
      self.q.add((maxPriority + 1, num))
    else:
      self.q.add((0, num))
    return num"
"1757","SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y';"
"1758","class Solution:
  def minOperations(self, s: str) -> int:
    # the cost to make s ""1010""
    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))
    # the cost to make s ""0101""
    cost01 = len(s) - cost10
    return min(cost10, cost01)"
"1759","class Solution:
  def countHomogenous(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = 0
    currentChar = '@'

    for c in s:
      count = count + 1 if c == currentChar else 1
      currentChar = c
      ans += count
      ans %= kMod

    return ans"
"176","WITH
  RankedEmployees AS (
    SELECT *, DENSE_RANK() OVER(ORDER BY salary DESC) AS `rank`
    FROM Employee
  )
SELECT MAX(salary) AS SecondHighestSalary
FROM RankedEmployees
WHERE `rank` = 2;"
"1760","class Solution:
  def minimumSize(self, nums: list[int], maxOperations: int) -> int:
    # Returns the number of operations required to make m penalty.
    def numOperations(m: int) -> int:
      return sum((num - 1) // m for num in nums) <= maxOperations
    return bisect.bisect_left(range(1, max(nums)), True,
                              key=lambda m: numOperations(m)) + 1"
"1761","class Solution:
  def minTrioDegree(self, n: int, edges: list[list[int]]) -> int:
    ans = math.inf
    graph = [set() for _ in range(n)]
    degrees = [0] * n

    for u, v in edges:
      u -= 1
      v -= 1
      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.
      graph[min(u, v)].add(max(u, v))
      degrees[u] += 1
      degrees[v] += 1

    for u in range(n):
      for v in graph[u]:
        for w in graph[u]:
          if w in graph[v]:
            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)

    return -1 if ans == math.inf else ans"
"1762","class Solution:
  def findBuildings(self, heights: list[int]) -> list[int]:
    stack = []

    for i, height in enumerate(heights):
      while stack and heights[stack[-1]] <= height:
        stack.pop()
      stack.append(i)

    return stack"
"1763","class Solution:
  def longestNiceSubstring(self, s: str) -> str:
    if len(s) < 2:
      return ''

    seen = set(s)

    for i, c in enumerate(s):
      # If both upper and lower case letters exists in the string, keep moving,
      # else take the erroneous character as a partition and check for its left
      # and right parts to be nice strings.
      if c.swapcase() not in seen:
        prefix = self.longestNiceSubstring(s[:i])
        suffix = self.longestNiceSubstring(s[i + 1:])
        return max(prefix, suffix, key=len)

    return s"
"1764","class Solution:
  def canChoose(self, groups: list[list[int]], nums: list[int]) -> bool:
    i = 0  # groups' index
    j = 0  # nums' index

    while i < len(groups) and j < len(nums):
      if self._isMatch(groups[i], nums, j):
        j += len(groups[i])
        i += 1
      else:
        j += 1

    return i == len(groups)

  # Returns True if group == nums[j..j + |group|].
  def _isMatch(self, group: list[int], nums: list[int], j: int) -> bool:
    if j + |group | > len(nums):
      return False
    for i, g in enumerate(group):
      if g != nums[j + i]:
        return False
    return True"
"1765","class Solution:
  def highestPeak(self, isWater: list[list[int]]) -> list[list[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(isWater)
    n = len(isWater[0])
    ans = [[-1] * n for _ in range(m)]
    q = collections.deque()

    for i in range(m):
      for j in range(n):
        if isWater[i][j] == 1:
          q.append((i, j))
          ans[i][j] = 0

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if ans[x][y] != -1:
          continue
        ans[x][y] = ans[i][j] + 1
        q.append((x, y))

    return ans"
"1766","class Solution:
  def getCoprimes(self, nums: list[int], edges: list[list[int]]) -> list[int]:
    kMax = 50
    ans = [-1] * len(nums)
    tree = [[] for _ in range(len(nums))]
    # stacks[i] := (node, depth)s of nodes with value i
    stacks = [[] for _ in range(kMax + 1)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def getAncestor(u: int) -> int:
      maxNode = -1
      maxDepth = -1
      for i, stack in enumerate(stacks):
        if stack and stack[-1][1] > maxDepth and math.gcd(nums[u], i) == 1:
          maxNode, maxDepth = stack[-1]
      return maxNode

    def dfs(u: int, prev: int, depth: int) -> int:
      ans[u] = getAncestor(u)
      stacks[nums[u]].append((u, depth))

      for v in tree[u]:
        if v != prev:
          dfs(v, u, depth + 1)

      stacks[nums[u]].pop()

    dfs(0, -1, 0)
    return ans"
"1767","WITH
  RECURSIVE TaskToSubtask AS (
    SELECT task_id, subtasks_count AS subtask_id FROM Tasks
    UNION ALL
    SELECT task_id, subtask_id - 1 FROM TaskToSubtask
    WHERE subtask_id > 1
  )
SELECT * FROM TaskToSubtask
EXCEPT
SELECT * FROM Executed;"
"1768","class Solution:
  def mergeAlternately(self, word1: str, word2: str) -> str:
    return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))"
"1769","class Solution {
  public int[] minOperations(String boxes) {
    int[] ans = new int[boxes.length()];

    for (int i = 0, count = 0, moves = 0; i < boxes.length(); ++i) {
      ans[i] += moves;
      count += boxes.charAt(i) == '1' ? 1 : 0;
      moves += count;
    }

    for (int i = boxes.length() - 1, count = 0, moves = 0; i >= 0; --i) {
      ans[i] += moves;
      count += boxes.charAt(i) == '1' ? 1 : 0;
      moves += count;
    }

    return ans;
  }
}"
"177","CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
    WITH
      RankedEmployees AS (
        SELECT *, DENSE_RANK() OVER(ORDER BY salary DESC) AS `rank`
        FROM Employee
      )
    SELECT MAX(salary) AS SecondHighestSalary
    FROM RankedEmployees
    WHERE `rank` = N
  );
END"
"1770","class Solution:
  def maximumScore(self, nums: list[int], multipliers: list[int]) -> int:
    @functools.lru_cache(2000)
    def dp(s: int, i: int) -> int:
      """"""Returns the maximum score of nums[s..e] and multipliers[i].""""""
      if i == len(multipliers):
        return 0

      # The number of nums picked on the start side is s.
      # The number of nums picked on the end side is i - s.
      # So, e = n - (i - s) - 1.
      e = len(nums) - (i - s) - 1
      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)
      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)
      return max(pickStart, pickEnd)

    return dp(0, 0)"
"1771","class Solution {
 public:
  int longestPalindrome(string word1, string word2) {
    const string& s = word1 + word2;
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := the length of LPS(s[i..j])
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          dp[i][j] = 2 + dp[i + 1][j - 1];
          if (i < word1.length() && j >= word1.length())
            ans = max(ans, dp[i][j]);
        } else {
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
      }

    return ans;
  }
};"
"1772","class Solution {
  public String[] sortFeatures(String[] features, String[] responses) {
    String[] ans = new String[features.length];
    int[][] featCount = new int[features.length][]; // {i: count[features[i]]}
    Map<String, Integer> count = new HashMap<>();

    for (final String res : responses)
      for (final String token : new HashSet<>(Arrays.asList(res.split("" ""))))
        count.merge(token, 1, Integer::sum);

    for (int i = 0; i < features.length; ++i)
      featCount[i] = new int[] {i, count.getOrDefault(features[i], 0)};

    Arrays.sort(featCount,
                (a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(b[1], a[1]));

    for (int i = 0; i < features.length; ++i)
      ans[i] = features[featCount[i][0]];

    return ans;
  }
}"
"1773","class Solution {
 public:
  int countMatches(vector<vector<string>>& items, string ruleKey,
                   string ruleValue) {
    const int index = ruleKey == ""type"" ? 0 : ruleKey == ""color"" ? 1 : 2;
    return ranges::count_if(items, [index, &ruleValue](const auto& item) {
      return item[index] == ruleValue;
    });
  }
};"
"1774","class Solution {
 public:
  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts,
                  int target) {
    int ans = INT_MAX;

    for (const int baseCost : baseCosts)
      dfs(toppingCosts, 0, target, baseCost, ans);

    return ans;
  }

 private:
  void dfs(const vector<int>& toppingCosts, int i, int target, int currCost,
           int& ans) {
    if (abs(currCost - target) < abs(ans - target))
      ans = currCost;
    if (i == toppingCosts.size() || currCost >= target)
      return;

    for (int k = 0; k < 3; ++k)
      dfs(toppingCosts, i + 1, target, currCost + k * toppingCosts[i], ans);
  }
};"
"1775","class Solution {
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())
      return -1;

    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
    if (sum1 > sum2)
      return minOperations(nums2, nums1);

    int ans = 0;
    // increasing in `nums1` and decreasing in `nums2`
    vector<int> count(6);

    for (const int num : nums1)
      ++count[6 - num];

    for (const int num : nums2)
      ++count[num - 1];

    for (int i = 5; sum2 > sum1;) {
      while (count[i] == 0)
        --i;
      sum1 += i;
      --count[i];
      ++ans;
    }

    return ans;
  }
};"
"1776","class Solution:
  def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:
    ans = []
    stack = []  # (pos, speed, collisionTime)

    def getCollisionTime(
            car: tuple[int, int, int],
            pos: int, speed: int) -> float:
      return (car[0] - pos) / (speed - car[1])

    for pos, speed in reversed(cars):
      while stack and (
              speed <= stack[-1][1] or getCollisionTime(stack[-1],
                                                        pos, speed) >=
              stack[-1][2]):
        stack.pop()
      if stack:
        collisionTime = getCollisionTime(stack[-1], pos, speed)
        stack.append((pos, speed, collisionTime))
        ans.append(collisionTime)
      else:
        stack.append((pos, speed, math.inf))
        ans.append(-1)

    return ans[::-1]"
"1777","SELECT
  product_id,
  MAX(CASE WHEN store = 'store1' THEN price END) AS store1,
  MAX(CASE WHEN store = 'store2' THEN price END) AS store2,
  MAX(CASE WHEN store = 'store3' THEN price END) AS store3
FROM Products
GROUP BY 1;"
"1778","/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *   boolean canMove(char direction);
 *   void move(char direction);
 *   boolean isTarget();
 * }
 */

enum Grid { kUnvisited, kStart, kTarget, kBlocked, kEmpty }

class Solution {
  public int findShortestPath(GridMaster master) {
    final int m = 501;
    final int startX = m;
    final int startY = m;
    Grid[][] grid = new Grid[m * 2][m * 2];
    Arrays.stream(grid).forEach(A -> Arrays.fill(A, Grid.kUnvisited));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY);

    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(startX, startY)));
    grid[startX][startY] = Grid.kBlocked;

    // Find the steps by BFS.
    for (int step = 1; !q.isEmpty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        final int i = q.peek().getKey();
        final int j = q.poll().getValue();
        for (int[] dir : dirs) {
          final int x = i + dir[0];
          final int y = j + dir[1];
          if (grid[x][y] == Grid.kTarget)
            return step;
          if (grid[x][y] == Grid.kBlocked)
            continue;
          grid[x][y] = Grid.kBlocked;
          q.offer(new Pair<>(x, y));
        }
      }

    return -1;
  }

  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  private static final char[] charTable = {'R', 'D', 'L', 'U'};

  private void dfs(GridMaster master, Grid[][] grid, int i, int j) {
    if (grid[i][j] != Grid.kUnvisited)
      return;
    if (master.isTarget())
      grid[i][j] = Grid.kTarget;
    else
      grid[i][j] = Grid.kEmpty;

    for (int k = 0; k < 4; ++k) {
      final int x = i + dirs[k][0];
      final int y = j + dirs[k][1];
      final char d = charTable[k];
      final char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d)) {
        master.move(d);
        dfs(master, grid, x, y);
        master.move(undoD);
      } else {
        grid[x][y] = Grid.kBlocked;
      }
    }
  }
}"
"1779","class Solution {
  public int nearestValidPoint(int x, int y, int[][] points) {
    int ans = -1;
    int minDist = Integer.MAX_VALUE;

    for (int i = 0; i < points.length; ++i) {
      final int dx = x - points[i][0];
      final int dy = y - points[i][1];
      if (dx == 0 || dy == 0) {
        final int dist = Math.abs(dx + dy);
        if (dist < minDist) {
          minDist = dist;
          ans = i;
        }
      }
    }

    return ans;
  }
}"
"178","SELECT
  score,
  DENSE_RANK() OVER(ORDER BY score DESC) AS `rank`
FROM Scores;"
"1780","class Solution:
  def checkPowersOfThree(self, n: int) -> bool:
    while n > 1:
      n, r = divmod(n, 3)
      if r == 2:
        return False
    return True"
"1781","class Solution:
  def beautySum(self, s: str) -> int:
    ans = 0

    for i in range(len(s)):
      count = collections.Counter()
      for j in range(i, len(s)):
        count[s[j]] += 1
        ans += max(count.values()) - min(count.values())

    return ans"
"1782","class Solution:
  def countPairs(
      self,
      n: int,
      edges: list[list[int]],
      queries: list[int],
  ) -> list[int]:
    ans = [0] * len(queries)

    # count[i] := the number of edges of node i
    count = [0] * (n + 1)

    # shared[i][j] := the number of edges incident to i or j, where i < j
    shared = [collections.Counter() for _ in range(n + 1)]

    for u, v in edges:
      count[u] += 1
      count[v] += 1
      shared[min(u, v)][max(u, v)] += 1

    sortedCount = sorted(count)

    for k, query in enumerate(queries):
      i = 1
      j = n
      while i < j:
        if sortedCount[i] + sortedCount[j] > query:
          # sortedCount[i] + sortedCount[j] > query
          # sortedCount[i + 1] + sortedCount[j] > query
          # ...
          # sortedCount[j - 1] + sortedCount[j] > query
          # So, there are (j - 1) - i + 1 = j - i pairs > query
          ans[k] += j - i
          j -= 1
        else:
          i += 1
      for i in range(1, n + 1):
        for j, sh in shared[i].items():
          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:
            ans[k] -= 1

    return ans"
"1783","SELECT
  Players.player_id,
  Players.player_name,
  SUM(Players.player_id = Championships.Wimbledon) + SUM(Players.player_id = Championships.Fr_open) + SUM(Players.player_id = Championships.US_open) + SUM(Players.player_id = Championships.Au_open) AS grand_slams_count
FROM Players
INNER JOIN Championships
  ON (
    Players.player_id IN (
      Championships.Wimbledon,
      Championships.Fr_open,
      Championships.US_open,
      Championships.Au_open
    )
  )
GROUP BY 1;"
"1784","class Solution:
  def checkOnesSegment(self, s: str) -> bool:
    return '01' not in s"
"1785","class Solution {
  public int minElements(int[] nums, int limit, int goal) {
    final long sum = Arrays.stream(nums).asLongStream().sum();
    final double diff = Math.abs(goal - sum);
    return (int) Math.ceil(diff / limit);
  }
}"
"1786","class Solution:
  def countRestrictedPaths(self, n: int, edges: list[list[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u - 1].append((v - 1, w))
      graph[v - 1].append((u - 1, w))

    return self._dijkstra(graph, 0, n - 1)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      dst: int,
  ) -> int:
    kMod = 10**9 + 7
    # ways[i] := the number of restricted path from i to n
    ways = [0] * len(graph)
    # dist[i] := the distance to the last node of i
    dist = [math.inf] * len(graph)

    ways[dst] = 1
    dist[dst] = 0
    minHeap = [(dist[dst], dst)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))
        if dist[v] < dist[u]:
          ways[u] += ways[v]
          ways[u] %= kMod

    return ways[src]"
"1787","class Solution:
  def minChanges(self, nums: list[int], k: int) -> int:
    kMax = 1024
    n = len(nums)
    # counts[i] := the counter that maps at the i-th position
    counts = [collections.Counter() for _ in range(k)]
    # dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k - 1]) is j
    dp = [[n] * kMax for _ in range(k)]

    for i, num in enumerate(nums):
      counts[i % k][num] += 1

    def countAt(i: int) -> int:
      return n // k + (1 if n % k > i else 0)

    # Initialize the DP array.
    for j in range(kMax):
      dp[k - 1][j] = countAt(k - 1) - counts[k - 1][j]

    for i in range(k - 2, -1, -1):
      # The worst-case scenario is changing all the i-th position numbers to a
      # non-existent value in the current bucket.
      changeAll = countAt(i) + min(dp[i + 1])
      for j in range(kMax):
        dp[i][j] = changeAll
        for num, freq in counts[i].items():
          # the cost to change every number in the i-th position to `num`
          cost = countAt(i) - freq
          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost)

    return dp[0][0]"
"1788","class Solution:
  def maximumBeauty(self, flowers: list[int]) -> int:
    ans = -math.inf
    prefix = 0
    flowerToPrefix = collections.defaultdict(int)

    for flower in flowers:
      if flower in flowerToPrefix:
        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)
      prefix += max(0, flower)
      flowerToPrefix.setdefault(flower, prefix)

    return ans"
"1789","SELECT
  employee_id,
  department_id
FROM Employee
WHERE primary_flag = 'Y'
UNION DISTINCT
SELECT
  employee_id,
  department_id
FROM Employee
GROUP BY 1
HAVING COUNT(*) = 1;"
"179","class LargerStrKey(str):
  def __lt__(x: str, y: str) -> bool:
    return x + y > y + x


class Solution:
  def largestNumber(self, nums: list[int]) -> str:
    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'"
"1790","class Solution:
  # Similar to 859. Buddy Strings
  def areAlmostEqual(self, s1: str, s2: str) -> bool:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    return not diffIndices or (len(diffIndices) == 2 and
                               s1[diffIndices[0]] == s2[diffIndices[1]] and
                               s1[diffIndices[1]] == s2[diffIndices[0]])"
"1791","class Solution:
  def findCenter(self, edges: list[list[int]]) -> int:
    if edges[0][0] in edges[1]:
      return edges[0][0]
    return edges[0][1]"
"1792","class Solution:
  def maxAverageRatio(
      self,
      classes: list[list[int]],
      extraStudents: int,
  ) -> float:
    def extraPassRatio(pas: int, total: int) -> float:
      """"""Returns the extra pass ratio if a brilliant student joins.""""""
      return (pas + 1) / (total + 1) - pas / total

    maxHeap = [(-extraPassRatio(pas, total), pas, total)
               for pas, total in classes]
    heapq.heapify(maxHeap)

    for _ in range(extraStudents):
      _, pas, total = heapq.heappop(maxHeap)
      heapq.heappush(
          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))

    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)"
"1793","class Solution:
  # Similar to 84. Largest Rectangle in Histogram
  def maximumScore(self, nums: list[int], k: int) -> int:
    ans = 0
    stack = []

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):
        h = nums[stack.pop()]
        w = i - stack[-1] - 1 if stack else i
        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:
          ans = max(ans, h * w)
      stack.append(i)

    return ans"
"1794","class Solution:
  def countQuadruples(self, s1: str, s2: str) -> int:
    # To minimize j - a, the length of the substring should be 1. This is
    # because for substrings with a size greater than 1, a will decrease,
    # causing j - a to become larger.
    ans = 0
    diff = math.inf  # diff := j - a
    firstJ = {}
    lastA = {}

    for j in range(len(s1) - 1, -1, -1):
      firstJ[s1[j]] = j

    for a in range(len(s2)):
      lastA[s2[a]] = a

    for c in string.ascii_lowercase:
      if c not in firstJ or c not in lastA:
        continue
      if firstJ[c] - lastA[c] < diff:
        diff = firstJ[c] - lastA[c]
        ans = 0
      if firstJ[c] - lastA[c] == diff:
        ans += 1

    return ans"
"1795","SELECT
  product_id,
  'store1' AS store,
  store1 AS price
FROM Products
WHERE store1 IS NOT NULL
UNION ALL
SELECT
  product_id,
  'store2',
  store2
FROM Products
WHERE store2 IS NOT NULL
UNION ALL
SELECT
  product_id,
  'store3',
  store3
FROM Products
WHERE store3 IS NOT NULL;"
"1796","class Solution:
  def secondHighest(self, s: str) -> int:
    maxDigit = -1
    secondMaxDigit = -1

    for c in s:
      if c.isdigit():
        d = int(c)
        if d > maxDigit:
          secondMaxDigit = maxDigit
          maxDigit = d
        elif maxDigit > d > secondMaxDigit:
          secondMaxDigit = d

    return secondMaxDigit"
"1797","from sortedcontainers import SortedSet


class AuthenticationManager:
  def __init__(self, timeToLive: int):
    self.timeToLive = timeToLive
    self.tokenIdToExpiryTime = {}
    self.times = SortedSet()

  def generate(self, tokenId: str, currentTime: int) -> None:
    self.tokenIdToExpiryTime[tokenId] = currentTime
    self.times.add(currentTime)

  def renew(self, tokenId: str, currentTime: int) -> None:
    if (tokenId not in self.tokenIdToExpiryTime or
            currentTime >= self.tokenIdToExpiryTime[tokenId] + self.timeToLive):
      return
    self.times.remove(self.tokenIdToExpiryTime[tokenId])
    self.tokenIdToExpiryTime[tokenId] = currentTime
    self.times.add(currentTime)

  def countUnexpiredTokens(self, currentTime: int) -> int:
    i = self.times.bisect_left(currentTime - self.timeToLive + 1)
    # Remove expired tokens.
    for _ in range(i):
      self.times.remove(self.times[0])
    return len(self.times)"
"1798","class Solution:
  def getMaximumConsecutive(self, coins: list[int]) -> int:
    ans = 1  # the next value we want to make

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

    return ans"
"1799","class Solution:
  def maxScore(self, nums: list[int]) -> int:
    n = len(nums) // 2

    @functools.lru_cache(None)
    def dp(k: int, mask: int) -> int:
      """"""
      Returns the maximum score you can receive after performing the k to n
      operations, where `mask` is the bitmask of the chosen numbers.
      """"""
      if k == n + 1:
        return 0

      res = 0

      for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
          chosenMask = 1 << i | 1 << j
          if (mask & chosenMask) == 0:
            res = max(
                res, k * math.gcd(nums[i], nums[j]) + dp(k + 1, mask | chosenMask))

      return res

    return dp(1, 0)"
"18","class Solution:
  def fourSum(self, nums: list[int], target: int):
    ans = []

    def nSum(
            l: int, r: int, target: int, n: int, path: list[int],
            ans: list[list[int]]) -> None:
      """"""Finds n numbers that add up to the target in [l, r].""""""
      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:
        return
      if n == 2:
        while l < r:
          summ = nums[l] + nums[r]
          if summ == target:
            ans.append(path + [nums[l], nums[r]])
            l += 1
            while nums[l] == nums[l - 1] and l < r:
              l += 1
          elif summ < target:
            l += 1
          else:
            r -= 1
        return

      for i in range(l, r + 1):
        if i > l and nums[i] == nums[i - 1]:
          continue

        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)

    nums.sort()
    nSum(0, len(nums) - 1, target, 4, [], ans)
    return ans"
"180","WITH
  LogsNeighbors AS (
    SELECT
      *,
      LAG(num) OVER(ORDER BY id) AS prev_num,
      LEAD(num) OVER(ORDER BY id) AS next_num
    FROM LOGS
  )
SELECT DISTINCT num AS ConsecutiveNums
FROM LogsNeighbors
WHERE
  num = prev_num
  AND num = next_num;"
"1800","class Solution:
  def maxAscendingSum(self, nums: list[int]) -> int:
    ans = 0
    sum = nums[0]

    for i in range(1, len(nums)):
      if nums[i] > nums[i - 1]:
        sum += nums[i]
      else:
        ans = max(ans, sum)
        sum = nums[i]

    return max(ans, sum)"
"1801","class Solution {
  public int getNumberOfBacklogOrders(int[][] orders) {
    final int kMod = 1_000_000_007;
    int ans = 0;
    Queue<int[]> buysMaxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));
    Queue<int[]> sellsMinHeap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

    for (int[] order : orders) {
      if (order[2] == 0)
        buysMaxHeap.offer(order);
      else
        sellsMinHeap.offer(order);
      while (!buysMaxHeap.isEmpty() && !sellsMinHeap.isEmpty() &&
             buysMaxHeap.peek()[0] >= sellsMinHeap.peek()[0]) {
        final int minAmount = Math.min(buysMaxHeap.peek()[1], sellsMinHeap.peek()[1]);
        buysMaxHeap.peek()[1] -= minAmount;
        sellsMinHeap.peek()[1] -= minAmount;
        if (buysMaxHeap.peek()[1] == 0)
          buysMaxHeap.poll();
        if (sellsMinHeap.peek()[1] == 0)
          sellsMinHeap.poll();
      }
    }

    while (!buysMaxHeap.isEmpty()) {
      ans += buysMaxHeap.poll()[1];
      ans %= kMod;
    }

    while (!sellsMinHeap.isEmpty()) {
      ans += sellsMinHeap.poll()[1];
      ans %= kMod;
    }

    return ans;
  }
}"
"1802","class Solution {
  public int maxValue(int n, int index, int maxSum) {
    maxSum -= n;

    int l = 0;
    int r = maxSum;

    // Find the first value x s.t. if A[index] = x, then sum(A) >= maxSum.
    while (l < r) {
      final int m = (l + r) / 2;
      if (getSum(n, index, m) >= maxSum)
        r = m;
      else
        l = m + 1;
    }

    return getSum(n, index, l) > maxSum ? l : l + 1;
  }

  // Returns the minimum sum if nums[index] = x.
  private long getSum(int n, int index, int x) {
    long l = Math.min(index, x - 1);
    long r = Math.min(n - index, x);
    long lSum = ((x - 1) + (x - 1 - l + 1)) * l / 2;
    long rSum = (x + (x - r + 1)) * r / 2;
    return lSum + rSum;
  }
}"
"1803","class TrieNode {
  public TrieNode[] children = new TrieNode[2];
  public int count = 0;
}

class Solution {
  public int countPairs(int[] nums, int low, int high) {
    int ans = 0;

    for (final int num : nums) {
      ans += getCount(num, high + 1) - getCount(num, low);
      insert(num);
    }

    return ans;
  }

  private final int kHeight = 14;
  private TrieNode root = new TrieNode();

  private void insert(int num) {
    TrieNode node = root;
    for (int i = kHeight; i >= 0; --i) {
      final int bit = num >> i & 1;
      if (node.children[bit] == null)
        node.children[bit] = new TrieNode();
      node = node.children[bit];
      ++node.count;
    }
  }

  // Returns the number of numbers < limit.
  private int getCount(int num, int limit) {
    int count = 0;
    TrieNode node = root;
    for (int i = kHeight; i >= 0; --i) {
      final int bit = num >> i & 1;
      final int bitLimit = ((limit >> i) & 1);
      if (bitLimit == 1) {
        if (node.children[bit] != null)
          count += node.children[bit].count;
        node = node.children[bit ^ 1];
      } else {
        node = node.children[bit];
      }
      if (node == null)
        break;
    }
    return count;
  }
}"
"1804","class TrieNode {
  public TrieNode[] children = new TrieNode[26];
  public int prefixCount = 0;
  public int wordCount = 0;
}

class Trie {
  public void insert(String word) {
    TrieNode node = root;
    for (final char c : word.toCharArray()) {
      final int i = c - 'a';
      if (node.children[i] == null)
        node.children[i] = new TrieNode();
      node = node.children[i];
      ++node.prefixCount;
    }
    ++node.wordCount;
  }

  public int countWordsEqualTo(String word) {
    TrieNode node = find(word);
    return node == null ? 0 : node.wordCount;
  }

  public int countWordsStartingWith(String prefix) {
    TrieNode node = find(prefix);
    return node == null ? 0 : node.prefixCount;
  }

  public void erase(String word) {
    TrieNode node = root;
    for (final char c : word.toCharArray()) {
      final int i = c - 'a';
      node = node.children[i];
      --node.prefixCount;
    }
    --node.wordCount;
  }

  private TrieNode root = new TrieNode();

  private TrieNode find(final String s) {
    TrieNode node = root;
    for (final char c : s.toCharArray()) {
      final int i = c - 'a';
      if (node.children[i] == null)
        return null;
      node = node.children[i];
    }
    return node;
  }
}"
"1805","class Solution:
  def numDifferentIntegers(self, word: str) -> int:
    nums = set()
    curr = []

    for c in word:
      if c.isdigit():
        curr.append(c)
      elif curr:
        nums.add(''.join(self._removeLeadingZeros(curr)))
        curr = []

    if curr:
      nums.add(''.join(self._removeLeadingZeros(curr)))

    return len(nums)

  def _removeLeadingZeros(self, s: str) -> str:
    index = next((i for i, c in enumerate(s) if c != '0'), -1)
    return ['0'] if index == -1 else s[index:]"
"1806","class Solution {
  public int reinitializePermutation(int n) {
    int ans = 0;
    int i = 1;

    do {
      if (i < n / 2)
        i = i * 2;
      else
        i = (i - n / 2) * 2 + 1;
      ++ans;
    } while (i != 1);

    return ans;
  }
}"
"1807","class Solution {
  public String evaluate(String s, List<List<String>> knowledge) {
    StringBuilder sb = new StringBuilder();
    Map<String, String> map = new HashMap<>();

    for (List<String> list : knowledge)
      map.put(""("" + list.get(0) + "")"", list.get(1));

    for (int i = 0; i < s.length(); ++i) {
      final char c = s.charAt(i);
      if (c == '(') {
        final int j = s.indexOf(')', i);
        sb.append(map.getOrDefault(s.substring(i, j + 1), ""?""));
        i = j;
      } else {
        sb.append(c);
      }
    }

    return sb.toString();
  }
}"
"1808","class Solution {
 public:
  int maxNiceDivisors(int primeFactors) {
    if (primeFactors <= 3)
      return primeFactors;
    if (primeFactors % 3 == 0)
      return modPow(3, primeFactors / 3) % kMod;
    if (primeFactors % 3 == 1)
      return 4L * modPow(3, (primeFactors - 4) / 3) % kMod;
    return 2L * modPow(3, (primeFactors - 2) / 3) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};"
"1809","SELECT Playback.session_id
FROM Playback
LEFT JOIN Ads
  ON (
    Playback.customer_id = Ads.customer_id
    AND Ads.timestamp BETWEEN Playback.start_time AND Playback.end_time)
WHERE Ads.ad_id IS NULL;"
"181","SELECT Worker.name AS Employee
FROM Employee AS Worker
INNER JOIN Employee AS Manager
  ON (Worker.managerId = Manager.id)
WHERE Worker.salary > Manager.salary;"
"1810","/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *   boolean canMove(char direction);
 *   int move(char direction);
 *   boolean isTarget();
 * }
 */

class Solution {
  public int findShortestPath(GridMaster master) {
    final int m = 100;
    final int startX = m;
    final int startY = m;
    int[] target = {m * 2, m * 2};
    int[][] grid = new int[m * 2][m * 2];
    boolean[][] seen = new boolean[m * 2][m * 2];
    Arrays.stream(grid).forEach(A -> Arrays.fill(A, -1));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY, target);

    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2])) {
      { offer(new int[] {startX, startY, 0}); }
    };

    // Find the steps by BFS.
    while (!minHeap.isEmpty()) {
      final int i = minHeap.peek()[0];
      final int j = minHeap.peek()[1];
      final int cost = minHeap.poll()[2];
      if (i == target[0] && j == target[1])
        return cost;
      if (seen[i][j])
        continue;
      seen[i][j] = true;
      for (int[] dir : dirs) {
        final int x = i + dir[0];
        final int y = j + dir[1];
        if (x < 0 || x == 2 * m || y < 0 || y == 2 * m)
          continue;
        if (seen[x][y] || grid[x][y] == -1)
          continue;
        final int nextCost = cost + grid[x][y];
        minHeap.offer(new int[] {x, y, nextCost});
      }
    }

    return -1;
  }

  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  private static final char[] charTable = {'R', 'D', 'L', 'U'};

  private void dfs(GridMaster master, int[][] grid, int i, int j, int[] target) {
    if (master.isTarget()) {
      target[0] = i;
      target[1] = j;
    }

    for (int k = 0; k < 4; ++k) {
      final int x = i + dirs[k][0];
      final int y = j + dirs[k][1];
      final char d = charTable[k];
      final char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d) && grid[x][y] == -1) {
        grid[x][y] = master.move(d);
        dfs(master, grid, x, y, target);
        master.move(undoD);
      }
    }
  }
}"
"1811","WITH
  UserToContest AS (
    SELECT gold_medal AS user_id, contest_id FROM Contests
    UNION ALL
    SELECT silver_medal AS user_id, contest_id FROM Contests
    UNION ALL
    SELECT bronze_medal AS user_id, contest_id FROM Contests
  ),
  UserToContestWithGroupId AS (
    SELECT
      user_id,
      contest_id - ROW_NUMBER() OVER(
        PARTITION BY user_id
        ORDER BY contest_id
      ) AS group_id
    FROM UserToContest
  ),
  CandidateUserIds AS (
    -- consecutive medal winners
    SELECT user_id
    FROM UserToContestWithGroupId
    GROUP BY user_id, group_id
    HAVING COUNT(*) >= 3
    UNION DISTINCT
    -- gold medal winners
    SELECT gold_medal AS user_id
    FROM Contests
    GROUP BY user_id
    HAVING COUNT(*) >= 3
  )
SELECT
  Users.name,
  Users.mail
FROM CandidateUserIds
INNER JOIN Users
  USING (user_id);"
"1812","class Solution:
  def squareIsWhite(self, coordinates: str) -> bool:
    letter, digit = coordinates
    return ord(letter) % 2 != int(digit) % 2"
"1813","class Solution:
  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
    if len(sentence1) == len(sentence2):
      return sentence1 == sentence2

    words1 = sentence1.split()
    words2 = sentence2.split()
    m, n = map(len, (words1, words2))
    if m > n:
      return self.areSentencesSimilar(sentence2, sentence1)

    i = 0  # words1's index
    while i < m and words1[i] == words2[i]:
      i += 1
    while i < m and words1[i] == words2[i + n - m]:
      i += 1

    return i == m"
"1814","class Solution:
  def countNicePairs(self, nums: list[int]) -> int:
    freqs = collections.Counter(num - int(str(num)[::-1]) for num in nums)
    return sum(freq * (freq - 1) // 2 for freq in freqs.values()) % 1000000007"
"1815","class Solution:
  def maxHappyGroups(self, batchSize: int, groups: list[int]) -> int:
    happy = 0
    freq = [0] * batchSize

    for g in groups:
      g %= batchSize
      if g == 0:
        happy += 1
      elif freq[batchSize - g]:
        freq[batchSize - g] -= 1
        happy += 1
      else:
        freq[g] += 1

    @functools.lru_cache(None)
    def dp(freq: int, remainder: int) -> int:
      """"""Returns the maximum number of partitions can be formed.""""""
      ans = 0
      if any(freq):
        for i, f in enumerate(freq):
          if f:
            ans = max(ans, dp(freq[:i] + (f - 1,) +
                              freq[i + 1:], (remainder + i) % batchSize))
        if remainder == 0:
          ans += 1
      return ans

    return happy + dp(tuple(freq), 0)"
"1816","class Solution:
  def truncateSentence(self, s: str, k: int) -> str:
    return ' '.join(s.split()[:k])"
"1817","class Solution:
  def findingUsersActiveMinutes(
      self,
      logs: list[list[int]],
      k: int,
  ) -> list[int]:
    idToTimes = collections.defaultdict(set)

    for id, time in logs:
      idToTimes[id].add(time)

    c = collections.Counter(len(times) for times in idToTimes.values())
    return [c[i] for i in range(1, k + 1)]"
"1818","class Solution:
  def minAbsoluteSumDiff(self, nums1: list[int], nums2: list[int]) -> int:
    ans = math.inf
    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]
    sumDiff = sum(diffs)

    nums1.sort()

    for num, diff in zip(nums2, diffs):
      i = bisect.bisect_left(nums1, num)
      if i > 0:
        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))
      if i < len(nums1):
        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))

    return ans % int(1e9 + 7)"
"1819","class Solution {
 public:
  int countDifferentSubsequenceGCDs(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    int ans = 0;
    // factor[i] := the GCD of numbers having factor i
    vector<int> factor(maxNum + 1);

    for (const int num : nums)
      for (int i = 1; i * i <= num; ++i)
        if (num % i == 0) {
          const int j = num / i;
          factor[i] = __gcd(factor[i], num);
          factor[j] = __gcd(factor[j], num);
        }

    for (int i = 1; i <= maxNum; ++i)
      if (factor[i] == i)
        ++ans;

    return ans;
  }
};"
"182","SELECT email
FROM Person
GROUP BY 1
HAVING COUNT(*) > 1;"
"1820","class Solution:
  def maximumInvitations(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    mates = [-1] * n  # mates[i] := the i-th girl's mate

    def canInvite(i: int, seen: list[bool]) -> bool:
      """"""Returns True if the i-th boy can make an invitation.""""""
      # The i-th boy asks each girl.
      for j in range(n):
        if not grid[i][j] or seen[j]:
          continue
        seen[j] = True
        if mates[j] == -1 or canInvite(mates[j], seen):
          mates[j] = i  # Match the j-th girl with i-th boy.
          return True
      return False

    for i in range(m):
      seen = [False] * n
      if canInvite(i, seen):
        ans += 1

    return ans"
"1821","SELECT DISTINCT customer_id
FROM Customers
WHERE year = 2021 AND revenue > 0;"
"1822","class Solution:
  def arraySign(self, nums: list[int]) -> int:
    sign = 1

    for num in nums:
      if num == 0:
        return 0
      if num < 0:
        sign = -sign

    return sign"
"1823","class Solution:
  def findTheWinner(self, n: int, k: int) -> int:
    # e.g. n = 4, k = 2.
    # By using 0-indexed notation, we have the following circle:
    #
    # 0 -> 1 -> 2 -> 3 -> 0
    #      x
    #           0 -> 1 -> 2 -> 0
    #
    # After the first round, 1 is removed.
    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.
    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).
    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.
    def f(n: int, k: int) -> int:
      if n == 1:
        return 0
      return (f(n - 1, k) + k) % n

    # Converts back to 1-indexed.
    return f(n, k) + 1"
"1824","class Solution:
  def minSideJumps(self, obstacles: list[int]) -> int:
    kInf = 1e6
    # dp[i] := the minimum jump to reach the i-th lane
    dp = [kInf, 1, 0, 1]

    for obstacle in obstacles:
      print(dp)
      if obstacle > 0:
        dp[obstacle] = kInf
      for i in range(1, 4):  # the current
        if i != obstacle:
          for j in range(1, 4):  # the previous
            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))

    return min(dp)"
"1825","class MKAverage {
 public:
  MKAverage(int m, int k) : m(m), k(k) {}

  void addElement(int num) {
    q.push(num);
    add(mid, num);
    midSum += num;

    if (q.size() > m) {
      const int removed = q.front();
      q.pop();
      if (top.contains(removed)) {
        remove(top, removed);
        --topSize;
      } else if (mid.contains(removed)) {
        remove(mid, removed);
        midSum -= removed;
      } else {
        remove(bot, removed);
        --botSize;
      }
    }

    // Move item(s) from `mid` to `top` to fill k slots.
    while (!mid.empty() && topSize < k) {
      midSum -= mid.rbegin()->first;
      add(top, remove(mid, mid.rbegin()->first));
      ++topSize;
    }

    // Rebalance `mid` and `top`.
    while (!mid.empty() && mid.rbegin()->first > top.begin()->first) {
      midSum -= mid.rbegin()->first;
      midSum += top.begin()->first;
      add(top, remove(mid, mid.rbegin()->first));
      add(mid, remove(top, top.begin()->first));
    }

    // Move item(s) from `mid` to `bot` to fill k slots.
    while (!mid.empty() && botSize < k) {
      midSum -= mid.begin()->first;
      add(bot, remove(mid, mid.begin()->first));
      ++botSize;
    }

    // Move item(s) from `mid` to `bot` to fill k slots.
    while (!mid.empty() && mid.begin()->first < bot.rbegin()->first) {
      midSum -= mid.begin()->first;
      midSum += bot.rbegin()->first;
      add(bot, remove(mid, mid.begin()->first));
      add(mid, remove(bot, bot.rbegin()->first));
    }
  }

  int calculateMKAverage() {
    return q.size() == m ? midSum / (m - 2 * k) : -1;
  }

 private:
  const int m;
  const int k;
  queue<int> q;
  map<int, int> top;
  map<int, int> mid;
  map<int, int> bot;
  int topSize = 0;
  int botSize = 0;
  long midSum = 0;

  void add(map<int, int>& map, int num) {
    ++map[num];
  }

  int remove(map<int, int>& map, int num) {
    if (--map[num] == 0)
      map.erase(num);
    return num;
  }
};"
"1826","class Solution:
  def badSensor(self, sensor1: list[int], sensor2: list[int]) -> int:
    # A -> B, so B is defect
    def canReplace(A, B):
      i = 0  # A's index
      j = 0  # B's index
      droppedValue = -1

      while i < len(A):
        if A[i] == B[j]:
          i += 1
          j += 1
        else:
          droppedValue = A[i]
          i += 1

      return j == len(B) - 1 and B[-1] != droppedValue

    oneDefect = canReplace(sensor2, sensor1)
    twoDefect = canReplace(sensor1, sensor2)
    if oneDefect and twoDefect:
      return -1
    if not oneDefect and not twoDefect:
      return -1
    return 1 if oneDefect else 2"
"1827","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    ans = 0
    last = 0

    for num in nums:
      ans += max(0, last - num + 1)
      last = max(num, last + 1)

    return ans"
"1828","class Solution:
  def countPoints(
      self,
      points: list[list[int]],
      queries: list[list[int]],
  ) -> list[int]:
    ans = []

    for xj, yj, rj in queries:
      count = 0
      for xi, yi in points:
        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:
          count += 1
      ans.append(count)

    return ans"
"1829","class Solution:
  def getMaximumXor(self, nums: list[int], maximumBit: int) -> list[int]:
    mx = (1 << maximumBit) - 1
    ans = []
    xors = 0

    for num in nums:
      xors ^= num
      ans.append(xors ^ mx)

    return ans[::-1]"
"183","SELECT Customers.name AS Customers
FROM Customers
LEFT JOIN Orders
  ON (Customers.id = Orders.customerId)
WHERE Orders.id IS NULL;"
"1830","class Solution:
  def makeStringSorted(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = [0] * 26

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    for i, c in enumerate(reversed(s)):
      order = string.ascii_lowercase.index(c)
      count[order] += 1
      # count[:order] := s[i] can be any character smaller than c
      # fact(i) := s[i + 1..n - 1] can be any sequence of characters
      perm = sum(count[:order]) * fact(i)
      for j in range(26):
        perm = perm * inv(fact(count[j])) % kMod
      ans = (ans + perm) % kMod

    return ans"
"1831","WITH
  RankedTransactions AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY DATE(day)
        ORDER BY amount DESC
      ) AS `rank`
    FROM Transactions
  )
SELECT transaction_id
FROM RankedTransactions
WHERE `rank` = 1
ORDER BY 1;"
"1832","class Solution:
  def checkIfPangram(self, sentence: str) -> bool:
    seen = 0

    for c in sentence:
      seen |= 1 << string.ascii_lowercase.index(c)

    return seen == (1 << 26) - 1"
"1833","class Solution:
  def maxIceCream(self, costs: list[int], coins: int) -> int:
    for i, cost in enumerate(sorted(costs)):
      if coins >= cost:
        coins -= cost
      else:
        return i

    return len(costs)"
"1834","class Solution:
  def getOrder(self, tasks: list[list[int]]) -> list[int]:
    n = len(tasks)
    A = [[*task, i] for i, task in enumerate(tasks)]
    ans = []
    minHeap = []
    i = 0  # tasks' index
    time = 0  # the current time

    A.sort()

    while i < n or minHeap:
      if not minHeap:
        time = max(time, A[i][0])
      while i < n and time >= A[i][0]:
        heapq.heappush(minHeap, (A[i][1], A[i][2]))
        i += 1
      procTime, index = heapq.heappop(minHeap)
      time += procTime
      ans.append(index)

    return ans"
"1835","class Solution:
  def getXORSum(self, arr1: list[int], arr2: list[int]) -> int:
    return functools.reduce(
        operator.xor, arr1) & functools.reduce(
        operator.xor, arr2)"
"1836","class Solution:
  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    count = collections.Counter()

    curr = head
    while curr:
      count[curr.val] += 1
      curr = curr.next

    curr = dummy

    while curr:
      while curr.next and curr.next.val in count and count[curr.next.val] > 1:
        curr.next = curr.next.next
      curr = curr.next

    return dummy.next"
"1837","class Solution:
  def sumBase(self, n: int, k: int) -> int:
    ans = 0

    while n > 0:
      ans += n % k
      n //= k

    return ans"
"1838","class Solution:
  def maxFrequency(self, nums: list[int], k: int) -> int:
    ans = 0
    summ = 0

    nums.sort()

    l = 0
    for r, num in enumerate(nums):
      summ += num
      while summ + k < num * (r - l + 1):
        summ -= nums[l]
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"1839","class Solution:
  def longestBeautifulSubstring(self, word: str) -> int:
    ans = 0
    count = 1

    l = 0
    for r in range(1, len(word)):
      curr = word[r]
      prev = word[r - 1]
      if curr >= prev:
        if curr > prev:
          count += 1
        if count == 5:
          ans = max(ans, r - l + 1)
      else:
        count = 1
        l = r

    return ans"
"184","WITH
  EmployeesWithMaxSalaryInDepartment AS (
    SELECT
      Department.name AS department,
      Employee.name AS employee,
      Employee.salary,
      MAX(Employee.salary) OVER(
        PARTITION BY Employee.departmentId
      ) AS max_salary
    FROM Employee
    LEFT JOIN Department
      ON (Employee.departmentId = Department.id)
  )
SELECT
  department AS Department,
  employee AS Employee,
  salary AS Salary
FROM EmployeesWithMaxSalaryInDepartment
WHERE salary = max_salary;"
"1840","class Solution:
  def maxBuilding(self, n: int, restrictions: list[list[int]]) -> int:
    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])

    for i in range(len(A)):
      dist = A[i][0] - A[i - 1][0]
      A[i][1] = min(A[i][1], A[i - 1][1] + dist)

    for i in reversed(range(len(A) - 1)):
      dist = A[i + 1][0] - A[i][0]
      A[i][1] = min(A[i][1], A[i + 1][1] + dist)

    ans = 0

    for (l, hL), (r, hR) in zip(A, A[1:]):
      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)

    return ans"
"1841","SELECT
  Teams.team_name,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id
      OR Matches.away_team_id = Teams.team_id THEN 1
      ELSE 0
    END
  ) AS matches_played,
  SUM(
    CASE
      WHEN Teams.team_id = Matches.home_team_id
      AND Matches.home_team_goals > Matches.away_team_goals THEN 3
      WHEN Teams.team_id = Matches.away_team_id
      AND Matches.home_team_goals < Matches.away_team_goals THEN 3
      WHEN Matches.home_team_goals = Matches.away_team_goals THEN 1
      ELSE 0
    END
  ) AS points,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.home_team_goals
      ELSE Matches.away_team_goals
    END
  ) AS goal_for,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.away_team_goals
      ELSE Matches.home_team_goals
    END
  ) AS goal_against,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.home_team_goals - Matches.away_team_goals
      ELSE Matches.away_team_goals - Matches.home_team_goals
    END
  ) AS goal_diff
FROM Matches
INNER JOIN Teams
  ON (
    Matches.home_team_id = Teams.team_id
    OR Matches.away_team_id = Teams.team_id)
GROUP BY 1
ORDER BY points DESC, goal_diff DESC, team_name;"
"1842","class Solution:
  def nextPalindrome(self, num: str) -> str:
    def nextPermutation(nums: list[int]) -> bool:
      n = len(nums)

      # From the back to the front, find the first num < nums[i + 1].
      i = n - 2
      while i >= 0:
        if nums[i] < nums[i + 1]:
          break
        i -= 1

      if i < 0:
        return False

      # From the back to the front, find the first num > nums[i] and swap it
      # with nums[i].
      for j in range(n - 1, i, -1):
        if nums[j] > nums[i]:
          nums[i], nums[j] = nums[j], nums[i]
          break

      def reverse(nums, l, r):
        while l < r:
          nums[l], nums[r] = nums[r], nums[l]
          l += 1
          r -= 1

      # Reverse nums[i + 1..n - 1].
      reverse(nums, i + 1, len(nums) - 1)
      return True

    n = len(num)
    A = [int(num[i]) for i in range(len(num) // 2)]

    if not nextPermutation(A):
      return ''

    s = ''.join([chr(ord('0') + a) for a in A])
    if n % 2 == 1:
      return s + num[n // 2] + s[::-1]
    return s + s[::-1]"
"1843","WITH
  SuspiciousAccountToMonth AS (
    SELECT
      Transactions.account_id,
      DATE_FORMAT(Transactions.day, '%Y%m') AS month,
      Accounts.max_income
    FROM Transactions
    INNER JOIN Accounts
      USING (account_id)
    WHERE Transactions.type = 'Creditor'
    GROUP BY 1, 2
    HAVING SUM(Transactions.amount) > Accounts.max_income
  )
SELECT DISTINCT CurrMonth.account_id
FROM SuspiciousAccountToMonth AS CurrMonth
INNER JOIN SuspiciousAccountToMonth AS NextMonth
  USING (account_id)
WHERE PERIOD_DIFF(NextMonth.month, CurrMonth.month) = 1;"
"1844","class Solution:
  def replaceDigits(self, s: str) -> str:
    return ''.join(
        c if i % 2 == 0 else chr(ord(s[i - 1]) + int(c))
        for i, c in enumerate(s)
    )"
"1845","class SeatManager:
  def __init__(self, n: int):
    self.minHeap = [i + 1 for i in range(n)]

  def reserve(self) -> int:
    return heapq.heappop(self.minHeap)

  def unreserve(self, seatNumber: int) -> None:
    heapq.heappush(self.minHeap, seatNumber)"
"1846","class Solution:
  def maximumElementAfterDecrementingAndRearranging(
      self, arr: list[int],
  ) -> int:
    arr.sort()
    arr[0] = 1

    for i in range(1, len(arr)):
      arr[i] = min(arr[i], arr[i - 1] + 1)

    return arr[-1]"
"1847","from sortedcontainers import SortedList


class Solution:
  def closestRoom(
      self,
      rooms: list[list[int]],
      queries: list[list[int]],
  ) -> list[int]:
    ans = [0] * len(queries)
    qs = [[*q, i] for i, q in enumerate(queries)]
    roomIds = SortedList()

    rooms.sort(key=lambda x: -x[1])
    qs.sort(key=lambda x: -x[1])

    def searchClosestRoomId(roomIds: SortedList, preferred: int):
      if not roomIds:
        return -1

      candIds = []
      i = roomIds.bisect_right(preferred)
      if i > 0:
        candIds.append(roomIds[i - 1])
      if i < len(roomIds):
        candIds.append(roomIds[i])
      return min(candIds, key=lambda x: abs(x - preferred))

    i = 0  # rooms' index
    for preferred, minSize, index in qs:
      while i < len(rooms) and rooms[i][1] >= minSize:
        roomIds.add(rooms[i][0])
        i += 1
      ans[index] = searchClosestRoomId(roomIds, preferred)

    return ans"
"1848","class Solution:
  def getMinDistance(self, nums: list[int], target: int, start: int) -> int:
    ans = math.inf

    for i, num in enumerate(nums):
      if num == target:
        ans = min(ans, abs(i - start))

    return ans"
"1849","class Solution:
  def splitString(self, s: str) -> bool:
    def isValid(s: str, start: int, prev: int, segment: int) -> bool:
      if start == len(s) and segment > 1:
        return True

      curr = 0
      for i in range(start, len(s)):
        curr = curr * 10 + int(s[i])
        if curr > 9999999999:
          return False
        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):
          return True

      return False

    return isValid(s, 0, -1, 0)"
"185","WITH
  EmployeesWithRankInDepartment AS (
    SELECT
      Department.name AS department,
      Employee.name AS employee,
      Employee.salary,
      DENSE_RANK() OVER(
        PARTITION BY Employee.departmentId
        ORDER BY Employee.salary DESC
      ) AS `rank`
    FROM Department
    INNER JOIN Employee
      ON (Department.id = Employee.departmentId )
  )
SELECT
  department AS Department,
  employee AS Employee,
  salary AS Salary
FROM EmployeesWithRankInDepartment
WHERE `rank` <= 3;"
"1850","class Solution:
  def getMinSwaps(self, num: str, k: int) -> int:
    def nextPermutation(nums: list[int]):
      n = len(nums)

      # From the back to the front, find the first num < nums[i + 1].
      i = n - 2
      while i >= 0:
        if nums[i] < nums[i + 1]:
          break
        i -= 1

      # From the back to the front, find the first num > nums[i] and swap it with nums[i].
      if i >= 0:
        for j in range(n - 1, i, -1):
          if nums[j] > nums[i]:
            nums[i], nums[j] = nums[j], nums[i]
            break

      def reverse(nums, l, r):
        while l < r:
          nums[l], nums[r] = nums[r], nums[l]
          l += 1
          r -= 1

      # Reverse nums[i + 1..n - 1]
      reverse(nums, i + 1, len(nums) - 1)

    A = [int(c) for c in num]  # Original
    B = A.copy()  # Permutated

    for _ in range(k):
      nextPermutation(B)

    def countSteps(A: list[int], B: list[int]) -> int:
      count = 0

      j = 0
      for i in range(len(A)):
        j = i
        while A[i] != B[j]:
          j += 1
        while i < j:
          B[j], B[j - 1] = B[j - 1], B[j]
          j -= 1
          count += 1

      return count

    return countSteps(A, B)"
"1851","class Solution {
  public int[] minInterval(int[][] intervals, int[] queries) {
    record T(int size, int right) {}
    int[] ans = new int[queries.length];
    Arrays.fill(ans, -1);
    Queue<T> minHeap = new PriorityQueue<T>((a, b) -> Integer.compare(a.size, b.size));
    Integer[] indices = new Integer[queries.length];

    for (int i = 0; i < queries.length; ++i)
      indices[i] = i;

    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    Arrays.sort(indices, (a, b) -> Integer.compare(queries[a], queries[b]));

    int i = 0; // intervals' index
    for (final int index : indices) {
      while (i < intervals.length && intervals[i][0] <= queries[index]) {
        minHeap.offer(new T(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]));
        ++i;
      }
      while (!minHeap.isEmpty() && minHeap.peek().right < queries[index])
        minHeap.poll();
      if (!minHeap.isEmpty())
        ans[index] = minHeap.peek().size;
    }

    return ans;
  }
}"
"1852","class Solution:
  def distinctNumbers(self, nums: list[int], k: int) -> list[int]:
    ans = []
    count = collections.Counter()
    distinct = 0

    for i, num in enumerate(nums):
      count[num] += 1
      if count[num] == 1:
        distinct += 1
      if i >= k:
        count[nums[i - k]] -= 1
        if count[nums[i - k]] == 0:
          distinct -= 1
      if i >= k - 1:
        ans.append(distinct)

    return ans"
"1853","SELECT DATE_FORMAT(day, '%W, %M %e, %Y') AS day
FROM Days"
"1854","class Solution:
  def maximumPopulation(self, logs: list[list[int]]) -> int:
    kMinYear = 1950
    kMaxYear = 2050
    ans = 0
    maxPopulation = 0
    runningPopulation = 0
    # population[i] := the population of year i
    population = [0] * (kMaxYear + 1)

    for birth, death in logs:
      population[birth] += 1
      population[death] -= 1

    for year in range(kMinYear, kMaxYear + 1):
      runningPopulation += population[year]
      if runningPopulation > maxPopulation:
        maxPopulation = runningPopulation
        ans = year

    return ans"
"1855","class Solution:
  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:
    ans = 0
    i = 0
    j = 0

    while i < len(nums1) and j < len(nums2):
      if nums1[i] > nums2[j]:
        i += 1
      else:
        ans = max(ans, j - i)
        j += 1

    return ans"
"1856","class Solution:
  def maxSumMinProduct(self, nums: list[int]) -> int:
    ans = 0
    stack = []
    prefix = list(itertools.accumulate(nums, initial=0))

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):
        minVal = nums[stack.pop()]
        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]
        ans = max(ans, minVal * summ)
      stack.append(i)

    return ans % int(1e9 + 7)"
"1857","class Solution:
  def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:
    n = len(colors)
    ans = 0
    processed = 0
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    q = collections.deque()
    count = [[0] * 26 for _ in range(n)]

    # Build the graph.
    for u, v in edges:
      graph[u].append(v)
      inDegrees[v] += 1

    # Vpology
    for i, degree in enumerate(inDegrees):
      if degree == 0:
        q.append(i)

    while q:
      u = q.popleft()
      processed += 1
      count[u][ord(colors[u]) - ord('a')] += 1
      ans = max(ans, count[u][ord(colors[u]) - ord('a')])
      for v in graph[u]:
        for i in range(26):
          count[v][i] = max(count[v][i], count[u][i])
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return ans if processed == n else -1"
"1858","class Solution:
  def __init__(self):
    self.root = {}

  def longestWord(self, words: list[str]) -> str:
    ans = ''

    for word in words:
      self.insert(word)

    for word in words:
      if not self.allPrefixed(word):
        continue
      if len(ans) < len(word) or (len(ans) == len(word) and ans > word):
        ans = word

    return ans

  def insert(self, word: str) -> None:
    node = self.root
    for c in word:
      if c not in node:
        node[c] = {}
      node = node[c]
    node['isWord'] = True

  def allPrefixed(self, word: str) -> bool:
    node = self.root
    for c in word:
      node = node[c]
      if 'isWord' not in node:
        return False
    return True"
"1859","class Solution:
  def sortSentence(self, s: str) -> str:
    return ' '.join([word[:-1]
                     for word in sorted(s.split(), key=lambda x: x[-1])])"
"186","class Solution:
  def reverseWords(self, s: list[str]) -> None:
    def reverse(l: int, r: int) -> None:
      while l < r:
        s[l], s[r] = s[r], s[l]
        l += 1
        r -= 1

    def reverseWords(n: int) -> None:
      i = 0
      j = 0

      while i < n:
        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.
          i += 1
        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.
          j += 1
        reverse(i, j - 1)  # Reverse the word.

    reverse(0, len(s) - 1)  # Reverse the whole string.
    reverseWords(len(s))  # Reverse each word."
"1860","class Solution:
  def memLeak(self, memory1: int, memory2: int) -> list[int]:
    i = 1

    while memory1 >= i or memory2 >= i:
      if memory1 >= memory2:
        memory1 -= i
      else:
        memory2 -= i
      i += 1

    return [i, memory1, memory2]"
"1861","class Solution:
  def rotateTheBox(self, box: list[list[str]]) -> list[list[str]]:
    m = len(box)
    n = len(box[0])
    rotated = [['.'] * m for _ in range(n)]

    for i in range(m):
      k = n - 1
      for j in reversed(range(n)):
        if box[i][j] != '.':
          if box[i][j] == '*':
            k = j
          rotated[k][m - i - 1] = box[i][j]
          k -= 1

    return [''.join(row) for row in rotated]"
"1862","class Solution:
  def sumOfFlooredPairs(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    kMax = max(nums)
    ans = 0
    count = [0] * (kMax + 1)

    for num in nums:
      count[num] += 1

    for i in range(1, kMax + 1):
      count[i] += count[i - 1]

    for i in range(1, kMax + 1):
      if count[i] > count[i - 1]:
        summ = 0
        j = 1
        while i * j <= kMax:
          lo = i * j - 1
          hi = i * (j + 1) - 1
          summ += (count[min(hi, kMax)] - count[lo]) * j
          j += 1
        ans += summ * (count[i] - count[i - 1])
        ans %= kMod

    return ans"
"1863","class Solution:
  def subsetXORSum(self, nums: list[int]) -> int:
    def dfs(i: int, xors: int) -> int:
      if i == len(nums):
        return xors

      x = dfs(i + 1, xors)
      y = dfs(i + 1, nums[i] ^ xors)
      return x + y

    return dfs(0, 0)"
"1864","class Solution:
  def minSwaps(self, s: str) -> int:
    ones = s.count('1')
    zeros = len(s) - ones
    if abs(ones - zeros) > 1:
      return -1

    def countSwaps(curr: str) -> int:
      swaps = 0
      for c in s:
        if c != curr:
          swaps += 1
        curr = chr(ord(curr) ^ 1)
      return swaps // 2

    if ones > zeros:
      return countSwaps('1')
    if zeros > ones:
      return countSwaps('0')
    return min(countSwaps('1'), countSwaps('0'))"
"1865","class FindSumPairs:
  def __init__(self, nums1: list[int], nums2: list[int]):
    self.nums1 = nums1
    self.nums2 = nums2
    self.count2 = collections.Counter(nums2)

  def add(self, index: int, val: int) -> None:
    self.count2[self.nums2[index]] -= 1
    self.nums2[index] += val
    self.count2[self.nums2[index]] += 1

  def count(self, tot: int) -> int:
    ans = 0
    for num in self.nums1:
      ans += self.count2[tot - num]
    return ans"
"1866","class Solution:
  @functools.lru_cache(None)
  def rearrangeSticks(self, n: int, k: int) -> int:
    if n == k:
      return 1
    if k == 0:
      return 0
    return (self.rearrangeSticks(n - 1, k - 1) +
            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.kMod

  kMod = 1_000_000_007"
"1867","WITH
  GroupedOrders AS (
    SELECT
      order_id,
      MAX(quantity) AS max_quantity,
      MAX(AVG(quantity)) OVER() AS max_avg_quantity
    FROM OrdersDetails
    GROUP BY 1
  )
SELECT order_id
FROM GroupedOrders
WHERE max_quantity > max_avg_quantity;"
"1868","class Solution:
  def findRLEArray(self, encoded1: list[list[int]],
                   encoded2: list[list[int]]) -> list[list[int]]:
    ans = []
    i = 0  # encoded1's index
    j = 0  # encoded2's index

    while i < len(encoded1) and j < len(encoded2):
      mult = encoded1[i][0] * encoded2[j][0]
      minFreq = min(encoded1[i][1], encoded2[j][1])
      if ans and mult == ans[-1][0]:
        ans[-1][1] += minFreq
      else:
        ans.append([mult, minFreq])
      encoded1[i][1] -= minFreq
      encoded2[j][1] -= minFreq
      if encoded1[i][1] == 0:
        i += 1
      if encoded2[j][1] == 0:
        j += 1

    return ans"
"1869","class Solution:
  def checkZeroOnes(self, s: str) -> bool:
    longestOnes = 0
    longestZeros = 0
    currentOnes = 0
    currentZeros = 0

    for c in s:
      if c == '0':
        currentOnes = 0
        currentZeros += 1
        longestZeros = max(longestZeros, currentZeros)
      else:
        currentZeros = 0
        currentOnes += 1
        longestOnes = max(longestOnes, currentOnes)

    return longestOnes > longestZeros"
"187","class Solution:
  def findRepeatedDnaSequences(self, s: str) -> list[str]:
    ans = set()
    seen = set()

    for i in range(len(s) - 9):
      seq = s[i:i + 10]
      if seq in seen:
        ans.add(seq)
      seen.add(seq)

    return list(ans)"
"1870","class Solution:
  def minSpeedOnTime(self, dist: list[int], hour: float) -> int:
    ans = -1
    l = 1
    r = int(1e7)

    def time(speed: int) -> float:
      summ = 0
      for i in range(len(dist) - 1):
        summ += math.ceil(dist[i] / speed)
      return summ + dist[-1] / speed

    while l <= r:
      m = (l + r) // 2
      if time(m) > hour:
        l = m + 1
      else:
        ans = m
        r = m - 1

    return ans"
"1871","class Solution:
  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
    count = 0
    dp = [True] + [False] * (len(s) - 1)

    for i in range(minJump, len(s)):
      count += dp[i - minJump]
      if i - maxJump > 0:
        count -= dp[i - maxJump - 1]
      dp[i] = count and s[i] == '0'

    return dp[-1]"
"1872","class Solution:
  def stoneGameVIII(self, stones: list[int]) -> int:
    n = len(stones)
    prefix = list(itertools.accumulate(stones))
    # dp[i] := the maximum score difference the current player can get when the
    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]
    dp = [-math.inf] * n

    # Must take all when there're only two stones left.
    dp[n - 2] = prefix[-1]

    for i in reversed(range(n - 2)):
      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])

    return dp[0]"
"1873","SELECT
  employee_id,
  IF(employee_id % 2 = 1 AND LEFT(name, 1) != 'M', salary, 0) AS bonus
FROM Employees
ORDER BY 1;"
"1874","class Solution:
  def minProductSum(self, nums1: list[int], nums2: list[int]) -> int:
    return sum([a * b for a, b in zip(sorted(nums1), sorted(nums2, reverse=True))])"
"1875","WITH
  EmployeesWithCountPerSalary AS (
    SELECT
      *,
      COUNT(employee_id) OVER(PARTITION BY salary) AS count_per_salary
    FROM Employees
  )
SELECT
  employee_id,
  name,
  salary,
  DENSE_RANK() OVER(ORDER BY salary) AS team_id
FROM EmployeesWithCountPerSalary
WHERE count_per_salary > 1
ORDER BY team_id, employee_id;"
"1876","class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    ans = 0

    for a, b, c in zip(s, s[1:], s[2:]):
      if a == b or a == c or b == c:
        continue
      ans += 1

    return ans"
"1877","class Solution:
  def minPairSum(self, nums: list[int]) -> int:
    nums.sort()
    return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) // 2))"
"1878","from sortedcontainers import SortedSet


class Solution:
  def getBiggestThree(self, grid: list[list[int]]) -> list[int]:
    m = len(grid)
    n = len(grid[0])
    sums = SortedSet()

    for i in range(m):
      for j in range(n):
        sz = 0
        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:
          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)
          sums.add(summ)
          if len(sums) > 3:
            sums.pop(0)
          sz += 1

    return sums

  def _getSum(self, grid: list[list[int]], i: int, j: int, sz: int) -> int:
    """"""
    Returns the sum of the rhombus, where the top grid is (i, j) and the edge
    size is `sz`.
    """"""
    x = i
    y = j
    summ = 0

    # Go left down.
    for _ in range(sz):
      x -= 1
      y += 1
      summ += grid[x][y]

    # Go right down.
    for _ in range(sz):
      x += 1
      y += 1
      summ += grid[x][y]

    # Go right up.
    for _ in range(sz):
      x += 1
      y -= 1
      summ += grid[x][y]

    # Go left up.
    for _ in range(sz):
      x -= 1
      y -= 1
      summ += grid[x][y]

    return summ"
"1879","class Solution:
  def minimumXORSum(self, nums1: list[int], nums2: list[int]) -> int:
    @functools.lru_cache(None)
    def dp(mask: int) -> int:
      i = mask.bit_count()
      if i == len(nums1):
        return 0
      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)
                 for j in range(len(nums2)) if not mask >> j & 1)
    return dp(0)"
"188","class Solution:
  def maxProfit(self, k: int, prices: list[int]) -> int:
    if k >= len(prices) // 2:
      sell = 0
      hold = -math.inf

      for price in prices:
        sell = max(sell, hold + price)
        hold = max(hold, sell - price)

      return sell

    sell = [0] * (k + 1)
    hold = [-math.inf] * (k + 1)

    for price in prices:
      for i in range(k, 0, -1):
        sell[i] = max(sell[i], hold[i] + price)
        hold[i] = max(hold[i], sell[i - 1] - price)

    return sell[k]"
"1880","class Solution:
  def isSumEqual(
      self,
      firstWord: str,
      secondWord: str,
      targetWord: str,
  ) -> bool:
    first = self._getNumber(firstWord)
    second = self._getNumber(secondWord)
    target = self._getNumber(targetWord)
    return first + second == target

  def _getNumber(self, word: str) -> int:
    num = 0
    for c in word:
      num = num * 10 + string.ascii_lowercase.index(c)
    return num"
"1881","class Solution:
  def maxValue(self, n: str, x: int) -> str:
    isNegative = n[0] == '-'

    for i, c in enumerate(n):
      if not isNegative and int(c) < x or isNegative and int(c) > x:
        return n[:i] + str(x) + n[i:]

    return n + str(x)"
"1882","class Solution:
  def assignTasks(self, servers: list[int], tasks: list[int]) -> list[int]:
    ans = []
    free = []  # (weight, index, freeTime)
    used = []  # (freeTime, weight, index)

    for i, weight in enumerate(servers):
      heapq.heappush(free, (weight, i, 0))

    for i, executionTime in enumerate(tasks):  # i := the current time
      # Poll all servers that'll be free at time i.
      while used and used[0][0] <= i:
        curr = heapq.heappop(used)
        heapq.heappush(free, (curr[1], curr[2], curr[0]))
      if free:
        curr = heapq.heappop(free)
        ans.append(curr[1])
        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))
      else:
        curr = heapq.heappop(used)
        ans.append(curr[2])
        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))

    return ans"
"1883","class Solution:
  def minSkips(self, dist: list[int], speed: int, hoursBefore: int) -> int:
    kInf = 10**7
    kEps = 1e-9
    n = len(dist)
    # dp[i][j] := the minimum time, where i is the number of roads we traversed
    # so far and j is the number of skips we did
    dp = [[kInf] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i, d in enumerate(dist, 1):
      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - kEps)
      for j in range(1, i + 1):
        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,
                       math.ceil(dp[i - 1][j] + d / speed - kEps))

    for j, time in enumerate(dp[-1]):
      if time <= hoursBefore:
        return j

    return -1"
"1884","class Solution {
  public int twoEggDrop(int n) {
    return superEggDrop(2, n);
  }

  // Same as 887. Super Egg Drop
  private int superEggDrop(int k, int n) {
    int[][] mem = new int[k + 1][n + 1];
    Arrays.stream(mem).forEach(A -> Arrays.fill(A, -1));
    return drop(k, n, mem);
  }

  // Returns the minimum number of moves to know f with k eggs and n floors.
  private int drop(int k, int n, int[][] mem) {
    if (k == 0) // no eggs -> done
      return 0;
    if (k == 1) // one egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0) // no floor -> done
      return 0;
    if (n == 1) // one floor -> drop from that floor
      return 1;
    if (mem[k][n] != -1)
      return mem[k][n];

    int l = 1;
    int r = n + 1;

    while (l < r) {
      final int m = (l + r) / 2;
      final int broken = drop(k - 1, m - 1, mem);
      final int unbroken = drop(k, n - m, mem);
      if (broken >= unbroken)
        r = m;
      else
        l = m + 1;
    }

    return mem[k][n] = 1 + drop(k - 1, l - 1, mem);
  }
}"
"1885","class Solution:
  def countPairs(self, nums1: list[int], nums2: list[int]) -> int:
    ans = 0
    A = sorted([x - y for x, y in zip(nums1, nums2)])

    for i, a in enumerate(A):
      index = bisect_left(A, -a + 1)
      ans += len(A) - max(i + 1, index)

    return ans"
"1886","class Solution:
  def findRotation(self, mat: list[list[int]], target: list[list[int]]) -> bool:
    for _ in range(4):
      if mat == target:
        return True
      mat = [list(x) for x in zip(*mat[::-1])]
    return False"
"1887","class Solution:
  def reductionOperations(self, nums: list[int]) -> int:
    ans = 0

    nums.sort()

    for i in range(len(nums) - 1, 0, -1):
      if nums[i] != nums[i - 1]:
        ans += len(nums) - i

    return ans"
"1888","class Solution:
  def minFlips(self, s: str) -> int:
    n = len(s)
    # count[0][0] :=  the number of '0' in the even indices
    # count[0][1] :=  the number of '0' in the odd indices
    # count[1][0] :=  the number of '1' in the even indices
    # count[1][1] :=  the number of '1' in the odd indices
    count = [[0] * 2 for _ in range(2)]

    for i, c in enumerate(s):
      count[int(c)][i % 2] += 1

    # min(make all 0s in the even indices + make all 1s in the odd indices,
    #     make all 1s in the even indices + make all 0s in the odd indices)
    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])

    for i, c in enumerate(s):
      count[int(c)][i % 2] -= 1
      count[int(c)][(n + i) % 2] += 1
      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])

    return ans"
"1889","class Solution:
  def minWastedSpace(self, packages: list[int], boxes: list[list[int]]) -> int:
    ans = math.inf

    packages.sort()

    for box in boxes:
      box.sort()
      if box[-1] < packages[-1]:
        continue
      accu = 0
      i = 0
      for b in box:
        j = bisect.bisect(packages, b, i)
        accu += b * (j - i)
        i = j
      ans = min(ans, accu)

    return -1 if ans == math.inf else (ans - sum(packages)) % int(1e9 + 7)"
"189","class Solution:
  def rotate(self, nums: list[int], k: int) -> None:
    k %= len(nums)
    self.reverse(nums, 0, len(nums) - 1)
    self.reverse(nums, 0, k - 1)
    self.reverse(nums, k, len(nums) - 1)

  def reverse(self, nums: list[int], l: int, r: int) -> None:
    while l < r:
      nums[l], nums[r] = nums[r], nums[l]
      l += 1
      r -= 1"
"1890","SELECT
  user_id,
  MAX(time_stamp) AS last_stamp
FROM Logins
WHERE YEAR(time_stamp) = 2020
GROUP BY 1;"
"1891","class Solution:
  def maxLength(self, ribbons: list[int], k: int) -> int:
    def isCutPossible(length: int) -> bool:
      count = 0
      for ribbon in ribbons:
        count += ribbon // length
      return count >= k

    l = 1
    r = sum(ribbons) // k + 1

    while l < r:
      m = (l + r) // 2
      if not isCutPossible(m):
        r = m
      else:
        l = m + 1

    return l - 1"
"1892","WITH
  UserToFriends AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id AS user_id, user1_id AS friend_id FROM friendship
  )
SELECT
  UserToFriends.user_id,
  FriendLikes.page_id,
  COUNT(DISTINCT UserToFriends.friend_id) AS friends_likes
FROM UserToFriends
LEFT JOIN Likes AS FriendLikes
  ON (UserToFriends.friend_id = FriendLikes.user_id)
LEFT JOIN Likes AS UserLikes
  ON (
    UserToFriends.user_id = UserLikes.user_id
    AND FriendLikes.page_id = UserLikes.page_id)
WHERE UserLikes.page_id IS NULL
GROUP BY 1, 2;"
"1893","class Solution:
  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:
    return all(any(l <= i <= r for l, r in ranges) for i in range(
        left, right + 1))"
"1894","class Solution:
  def chalkReplacer(self, chalk: list[int], k: int) -> int:
    k %= sum(chalk)
    if k == 0:
      return 0

    for i, c in enumerate(chalk):
      k -= c
      if k < 0:
        return i"
"1895","class Solution:
  def largestMagicSquare(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # prefixRow[i][j] := the sum of the first j numbers in the i-th row
    prefixRow = [[0] * (n + 1) for _ in range(m)]
    # prefixCol[i][j] := the sum of the first j numbers in the i-th column
    prefixCol = [[0] * (m + 1) for _ in range(n)]

    for i in range(m):
      for j in range(n):
        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j]
        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j]

    def isMagicSquare(i: int, j: int, k: int) -> bool:
      """"""Returns True if grid[i..i + k)[j..j + k) is a magic square.""""""
      diag, antiDiag = 0, 0
      for d in range(k):
        diag += grid[i + d][j + d]
        antiDiag += grid[i + d][j + k - 1 - d]
      if diag != antiDiag:
        return False
      for d in range(k):
        if self._getSum(prefixRow, i + d, j, j + k - 1) != diag:
          return False
        if self._getSum(prefixCol, j + d, i, i + k - 1) != diag:
          return False
      return True

    def containsMagicSquare(k: int) -> bool:
      """"""Returns True if the grid contains any magic square of size k x k.""""""
      for i in range(m - k + 1):
        for j in range(n - k + 1):
          if isMagicSquare(i, j, k):
            return True
      return False

    for k in range(min(m, n), 1, -1):
      if containsMagicSquare(k):
        return k

    return 1

  def _getSum(self, prefix: list[list[int]], i: int, l: int, r: int) -> int:
    """"""Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).""""""
    return prefix[i][r + 1] - prefix[i][l]"
"1896","class Solution:
  def minOperationsToFlip(self, expression: str) -> int:
    stack = []  # [(the expression, the cost to toggle the expression)]

    for e in expression:
      if e in '(&|':
        # These aren't expressions, so the cost is meaningless.
        stack.append((e, 0))
        continue
      if e == ')':
        lastPair = stack.pop()
        stack.pop()  # Pop '('.
      else:  # e == '0' or e == '1'
        # Store the '0' or '1'. The cost to change their values is just 1,
        # whether it's changing '0' to '1' or '1' to '0'.
        lastPair = (e, 1)
      if stack and stack[-1][0] in '&|':
        op = stack.pop()[0]
        a, costA = stack.pop()
        b, costB = lastPair
        # Determine the cost to toggle op(a, b).
        if op == '&':
          if a == '0' and b == '0':
            # Change '&' to '|' and a|b to '1'.
            lastPair = ('0', 1 + min(costA, costB))
          elif a == '0' and b == '1':
            # Change '&' to '|'.
            lastPair = ('0', 1)
          elif a == '1' and b == '0':
            # Change '&' to '|'.
            lastPair = ('0', 1)
          else:  # a == '1' and b == '1'
            # Change a|b to '0'.
            lastPair = ('1', min(costA, costB))
        else:  # op == '|'
          if a == '0' and b == '0':
            # Change a|b to '1'.
            lastPair = ('0', min(costA, costB))
          elif a == '0' and b == '1':
            # Change '|' to '&'.
            lastPair = ('1', 1)
          elif a == '1' and b == '0':
            # Change '|' to '&'.
            lastPair = ('1', 1)
          else:  # a == '1' and b == '1'
            # Change '|' to '&' and a|b to '0'.
            lastPair = ('1', 1 + min(costA, costB))
      stack.append(lastPair)

    return stack[-1][1]"
"1897","class Solution:
  def makeEqual(self, words: list[str]) -> bool:
    return all(c % len(words) == 0
               for c in collections.Counter(''.join(words)).values())"
"1898","class Solution:
  def maximumRemovals(self, s: str, p: str, removable: list[int]) -> int:
    l = 0
    r = len(removable) + 1

    def remove(k: int) -> str:
      removed = [c for c in s]
      for i in range(k):
        removed[removable[i]] = '*'
      return ''.join(removed)

    def isSubsequence(p: str, s: str) -> bool:
      i = 0
      for j, c in enumerate(s):
        if p[i] == s[j]:
          i += 1
          if i == len(p):
            return True
      return False

    while l < r:
      m = (l + r) // 2
      removed = remove(m)
      if isSubsequence(p, removed):
        l = m + 1
      else:
        r = m

    return l - 1"
"1899","class Solution:
  def mergeTriplets(self, triplets: list[list[int]], target: list[int]) -> bool:
    merged = [0] * len(target)

    for triplet in triplets:
      if all(a <= b for a, b in zip(triplet, target)):
        for i in range(3):
          merged[i] = max(merged[i], triplet[i])

    return merged == target"
"19","class Solution:
  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
    slow = head
    fast = head

    for _ in range(n):
      fast = fast.next
    if not fast:
      return head.next

    while fast.next:
      slow = slow.next
      fast = fast.next
    slow.next = slow.next.next

    return head"
"190","class Solution:
  def reverseBits(self, n: int) -> int:
    ans = 0

    for i in range(32):
      if n >> i & 1:
        ans |= 1 << 31 - i

    return ans"
"1900","class Solution:
  def earliestAndLatest(self, n: int,
                        firstPlayer: int, secondPlayer: int) -> list[int]:
    @functools.lru_cache(None)
    def dp(l: int, r: int, k: int) -> list[int]:
      """"""
      Returns the (earliest, latest) pair, the first player is the l-th player
      from the front, the second player is the r-th player from the end, and
      there're k people.
      """"""
      if l == r:
        return [1, 1]
      if l > r:
        return dp(r, l, k)

      a = math.inf
      b = -math.inf

      # Enumerate all the possible positions.
      for i in range(1, l + 1):
        for j in range(l - i + 1, r - i + 1):
          if not l + r - k // 2 <= i + j <= (k + 1) // 2:
            continue
          x, y = dp(i, j, (k + 1) // 2)
          a = min(a, x + 1)
          b = max(b, y + 1)

      return [a, b]

    return dp(firstPlayer, n - secondPlayer + 1, n)"
"1901","class Solution:
  def findPeakGrid(self, mat: list[list[int]]) -> list[int]:
    l = 0
    r = len(mat) - 1

    while l < r:
      m = (l + r) // 2
      if max(mat[m]) >= max(mat[m + 1]):
        r = m
      else:
        l = m + 1

    return [l, mat[l].index(max(mat[l]))]"
"1902","class Solution {
  public int maxDepthBST(int[] order) {
    int ans = 1;
    TreeMap<Integer, Integer> valToDepth = new TreeMap<>();

    for (final int val : order) {
      Map.Entry<Integer, Integer> l = valToDepth.floorEntry(val);
      Map.Entry<Integer, Integer> r = valToDepth.ceilingEntry(val);
      final int leftDepth = l == null ? 0 : l.getValue();
      final int rightDepth = r == null ? 0 : r.getValue();
      final int depth = Math.max(leftDepth, rightDepth) + 1;
      ans = Math.max(ans, depth);
      valToDepth.put(val, depth);
    }

    return ans;
  }
}"
"1903","class Solution:
  def largestOddNumber(self, num: str) -> str:
    for i, n in reversed(list(enumerate(num))):
      if int(n) % 2 == 1:
        return num[:i + 1]
    return ''"
"1904","class Solution:
  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:
    start = self._getMinutes(loginTime)
    finish = self._getMinutes(logoutTime)
    if start > finish:
      finish += 60 * 24

    return max(0, finish // 15 - (start + 14) // 15)

  def _getMinutes(self, time: str) -> int:
    h, m = map(int, time.split(':'))
    return 60 * h + m"
"1905","class Solution:
  def countSubIslands(
      self,
      grid1: list[list[int]],
      grid2: list[list[int]],
  ) -> int:
    m = len(grid2)
    n = len(grid2[0])

    def dfs(i: int, j: int) -> int:
      if i < 0 or i == m or j < 0 or j == n:
        return 1
      if grid2[i][j] != 1:
        return 1

      grid2[i][j] = 2  # Mark 2 as visited.

      return (dfs(i + 1, j) & dfs(i - 1, j) &
              dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j])

    ans = 0

    for i in range(m):
      for j in range(n):
        if grid2[i][j] == 1:
          ans += dfs(i, j)

    return ans"
"1906","class Solution:
  def minDifference(
      self,
      nums: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    numToIndices = [[] for _ in range(101)]

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    if len(numToIndices[nums[0]]) == len(nums):
      return [-1] * len(queries)

    ans = []

    for l, r in queries:
      prevNum = -1
      minDiff = 101
      for num in range(1, 101):
        indices = numToIndices[num]
        i = bisect_left(indices, l)
        if i == len(indices) or indices[i] > r:
          continue
        if prevNum != -1:
          minDiff = min(minDiff, num - prevNum)
        prevNum = num
      ans.append(-1 if minDiff == 101 else minDiff)

    return ans"
"1907","SELECT
  'Low Salary' AS Category,
  SUM(income < 20000) AS accounts_count
FROM Accounts
UNION ALL
SELECT
  'Average Salary' Category,
  SUM(income >= 20000 AND income <= 50000) AS accounts_count
FROM Accounts
UNION ALL
SELECT
  'High Salary' category,
  SUM(income > 50000) AS accounts_count
FROM Accounts;"
"1908","class Solution:
  def nimGame(self, piles: list[int]) -> bool:
    return functools.reduce(operator.xor, piles) > 0"
"1909","class Solution:
  def canBeIncreasing(self, nums: list[int]) -> bool:
    removed = False

    for i in range(1, len(nums)):
      if nums[i - 1] >= nums[i]:
        if removed:
          return False
        removed = True  # Remove nums[i - 1].
        if i > 1 and nums[i - 2] >= nums[i]:
          nums[i] = nums[i - 1]  # Remove nums[i] instead.

    return True"
"191","class Solution:
  def hammingWeight(self, n: int) -> int:
    ans = 0

    for i in range(32):
      if (n >> i) & 1:
        ans += 1

    return ans"
"1910","class Solution:
  def removeOccurrences(self, s: str, part: str) -> str:
    n = len(s)
    k = len(part)

    t = [' '] * n
    j = 0  # t's index

    for i, c in enumerate(s):
      t[j] = c
      j += 1
      if j >= k and ''.join(t[j - k:j]) == part:
        j -= k

    return ''.join(t[:j])"
"1911","class Solution:
  def maxAlternatingSum(self, nums: list[int]) -> int:
    even = 0  # the maximum alternating sum ending in an even index
    odd = 0  # the maximum alternating sum ending in an odd index

    for num in nums:
      even = max(even, odd + num)
      odd = even - num

    return even"
"1912","from sortedcontainers import SortedList


class MovieRentingSystem:
  def __init__(self, n: int, entries: list[list[int]]):
    self.unrented = collections.defaultdict(
        SortedList)  # {movie: (price, shop)}
    self.shopAndMovieToPrice = {}  # {(shop, movie): price}
    self.rented = SortedList()  # (price, shop, movie)
    for shop, movie, price in entries:
      self.unrented[movie].add((price, shop))
      self.shopAndMovieToPrice[(shop, movie)] = price

  def search(self, movie: int) -> list[int]:
    return [shop for _, shop in self.unrented[movie][:5]]

  def rent(self, shop: int, movie: int) -> None:
    price = self.shopAndMovieToPrice[(shop, movie)]
    self.unrented[movie].remove((price, shop))
    self.rented.add((price, shop, movie))

  def drop(self, shop: int, movie: int) -> None:
    price = self.shopAndMovieToPrice[(shop, movie)]
    self.unrented[movie].add((price, shop))
    self.rented.remove((price, shop, movie))

  def report(self) -> list[list[int]]:
    return [[shop, movie] for _, shop, movie in self.rented[:5]]"
"1913","class Solution:
  def maxProductDifference(self, nums: list[int]) -> int:
    max1 = -math.inf
    max2 = -math.inf
    min1 = math.inf
    min2 = math.inf

    for num in nums:
      if num > max1:
        max2 = max1
        max1 = num
      elif num > max2:
        max2 = num
      if num < min1:
        min2 = min1
        min1 = num
      elif num < min2:
        min2 = num

    return max1 * max2 - min1 * min2"
"1914","class Solution:
  def rotateGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:
    m = len(grid)
    n = len(grid[0])
    t = 0  # the top
    l = 0  # the left
    b = m - 1  # the bottom
    r = n - 1  # the right

    while t < b and l < r:
      elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4
      netRotations = k % elementInThisLayer
      for _ in range(netRotations):
        topLeft = grid[t][l]
        for j in range(l, r):
          grid[t][j] = grid[t][j + 1]
        for i in range(t, b):
          grid[i][r] = grid[i + 1][r]
        for j in range(r, l, - 1):
          grid[b][j] = grid[b][j - 1]
        for i in range(b, t, -1):
          grid[i][l] = grid[i - 1][l]
        grid[t + 1][l] = topLeft
      t += 1
      l += 1
      b -= 1
      r -= 1

    return grid"
"1915","class Solution:
  def wonderfulSubstrings(self, word: str) -> int:
    ans = 0
    prefix = 0  # the binary prefix
    count = [0] * 1024  # the binary prefix count
    count[0] = 1  # the empty string """"

    for c in word:
      prefix ^= 1 << string.ascii_lowercase.index(c)
      # All the letters occur even number of times.
      ans += count[prefix]
      # `c` occurs odd number of times.
      ans += sum(count[prefix ^ 1 << i] for i in range(10))
      count[prefix] += 1

    return ans"
"1916","class Solution:
  def waysToBuildRooms(self, prevRoom: list[int]) -> int:
    kMod = 1_000_000_007
    graph = collections.defaultdict(list)

    for i, prev in enumerate(prevRoom):
      graph[prev].append(i)

    def dfs(node: int) -> tuple[int, int]:
      if not graph[node]:
        return 1, 1

      ans = 1
      l = 0

      for child in graph[node]:
        temp, r = dfs(child)
        ans = (ans * temp * math.comb(l + r, r)) % kMod
        l += r

      return ans, l + 1

    return dfs(0)[0]"
"1917","WITH
  RecommendedUserPairs AS (
    SELECT
      Listen1.user_id AS user1_id,
      Listen2.user_id AS user2_id
    FROM Listens AS Listen1
    INNER JOIN Listens AS Listen2
      USING (song_id, day)
    WHERE
      Listen1.user_id < Listen2.user_id
      AND NOT EXISTS(
        SELECT * FROM Friendship
        WHERE
          Listen1.user_id = Friendship.user1_id
          AND Listen2.user_id = Friendship.user2_id)
    GROUP BY Listen1.user_id, Listen2.user_id, Listen1.day
    HAVING COUNT(DISTINCT Listen1.song_id) >= 3
  )
SELECT
  user1_id AS user_id,
  user2_id AS recommended_id
FROM RecommendedUserPairs
UNION
SELECT
  user2_id AS user_id,
  user1_id AS recommended_id
FROM RecommendedUserPairs;"
"1918","class Solution:
  def kthSmallestSubarraySum(self, nums: list[int], k: int) -> int:
    def numSubarrayLessThan(m: int) -> int:
      res = 0
      summ = 0
      l = 0
      for r, num in enumerate(nums):
        summ += num
        while summ > m:
          summ -= nums[l]
          l += 1
        res += r - l + 1
      return res

    return bisect.bisect_left(range(sum(nums)), k,
                              key=lambda m: numSubarrayLessThan(m))"
"1919","SELECT DISTINCT
  Listen1.user_id AS user1_id,
  Listen2.user_id AS user2_id
FROM Listens AS Listen1
INNER JOIN Listens AS Listen2
  USING (song_id, day)
WHERE
  Listen1.user_id < Listen2.user_id
  AND EXISTS(
    SELECT * FROM Friendship
    WHERE
      Listen1.user_id = Friendship.user1_id
      AND Listen2.user_id = Friendship.user2_id)
GROUP BY Listen1.user_id, Listen2.user_id, Listen1.day
HAVING COUNT(DISTINCT Listen1.song_id) >= 3"
"192","cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'"
"1920","class Solution:
  def buildArray(self, nums: list[int]) -> list[int]:
    n = len(nums)

    for i, num in enumerate(nums):
      nums[i] += n * (nums[num] % n)

    for i in range(n):
      nums[i] //= n

    return nums"
"1921","class Solution:
  def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:
    for i, arrivalTime in enumerate(
            sorted([(d - 1) // s for d, s in zip(dist, speed)])):
      if i > arrivalTime:
        return i
    return len(dist)"
"1922","class Solution:
  def countGoodNumbers(self, n: int) -> int:
    kMod = 1_000_000_007

    def modPow(x: int, n: int) -> int:
      if n == 0:
        return 1
      if n % 2 == 1:
        return x * modPow(x, n - 1) % kMod
      return modPow(x * x % kMod, n // 2)

    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % kMod"
"1923","class Solution:
  def __init__(self):
    self.kBase = 165_131
    self.kHash = 8_417_508_174_513

  def longestCommonSubpath(self, n: int, paths: list[list[int]]) -> int:
    l = 0
    r = len(paths[0])

    while l < r:
      m = l + (r - l + 1) // 2
      if self._checkCommonSubpath(paths, m):
        l = m
      else:
        r = m - 1

    return l

  def _checkCommonSubpath(self, paths: list[list[int]], m: int) -> bool:
    """"""
    Returns True if there's a common subpath of length m for all the paths.
    """"""
    # Calculate the hash values for subpaths of length m for every path.
    hashSets = [self._rabinKarp(path, m) for path in paths]

    # Check if there is a common subpath of length m.
    for subpathHash in hashSets[0]:
      if all(subpathHash in hashSet for hashSet in hashSets):
        return True

    return False

  def _rabinKarp(self, path: list[int], m: int) -> set[int]:
    """"""Returns the hash values for subpaths of length m in the path.""""""
    hashes = set()
    maxPower = 1
    hash = 0

    for i, num in enumerate(path):
      hash = (hash * self.kBase + num) % self.kHash
      if i >= m:
        hash = (hash - path[i - m] * maxPower %
                self.kHash + self.kHash) % self.kHash
      else:
        maxPower = maxPower * self.kBase % self.kHash
      if i >= m - 1:
        hashes.add(hash)

    return hashes"
"1924","from dataclasses import dataclass


@dataclass(frozen=True)
class Point:
  x: float
  y: float


@dataclass(frozen=True)
class Disk:
  center: Point
  radius: float


class Solution:
  def outerTrees(self, trees: list[list[int]]) -> list[float]:
    points = [Point(x, y) for x, y in trees]
    disk = self._welzl(points, 0, [])
    return [disk.center.x, disk.center.y, disk.radius]

  def _welzl(
      self,
      points: list[Point],
      i: int,
      planePoints: list[Point],
  ) -> Disk:
    """"""Returns the smallest disk that encloses points[i..n).

    https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm
    """"""
    if i == len(points) or len(planePoints) == 3:
      return self._trivial(planePoints)
    disk = self._welzl(points, i + 1, planePoints)
    if self._inside(disk, points[i]):
      return disk
    return self._welzl(points, i + 1, planePoints + [points[i]])

  def _trivial(self, planePoints: list[Point]) -> Disk:
    """"""Returns the smallest disk that encloses `planePoints`.""""""
    if len(planePoints) == 0:
      return Disk(Point(0, 0), 0)
    if len(planePoints) == 1:
      return Disk(Point(planePoints[0].x, planePoints[0].y), 0)
    if len(planePoints) == 2:
      return self._getDisk(planePoints[0], planePoints[1])

    disk01 = self._getDisk(planePoints[0], planePoints[1])
    if self._inside(disk01, planePoints[2]):
      return disk01

    disk02 = self._getDisk(planePoints[0], planePoints[2])
    if self._inside(disk02, planePoints[1]):
      return disk02

    disk12 = self._getDisk(planePoints[1], planePoints[2])
    if self._inside(disk12, planePoints[0]):
      return disk12

    return self._getDiskFromThree(
        planePoints[0],
        planePoints[1],
        planePoints[2])

  def _getDisk(self, A: Point, B: Point) -> Disk:
    """"""Returns the smallest disk that encloses the points A and B.""""""
    x = (A.x + B.x) / 2
    y = (A.y + B.y) / 2
    return Disk(Point(x, y), self._distance(A, B) / 2)

  def _getDiskFromThree(self, A: Point, B: Point, C: Point) -> Disk:
    """"""Returns the smallest disk that encloses the points A, B, and C.""""""
    # Calculate midpoints.
    mAB = Point((A.x + B.x) / 2, (A.y + B.y) / 2)
    mBC = Point((B.x + C.x) / 2, (B.y + C.y) / 2)

    # Calculate the slopes and the perpendicular slopes.
    slopeAB = math.inf if B.x == A.x else (B.y - A.y) / (B.x - A.x)
    slopeBC = math.inf if C.x == B.x else (C.y - B.y) / (C.x - B.x)
    perpSlopeAB = math.inf if slopeAB == 0 else -1 / slopeAB
    perpSlopeBC = math.inf if slopeBC == 0 else -1 / slopeBC

    # Calculate the center.
    x = (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x +
         mAB.y - mBC.y) / (perpSlopeBC - perpSlopeAB)
    y = perpSlopeAB * (x - mAB.x) + mAB.y
    center = Point(x, y)
    return Disk(center, self._distance(center, A))

  def _inside(self, disk: Disk, point: Point) -> bool:
    """"""Returns True if the point is inside the disk.""""""
    return disk.radius > 0 and self._distance(disk.center, point) <= disk.radius

  def _distance(self, A: Point, B: Point) -> float:
    dx = A.x - B.x
    dy = A.y - B.y
    return math.sqrt(dx**2 + dy**2)"
"1925","class Solution:
  def countTriples(self, n: int) -> int:
    ans = 0
    squared = set()

    for i in range(1, n + 1):
      squared.add(i * i)

    for a in squared:
      for b in squared:
        if a + b in squared:
          ans += 1

    return ans"
"1926","class Solution:
  def nearestExit(self, maze: list[list[str]], entrance: list[int]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(maze)
    n = len(maze[0])
    q = collections.deque([(entrance[0], entrance[1])])
    seen = {(entrance[0], entrance[1])}

    step = 1
    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if (x, y) in seen or maze[x][y] == '+':
            continue
          if x == 0 or x == m - 1 or y == 0 or y == n - 1:
            return step
          q.append((x, y))
          seen.add((x, y))
      step += 1

    return -1"
"1927","class Solution:
  def sumGame(self, num: str) -> bool:
    n = len(num)
    ans = 0.0

    def getExpectation(c: str) -> float:
      return 4.5 if c == '?' else int(c)

    for i in range(n // 2):
      ans += getExpectation(num[i])

    for i in range(n // 2, n):
      ans -= getExpectation(num[i])

    return ans != 0.0"
"1928","class Solution:
  def minCost(
      self,
      maxTime: int,
      edges: list[list[int]],
      passingFees: list[int],
  ) -> int:
    n = len(passingFees)
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      dst: int,
      maxTime: int,
      passingFees: list[int],
  ) -> int:
    # cost[i] := the minimum cost to reach the i-th city
    cost = [math.inf] * len(graph)
    # dist[i] := the minimum time to reach the i-th city
    dist = [maxTime + 1] * len(graph)

    cost[src] = passingFees[src]
    dist[src] = 0
    minHeap = [(cost[src], dist[src], src)]  # (cost[u], dist[u], u)

    while minHeap:
      currCost, d, u = heapq.heappop(minHeap)
      if u == dst:
        return cost[dst]
      if d > dist[u] and currCost > cost[u]:
        continue
      for v, w in graph[u]:
        if d + w > maxTime:
          continue
        # Go from u -> v.
        if currCost + passingFees[v] < cost[v]:
          cost[v] = currCost + passingFees[v]
          dist[v] = d + w
          heapq.heappush(minHeap, (cost[v], dist[v], v))
        elif d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))

    return -1"
"1929","class Solution:
  def getConcatenation(self, nums: list[int]) -> list[int]:
    return nums * 2"
"193","grep -e ""^[0-9]\{3\}\-[0-9]\{3\}\-[0-9]\{4\}$"" -e ""^([0-9]\{3\}) [0-9]\{3\}\-[0-9]\{4\}$"" file.txt"
"1930","class Solution:
  def countPalindromicSubsequence(self, s: str) -> int:
    ans = 0
    first = [len(s)] * 26
    last = [0] * 26

    for i, c in enumerate(s):
      index = string.ascii_lowercase.index(c)
      first[index] = min(first[index], i)
      last[index] = i

    for f, l in zip(first, last):
      if f < l:
        ans += len(set(s[f + 1:l]))

    return ans"
"1931","class Solution:
  def colorTheGrid(self, m: int, n: int) -> int:
    def getColor(mask: int, r: int) -> int:
      return mask >> r * 2 & 3

    def setColor(mask: int, r: int, color: int) -> int:
      return mask | color << r * 2

    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(r: int, c: int, prevColMask: int, currColMask: int) -> int:
      if c == n:
        return 1
      if r == m:
        return dp(0, c + 1, currColMask, 0)

      ans = 0

      # 1 := red, 2 := green, 3 := blue
      for color in range(1, 4):
        if getColor(prevColMask, r) == color:
          continue
        if r > 0 and getColor(currColMask, r - 1) == color:
          continue
        ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color))
        ans %= kMod

      return ans

    return dp(0, 0, 0, 0)"
"1932","class Solution:
  def canMerge(self, trees: list[TreeNode]) -> TreeNode | None:
    valToNode = {}  # {val: node}
    count = collections.Counter()  # {val: freq}

    for tree in trees:
      valToNode[tree.val] = tree
      count[tree.val] += 1
      if tree.left:
        count[tree.left.val] += 1
      if tree.right:
        count[tree.right.val] += 1

    def isValidBST(tree: TreeNode | None, minNode: TreeNode | None,
                   maxNode: TreeNode | None) -> bool:
      if not tree:
        return True
      if minNode and tree.val <= minNode.val:
        return False
      if maxNode and tree.val >= maxNode.val:
        return False
      if not tree.left and not tree.right and tree.val in valToNode:
        val = tree.val
        tree.left = valToNode[val].left
        tree.right = valToNode[val].right
        del valToNode[val]

      return isValidBST(
          tree.left, minNode, tree) and isValidBST(
          tree.right, tree, maxNode)

    for tree in trees:
      if count[tree.val] == 1:
        if isValidBST(tree, None, None) and len(valToNode) <= 1:
          return tree
        return None

    return None"
"1933","class Solution:
  def isDecomposable(self, s: str) -> bool:
    twos = 0

    for _, group in itertools.groupby(s):
      groupLength = len(list(group))
      if groupLength % 3 == 1:
        return False
      if groupLength % 3 == 2:
        twos += 1
        if twos > 1:
          return False

    return twos == 1"
"1934","SELECT
  Signups.user_id,
  IFNULL(ROUND(AVG(Confirmations.action = 'confirmed'), 2), 0) AS confirmation_rate
FROM Signups
LEFT JOIN Confirmations
  USING (user_id)
GROUP BY 1;"
"1935","class Solution:
  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
    ans = 0
    broken = set(brokenLetters)

    for word in text.split():
      ans += all(c not in broken for c in word)

    return ans"
"1936","class Solution:
  def addRungs(self, rungs: list[int], dist: int) -> int:
    ans = 0
    prev = 0

    for rung in rungs:
      ans += (rung - prev - 1) // dist
      prev = rung

    return ans"
"1937","class Solution:
  def maxPoints(self, points: list[list[int]]) -> int:
    n = len(points[0])
    # dp[j] := the maximum number of points you can have if points[i][j] is the
    # most recent cell you picked
    dp = [0] * n

    for row in points:
      leftToRight = [0] * n
      runningMax = 0
      for j in range(n):
        runningMax = max(runningMax - 1, dp[j])
        leftToRight[j] = runningMax

      rightToLeft = [0] * n
      runningMax = 0
      for j in range(n - 1, - 1, -1):
        runningMax = max(runningMax - 1, dp[j])
        rightToLeft[j] = runningMax

      for j in range(n):
        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]

    return max(dp)"
"1938","class TrieNode:
  def __init__(self):
    self.children: list[TrieNode] = [None] * 2
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()
    self.kHeight = 17

  def update(self, num: int, val: int) -> None:
    node = self.root
    for i in range(self.kHeight, -1, -1):
      bit = (num >> i) & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]
      node.count += val

  def query(self, num: int) -> int:
    ans = 0
    node = self.root
    for i in range(self.kHeight, -1, -1):
      bit = (num >> i) & 1
      targetBit = bit ^ 1
      if node.children[targetBit] and node.children[targetBit].count > 0:
        ans += 1 << i
        node = node.children[targetBit]
      else:
        node = node.children[targetBit ^ 1]
    return ans


class Solution:
  def maxGeneticDifference(
      self,
      parents: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    n = len(parents)
    ans = [0] * len(queries)
    rootVal = -1
    tree = [[] for _ in range(n)]
    nodeToQueries = collections.defaultdict(list)  # {node: (index, val)}
    trie = Trie()

    for i, parent in enumerate(parents):
      if parent == -1:
        rootVal = i
      else:
        tree[parent].append(i)

    for i, (node, val) in enumerate(queries):
      nodeToQueries[node].append((i, val))

    def dfs(node: int) -> None:
      trie.update(node, 1)

      # Answer queries for node
      for i, val in nodeToQueries[node]:
        ans[i] = trie.query(val)

      for child in tree[node]:
        dfs(child)

      trie.update(node, -1)

    dfs(rootVal)
    return ans"
"1939","WITH
  UserToTimestampDiff AS (
    SELECT user_id,
      TIMESTAMPDIFF(
        SECOND,
        time_stamp,
        LEAD(time_stamp) OVER(
          PARTITION BY user_id
          ORDER BY time_stamp
        )
      ) AS timestamp_diff
    FROM Confirmations
  )
SELECT DISTINCT user_id
FROM UserToTimestampDiff
WHERE timestamp_diff <= 24 * 60 * 60;"
"194","awk '{
  for (i = 1; i <= NF; ++i) {
    if (NR == 1) {
      arr[i] = $i;
    } else {
      arr[i] = arr[i] "" "" $i;
    }
  }
} END {
  for (i = 1; i <= NF; ++i) {
    print arr[i];
  }
}' file.txt"
"1940","class Solution:
  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:
    kMax = 100
    ans = []
    count = [0] * (kMax + 1)

    for array in arrays:
      for a in array:
        count[a] += 1
        if count[a] == len(arrays):
          ans.append(a)

    return ans"
"1941","class Solution:
  def areOccurrencesEqual(self, s: str) -> bool:
    return len(set(collections.Counter(s).values())) == 1"
"1942","class Solution:
  def smallestChair(self, times: list[list[int]], targetFriend: int) -> int:
    nextUnsatChair = 0
    emptyChairs = []
    occupied = []  # (leaving, chair)

    for i in range(len(times)):
      times[i].append(i)

    times.sort(key=lambda x: x[0])

    for arrival, leaving, i in times:
      while len(occupied) > 0 and occupied[0][0] <= arrival:
        unsatChair = heapq.heappop(occupied)[1]
        heapq.heappush(emptyChairs, unsatChair)
      if i == targetFriend:
        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair
      if len(emptyChairs) == 0:
        heapq.heappush(occupied, (leaving, nextUnsatChair))
        nextUnsatChair += 1
      else:
        emptyChair = heapq.heappop(emptyChairs)
        heapq.heappush(occupied, (leaving, emptyChair))"
"1943","from sortedcontainers import SortedDict


class Solution:
  def splitPainting(self, segments: list[list[int]]) -> list[list[int]]:
    ans = []
    prevIndex = 0
    runningMix = 0
    timeline = SortedDict()

    for start, end, color in segments:
      timeline[start] = timeline.get(start, 0) + color
      timeline[end] = timeline.get(end, 0) - color

    for i, mix in timeline.items():
      if runningMix > 0:
        ans.append([prevIndex, i, runningMix])
      runningMix += mix
      prevIndex = i

    return ans"
"1944","class Solution:
  def canSeePersonsCount(self, heights: list[int]) -> list[int]:
    ans = [0] * len(heights)
    stack = []

    for i, height in enumerate(heights):
      while stack and heights[stack[-1]] <= height:
        ans[stack.pop()] += 1
      if stack:
        ans[stack[-1]] += 1
      stack.append(i)

    return ans"
"1945","class Solution:
  def getLucky(self, s: str, k: int) -> int:
    ans = self._convert(s)
    for _ in range(k):
      ans = self._getDigitSum(ans)
    return ans

  def _convert(self, s: str) -> int:
    return int(''.join(str(string.ascii_lowercase.index(c) + 1) for c in s))

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"1946","class Solution:
  def maximumNumber(self, num: str, change: list[int]) -> str:
    numList = list(num)
    mutated = False

    for i, c in enumerate(numList):
      d = int(c)
      numlist[i] = chr(ord('0') + max(d, change[d]))
      if mutated and d > change[d]:
        return ''.join(numList)
      if d < change[d]:
        mutated = True

    return ''.join(numList)"
"1947","class Solution:
  def maxCompatibilitySum(
      self,
      students: list[list[int]],
      mentors: list[list[int]],
  ) -> int:
    ans = 0

    def dfs(i: int, scoreSum: int, used: list[bool]) -> None:
      nonlocal ans
      if i == len(students):
        ans = max(ans, scoreSum)
        return

      for j, mentor in enumerate(mentors):
        if used[j]:
          continue
        used[j] = True  # The `mentors[j]` is used.
        dfs(i + 1, scoreSum + sum(s == m
                                  for s, m in zip(students[i], mentor)), used)
        used[j] = False

    dfs(0, 0, [False] * len(students))
    return ans"
"1948","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.deleted = False


class Solution:
  def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:
    ans = []
    root = TrieNode()
    subtreeToNodes: dict[str, list[TrieNode]] = collections.defaultdict(list)

    # Construct the Trie
    for path in sorted(paths):
      node = root
      for s in path:
        node = node.children[s]

    # For each subtree, fill in the {subtree encoding: [root]} hash table
    def buildSubtreeToRoots(node: TrieNode) -> str:
      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])
                              for s in node.children) + ')'
      if subtree != '()':
        subtreeToNodes[subtree].append(node)
      return subtree

    buildSubtreeToRoots(root)

    # Mark nodes that should be deleted
    for nodes in subtreeToNodes.values():
      if len(nodes) > 1:
        for node in nodes:
          node.deleted = True

    # Construct the answer array for nodes that haven't been deleted
    def constructPath(node: TrieNode, path: list[str]) -> None:
      for s, child in node.children.items():
        if not child.deleted:
          constructPath(child, path + [s])
      if path:
        ans.append(path)

    constructPath(root, [])
    return ans"
"1949","WITH
  TwoWayFriendship AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id, user1_id FROM Friendship
  )
SELECT
  User1.user_id AS user1_id,
  User2.user_id AS user2_id,
  COUNT(*) AS common_friend
FROM TwoWayFriendship AS User1
INNER JOIN TwoWayFriendship AS User2
  ON (
    User1.friend_id = User2.friend_id
    AND User1.user_id < User2.user_id)
WHERE EXISTS (
  SELECT *
  FROM Friendship
  WHERE
    Friendship.user1_id = User1.user_id
    AND Friendship.user2_id = User2.user_id
)
GROUP BY 1, 2
HAVING common_friend >= 3;"
"195","awk 'NR == 10' file.txt"
"1950","class Solution:
  # Similar to 1950. Maximum of Minimum Values in All Subarrays
  def findMaximums(self, nums: list[int]) -> list[int]:
    n = len(nums)
    ans = [0] * n
    # prevMin[i] := the index k s.t.
    # nums[k] is the previous minimum in nums[0..n)
    prevMin = [-1] * n
    # nextMin[i] := the index k s.t.
    # nums[k] is the next minimum innums[i + 1..n)
    nextMin = [n] * n
    stack = []

    for i, num in enumerate(nums):
      while stack and nums[stack[-1]] > nums[i]:
        index = stack.pop()
        nextMin[index] = i
      if stack:
        prevMin[i] = stack[-1]
      stack.append(i)

    # For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.
    # nums[i] is the minimum in nums[l..r].
    # So, the ans[r - l + 1] will be at least nums[i].
    for num, l, r in zip(nums, prevMin, nextMin):
      sz = r - l - 1
      ans[sz - 1] = max(ans[sz - 1], num)

    # ans[i] should always >= ans[i + 1..n).
    for i in range(n - 2, -1, -1):
      ans[i] = max(ans[i], ans[i + 1])

    return ans"
"1951","WITH
  RankedRelations AS (
    SELECT
      User1.user_id AS user1_id,
      User2.user_id AS user2_id,
      RANK() OVER(ORDER BY COUNT(User1.follower_id) DESC) AS `rank`
    FROM Relations AS User1
    INNER JOIN Relations AS User2
      USING (follower_id)
    WHERE User1.user_id < User2.user_id
    GROUP BY 1, 2
  )
SELECT user1_id, user2_id
FROM RankedRelations
WHERE `rank` = 1;"
"1952","class Solution:
  def isThree(self, n: int) -> bool:
    if n == 1:
      return False
    # The numbers with exactly three divisors are perfect squares of a prime
    # number.
    root = math.isqrt(n)
    return (root**2 == n and
            all(root % i != 0
                for i in range(2, math.isqrt(root) + 1)))"
"1953","class Solution:
  def numberOfWeeks(self, milestones: list[int]) -> int:
    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.
    summ = sum(milestones)
    nonMax = summ - max(milestones)
    return min(summ, 2 * nonMax + 1)"
"1954","class Solution:
  def minimumPerimeter(self, neededApples: int) -> int:
    def numApples(k: int) -> int:
      """"""Returns the number of apples at the k-th level.

         k := the level making perimeter = 8k
      p(k) := the number of apples at the k-th level on the perimeter
      n(k) := the number of apples at the k-th level not no the perimeter

      p(1) =             1 + 2
      p(2) =         3 + 2 + 3 + 4
      p(3) =     5 + 4 + 3 + 4 + 5 + 6
      p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8
      p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k
          = k + 2k^2 + 2*k(k-1)//2
          = k + 2k^2 + k^2 - k = 3k^2

      n(k) = p(1) + p(2) + p(3) + ... + p(k)
          = 3*1  + 3*4  + 3*9  + ... + 3*k^2
          = 3 * (1 + 4 + 9 + ... + k^2)
          = 3 * k(k+1)(2k+1)//6 = k(k+1)(2k+1)//2
      So, the number of apples at the k-th level should be
        k(k+1)(2k+1)//2 * 4 = 2k(k+1)(2k+1)
      """"""
      return 2 * k * (k + 1) * (2 * k + 1)

    return bisect.bisect_left(range(100_000), neededApples,
                              key=lambda m: numApples(m)) * 8"
"1955","class Solution:
  def countSpecialSubsequences(self, nums: list[int]) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, prev: int) -> int:
      """"""
      Returns the number of increasing subsequences of the first i numbers,
      where the the previous number is j - 1.
      """"""
      if i == len(nums):
        return prev == 2

      res = 0

      # Don't include `nums[i]`.
      res += dp(i + 1, prev)

      # Include `nums[i]`.
      if nums[i] == prev:
        res += dp(i + 1, prev)
      if prev == -1 and nums[i] == 0:
        res += dp(i + 1, 0)
      if prev == 0 and nums[i] == 1:
        res += dp(i + 1, 1)
      if prev == 1 and nums[i] == 2:
        res += dp(i + 1, 2)

      res %= kMod
      return res

    return dp(0, -1)"
"1956","class Solution:
  def minDayskVariants(self, points: list[list[int]], k: int) -> int:
    kMax = 100
    ans = math.inf

    for a in range(1, kMax + 1):
      for b in range(1, kMax + 1):
        # Stores the k minimum distances of points that can reach (a, b).
        maxHeap = []
        for x, y in points:
          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))
          if len(maxHeap) > k:
            heapq.heappop(maxHeap)
        ans = min(ans, -maxHeap[0])

    return ans"
"1957","class Solution:
  def makeFancyString(self, s: str) -> str:
    ans = []
    for c in s:
      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:
        ans.append(c)
    return ''.join(ans)"
"1958","class Solution:
  def checkMove(
      self,
      board: list[list[str]],
      rMove: int,
      cMove: int,
      color: str,
  ) -> bool:
    dirs = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
            (0, 1), (1, -1), (1, 0), (1, 1))

    for dx, dy in dirs:
      cellsCount = 2
      i = rMove + dx
      j = cMove + dy
      while 0 <= i < 8 and 0 <= j < 8:
        # There are no free cells in between.
        if board[i][j] == '.':
          break
        # Need >= 3 cells.
        if cellsCount == 2 and board[i][j] == color:
          break
        # >= 3 cells.
        if board[i][j] == color:
          return True
        i += dx
        j += dy
        cellsCount += 1

    return False"
"1959","class Solution:
  def minSpaceWastedKResizing(self, nums: list[int], k: int) -> int:
    kMax = 200_000_000

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""
      Returns the minimum space wasted for nums[i..n) if you can resize k times.
      """"""
      if i == len(nums):
        return 0
      if k == -1:
        return kMax

      res = kMax
      summ = 0
      maxNum = nums[i]

      for j in range(i, len(nums)):
        summ += nums[j]
        maxNum = max(maxNum, nums[j])
        wasted = maxNum * (j - i + 1) - summ
        res = min(res, dp(j + 1, k - 1) + wasted)

      return res

    return dp(0, k)"
"196","DELETE P2
FROM Person AS P1
INNER JOIN Person AS P2
  ON (P1.email = P2.email)
WHERE P1.id < P2.id;"
"1960","class Solution:
  def maxProduct(self, s: str) -> int:
    n = len(s)

    def manacher(s: str) -> list[int]:
      maxExtends = [0] * n
      leftToRight = [1] * n
      center = 0

      for i in range(n):
        r = center + maxExtends[center] - 1
        mirrorIndex = center - (i - center)
        extend = 1 if i > r else min(maxExtends[mirrorIndex], r - i + 1)
        while i - extend >= 0 and i + extend < n and s[i - extend] == s[i + extend]:
          leftToRight[i + extend] = 2 * extend + 1
          extend += 1
        maxExtends[i] = extend
        if i + maxExtends[i] >= r:
          center = i

      for i in range(1, n):
        leftToRight[i] = max(leftToRight[i], leftToRight[i - 1])

      return leftToRight

    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]
    maxLeft = manacher(s)
    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]
    maxRight = manacher(s[::-1])[::-1]
    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))"
"1961","class Solution:
  def isPrefixString(self, s: str, words: list[str]) -> bool:
    prefix = []
    for word in words:
      prefix.append(word)
      if ''.join(prefix) == s:
        return True
    return False"
"1962","class Solution:
  def minStoneSum(self, piles: list[int], k: int) -> int:
    maxHeap = [-pile for pile in piles]
    heapq.heapify(maxHeap)

    for _ in range(k):
      heapq.heapreplace(maxHeap, maxHeap[0] // 2)

    return -sum(maxHeap)"
"1963","class Solution:
  def minSwaps(self, s: str) -> int:
    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.
    # The answer is ceil(# of unmatched pairs // 2).
    unmatched = 0

    for c in s:
      if c == '[':
        unmatched += 1
      elif unmatched > 0:  # c == ']' and there's a match.
        unmatched -= 1

    return (unmatched + 1) // 2"
"1964","class Solution:
  # Similar to 300. Longest Increasing Subsequence
  def longestObstacleCourseAtEachPosition(
      self, obstacles: list[int],
  ) -> list[int]:
    ans = []
    # tails[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tails = []

    for obstacle in obstacles:
      if not tails or obstacle >= tails[-1]:
        tails.append(obstacle)
        ans.append(len(tails))
      else:
        index = bisect.bisect_right(tails, obstacle)
        tails[index] = obstacle
        ans.append(index + 1)

    return ans"
"1965","SELECT Employees.employee_id
FROM Employees
LEFT JOIN Salaries
  USING (employee_id)
WHERE Salaries.salary IS NULL
UNION ALL
SELECT Salaries.employee_id
FROM Salaries
LEFT JOIN Employees
  USING (employee_id)
WHERE Employees.name IS NULL
ORDER BY 1;"
"1966","class Solution:
  def binarySearchableNumbers(self, nums: list[int]) -> int:
    n = len(nums)
    # prefixMaxs[i] := max(nums[0..i))
    prefixMaxs = [0] * n
    # suffixMins[i] := min(nums[i + 1..n))
    suffixMins = [0] * n

    # Fill in `prefixMaxs`.
    prefixMaxs[0] = -math.inf
    for i in range(1, n):
      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])

    # Fill in `suffixMins`.
    suffixMins[n - 1] = math.inf
    for i in range(n - 2, -1, -1):
      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])

    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))"
"1967","class Solution:
  def numOfStrings(self, patterns: list[str], word: str) -> int:
    return sum(pattern in word for pattern in patterns)"
"1968","class Solution:
  def rearrangeArray(self, nums: list[int]) -> list[int]:
    nums.sort()
    for i in range(1, len(nums), 2):
      nums[i], nums[i - 1] = nums[i - 1], nums[i]
    return nums"
"1969","class Solution:
  def minNonZeroProduct(self, p: int) -> int:
    kMod = 1_000_000_007
    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].
    n = 1 << p
    halfCount = n // 2 - 1
    return pow(n - 2, halfCount, kMod) * ((n - 1) % kMod) % kMod"
"197","SELECT Today.id
FROM Weather AS Today
INNER JOIN Weather AS Yesterday
  ON (DATE_SUB(Today.recordDate, INTERVAL 1 DAY) = Yesterday.recordDate)
WHERE Today.temperature > Yesterday.temperature;"
"1970","class Solution:
  def latestDayToCross(self, row: int, col: int, cells: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))

    def canWalk(day: int) -> bool:
      matrix = [[0] * col for _ in range(row)]
      for i in range(day):
        x, y = cells[i]
        matrix[x - 1][y - 1] = 1

      q = collections.deque()

      for j in range(col):
        if matrix[0][j] == 0:
          q.append((0, j))
          matrix[0][j] = 1

      while q:
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == row or y < 0 or y == col:
            continue
          if matrix[x][y] == 1:
            continue
          if x == row - 1:
            return True
          q.append((x, y))
          matrix[x][y] = 1

      return False

    ans = 0
    l = 1
    r = len(cells) - 1

    while l <= r:
      m = (l + r) // 2
      if canWalk(m):
        ans = m
        l = m + 1
      else:
        r = m - 1

    return ans"
"1971","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def validPath(
      self,
      n: int,
      edges: list[list[int]],
      source: int,
      destination: int,
  ) -> bool:
    uf = UnionFind(n)

    for u, v in edges:
      uf.unionByRank(u, v)

    return uf.find(source) == uf.find(destination)"
"1972","WITH
  TwoWayCalls AS (
    SELECT caller_id, recipient_id, call_time FROM Calls
    UNION ALL
    SELECT recipient_id, caller_id, call_time FROM Calls
  ),
  RankedCalls AS (
    SELECT
      caller_id,
      recipient_id,
      DATE(call_time) AS `date`,
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time ASC
      ) AS rank_asc
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time DESC
      ) AS rank_desc
    FROM TwoWayCalls
  )
SELECT DISTINCT caller_id AS user_id
FROM RankedCalls
WHERE rank_asc = 1 OR rank_desc = 1
GROUP BY caller_id, `date`
HAVING COUNT(DISTINCT recipient_id) = 1;"
"1973","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  summ: int
  count: int


class Solution:
  def equalToDescendants(self, root: TreeNode | None) -> int:
    def dfs(root: TreeNode | None) -> T:
      if not root:
        return T(0, 0)
      left = dfs(root.left)
      right = dfs(root.right)
      return T(root.val + left.summ + right.summ,
               left.count + right.count +
               (1 if root.val == left.summ + right.summ else 0))

    return dfs(root).count"
"1974","class Solution:
  def minTimeToType(self, word: str) -> int:
    moves = 0
    letter = 'a'

    for c in word:
      diff = abs(ord(c) - ord(letter))
      moves += min(diff, 26 - diff)
      letter = c

    return moves + len(word)"
"1975","class Solution:
  def maxMatrixSum(self, matrix: list[list[int]]) -> int:
    absSum = 0
    minAbs = math.inf
    # 0 := even number of negatives
    # 1 := odd number of negatives
    oddNeg = 0

    for row in matrix:
      for num in row:
        absSum += abs(num)
        minAbs = min(minAbs, abs(num))
        if num < 0:
          oddNeg ^= 1

    return absSum - oddNeg * minAbs * 2"
"1976","class Solution:
  def countPaths(self, n: int, roads: list[list[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in roads:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, n - 1)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      dst: int,
  ) -> int:
    kMod = 10**9 + 7
    ways = [0] * len(graph)
    dist = [math.inf] * len(graph)

    ways[src] = 1
    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          ways[v] = ways[u]
          heapq.heappush(minHeap, (dist[v], v))
        elif d + w == dist[v]:
          ways[v] += ways[u]
          ways[v] %= kMod

    return ways[dst]"
"1977","class Solution:
  def numberOfCombinations(self, num: str) -> int:
    if num[0] == '0':
      return 0

    kMod = 1_000_000_007
    n = len(num)
    # dp[i][k] := the number of possible lists of integers ending in num[i]
    # with the length of the last number being 1..k
    dp = [[0] * (n + 1) for _ in range(n)]
    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)
    lcs = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(n - 1, -1, -1):
      for j in range(i + 1, n):
        if num[i] == num[j]:
          lcs[i][j] = lcs[i + 1][j + 1] + 1

    for i in range(n):
      for k in range(1, i + 2):
        dp[i][k] += dp[i][k - 1]
        dp[i][k] %= kMod
        # The last number is num[s..i].
        s = i - k + 1
        if num[s] == '0':
          # the number of possible lists of integers ending in num[i] with the
          # length of the last number being k
          continue
        if s == 0:  # the whole string
          dp[i][k] += 1
          continue
        if s < k:
          # The length k is not enough, so add the number of possible lists of
          # integers in num[0..s - 1].
          dp[i][k] += dp[s - 1][s]
          continue
        l = lcs[s - k][s]
        if l >= k or num[s - k + l] <= num[s + l]:
          # Have enough length k and num[s - k..s - 1] <= num[j..i].
          dp[i][k] += dp[s - 1][k]
        else:
          # Have enough length k but num[s - k..s - 1] > num[j..i].
          dp[i][k] += dp[s - 1][k - 1]

    return dp[n - 1][n] % kMod"
"1978","SELECT Employee.employee_id
FROM Employees AS Employee
LEFT JOIN Employees AS Manager
  ON (Employee.manager_id = Manager.employee_id)
WHERE
  Employee.salary < 30000
  AND Employee.manager_id IS NOT NULL
  AND Manager.employee_id IS NULL
ORDER BY 1;"
"1979","class Solution:
  def findGCD(self, nums: list[int]) -> int:
    return math.gcd(min(nums), max(nums))"
"198","class Solution:
  def rob(self, nums: list[int]) -> int:
    prev1 = 0  # dp[i - 1]
    prev2 = 0  # dp[i - 2]

    for num in nums:
      dp = max(prev1, prev2 + num)
      prev2 = prev1
      prev1 = dp

    return prev1"
"1980","class Solution:
  def findDifferentBinaryString(self, nums: list[str]) -> str:
    return ''.join('1' if num[i] == '0' else '0' for i, num in enumerate(nums))"
"1981","class Solution:
  def minimizeTheDifference(self, mat: list[list[int]], target: int) -> int:
    minSum = sum(min(row) for row in mat)
    if minSum >= target:  # No need to consider any larger combination.
      return minSum - target

    @functools.lru_cache(None)
    def dp(i: int, summ: int) -> int:
      if i == len(mat):
        return abs(summ - target)
      return min(dp(i + 1, summ + num) for num in mat[i])

    return dp(0, 0)"
"1982","class Solution:
  def recoverArray(self, n: int, sums: list[int]) -> list[int]:
    def recover(sums: list[int]) -> list[int]:
      if len(sums) == 1:
        return []

      count = collections.Counter(sums)
      # Either num or -num must be in the final array.
      #  num + sumsExcludingNum = sumsIncludingNum
      # -num + sumsIncludingNum = sumsExcludingNum
      num = sums[1] - sums[0]
      sumsExcludingNum = []
      sumsIncludingNum = []
      chooseSumsExcludingNum = True

      for summ in sums:
        if count[summ] == 0:
          continue
        count[summ] -= 1
        count[summ + num] -= 1
        sumsExcludingNum.append(summ)
        sumsIncludingNum.append(summ + num)
        if summ + num == 0:
          chooseSumsExcludingNum = False

      # Choose `sumsExludingNum` by default since we want to gradually strip
      # `num` from each sum in `sums` to have the final array. However, we should
      # always choose the group of sums with 0 since it's a must-have.
      return ([num] + recover(sumsExcludingNum) if chooseSumsExcludingNum else
              [-num] + recover(sumsIncludingNum))

    return recover(sorted(sums))"
"1983","class Solution:
  def widestPairOfIndices(self, nums1: list[int], nums2: list[int]) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      prefix += num1 - num2
      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))

    return ans"
"1984","class Solution:
  def minimumDifference(self, nums: list[int], k: int) -> int:
    nums.sort()
    ans = nums[k - 1] - nums[0]

    for i in range(k, len(nums)):
      ans = min(ans, nums[i] - nums[i - k + 1])

    return ans"
"1985","class Solution:
  # Similar to 215. Kth Largest Element in an Array
  def kthLargestNumber(self, nums: list[str], k: int) -> str:
    minHeap = []

    for num in nums:
      heapq.heappush(minHeap, int(num))
      if len(minHeap) > k:
        heapq.heappop(minHeap)

    return str(minHeap[0])"
"1986","class Solution:
  def minSessions(self, tasks: list[int], sessionTime: int) -> int:
    # Returns True if we can assign tasks[s..n) to `sessions`. Note that `sessions`
    # may be occupied by some tasks.
    def dfs(s: int, sessions: list[int]) -> bool:
      if s == len(tasks):
        return True

      for i, session in enumerate(sessions):
        # Can't assign the tasks[s] to this session.
        if session + tasks[s] > sessionTime:
          continue
        # Assign the tasks[s] to this session.
        sessions[i] += tasks[s]
        if dfs(s + 1, sessions):
          return True
        # Backtracking.
        sessions[i] -= tasks[s]
        # If it's the first time we assign the tasks[s] to this session, then future
        # `session`s can't satisfy either.
        if sessions[i] == 0:
          return False

      return False

    for numSessions in range(1, len(tasks) + 1):
      if dfs(0, [0] * numSessions):
        return numSessions"
"1987","class Solution:
  # Similar to 940. Distinct Subsequences II
  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
    kMod = 1_000_000_007
    # endsIn[i] := the number of subsequence that end in ('0' + i)
    endsIn = {'0': 0, '1': 0}

    for c in binary:
      endsIn[c] = sum(endsIn.values()) % kMod
      # Don't count '0' since we want to avoid the leading zeros case.
      # However, we can always count '1'.
      if c == '1':
        endsIn['1'] += 1

    # Count '0' in the end.
    return (sum(endsIn.values()) + ('0' in binary)) % kMod"
"1988","SELECT
  Schools.school_id,
  IFNULL(MIN(Exam.score), -1) AS score
FROM Schools
LEFT JOIN Exam
  ON (capacity >= student_count)
GROUP BY 1;"
"1989","class Solution:
  def catchMaximumAmountofPeople(self, team: list[int], dist: int) -> int:
    ans = 0
    i = 0  # 0s index
    j = 0  # 1s index

    while i < len(team) and j < len(team):
      if i + dist < j or team[i] != 0:
        # Find the next 0 that can be caught by 1.
        i += 1
      elif j + dist < i or team[j] != 1:
        # Find the next 1 that can catch 0.
        j += 1
      else:
        # team[j] catches team[i], so move both.
        ans += 1
        i += 1
        j += 1

    return ans"
"199","class Solution:
  def rightSideView(self, root: TreeNode | None) -> list[int]:
    ans = []

    def dfs(root: TreeNode | None, depth: int) -> None:
      if not root:
        return

      if depth == len(ans):
        ans.append(root.val)
      dfs(root.right, depth + 1)
      dfs(root.left, depth + 1)

    dfs(root, 0)
    return ans"
"1990","WITH
  Platforms AS (
    SELECT 'Android' AS platform
    UNION ALL
    SELECT 'IOS' AS platform
    UNION ALL
    SELECT 'Web' AS platform
  ),
  ExperimentNames AS (
    SELECT 'Reading' AS experiment_name
    UNION ALL
    SELECT 'Sports'
    UNION ALL
    SELECT 'Programming'
  )
SELECT
  Platforms.platform,
  ExperimentNames.experiment_name,
  COUNT(experiment_id) AS num_experiments
FROM Platforms
CROSS JOIN ExperimentNames
LEFT JOIN Experiments
  USING (platform, experiment_name)
GROUP BY 1, 2;"
"1991","class Solution:
  def findMiddleIndex(self, nums: list[int]) -> int:
    prefix = 0
    suffix = sum(nums)

    for i, num in enumerate(nums):
      suffix -= num
      if prefix == suffix:
        return i
      prefix += num

    return -1"
"1992","class Solution:
  def findFarmland(self, land: list[list[int]]) -> list[list[int]]:
    ans = []

    def dfs(i: int, j: int, cell: list[int]) -> None:
      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):
        return
      if land[i][j] != 1:
        return
      land[i][j] = 2  # Mark as visited.
      cell[0] = max(cell[0], i)
      cell[1] = max(cell[1], j)
      dfs(i + 1, j, cell)
      dfs(i, j + 1, cell)

    for i in range(len(land)):
      for j in range(len(land[0])):
        if land[i][j] == 1:
          cell = [i, j]
          dfs(i, j, cell)
          ans.append([i, j, *cell])

    return ans"
"1993","class Node:
  def __init__(self):
    self.children: list[int] = []
    self.lockedBy = -1


class LockingTree:
  def __init__(self, parent: list[int]):
    self.parent = parent
    self.nodes = [Node() for _ in range(len(parent))]
    for i in range(1, len(parent)):
      self.nodes[parent[i]].children.append(i)

  def lock(self, num: int, user: int) -> bool:
    if self.nodes[num].lockedBy != -1:
      return False
    self.nodes[num].lockedBy = user
    return True

  def unlock(self, num: int, user: int) -> bool:
    if self.nodes[num].lockedBy != user:
      return False
    self.nodes[num].lockedBy = -1
    return True

  def upgrade(self, num: int, user: int) -> bool:
    if self.nodes[num].lockedBy != -1:
      return False
    if not self._anyLockedDescendant(num):
      return False

    # Walk up the hierarchy to ensure that there are no locked ancestors.
    i = num
    while i != -1:
      if self.nodes[i].lockedBy != -1:
        return False
      i = self.parent[i]

    self._unlockDescendants(num)
    self.nodes[num].lockedBy = user
    return True

  def _anyLockedDescendant(self, i: int) -> bool:
    return (self.nodes[i].lockedBy != -1 or
            any(self._anyLockedDescendant(child)
            for child in self.nodes[i].children))

  def _unlockDescendants(self, i: int) -> None:
    self.nodes[i].lockedBy = -1
    for child in self.nodes[i].children:
      self._unlockDescendants(child)"
"1994","class Solution:
  def numberOfGoodSubsets(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    n = 1 << len(primes)
    # dp[i] := the number of good subsets with set of primes = i bit mask
    dp = [1] + [0] * (n - 1)
    count = collections.Counter(nums)

    for num, freq in count.items():
      if num == 1:
        continue
      if any(num % squared == 0 for squared in [4, 9, 25]):
        continue
      numPrimesMask = sum(1 << i
                          for i, prime in enumerate(primes)
                          if num % prime == 0)
      for primesMask in range(n):
        # Skip since there're commen set of primes (becomes invalid subset)
        if primesMask & numPrimesMask > 0:
          continue
        nextPrimesMask = numPrimesMask | primesMask
        dp[nextPrimesMask] += dp[primesMask] * freq
        dp[nextPrimesMask] %= kMod

    return (1 << count[1]) * sum(dp[1:]) % kMod"
"1995","class Solution:
  def countQuadruplets(self, nums: list[int]) -> int:
    n = len(nums)
    ans = 0
    count = collections.Counter()

    for c in range(n - 1, 1, -1):  # `c` also represents `d`.
      for b in range(c - 1, 0, -1):
        for a in range(b - 1, -1, -1):
          ans += count[nums[a] + nums[b] + nums[c]]
      count[nums[c]] += 1  # c := d

    return ans"
"1996","class Solution:
  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:
    ans = 0
    maxDefense = 0

    # Sort properties by `attack` in descending order, then by `defense` in
    # ascending order.
    for _, defense in sorted(properties, key=lambda x: (-x[0], x[1])):
      if defense < maxDefense:
        ans += 1
      maxDefense = max(maxDefense, defense)

    return ans"
"1997","class Solution:
  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(nextVisit)
    # dp[i] := the number of days to visit room i for the first time
    dp = [0] * n

    # Whenever we visit i, visit times of room[0..i - 1] are all even.
    # Therefore, the rooms before i can be seen as reset and we can safely
    # reuse dp[0..i - 1] as first-time visit to get second-time visit.
    for i in range(1, n):
      # The total days to visit room[i] is the sum of
      #   * dp[i - 1]: 1st-time visit room[i - 1]
      #   * 1: visit room[nextVisit[i - 1]]
      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]
      #   * 1: visit room[i]
      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % kMod

    return dp[-1]"
"1998","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def gcdSort(self, nums: list[int]) -> bool:
    mx = max(nums)
    minPrimeFactors = self._sieveEratosthenes(mx + 1)
    uf = UnionFind(mx + 1)

    for num in nums:
      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):
        uf.unionByRank(num, primeFactor)

    for a, b in zip(nums, sorted(nums)):
      # Can't swap nums[i] with sortedNums[i].
      if uf.find(a) != uf.find(b):
        return False

    return True

  def _sieveEratosthenes(self, n: int) -> list[int]:
    """"""Gets the minimum prime factor of i, where 1 < i <= n.""""""
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:  # `i` is prime.
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:
    primeFactors = []
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.append(divisor)
      while num % divisor == 0:
        num //= divisor
    return primeFactors"
"1999","class Solution:
  def findInteger(self, k: int, digit1: int, digit2: int) -> int:
    minDigit = min(digit1, digit2)
    maxDigit = max(digit1, digit2)
    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]
    q = collections.deque()

    for digit in digits:
      q.append(digit)

    while q:
      u = q.popleft()
      if u > k and u % k == 0:
        return u
      if u == 0:
        continue
      for digit in digits:
        nextNum = u * 10 + digit
        if nextNum > 2**31 - 1:
          continue
        q.append(nextNum)

    return -1"
"2","class Solution:
  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while carry or l1 or l2:
      if l1:
        carry += l1.val
        l1 = l1.next
      if l2:
        carry += l2.val
        l2 = l2.next
      curr.next = ListNode(carry % 10)
      carry //= 10
      curr = curr.next

    return dummy.next"
"20","class Solution:
  def isValid(self, s: str) -> bool:
    stack = []

    for c in s:
      if c == '(':
        stack.append(')')
      elif c == '{':
        stack.append('}')
      elif c == '[':
        stack.append(']')
      elif not stack or stack.pop() != c:
        return False

    return not stack"
"200","class Solution:
  def numIslands(self, grid: list[list[str]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    def bfs(r, c):
      q = collections.deque([(r, c)])
      grid[r][c] = '2'  # Mark '2' as visited.
      while q:
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if grid[x][y] != '1':
            continue
          q.append((x, y))
          grid[x][y] = '2'  # Mark '2' as visited.

    ans = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == '1':
          bfs(i, j)
          ans += 1

    return ans"
"2000","class Solution:
  def reversePrefix(self, word: str, ch: str) -> str:
    i = word.find(ch) + 1
    return word[:i][::-1] + word[i:]"
"2001","class Solution:
  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:
    ratioCount = collections.Counter()

    def gcd(a: int, b: int) -> int:
      return a if b == 0 else gcd(b, a % b)

    for width, height in rectangles:
      d = gcd(width, height)
      ratioCount[(width // d, height // d)] += 1

    return sum(c * (c - 1) // 2 for c in ratioCount.values())"
"2002","class Solution:
  def maxProduct(self, s: str) -> int:
    ans = 0

    def isPalindrome(s: str) -> bool:
      i = 0
      j = len(s) - 1
      while i < j:
        if s[i] != s[j]:
          return False
        i += 1
        j -= 1
      return True

    @functools.lru_cache(None)
    def dfs(i: int, s1: str, s2: str) -> None:
      nonlocal ans
      if i == len(s):
        if isPalindrome(s1) and isPalindrome(s2):
          ans = max(ans, len(s1) * len(s2))
        return

      dfs(i + 1, s1 + s[i], s2)
      dfs(i + 1, s1, s2 + s[i])
      dfs(i + 1, s1, s2)

    dfs(0, '', '')
    return ans"
"2003","class Solution:
  def smallestMissingValueSubtree(
      self,
      parents: list[int],
      nums: list[int],
  ) -> list[int]:
    n = len(parents)
    ans = [1] * n
    tree = [[] for _ in range(n)]
    seen = set()
    minMiss = 1

    for i in range(1, n):
      tree[parents[i]].append(i)

    def getNode(nums: list[int]) -> int:
      for i, num in enumerate(nums):
        if num == 1:
          return i
      return -1

    nodeThatsOne = getNode(nums)
    if nodeThatsOne == -1:
      return ans

    u = nodeThatsOne
    prev = -1  # the u that just handled

    def dfs(u: int) -> None:
      seen.add(nums[u])
      for v in tree[u]:
        dfs(v)

    # Upward from `nodeThatsOne` to the root `u`.
    while u != -1:
      for v in tree[u]:
        if v != prev:
          dfs(v)
      seen.add(nums[u])
      while minMiss in seen:
        minMiss += 1
      ans[u] = minMiss
      prev = u
      u = parents[u]

    return ans"
"2004","WITH
  AccumualtedCandidates AS (
    SELECT
      employee_id,
      experience,
      ROW_NUMBER() OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS candidate_count,
      SUM(salary) OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS accumulated_salary
    FROM Candidates
  ),
  MaxHiredSeniors AS (
    SELECT
      IFNULL(MAX(candidate_count), 0) AS accepted_candidates,
      IFNULL(MAX(accumulated_salary), 0) AS accumulated_salary
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  )
SELECT
  'Senior' AS experience,
  accepted_candidates
FROM MaxHiredSeniors
UNION ALL
SELECT
  'Junior' AS experience,
  COUNT(*) AS accepted_candidates
FROM AccumualtedCandidates AS Juniors
WHERE
  experience = 'Junior'
  AND Juniors.accumulated_salary < (
    SELECT 70000 - MaxHiredSeniors.accumulated_salary
    FROM MaxHiredSeniors
  );"
"2005","class Solution:
  def findGameWinner(self, n: int) -> bool:
    return n % 6 != 1"
"2006","class Solution:
  def countKDifference(self, nums: list[int], k: int) -> int:
    count = collections.Counter(nums)
    return sum(count[i] * count[i - k] for i in range(k + 1, 101))"
"2007","class Solution:
  def findOriginalArray(self, changed: list[int]) -> list[int]:
    ans = []
    q = collections.deque()

    for num in sorted(changed):
      if q and num == q[0]:
        q.popleft()
      else:
        q.append(num * 2)
        ans.append(num)

    return [] if q else ans"
"2008","class Solution:
  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:
    startToEndAndEarns = [[] for _ in range(n)]
    # dp[i] := the maximum dollars you can earn starting at i
    dp = [0] * (n + 1)

    for start, end, tip in rides:
      earn = end - start + tip
      startToEndAndEarns[start].append((end, earn))

    for i in range(n - 1, 0, -1):
      dp[i] = dp[i + 1]
      for end, earn in startToEndAndEarns[i]:
        dp[i] = max(dp[i], dp[end] + earn)

    return dp[1]"
"2009","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    n = len(nums)
    ans = n
    nums = sorted(set(nums))

    for i, start in enumerate(nums):
      end = start + n - 1
      index = bisect_right(nums, end)
      uniqueLength = index - i
      ans = min(ans, n - uniqueLength)

    return ans"
"201","class Solution:
  def rangeBitwiseAnd(self, m: int, n: int) -> int:
    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m"
"2010","WITH
  AccumualtedCandidates AS (
    SELECT
      employee_id,
      experience,
      ROW_NUMBER() OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS candidate_count,
      SUM(salary) OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS accumulated_salary
    FROM Candidates
  ),
  HiredSeniors AS (
    SELECT
      employee_id,
      accumulated_salary
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  )
SELECT HiredSeniors.employee_id
FROM HiredSeniors
UNION ALL
SELECT Juniors.employee_id
FROM AccumualtedCandidates AS Juniors
WHERE
  experience = 'Junior'
  AND Juniors.accumulated_salary < (
    SELECT 70000 - IFNULL(MAX(accumulated_salary), 0)
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  );"
"2011","class Solution:
  def finalValueAfterOperations(self, operations: list[str]) -> int:
    return sum(op[1] == '+' or -1 for op in operations)"
"2012","class Solution:
  def sumOfBeauties(self, nums: list[int]) -> int:
    n = len(nums)
    ans = 0
    minOfRight = [0] * (n - 1) + [nums[-1]]

    for i in range(n - 2, 1, -1):
      minOfRight[i] = min(nums[i], minOfRight[i + 1])

    maxOfLeft = nums[0]

    for i in range(1, n - 1):
      if maxOfLeft < nums[i] < minOfRight[i + 1]:
        ans += 2
      elif nums[i - 1] < nums[i] < nums[i + 1]:
        ans += 1
      maxOfLeft = max(maxOfLeft, nums[i])

    return ans"
"2013","class DetectSquares:
  def __init__(self):
    self.pointCount = collections.Counter()

  def add(self, point: list[int]) -> None:
    self.pointCount[tuple(point)] += 1

  def count(self, point: list[int]) -> int:
    x1, y1 = point
    ans = 0
    for (x3, y3), c in self.pointCount.items():
      if x1 != x3 and abs(x1 - x3) == abs(y1 - y3):
        ans += c * self.pointCount[(x1, y3)] * self.pointCount[(x3, y1)]
    return ans"
"2014","class Solution:
  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
    ans = ''
    count = [0] * 26
    possibleChars = []
    # Stores subsequences, where the length grows by 1 each time.
    q = collections.deque([''])

    for c in s:
      count[string.ascii_lowercase.index(c)] += 1

    for c in string.ascii_lowercase:
      if count[string.ascii_lowercase.index(c)] >= k:
        possibleChars.append(c)

    def isSubsequence(subseq: str, s: str, k: int) -> bool:
      i = 0  # subseq's index
      for c in s:
        if c == subseq[i]:
          i += 1
          if i == len(subseq):
            k -= 1
            if k == 0:
              return True
            i = 0
      return False

    while q:
      currSubseq = q.popleft()
      if len(currSubseq) * k > len(s):
        return ans
      for c in possibleChars:
        newSubseq = currSubseq + c
        if isSubsequence(newSubseq, s, k):
          q.append(newSubseq)
          ans = newSubseq

    return ans"
"2015","class Solution:
  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:
    ans = []
    events = []

    for start, end, height in buildings:
      events.append((start, height))
      events.append((end, -height))

    prev = 0
    count = 0
    sumHeight = 0

    for curr, height in sorted(events):
      if sumHeight > 0 and curr > prev:
        avgHeight = sumHeight // count
        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:
          ans[-1][1] = curr
        else:
          ans.append([prev, curr, avgHeight])
      sumHeight += height
      count += 1 if height > 0 else -1
      prev = curr

    return ans"
"2016","class Solution:
  def maximumDifference(self, nums: list[int]) -> int:
    ans = -1
    mn = nums[0]

    for i in range(len(nums)):
      if nums[i] > mn:
        ans = max(ans, nums[i] - mn)
      mn = min(mn, nums[i])

    return ans"
"2017","class Solution:
  def gridGame(self, grid: list[list[int]]) -> int:
    n = len(grid[0])
    ans = math.inf
    sumRow0 = sum(grid[0])
    sumRow1 = 0

    for i in range(n):
      sumRow0 -= grid[0][i]
      ans = min(ans, max(sumRow0, sumRow1))
      sumRow1 += grid[1][i]

    return ans"
"2018","class Solution:
  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:
    for x in board, zip(*board):
      for row in x:
        for token in ''.join(row).split('#'):
          for letters in word, word[::-1]:
            if len(token) == len(letters):
              if all(c in (' ', letter) for c, letter in zip(token, letters)):
                return True
    return False"
"2019","class Solution:
  def scoreOfStudents(self, s: str, answers: list[int]) -> int:
    n = len(s) // 2 + 1
    ans = 0
    func = {'+': operator.add, '*': operator.mul}
    dp = [[set() for j in range(n)] for _ in range(n)]

    for i in range(n):
      dp[i][i].add(int(s[i * 2]))

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        for k in range(i, j):
          op = s[k * 2 + 1]
          for a in dp[i][k]:
            for b in dp[k + 1][j]:
              res = func[op](a, b)
              if res <= 1000:
                dp[i][j].add(res)

    correctAnswer = eval(s)

    for answer, freq in collections.Counter(answers).items():
      if answer == correctAnswer:
        ans += 5 * freq
      elif answer in dp[0][n - 1]:
        ans += 2 * freq

    return ans"
"202","class Solution:
  def isHappy(self, n: int) -> bool:
    def squaredSum(n: int) -> bool:
      summ = 0
      while n > 0:
        summ += pow(n % 10, 2)
        n //= 10
      return summ

    slow = squaredSum(n)
    fast = squaredSum(squaredSum(n))

    while slow != fast:
      slow = squaredSum(slow)
      fast = squaredSum(squaredSum(fast))

    return slow == 1"
"2020","SELECT COUNT(Subscriptions.account_id) AS accounts_count
FROM Subscriptions
LEFT JOIN Streams
  USING (account_id)
WHERE
  2021 BETWEEN YEAR(Subscriptions.start_date) AND YEAR(Subscriptions.end_date)
  AND YEAR(Streams.stream_date) != 2021;"
"2021","from sortedcontainers import SortedDict


class Solution:
  def brightestPosition(self, lights: list[list[int]]) -> int:
    ans = math.inf
    maxBrightness = -1
    currBrightness = 0
    line = SortedDict()

    for position, rg in lights:
      start = position - rg
      end = position + rg + 1
      line[start] = line.get(start, 0) + 1
      line[end] = line.get(end, 0) - 1

    for pos, brightness in line.items():
      currBrightness += brightness
      if currBrightness > maxBrightness:
        maxBrightness = currBrightness
        ans = pos

    return ans"
"2022","class Solution:
  def construct2DArray(self, original: list[int],
                       m: int, n: int) -> list[list[int]]:
    if len(original) != m * n:
      return []

    ans = [[0] * n for _ in range(m)]

    for i, num in enumerate(original):
      ans[i // n][i % n] = num

    return ans"
"2023","class Solution:
  def numOfPairs(self, nums: list[str], target: str) -> int:
    ans = 0
    count = collections.Counter()

    for num in nums:
      k = len(num)
      if target[:k] == num:
        ans += count[target[k:]]
      if target[-k:] == num:
        ans += count[target[:-k]]
      count[num] += 1

    return ans"
"2024","class Solution:
  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
    ans = 0
    maxCount = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(answerKey):
      count[c == 'T'] += 1
      maxCount = max(maxCount, count[c == 'T'])
      while maxCount + k < r - l + 1:
        count[answerKey[l] == 'T'] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"2025","class Solution:
  def waysToPartition(self, nums: list[int], k: int) -> int:
    n = len(nums)
    summ = sum(nums)
    prefix = 0
    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)
    l = collections.Counter()
    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)
    r = collections.Counter()

    for pivot in range(1, n):
      prefix += nums[pivot - 1]
      suffix = summ - prefix
      r[prefix - suffix] += 1

    ans = r[0]
    prefix = 0

    for num in nums:
      ans = max(ans, l[k - num] + r[num - k])
      prefix += num
      suffix = summ - prefix
      diff = prefix - suffix
      r[diff] -= 1
      l[diff] += 1

    return ans"
"2026","SELECT problem_id
FROM Problems
WHERE likes / (likes + dislikes) < 0.6
ORDER BY 1;"
"2027","class Solution:
  def minimumMoves(self, s: str) -> int:
    ans = 0

    i = 0
    while i < len(s):
      if s[i] == 'O':
        i += 1
      else:
        ans += 1
        i += 3

    return ans"
"2028","class Solution:
  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:
    targetSum = (len(rolls) + n) * mean
    missingSum = targetSum - sum(rolls)
    if missingSum > n * 6 or missingSum < n:
      return []

    ans = [missingSum // n] * n
    for i in range(missingSum % n):
      ans[i] += 1

    return ans"
"2029","class Solution:
  def stoneGameIX(self, stones: list[int]) -> bool:
    count = collections.Counter(stone % 3 for stone in stones)
    if count[0] % 2 == 0:
      return min(count[1], count[2]) > 0
    return abs(count[1] - count[2]) > 2"
"203","class Solution:
  def removeElements(self, head: ListNode, val: int) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while head:
      if head.val != val:
        prev.next = head
        prev = prev.next
      head = head.next
    prev.next = None

    return dummy.next"
"2030","class Solution:
  def smallestSubsequence(
      self,
      s: str,
      k: int,
      letter: str,
      repetition: int,
  ) -> str:
    stack = []  # running string
    required = repetition
    nLetters = s.count(letter)

    for i, c in enumerate(s):
      # Make sure the length is sufficient:
      # Len(stack) := the length of running string
      # Len(s) - i := the length of remain chars
      # -1 := we're going to pop a char
      while (stack and stack[-1] > c
              and len(stack) + len(s) - i - 1 >= k
              and (stack[-1] != letter or nLetters > required)):
        if stack.pop() == letter:
          required += 1
      if len(stack) < k:
        if c == letter:
          stack.append(c)
          required -= 1
        elif k - len(stack) > required:
          stack.append(c)
      if c == letter:
        nLetters -= 1

    return ''.join(stack)"
"2031","class FenwichTree:
  def __init__(self, n: int):
    self.n = n
    self.sums = [0] * (2 * n + 1)

  def add(self, i: int, delta: int) -> None:
    i += self.n + 1  # re-mapping
    while i < len(self.sums):
      self.sums[i] += delta
      i += i & -i

  def get(self, i: int) -> int:
    i += self.n + 1  # re-mapping
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= i & -i
    return summ


class Solution:
  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    ans = 0
    prefix = 0
    tree = FenwichTree(len(nums))
    tree.add(0, 1)

    for num in nums:
      prefix += -1 if num == 0 else 1
      ans += tree.get(prefix - 1)
      ans %= kMod
      tree.add(prefix, 1)

    return ans"
"2032","class Solution:
  def twoOutOfThree(
      self,
      nums1: list[int],
      nums2: list[int],
      nums3: list[int],
  ) -> list[int]:
    count = collections.Counter()
    for nums in nums1, nums2, nums3:
      count.update(set(nums))
    return [i for i, c in count.items() if c >= 2]"
"2033","class Solution:
  def minOperations(self, grid: list[list[int]], x: int) -> int:
    A = sorted([a for row in grid for a in row])
    if any((a - A[0]) % x for a in A):
      return -1

    ans = 0

    for a in A:
      ans += abs(a - A[len(A) // 2]) // x

    return ans"
"2034","from sortedcontainers import SortedDict


class StockPrice:
  def __init__(self):
    self.timestampToPrice = SortedDict()
    self.pricesCount = SortedDict()

  def update(self, timestamp: int, price: int) -> None:
    if timestamp in self.timestampToPrice:
      prevPrice = self.timestampToPrice[timestamp]
      self.pricesCount[prevPrice] -= 1
      if self.pricesCount[prevPrice] == 0:
        del self.pricesCount[prevPrice]
    self.timestampToPrice[timestamp] = price
    self.pricesCount[price] = self.pricesCount.get(price, 0) + 1

  def current(self) -> int:
    return self.timestampToPrice.peekitem(-1)[1]

  def maximum(self) -> int:
    return self.pricesCount.peekitem(-1)[0]

  def minimum(self) -> int:
    return self.pricesCount.peekitem(0)[0]"
"2035","class Solution:
  def minimumDifference(self, nums: list[int]) -> int:
    n = len(nums) // 2
    summ = sum(nums)
    goal = summ // 2
    lNums = nums[:n]
    rNums = nums[n:]
    ans = abs(sum(lNums) - sum(rNums))
    lSums = [[] for _ in range(n + 1)]
    rSums = [[] for _ in range(n + 1)]

    def dfs(A: list[int], i: int, count: int, path: int, sums: list[list[int]]):
      if i == len(A):
        sums[count].append(path)
        return
      dfs(A, i + 1, count + 1, path + A[i], sums)
      dfs(A, i + 1, count, path, sums)

    dfs(lNums, 0, 0, 0, lSums)
    dfs(rNums, 0, 0, 0, rSums)

    for lCount in range(n):
      l = lSums[lCount]
      r = rSums[n - lCount]
      r.sort()
      for lSum in l:
        i = bisect_left(r, goal - lSum)
        if i < len(r):
          sumPartOne = summ - lSum - r[i]
          sumPartTwo = summ - sumPartOne
          ans = min(ans, abs(sumPartOne - sumPartTwo))
        if i > 0:
          sumPartOne = summ - lSum - r[i - 1]
          sumPartTwo = summ - sumPartOne
          ans = min(ans, abs(sumPartOne - sumPartTwo))

    return ans"
"2036","class Solution:
  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:
    ans = -math.inf
    even = 0  # the subarray sum starting from an even index
    odd = 0  # the subarray sum starting from an odd index

    for i in range(len(nums)):
      if i % 2 == 0:  # Must pick.
        even += nums[i]
      else:  # Start a fresh subarray or subtract `nums[i]`.
        even = max(0, even - nums[i])
      ans = max(ans, even)

    for i in range(1, len(nums)):
      if i % 2 == 1:  # Must pick.
        odd += nums[i]
      else:  # Start a fresh subarray or subtract `nums[i]`.
        odd = max(0, odd - nums[i])
      ans = max(ans, odd)

    return ans"
"2037","class Solution:
  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:
    return sum(
        abs(seat - student) for seat,
        student in zip(sorted(seats),
                       sorted(students)))"
"2038","class Solution:
  def winnerOfGame(self, colors: str) -> bool:
    countAAA = 0
    countBBB = 0

    for a, b, c in zip(colors, colors[1:], colors[2:]):
      if 'A' == a == b == c:
        countAAA += 1
      elif 'B' == a == b == c:
        countBBB += 1

    return countAAA > countBBB"
"2039","class Solution:
  def networkBecomesIdle(
      self,
      edges: list[list[int]],
      patience: list[int],
  ) -> int:
    n = len(patience)
    ans = 0
    graph = [[] for _ in range(n)]
    q = collections.deque([0])
    dist = [math.inf] * n  # dist[i] := the distance between i and 0
    dist[0] = 0

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    while q:
      for _ in range(len(q)):
        u = q.popleft()
        for v in graph[u]:
          if dist[v] == math.inf:
            dist[v] = dist[u] + 1
            q.append(v)

    for i in range(1, n):
      numResending = (dist[i] * 2 - 1) // patience[i]
      lastResendingTime = patience[i] * numResending
      lastArrivingTime = lastResendingTime + dist[i] * 2
      ans = max(ans, lastArrivingTime)

    return ans + 1"
"204","class Solution:
  def countPrimes(self, n: int) -> int:
    if n <= 2:
      return 0
    return sum(self._sieveEratosthenes(n))

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"2040","class Solution:
  def kthSmallestProduct(
      self,
      nums1: list[int],
      nums2: list[int],
      k: int,
  ) -> int:
    A1 = [-num for num in nums1 if num < 0][::-1]  # Reverse to sort ascending
    A2 = [num for num in nums1 if num >= 0]
    B1 = [-num for num in nums2 if num < 0][::-1]  # Reverse to sort ascending
    B2 = [num for num in nums2 if num >= 0]

    negCount = len(A1) * len(B2) + len(A2) * len(B1)

    if k > negCount:  # Find (k - negCount)-th positive
      k -= negCount
      sign = 1
    else:
      k = negCount - k + 1  # Find (negCount - k + 1)-th abs(negative).
      sign = -1
      B1, B2 = B2, B1

    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:
      ans = 0
      j = len(B) - 1
      for i in range(len(A)):
        # For each A[i], find the first index j s.t. A[i] * B[j] <= m
        # So numProductNoGreaterThan m for this row will be j + 1
        while j >= 0 and A[i] * B[j] > m:
          j -= 1
        ans += j + 1
      return ans

    l = 0
    r = 10**10

    while l < r:
      m = (l + r) // 2
      if (numProductNoGreaterThan(A1, B1, m) +
              numProductNoGreaterThan(A2, B2, m) >= k):
        r = m
      else:
        l = m + 1

    return sign * l"
"2041","SELECT Candidates.candidate_id
FROM Candidates
INNER JOIN Rounds
  USING (interview_id)
WHERE Candidates.years_of_exp >= 2
GROUP BY 1
HAVING SUM(Rounds.score) > 15;"
"2042","class Solution:
  def areNumbersAscending(self, s: str) -> bool:
    prev = 0

    for token in s.split():
      if token.isdigit():
        num = int(token)
        if num <= prev:
          return False
        prev = num

    return True"
"2043","class Bank:
  def __init__(self, balance: list[int]):
    self.balance = balance

  def transfer(self, account1: int, account2: int, money: int) -> bool:
    if not self._isValid(account2):
      return False
    return self.withdraw(account1, money) and self.deposit(account2, money)

  def deposit(self, account: int, money: int) -> bool:
    if not self._isValid(account):
      return False
    self.balance[account - 1] += money
    return True

  def withdraw(self, account: int, money: int) -> bool:
    if not self._isValid(account):
      return False
    if self.balance[account - 1] < money:
      return False
    self.balance[account - 1] -= money
    return True

  def _isValid(self, account: int) -> bool:
    return 1 <= account <= len(self.balance)"
"2044","class Solution:
  def countMaxOrSubsets(self, nums: list[int]) -> int:
    ors = functools.reduce(operator.or_, nums)
    ans = 0

    def dfs(i: int, path: int) -> None:
      nonlocal ans
      if i == len(nums):
        if path == ors:
          ans += 1
        return

      dfs(i + 1, path)
      dfs(i + 1, path | nums[i])

    dfs(0, 0)
    return ans"
"2045","class Solution:
  def secondMinimum(
      self,
      n: int,
      edges: list[list[int]],
      time: int,
      change: int,
  ) -> int:
    graph = [[] for _ in range(n + 1)]
    q = collections.deque([(1, 0)])
    # minTime[u][0] := the first minimum time to reach the node u
    # minTime[u][1] := the second minimum time to reach the node u
    minTime = [[math.inf] * 2 for _ in range(n + 1)]
    minTime[1][0] = 0

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    while q:
      u, prevTime = q.popleft()
      # Start from green.
      # If `numChangeSignal` is odd, now red.
      # If numChangeSignal is even -> now gree
      numChangeSignal = prevTime // change
      waitTime = (0 if numChangeSignal % 2 == 0
                  else change - (prevTime % change))
      newTime = prevTime + waitTime + time
      for v in graph[u]:
        if newTime < minTime[v][0]:
          minTime[v][0] = newTime
          q.append((v, newTime))
        elif minTime[v][0] < newTime < minTime[v][1]:
          if v == n:
            return newTime
          minTime[v][1] = newTime
          q.append((v, newTime))"
"2046","class Solution:
  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:
    prev = head
    curr = head.next

    while curr:
      if curr.val < 0:
        prev.next = curr.next
        curr.next = head
        head = curr
        curr = prev.next
      else:
        prev = curr
        curr = curr.next

    return head"
"2047","class Solution:
  def countValidWords(self, sentence: str) -> int:
    def isValid(token: str) -> bool:
      countHyphen = 0
      for i, c in enumerate(token):
        if c.isdigit():
          return False
        if c == '-':
          if i == 0 or not token[i - 1].isalpha():
            return False
          if i == len(token) - 1 or not token[i + 1].isalpha():
            return False
          if countHyphen == 1:
            return False
          countHyphen += 1
        if c in ['!', '.', ',']:
          if i != len(token) - 1:
            return False
      return True

    return sum(isValid(token) for token in sentence.split())"
"2048","class Solution:
  def nextBeautifulNumber(self, n: int) -> int:
    def isBalance(num: int) -> bool:
      count = [0] * 10
      while num > 0:
        if num % 10 == 0:
          return False
        count[num % 10] += 1
        num //= 10
      return all(c == i for i, c in enumerate(count) if c)

    n += 1
    while not isBalance(n):
      n += 1
    return n"
"2049","class Solution:
  def countHighestScoreNodes(self, parents: list[int]) -> int:
    tree = [[] for _ in range(len(parents))]

    for i, parent in enumerate(parents):
      if parent == -1:
        continue
      tree[parent].append(i)

    ans = 0
    maxScore = 0

    def dfs(u: int) -> int:  # Returns node count
      nonlocal ans
      nonlocal maxScore
      count = 1
      score = 1
      for v in tree[u]:
        childCount = dfs(v)
        count += childCount
        score *= childCount
      score *= len(parents) - count or 1
      if score > maxScore:
        maxScore = score
        ans = 1
      elif score == maxScore:
        ans += 1
      return count

    dfs(0)
    return ans"
"205","class Solution:
  def isIsomorphic(self, s: str, t: str) -> bool:
    return [*map(s.index, s)] == [*map(t.index, t)]"
"2050","class Solution:
  def minimumTime(
      self,
      n: int,
      relations: list[list[int]],
      time: list[int],
  ) -> int:
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    dist = time.copy()

    # Build the graph.
    for a, b in relations:
      u = a - 1
      v = b - 1
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      for v in graph[u]:
        dist[v] = max(dist[v], dist[u] + time[v])
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return max(dist)"
"2051","SELECT
  Members.member_id,
  Members.name,
  CASE
    WHEN COUNT(Visits.visit_id) = 0 THEN 'Bronze'
    WHEN COUNT(Purchases.visit_id) / COUNT(Visits.visit_id) >= 0.8 THEN 'Diamond'
    WHEN COUNT(Purchases.visit_id) / COUNT(Visits.visit_id) >= 0.5 THEN 'Gold'
    ELSE 'Silver'
  END AS category
FROM Members
LEFT JOIN Visits
  USING (member_id)
LEFT JOIN Purchases
  USING (visit_id)
GROUP BY 1;"
"2052","class Solution:
  def minimumCost(self, sentence: str, k: int) -> int:
    if len(sentence) <= k:
      return 0

    words = sentence.split()

    # dp[i] := the minimum cost of the first i words
    dp = [0] * (len(words) + 1)

    for i in range(1, len(words) + 1):
      n = len(words[i - 1])  # the length of the current row
      dp[i] = dp[i - 1] + (k - n)**2
      # Gradually add words[j - 1], words[j - 2], ....
      for j in range(i - 1, 0, -1):
        n += len(words[j - 1]) + 1
        if n > k:
          break
        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)

    lastRowLen = len(words[-1])
    i = len(words) - 2  # Greedily put words into last row

    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:
      lastRowLen += len(words[i]) + 1
      i -= 1

    return min(dp[i + 1:len(words)])"
"2053","class Solution:
  def kthDistinct(self, arr: list[str], k: int) -> str:
    count = collections.Counter(arr)

    for a in arr:
      if count[a] == 1:
        k -= 1
        if k == 0:
          return a

    return ''"
"2054","class Solution:
  def maxTwoEvents(self, events: list[list[int]]) -> int:
    ans = 0
    maxValue = 0
    evts = []  # (time, isStart, value)

    for s, e, v in events:
      evts.append((s, 1, v))
      evts.append((e + 1, 0, v))

    # When two events have the same time, the one is not start will be in the front
    evts.sort()

    for _, isStart, value in evts:
      if isStart:
        ans = max(ans, value + maxValue)
      else:
        maxValue = max(maxValue, value)

    return ans"
"2055","class Solution:
  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:
    n = len(s)
    ans = []
    closestLeftCandle = [0] * n
    closestRightCandle = [0] * n
    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]
    candle = -1
    count = 0

    for i, c in enumerate(s):
      if c == '|':
        candle = i
        count += 1
      closestLeftCandle[i] = candle
      candleCount[i] = count

    candle = -1
    for i, c in reversed(list(enumerate(s))):
      if c == '|':
        candle = i
      closestRightCandle[i] = candle

    for left, right in queries:
      l = closestRightCandle[left]
      r = closestLeftCandle[right]
      if l == -1 or r == -1 or l > r:
        ans.append(0)
      else:
        lengthBetweenCandles = r - l + 1
        numCandles = candleCount[r] - candleCount[l] + 1
        ans.append(lengthBetweenCandles - numCandles)

    return ans"
"2056","class Solution:
  def countCombinations(
      self,
      pieces: list[str],
      positions: list[list[int]],
  ) -> int:
    n = len(pieces)
    moves = {""rook"": [(1, 0), (-1, 0), (0, 1), (0, -1)],
             ""bishop"": [(1, 1), (1, -1), (-1, 1), (-1, -1)],
             ""queen"": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}
    hashedBoards = set()

    def getHash(board: list[list[int]]) -> Tuple:
      return tuple([tuple(pos) for pos in board])

    def dfs(
        board: list[list[int]],
        pieceMoves: list[tuple[int, int]],
        activeMask: int,
    ) -> None:
      """"""Performs a depth-first search to explore all possible board states.""""""
      if activeMask == 0:
        return
      hashedBoards.add(getHash(board))

      for nextActiveMask in range(1, 1 << n):
        if activeMask & nextActiveMask != nextActiveMask:
          continue

        # Copy the board.
        nextBoard = [pos.copy() for pos in board]

        # Move the pieces that are active in this turn.
        for i in range(n):
          if nextActiveMask >> i & 1:
            nextBoard[i][0] += pieceMoves[i][0]
            nextBoard[i][1] += pieceMoves[i][1]

        # No two or more pieces occupy the same square.
        if len(set(getHash(nextBoard))) < n:
          continue

        # Every piece needs to be in the boundary.
        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):
          dfs(nextBoard, pieceMoves, nextActiveMask)

    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):
      dfs(positions, pieceMoves, (1 << n) - 1)

    return len(hashedBoards)"
"2057","class Solution:
  def smallestEqual(self, nums: list[int]) -> int:
    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)"
"2058","class Solution:
  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:
    minDistance = math.inf
    firstMaIndex = -1
    prevMaIndex = -1
    index = 1
    prev = head  # Point to the index 0.
    curr = head.next  # Point to the index 1.

    while curr.next:
      if (curr.val > prev.val and curr.val > curr.next.val or
              curr.val < prev.val and curr.val < curr.next.val):
        if firstMaIndex == -1:  # Only assign once.
          firstMaIndex = index
        if prevMaIndex != -1:
          minDistance = min(minDistance, index - prevMaIndex)
        prevMaIndex = index
      prev = curr
      curr = curr.next
      index += 1

    if minDistance == math.inf:
      return [-1, -1]
    return [minDistance, prevMaIndex - firstMaIndex]"
"2059","class Solution:
  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:
    q = collections.deque([start])
    seen = {start}

    step = 1
    while q:
      for _ in range(len(q)):
        x = q.popleft()
        for num in nums:
          for res in (x + num, x - num, x ^ num):
            if res == goal:
              return step
            if res < 0 or res > 1000 or res in seen:
              continue
            seen.add(res)
            q.append(res)
      step += 1

    return -1"
"206","class Solution:
  def reverseList(self, head: ListNode | None) -> ListNode | None:
    if not head or not head.next:
      return head

    newHead = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return newHead"
"2060","class Solution:
  def possiblyEquals(self, s1: str, s2: str) -> bool:
    def getNums(s: str) -> set[int]:
      nums = {int(s)}
      for i in range(1, len(s)):
        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}
      return nums

    def getNextLetterIndex(s: str, i: int) -> int:
      j = i
      while j < len(s) and s[j].isdigit():
        j += 1
      return j

    @functools.lru_cache(None)
    def dp(i: int, j: int, paddingDiff: int) -> bool:
      """"""
      Returns True if s1[i..n) matches s2[j..n), accounting for the padding
      difference. Here, `paddingDiff` represents the signed padding. A positive
      `paddingDiff` indicates that s1 has an additional number of offset bytes
      compared to s2.
      """"""
      if i == len(s1) and j == len(s2):
        return paddingDiff == 0
      # Add padding on s1.
      if i < len(s1) and s1[i].isdigit():
        nextLetterIndex = getNextLetterIndex(s1, i)
        for num in getNums(s1[i:nextLetterIndex]):
          if dp(nextLetterIndex, j, paddingDiff + num):
            return True
      # Add padding on s2.
      elif j < len(s2) and s2[j].isdigit():
        nextLetterIndex = getNextLetterIndex(s2, j)
        for num in getNums(s2[j:nextLetterIndex]):
          if dp(i, nextLetterIndex, paddingDiff - num):
            return True
      # `s1` has more padding, so j needs to catch up.
      elif paddingDiff > 0:
        if j < len(s2):
          return dp(i, j + 1, paddingDiff - 1)
      # `s2` has more padding, so i needs to catch up.
      elif paddingDiff < 0:
        if i < len(s1):
          return dp(i + 1, j, paddingDiff + 1)
      # There's no padding difference, so consume the next letter.
      else:  # paddingDiff == 0
        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:
          return dp(i + 1, j + 1, 0)
      return False

    return dp(0, 0, 0)"
"2061","class Solution:
  def numberOfCleanRooms(self, room: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(room)
    n = len(room[0])
    ans = 1
    i = 0
    j = 0
    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up
    seen = {(i, j, state)}
    room[i][j] = 2  # 2 := cleaned

    while True:
      x = i + dirs[state]
      y = j + dirs[state + 1]
      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:
        # Turn 90 degrees clockwise.
        state = (state + 1) % 4
      else:
        # Walk to (x, y).
        if room[x][y] == 0:
          ans += 1
          room[x][y] = 2
        i = x
        j = y
      if (x, y, state) in seen:
        return ans
      seen.add((x, y, state))"
"2062","class Solution:
  def countVowelSubstrings(self, word: str) -> int:
    kVowels = 'aeiou'

    def countVowelSubstringsAtMost(goal: int) -> int:
      ans = 0
      k = goal
      count = collections.Counter()

      l = 0
      for r, c in enumerate(word):
        if c not in kVowels:  # Fresh start.
          l = r + 1
          k = goal
          count = collections.Counter()
          continue
        count[c] += 1
        if count[c] == 1:
          k -= 1
        while k == -1:
          count[word[l]] -= 1
          if count[word[l]] == 0:
            k += 1
          l += 1
        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]

      return ans

    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)"
"2063","class Solution:
  def countVowels(self, word: str) -> int:
    # dp[i] := the sum of the number of vowels of word[0..i), ...,
    # word[i - 1..i)
    dp = [0] * (len(word) + 1)

    for i, c in enumerate(word):
      dp[i + 1] = dp[i]
      if c in 'aeiou':
        dp[i + 1] += i + 1

    return sum(dp)"
"2064","class Solution:
  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:
    l = 1
    r = max(quantities)

    def numStores(m: int) -> int:
      return sum((q - 1) // m + 1 for q in quantities)

    while l < r:
      m = (l + r) // 2
      if numStores(m) <= n:
        r = m
      else:
        l = m + 1

    return l"
"2065","class Solution:
  def maximalPathQuality(
      self,
      values: list[int],
      edges: list[list[int]],
      maxTime: int,
  ) -> int:
    ans = 0
    graph = [[] for _ in range(len(values))]
    # (node, quality, remainingTime, seen)
    q = collections.deque([(0, values[0], maxTime, {0})])

    for u, v, time in edges:
      graph[u].append((v, time))
      graph[v].append((u, time))

    while q:
      u, quality, remainingTime, seen = q.popleft()
      if u == 0:
        ans = max(ans, quality)
      for v, time in graph[u]:
        if time <= remainingTime:
          q.append(
              (v, quality + values[v] * (v not in seen),
               remainingTime - time, seen | set([v])))

    return ans"
"2066","SELECT
  account_id,
  day,
  SUM(IF(type = 'Deposit', amount, -amount)) OVER(
    PARTITION BY account_id
    ORDER BY day
  ) AS balance
FROM Transactions
ORDER BY 1, 2;"
"2067","class Solution:
  def equalCountSubstrings(self, s: str, count: int) -> int:
    maxUnique = len(set(s))
    ans = 0

    for unique in range(1, maxUnique + 1):
      windowSize = unique * count
      lettersCount = collections.Counter()
      uniqueCount = 0
      for i, c in enumerate(s):
        lettersCount[c] += 1
        if lettersCount[c] == count:
          uniqueCount += 1
        if i >= windowSize:
          lettersCount[s[i - windowSize]] -= 1
          if lettersCount[s[i - windowSize]] == count - 1:
            uniqueCount -= 1
        ans += uniqueCount == unique

    return ans"
"2068","class Solution:
  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
    count = collections.Counter(word1)
    count.subtract(collections.Counter(word2))
    return all(abs(freq) <= 3 for freq in count.values())"
"2069","class Robot:
  def __init__(self, width: int, height: int):
    self.isOrigin = True
    self.i = 0
    self.pos = ([((0, 0), 'South')] +
                [((i, 0), 'East') for i in range(1, width)] +
                [((width - 1, j), 'North') for j in range(1, height)] +
                [((i, height - 1), 'West') for i in range(width - 2, -1, -1)] +
                [((0, j), 'South') for j in range(height - 2, 0, -1)])

  def step(self, num: int) -> None:
    self.isOrigin = False
    self.i = (self.i + num) % len(self.pos)

  def getPos(self) -> list[int]:
    return self.pos[self.i][0]

  def getDir(self) -> str:
    return 'East' if self.isOrigin else self.pos[self.i][1]"
"207","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:
    graph = [[] for _ in range(numCourses)]
    states = [State.kInit] * numCourses

    for v, u in prerequisites:
      graph[u].append(v)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited

      return False

    return not any(hasCycle(i) for i in range(numCourses))"
"2070","class Solution:
  def maximumBeauty(
      self,
      items: list[list[int]],
      queries: list[int],
  ) -> list[int]:
    prices, beauties = zip(*sorted(items))
    maxBeautySoFar = [0] * (len(beauties) + 1)

    for i, beauty in enumerate(beauties):
      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)

    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]"
"2071","from sortedcontainers import SortedList


class Solution:
  def maxTaskAssign(
      self,
      tasks: list[int],
      workers: list[int],
      pills: int,
      strength: int,
  ) -> int:
    tasks.sort()
    workers.sort()

    def canComplete(k: int, pillsLeft: int) -> bool:
      """"""Returns True if we can finish k tasks.""""""
      # k strongest workers
      sortedWorkers = SortedList(workers[-k:])

      # Out of the k smallest tasks, start from the biggest one.
      for i in reversed(range(k)):
        # Find the first worker that has strength >= tasks[i].
        index = sortedWorkers.bisect_left(tasks[i])
        if index < len(sortedWorkers):
          sortedWorkers.pop(index)
        elif pillsLeft > 0:
          # Find the first worker that has strength >= tasks[i] - strength.
          index = sortedWorkers.bisect_left(tasks[i] - strength)
          if index < len(sortedWorkers):
            sortedWorkers.pop(index)
            pillsLeft -= 1
          else:
            return False
        else:
          return False

      return True

    ans = 0
    l = 0
    r = min(len(tasks), len(workers))

    while l <= r:
      m = (l + r) // 2
      if canComplete(m, pills):
        ans = m
        l = m + 1
      else:
        r = m - 1

    return ans"
"2072","WITH
  NY AS (
    SELECT COUNT(student_id) AS `count`
    FROM NewYork
    WHERE score >= 90
  ),
  CA AS (
    SELECT COUNT(student_id) AS `count`
    FROM California
    WHERE score >= 90
  )
SELECT
  CASE
    WHEN NY.`count` > CA.`count` THEN 'New York University'
    WHEN NY.`count` < CA.`count` THEN 'California University'
    ELSE 'No Winner'
  END AS Winner
FROM NY, CA;"
"2073","class Solution:
  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:
    ans = 0

    for i, ticket in enumerate(tickets):
      if i <= k:
        ans += min(ticket, tickets[k])
      else:
        ans += min(ticket, tickets[k] - 1)

    return ans"
"2074","class Solution:
  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:
    # prev -> (head -> ... -> tail) -> next -> ...
    dummy = ListNode(0, head)
    prev = dummy
    tail = head
    next = head.next
    groupLength = 1

    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:
      length = 1
      tail = head
      while length < groupLength and tail.next:
        tail = tail.next
        length += 1
      return tail, length

    def reverse(head: ListNode | None) -> ListNode | None:
      prev = None
      while head:
        next = head.next
        head.next = prev
        prev = head
        head = next
      return prev

    while True:
      if groupLength % 2 == 1:
        prev.next = head
        prev = tail
      else:
        tail.next = None
        prev.next = reverse(head)
        # Prev -> (tail -> ... -> head) -> next -> ...
        head.next = next
        prev = head
      if not next:
        break
      head = next
      tail, length = getTailAndLength(head, groupLength + 1)
      next = tail.next
      groupLength = length

    return dummy.next"
"2075","class Solution:
  def decodeCiphertext(self, encodedText: str, rows: int) -> str:
    n = len(encodedText)
    cols = n // rows

    ans = []
    matrix = [[' '] * cols for _ in range(rows)]

    for i in range(rows):
      for j in range(cols):
        matrix[i][j] = encodedText[i * cols + j]

    for col in range(cols):
      i = 0
      j = col
      while i < rows and j < cols:
        ans.append(matrix[i][j])
        i += 1
        j += 1

    return ''.join(ans).rstrip()"
"2076","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def friendRequests(
      self,
      n: int,
      restrictions: list[list[int]],
      requests: list[list[int]],
  ) -> list[bool]:
    ans = []
    uf = UnionFind(n)

    for u, v in requests:
      pu = uf.find(u)
      pv = uf.find(v)
      isValid = True
      if pu != pv:
        for x, y in restrictions:
          px = uf.find(x)
          py = uf.find(y)
          if (pu, pv) in [(px, py), (py, px)]:
            isValid = False
            break
      ans.append(isValid)
      if isValid:
        uf.unionByRank(pu, pv)

    return ans"
"2077","class Solution:
  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:
    ans = 0
    graph = [[False] * 1001 for _ in range(n + 1)]

    for u, v in corridors:
      graph[u][v] = True
      graph[v][u] = True

    for u, v in corridors:
      for i in range(1, n + 1):
        if graph[u][i] and graph[i][v]:
          ans += 1

    return ans // 3"
"2078","class Solution:
  def maxDistance(self, colors: list[int]) -> int:
    # The maximum distance always includes either the first or the last house.
    n = len(colors)
    i = 0  # the leftmost index, where colors[i] != colors[-1]
    j = n - 1  # the rightmost index, where colors[j] != colors[0]
    while colors[i] == colors[-1]:
      i += 1
    while colors[j] == colors[0]:
      j -= 1
    return max(n - 1 - i, j)"
"2079","class Solution:
  def wateringPlants(self, plants: list[int], capacity: int) -> int:
    ans = 0
    currCapacity = 0

    for i, plant in enumerate(plants):
      if currCapacity + plant <= capacity:
        currCapacity += plant
      else:
        currCapacity = plant  # Reset
        ans += i * 2

    return ans + len(plants)"
"208","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.isWord = False


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str) -> bool:
    node: TrieNode = self._find(word)
    return node and node.isWord

  def startsWith(self, prefix: str) -> bool:
    return self._find(prefix)

  def _find(self, prefix: str) -> TrieNode | None:
    node: TrieNode = self.root
    for c in prefix:
      if c not in node.children:
        return None
      node = node.children[c]
    return node"
"2080","class RangeFreqQuery:
  def __init__(self, arr: list[int]):
    self.valueToIndices = collections.defaultdict(list)
    for i, a in enumerate(arr):
      self.valueToIndices[a].append(i)

  def query(self, left: int, right: int, value: int) -> int:
    indices = self.valueToIndices[value]
    i = bisect_left(indices, left)
    j = bisect_right(indices, right)
    return j - i"
"2081","class Solution:
  def kMirror(self, k: int, n: int) -> int:
    ans = 0
    A = ['0']

    def nextKMirror(A: list[str]) -> list[str]:
      for i in range(len(A) // 2, len(A)):
        nextNum = int(A[i]) + 1
        if nextNum < k:
          A[i] = str(nextNum)
          A[~i] = str(nextNum)
          for j in range(len(A) // 2, i):
            A[j] = '0'
            A[~j] = '0'
          return A
      return ['1'] + ['0'] * (len(A) - 1) + ['1']

    for _ in range(n):
      while True:
        A = nextKMirror(A)
        num = int(''.join(A), k)
        if str(num)[::-1] == str(num):
          break
      ans += num

    return ans"
"2082","SELECT COUNT(DISTINCT customer_id) AS rich_count
FROM Store
WHERE amount > 500;"
"2083","class Solution:
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    for c in s:
      ans += count[c] + 1
      count[c] += 1

    return ans"
"2084","WITH
  RankedOrders AS (
    SELECT
      *,
      RANK() OVER(PARTITION BY customer_id ORDER BY order_type) AS `rank`
    FROM Orders
  )
SELECT
  order_id,
  customer_id,
  order_type
FROM RankedOrders
WHERE `rank` = 1;"
"2085","class Solution:
  def countWords(self, words1: list[str], words2: list[str]) -> int:
    count = collections.Counter(words1)

    for word in words2:
      if word in count and count[word] < 2:
        count[word] -= 1

    return sum(value == 0 for value in count.values())"
"2086","class Solution:
  def minimumBuckets(self, street: str) -> int:
    A = list(street)

    for i, c in enumerate(A):
      if c == 'H':
        if i > 0 and A[i - 1] == 'B':
          continue
        if i + 1 < len(A) and A[i + 1] == '.':
          # Always prefer place a bucket in (i + 1) because it enhances the
          # possibility to collect the upcoming houses.
          A[i + 1] = 'B'
        elif i > 0 and A[i - 1] == '.':
          A[i - 1] = 'B'
        else:
          return -1

    return A.count('B')"
"2087","class Solution:
  def minCost(
      self,
      startPos: list[int],
      homePos: list[int],
      rowCosts: list[int],
      colCosts: list[int],
  ) -> int:
    ans = 0
    i, j = startPos
    x, y = homePos

    while i != x:
      i += 1 if i < x else -1
      ans += rowCosts[i]

    while j != y:
      j += 1 if j < y else -1
      ans += colCosts[j]

    return ans"
"2088","class Solution:
  def countPyramids(self, grid: list[list[int]]) -> int:
    # dp[i][j] := the maximum height of the pyramid for which it is the apex
    def count(dp: list[list[int]]) -> int:
      ans = 0
      for i in range(len(dp) - 2, -1, -1):
        for j in range(1, len(dp[0]) - 1):
          if dp[i][j] == 1:
            dp[i][j] = min(dp[i + 1][j - 1],
                           dp[i + 1][j],
                           dp[i + 1][j + 1]) + 1
            ans += dp[i][j] - 1
      return ans

    return count(deepcopy(grid)[::-1]) + count(grid)"
"2089","class Solution:
  def targetIndices(self, nums: list[int], target: int) -> list[int]:
    count = nums.count(target)
    lessThan = sum(num < target for num in nums)
    return [i for i in range(lessThan, lessThan + count)]"
"209","class Solution:
  def minSubArrayLen(self, target: int, nums: list[int]) -> int:
    ans = math.inf
    summ = 0
    j = 0

    for i, num in enumerate(nums):
      summ += num
      while summ >= target:
        ans = min(ans, i - j + 1)
        summ -= nums[j]
        j += 1

    return 0 if ans == math.inf else ans"
"2090","class Solution:
  def getAverages(self, nums: list[int], k: int) -> list[int]:
    n = len(nums)
    size = 2 * k + 1
    ans = [-1] * n
    if size > n:
      return ans

    summ = sum(nums[:size])

    for i in range(k, n - k):
      ans[i] = summ // size
      if i + k + 1 < n:
        summ += nums[i + k + 1] - nums[i - k]

    return ans"
"2091","class Solution:
  def minimumDeletions(self, nums: list[int]) -> int:
    n = len(nums)
    a = nums.index(min(nums))
    b = nums.index(max(nums))
    if a > b:
      a, b = b, a
    return min(a + 1 + n - b, b + 1, n - a)"
"2092","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def connected(self, u: int, v: int) -> bool:
    return self._find(self.id[u]) == self._find(self.id[v])

  def reset(self, u: int) -> None:
    self.id[u] = u

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findAllPeople(
      self,
      n: int,
      meetings: list[list[int]],
      firstPerson: int,
  ) -> list[int]:
    uf = UnionFind(n)
    timeToPairs = collections.defaultdict(list)

    uf.unionByRank(0, firstPerson)

    for x, y, time in meetings:
      timeToPairs[time].append((x, y))

    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):
      peopleUnioned = set()
      for x, y in pairs:
        uf.unionByRank(x, y)
        peopleUnioned.add(x)
        peopleUnioned.add(y)
      for person in peopleUnioned:
        if not uf.connected(person, 0):
          uf.reset(person)

    return [i for i in range(n) if uf.connected(i, 0)]"
"2093","class Solution:
  def minimumCost(
      self,
      n: int,
      highways: list[list[int]],
      discounts: int,
  ) -> int:
    graph = [[] for _ in range(n)]
    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)
    minDiscounts = {}

    for city1, city2, toll in highways:
      graph[city1].append((city2, toll))
      graph[city2].append((city1, toll))

    while minHeap:
      d, u, leftDiscounts = heapq.heappop(minHeap)
      if u == n - 1:
        return d
      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:
        continue
      minDiscounts[u] = leftDiscounts
      for v, w in graph[u]:
        heapq.heappush(minHeap, (d + w, v, leftDiscounts))
        if leftDiscounts > 0:
          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))

    return -1"
"2094","class Solution:
  def findEvenNumbers(self, digits: list[int]) -> list[int]:
    ans = []
    count = collections.Counter(digits)

    # Try to construct `abc`.
    for a in range(1, 10):
      for b in range(0, 10):
        for c in range(0, 9, 2):
          if count[a] > 0 and count[b] > (
                  b == a) and count[c] > (
                  c == a) + (
                  c == b):
            ans.append(a * 100 + b * 10 + c)

    return ans"
"2095","class Solution:
  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:
    dummy = ListNode(0, head)
    slow = dummy
    fast = dummy

    while fast.next and fast.next.next:
      slow = slow.next
      fast = fast.next.next

    # Delete the middle node.
    slow.next = slow.next.next
    return dummy.next"
"2096","class Solution:
  def getDirections(
      self,
      root: TreeNode | None,
      startValue: int,
      destValue: int,
  ) -> str:
    def dfs(root: TreeNode | None, val: int, path: list[str]) -> bool:
      """"""Builds the string in reverse order to avoid creating a new copy.""""""
      if root.val == val:
        return True
      if root.left and dfs(root.left, val, path):
        path.append('L')
      elif root.right and dfs(root.right, val, path):
        path.append('R')
      return len(path) > 0

    pathToStart = []
    pathToDest = []

    dfs(root, startValue, pathToStart)
    dfs(root, destValue, pathToDest)

    while pathToStart and pathToDest and pathToStart[-1] == pathToDest[-1]:
      pathToStart.pop()
      pathToDest.pop()

    return 'U' * len(pathToStart) + ''.join(reversed(pathToDest))"
"2097","class Solution:
  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:
    ans = []
    graph = collections.defaultdict(list)
    outDegree = collections.Counter()
    inDegrees = collections.Counter()

    for start, end in pairs:
      graph[start].append(end)
      outDegree[start] += 1
      inDegrees[end] += 1

    def getStartNode() -> int:
      for u in graph.keys():
        if outDegree[u] - inDegrees[u] == 1:
          return u
      return pairs[0][0]  # Arbitrarily choose a node.

    def euler(u: int) -> None:
      stack = graph[u]
      while stack:
        v = stack.pop()
        euler(v)
        ans.append([u, v])

    euler(getStartNode())
    return ans[::-1]"
"2098","class Solution:
  def largestEvenSum(self, nums: list[int], k: int) -> int:
    nums.sort()
    summ = sum(nums[-k:])
    if summ % 2 == 0:
      return summ

    minOdd = -1
    minEven = -1
    maxOdd = -1
    maxEven = -1

    for i in range(len(nums) - 1, len(nums) - k - 1, -1):
      if nums[i] & 1:
        minOdd = nums[i]
      else:
        minEven = nums[i]

    for i in range(len(nums) - k):
      if nums[i] & 1:
        maxOdd = nums[i]
      else:
        maxEven = nums[i]

    ans = -1

    if maxEven >= 0 and minOdd >= 0:
      ans = max(ans, summ + maxEven - minOdd)
    if maxOdd >= 0 and minEven >= 0:
      ans = max(ans, summ + maxOdd - minEven)
    return ans"
"2099","class Solution:
  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:
    ans = []
    threshold = sorted(nums)[-k]
    larger = sum(num > threshold for num in nums)
    equal = k - larger

    for num in nums:
      if num > threshold:
        ans.append(num)
      elif num == threshold and equal:
        ans.append(num)
        equal -= 1

    return ans"
"21","class Solution:
  def mergeTwoLists(
      self,
      list1: ListNode | None,
      list2: ListNode | None,
  ) -> ListNode | None:
    if not list1 or not list2:
      return list1 if list1 else list2
    if list1.val > list2.val:
      list1, list2 = list2, list1
    list1.next = self.mergeTwoLists(list1.next, list2)
    return list1"
"210","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def findOrder(
      self,
      numCourses: int,
      prerequisites: list[list[int]],
  ) -> list[int]:
    ans = []
    graph = [[] for _ in range(numCourses)]
    states = [State.kInit] * numCourses

    for v, u in prerequisites:
      graph[u].append(v)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited
      ans.append(u)

      return False

    if any(hasCycle(i) for i in range(numCourses)):
      return []

    return ans[::-1]"
"2100","class Solution:
  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:
    n = len(security)
    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i
    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i

    for i in range(1, n):
      if security[i - 1] >= security[i]:
        dec[i] = dec[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if security[i] <= security[i + 1]:
        inc[i] = inc[i + 1] + 1

    return [i for i, (a, b) in enumerate(zip(dec, inc))
            if a >= time and b >= time]"
"2101","class Solution:
  def maximumDetonation(self, bombs: list[list[int]]) -> int:
    n = len(bombs)
    ans = 0
    graph = [[] for _ in range(n)]

    for i, (xi, yi, ri) in enumerate(bombs):
      for j, (xj, yj, rj) in enumerate(bombs):
        if i == j:
          continue
        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:
          graph[i].append(j)

    def dfs(u: int, seen: set[int]) -> None:
      for v in graph[u]:
        if v in seen:
          continue
        seen.add(v)
        dfs(v, seen)

    for i in range(n):
      seen = set([i])
      dfs(i, seen)
      ans = max(ans, len(seen))

    return ans"
"2102","class Location:
  def __init__(self, name: str, score: int):
    self.name = name
    self.score = score

  def __lt__(self, location):
    if self.score == location.score:
      return self.name > location.name
    return self.score < location.score


class SORTracker:
  def __init__(self):
    self.l = []
    self.r = []
    self.k = 0  the number of times get() called

  def add(self, name: str, score: int) -> None:
    heapq.heappush(self.l, Location(name, score))
    if len(self.l) > self.k + 1:
      location = heapq.heappop(self.l)
      heapq.heappush(self.r, (-location.score, location.name))

  def get(self) -> str:
    name = self.l[0].name
    if self.r:
      topScore, topName = heapq.heappop(self.r)
      heapq.heappush(self.l, Location(topName, -topScore))
    self.k += 1
    return name"
"2103","class Solution:
  def countPoints(self, rings: str) -> int:
    colors = [0] * 10

    for c, num in zip(rings[::2], rings[1::2]):
      color = 1 if c == 'R' else 2 if c == 'G' else 4
      colors[int(num)] |= color

    return sum(color == 7 for color in colors)"
"2104","class Solution:
  def subArrayRanges(self, nums: list[int]) -> int:
    n = len(nums)

    def sumSubarray(A: list[int], op):
      res = 0
      prev = [-1] * n
      next = [n] * n
      stack = []

      for i, a in enumerate(A):
        while stack and op(A[stack[-1]], a):
          index = stack.pop()
          next[index] = i
        if stack:
          prev[i] = stack[-1]
        stack.append(i)

      for i, a in enumerate(A):
        res += a * (i - prev[i]) * (next[i] - i)

      return res

    return sumSubarray(nums, operator.lt) - sumSubarray(nums, operator.gt)"
"2105","class Solution:
  def minimumRefill(
      self,
      plants: list[int],
      capacityA: int,
      capacityB: int,
  ) -> int:
    ans = 0
    i = 0
    j = len(plants) - 1
    canA = capacityA
    canB = capacityB

    while i < j:
      ans += (canA < plants[i]) + (canB < plants[j])
      if canA < plants[i]:
        canA = capacityA
      if canB < plants[j]:
        canB = capacityB
      canA -= plants[i]
      canB -= plants[j]
      i += 1
      j -= 1

    return ans + (i == j and max(canA, canB) < plants[i])"
"2106","class Solution:
  def maxTotalFruits(
      self,
      fruits: list[list[int]],
      startPos: int,
      k: int,
  ) -> int:
    ans = 0
    maxRight = max(startPos, fruits[-1][0])
    amounts = [0] * (1 + maxRight)
    for position, amount in fruits:
      amounts[position] = amount
    prefix = list(itertools.accumulate(amounts, initial=0))

    def getFruits(leftSteps: int, rightSteps: int) -> int:
      l = max(0, startPos - leftSteps)
      r = min(maxRight, startPos + rightSteps)
      return prefix[r + 1] - prefix[l]

    # Go right first.
    for rightSteps in range(min(maxRight - startPos, k) + 1):
      leftSteps = max(0, k - 2 * rightSteps)  # Turn left
      ans = max(ans, getFruits(leftSteps, rightSteps))

    # Go left first.
    for leftSteps in range(min(startPos, k) + 1):
      rightSteps = max(0, k - 2 * leftSteps)  # Turn right
      ans = max(ans, getFruits(leftSteps, rightSteps))

    return ans"
"2107","class Solution:
  def shareCandies(self, candies: list[int], k: int) -> int:
    ans = 0
    count = collections.Counter(candies)
    unique = len(count)

    for i, candy in enumerate(candies):
      count[candy] -= 1
      if count[candy] == 0:
        del count[candy]
        unique -= 1
      if i >= k:
        count[candies[i - k]] += 1
        if count[candies[i - k]] == 1:
          unique += 1
      if i >= k - 1:
        ans = max(ans, unique)

    return ans"
"2108","class Solution:
  def firstPalindrome(self, words: list[str]) -> str:
    def isPalindrome(s: str) -> bool:
      i = 0
      j = len(s) - 1
      while i < j:
        if s[i] != s[j]:
          return False
        i += 1
        j -= 1
      return True
    return next((word for word in words if isPalindrome(word)), '')"
"2109","class Solution:
  def addSpaces(self, s: str, spaces: list[int]) -> str:
    ans = []
    j = 0  # spaces' index

    for i, c in enumerate(s):
      if j < len(spaces) and i == spaces[j]:
        ans.append(' ')
        j += 1
      ans.append(c)

    return ''.join(ans)"
"211","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.isWord = False


class WordDictionary:
  def __init__(self):
    self.root = TrieNode()

  def addWord(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str) -> bool:
    return self._dfs(word, 0, self.root)

  def _dfs(self, word: str, s: int, node: TrieNode) -> bool:
    if s == len(word):
      return node.isWord
    if word[s] != '.':
      child: TrieNode = node.children.get(word[s], None)
      return self._dfs(word, s + 1, child) if child else False
    return any(self._dfs(word, s + 1, child) for child in node.children.values())"
"2110","class Solution:
  def getDescentPeriods(self, prices: list[int]) -> int:
    ans = 1  # prices[0]
    dp = 1

    for i in range(1, len(prices)):
      if prices[i] == prices[i - 1] - 1:
        dp += 1
      else:
        dp = 1
      ans += dp

    return ans"
"2111","class Solution:
  def kIncreasing(self, arr: list[int], k: int) -> int:
    def numReplaced(A: list[int]) -> int:
      tails = []
      for a in A:
        if not tails or tails[-1] <= a:
          tails.append(a)
        else:
          tails[bisect_right(tails, a)] = a
      return len(A) - len(tails)

    return sum(numReplaced(arr[i::k]) for i in range(k))"
"2112","WITH
  AirportToCount AS (
    SELECT departure_airport AS airport_id, flights_count
    FROM Flights
    UNION ALL
    SELECT arrival_airport, flights_count
    FROM Flights
  ),
  RankedAirports AS (
    SELECT
      airport_id,
      RANK() OVER(ORDER BY SUM(flights_count) DESC) AS `rank`
    FROM AirportToCount
    GROUP BY 1
  )
SELECT airport_id
FROM RankedAirports
WHERE `rank` = 1;"
"2113","class Solution:
  def elementInNums(
      self,
      nums: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    n = len(nums)

    def f(time: int, index: int) -> int:
      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]
        index += time
        return -1 if index >= n else nums[index]
      else:  # [] -> [0] -> [0, 1]
        return -1 if index >= time - n else nums[index]

    return [f(time % (2 * n), index) for time, index in queries]"
"2114","class Solution:
  def mostWordsFound(self, sentences: list[str]) -> int:
    return max(s.count(' ') for s in sentences) + 1"
"2115","class Solution:
  def findAllRecipes(
      self,
      recipes: list[str],
      ingredients: list[list[str]],
      supplies: list[str],
  ) -> list[str]:
    ans = []
    supplies = set(supplies)
    graph = collections.defaultdict(list)
    inDegrees = collections.Counter()
    q = collections.deque()

    # Build the graph.
    for i, recipe in enumerate(recipes):
      for ingredient in ingredients[i]:
        if ingredient not in supplies:
          graph[ingredient].append(recipe)
          inDegrees[recipe] += 1

    # Perform topological sorting.
    for recipe in recipes:
      if inDegrees[recipe] == 0:
        q.append(recipe)

    while q:
      u = q.popleft()
      ans.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return ans"
"2116","class Solution:
  def canBeValid(self, s: str, locked: str) -> bool:
    if len(s) % 2 == 1:
      return False

    def check(s: str, locked: str, isForward: bool) -> bool:
      changeable = 0
      l = 0
      r = 0

      for c, lock in zip(s, locked):
        if lock == '0':
          changeable += 1
        elif c == '(':
          l += 1
        else:  # c == ')'
          r += 1
        if isForward and changeable + l - r < 0:
          return False
        if not isForward and changeable + r - l < 0:
          return False

      return True

    return check(s, locked, True) and check(s[::-1], locked[::-1], False)"
"2117","class Solution:
  def abbreviateProduct(self, left: int, right: int) -> str:
    prod = 1.0
    suf = 1
    countDigits = 0
    countZeros = 0

    for num in range(left, right + 1):
      prod *= num
      while prod >= 1.0:
        prod /= 10
        countDigits += 1
      suf *= num
      while suf % 10 == 0:
        suf //= 10
        countZeros += 1
      if suf > 10**8:
        suf %= 10**8

    if countDigits - countZeros <= 10:
      tens = 10**(countDigits - countZeros)
      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)

    pre = str(int(prod * 10 ** 5))
    suf = str(suf)[-5:]
    return pre + '...' + suf + 'e' + str(countZeros)"
"2118","WITH
  PowerToTerm AS (
    SELECT
      CONCAT(
        IF(factor > 0, '+', ''),
        factor,
        IF(power = 0, '', 'X'),
        IF(power IN (0, 1), '', CONCAT('^', power))
      ) AS term,
      power
    FROM Terms
    ORDER BY power DESC
  )
SELECT
  CONCAT(
    GROUP_CONCAT(
      term
      ORDER BY power DESC SEPARATOR ''
    ),
    '=0'
  ) AS equation
FROM PowerToTerm;"
"2119","class Solution:
  def isSameAfterReversals(self, num: int) -> bool:
    def getReversed(num: int) -> int:
      reversed = 0
      while num > 0:
        reversed = reversed * 10 + num % 10
        num //= 10
      return reversed

    reversed1 = getReversed(num)
    reversed2 = getReversed(reversed1)
    return reversed2 == num"
"212","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.word: str | None = None


class Solution:
  def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:
    m = len(board)
    n = len(board[0])
    ans = []
    root = TrieNode()

    def insert(word: str) -> None:
      node = root
      for c in word:
        node = node.children.setdefault(c, TrieNode())
      node.word = word

    for word in words:
      insert(word)

    def dfs(i: int, j: int, node: TrieNode) -> None:
      if i < 0 or i == m or j < 0 or j == n:
        return
      if board[i][j] == '*':
        return

      c = board[i][j]
      if c not in node.children:
        return

      child = node.children[c]
      if child.word:
        ans.append(child.word)
        child.word = None

      board[i][j] = '*'
      dfs(i + 1, j, child)
      dfs(i - 1, j, child)
      dfs(i, j + 1, child)
      dfs(i, j - 1, child)
      board[i][j] = c

    for i in range(m):
      for j in range(n):
        dfs(i, j, root)

    return ans"
"2120","class Solution:
  def executeInstructions(
      self,
      n: int,
      startPos: list[int],
      s: str,
  ) -> list[int]:
    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
    m = len(s)
    uMost = startPos[0] + 1
    dMost = n - startPos[0]
    lMost = startPos[1] + 1
    rMost = n - startPos[1]

    ans = [0] * m
    reach = {(0, None): m, (None, 0): m}
    x = 0
    y = 0

    for i in reversed(range(m)):
      dx, dy = moves[s[i]]
      x -= dx
      y -= dy
      reach[(x, None)] = i
      reach[(None, y)] = i
      out = min(reach.get((x - uMost, None), math.inf),
                reach.get((x + dMost, None), math.inf),
                reach.get((None, y - lMost), math.inf),
                reach.get((None, y + rMost), math.inf))
      ans[i] = m - i if out == math.inf else out - i - 1

    return ans"
"2121","class Solution:
  def getDistances(self, arr: list[int]) -> list[int]:
    prefix = [0] * len(arr)
    suffix = [0] * len(arr)
    numToIndices = collections.defaultdict(list)

    for i, a in enumerate(arr):
      numToIndices[a].append(i)

    for indices in numToIndices.values():
      for i in range(1, len(indices)):
        currIndex = indices[i]
        prevIndex = indices[i - 1]
        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)
      for i in range(len(indices) - 2, -1, -1):
        currIndex = indices[i]
        prevIndex = indices[i + 1]
        suffix[currIndex] += (suffix[prevIndex] +
                              (len(indices) - i - 1) * (prevIndex - currIndex))

    return [p + s for p, s in zip(prefix, suffix)]"
"2122","class Solution:
  def recoverArray(self, nums: list[int]) -> list[int]:
    nums = sorted(nums)

    def getArray(x: int, count: collections.Counter) -> list[int]:
      A = []
      for num in nums:
        if count[num] == 0:
          continue
        if count[num + x] == 0:
          return []
        count[num] -= 1
        count[num + x] -= 1
        A.append(num + x // 2)
      return A

    count = collections.Counter(nums)

    for i in range(1, len(nums)):
      x = nums[i] - nums[0]  # 2 * k
      if x <= 0 or x % 2 == 1:
        continue
      A = getArray(x, count.copy())
      if A:
        return A"
"2123","class Solution:
  def minimumOperations(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    seen = [[0] * n for _ in range(m)]
    match = [[-1] * n for _ in range(m)]

    def dfs(i: int, j: int, sessionId: int) -> int:
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if grid[x][y] == 0 or seen[x][y] == sessionId:
          continue
        seen[x][y] = sessionId
        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):
          match[x][y] = i * n + j
          match[i][j] = x * n + y
          return 1
      return 0

    ans = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1 and match[i][j] == -1:
          sessionId = i * n + j
          seen[i][j] = sessionId
          ans += dfs(i, j, sessionId)

    return ans"
"2124","class Solution:
  def checkString(self, s: str) -> bool:
    return 'ba' not in s"
"2125","class Solution:
  def numberOfBeams(self, bank: list[str]) -> int:
    ans = 0
    prevOnes = 0

    for row in bank:
      ones = row.count('1')
      if ones:
        ans += prevOnes * ones
        prevOnes = ones

    return ans"
"2126","class Solution:
  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:
    for asteroid in sorted(asteroids):
      if mass >= asteroid:
        mass += asteroid
      else:
        return False
    return True"
"2127","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def maximumInvitations(self, favorite: list[int]) -> int:
    n = len(favorite)
    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    maxChainLength = [1] * n

    # Build the graph.
    for i, f in enumerate(favorite):
      graph[i].append(f)
      inDegrees[f] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)
        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])

    for i in range(n):
      if favorite[favorite[i]] == i:
        # i <-> favorite[i] (the cycle's length = 2)
        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]

    maxCycleLength = 0  # Cycle: a -> b -> c -> a
    parent = [-1] * n
    seen = set()
    states = [State.kInit] * n

    def findCycle(u: int) -> None:
      nonlocal maxCycleLength
      seen.add(u)
      states[u] = State.kVisiting
      for v in graph[u]:
        if v not in seen:
          parent[v] = u
          findCycle(v)
        elif states[v] == State.kVisiting:
          # Find the cycle's length.
          curr = u
          cycleLength = 1
          while curr != v:
            curr = parent[curr]
            cycleLength += 1
          maxCycleLength = max(maxCycleLength, cycleLength)
      states[u] = State.kVisited

    for i in range(n):
      if i not in seen:
        findCycle(i)

    return max(sumComponentsLength // 2, maxCycleLength)"
"2128","class Solution:
  def removeOnes(self, grid: list[list[int]]) -> bool:
    revRow = [a ^ 1 for a in grid[0]]
    return all(row == grid[0] or row == revRow for row in grid)"
"2129","class Solution:
  def capitalizeTitle(self, title: str) -> str:
    return ' '.join(s.lower() if len(s) < 3
                    else s.capitalize() for s in title.split())"
"213","class Solution:
  def rob(self, nums: list[int]) -> int:
    if not nums:
      return 0
    if len(nums) < 2:
      return nums[0]

    def rob(l: int, r: int) -> int:
      dp1 = 0
      dp2 = 0

      for i in range(l, r + 1):
        temp = dp1
        dp1 = max(dp1, dp2 + nums[i])
        dp2 = temp

      return dp1

    return max(rob(0, len(nums) - 2),
               rob(1, len(nums) - 1))"
"2130","class Solution:
  def pairSum(self, head: ListNode | None) -> int:
    def reverseList(head: ListNode) -> ListNode:
      prev = None
      while head:
        next = head.next
        head.next = prev
        prev = head
        head = next
      return prev

    ans = 0
    slow = head
    fast = head

    # `slow` points to the start of the second half.
    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next

    # `tail` points to the end of the reversed second half.
    tail = reverseList(slow)

    while tail:
      ans = max(ans, head.val + tail.val)
      head = head.next
      tail = tail.next

    return ans"
"2131","class Solution:
  def longestPalindrome(self, words: list[str]) -> int:
    ans = 0
    count = [[0] * 26 for _ in range(26)]

    for a, b in words:
      i = string.ascii_lowercase.index(a)
      j = string.ascii_lowercase.index(b)
      if count[j][i]:
        ans += 4
        count[j][i] -= 1
      else:
        count[i][j] += 1

    for i in range(26):
      if count[i][i]:
        return ans + 2

    return ans"
"2132","class Solution:
  def possibleToStamp(
      self,
      grid: list[list[int]],
      stampHeight: int,
      stampWidth: int,
  ) -> bool:
    m = len(grid)
    n = len(grid[0])
    # A[i][j] := the number of 1s in grid[0..i)[0..j)
    A = [[0] * (n + 1) for _ in range(m + 1)]
    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)
    B = [[0] * (n + 1) for _ in range(m + 1)]
    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)
    fit = [[False] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]
        if i + 1 >= stampHeight and j + 1 >= stampWidth:
          x = i - stampHeight + 1
          y = j - stampWidth + 1
          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:
            fit[i][j] = True

    for i in range(m):
      for j in range(n):
        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]

    for i in range(m):
      for j in range(n):
        if not grid[i][j]:
          x = min(i + stampHeight, m)
          y = min(j + stampWidth, n)
          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:
            return False

    return True"
"2133","class Solution:
  def checkValid(self, matrix: list[list[int]]) -> bool:
    return all(min(len(set(row)), len(set(col))) == len(matrix)
               for row, col in zip(matrix, zip(*matrix)))"
"2134","class Solution:
  def minSwaps(self, nums: list[int]) -> int:
    n = len(nums)
    k = nums.count(1)
    ones = 0  # the number of ones in the window
    maxOnes = 0  # the maximum number of ones in the window

    for i in range(n * 2):
      if i >= k and nums[i % n - k]:  # Magic in Python :)
        ones -= 1
      if nums[i % n]:
        ones += 1
      maxOnes = max(maxOnes, ones)

    return k - maxOnes"
"2135","class Solution:
  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:
    def getMask(s: str) -> int:
      mask = 0
      for c in s:
        mask ^= 1 << string.ascii_lowercase.index(c)
      return mask

    ans = 0
    seen = set(getMask(w) for w in startWords)

    for targetWord in targetWords:
      mask = getMask(targetWord)
      for c in targetWord:
        # Toggle one character.
        if mask ^ 1 << string.ascii_lowercase.index(c) in seen:
          ans += 1
          break

    return ans"
"2136","class Solution:
  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:
    ans = 0
    time = 0

    for p, g in sorted(
        [(p, g) for (p, g) in zip(plantTime, growTime)],
            key=lambda x: -x[1]):
      time += p
      ans = max(ans, time + g)

    return ans"
"2137","class Solution:
  def equalizeWater(self, buckets: list[int], loss: int) -> float:
    kErr = 1e-5
    kPercentage = (100 - loss) / 100
    l = 0.0
    r = max(buckets)

    def canFill(target: float) -> bool:
      extra = 0
      need = 0
      for bucket in buckets:
        if bucket > target:
          extra += bucket - target
        else:
          need += target - bucket
      return extra * kPercentage >= need

    while r - l > kErr:
      m = (l + r) / 2
      if canFill(m):
        l = m
      else:
        r = m

    return l"
"2138","class Solution:
  def divideString(self, s: str, k: int, fill: str) -> list[str]:
    return [
        s[i:] + fill * (i + k - len(s)) if i + k > len(s)
        else s[i:i + k]
        for i in range(0, len(s), k)
    ]"
"2139","class Solution:
  def minMoves(self, target: int, maxDoubles: int) -> int:
    steps = 0

    while target > 1 and maxDoubles:
      if target % 2 == 1:
        target -= 1
      else:
        target //= 2
        maxDoubles -= 1
      steps += 1

    return steps + target - 1"
"214","class Solution:
  def shortestPalindrome(self, s: str) -> str:
    t = s[::-1]

    for i in range(len(t)):
      if s.startswith(t[i:]):
        return t[:i] + s

    return t + s"
"2140","class Solution:
  def mostPoints(self, questions: list[list[int]]) -> int:
    n = len(questions)
    # dp[i] := the maximum points starting from questions[i]
    dp = [0] * (n + 1)

    for i in reversed(range(n)):
      points, brainpower = questions[i]
      nextIndex = i + brainpower + 1
      nextPoints = dp[nextIndex] if nextIndex < n else 0
      dp[i] = max(points + nextPoints, dp[i + 1])

    return dp[0]"
"2141","class Solution:
  def maxRunTime(self, n: int, batteries: list[int]) -> int:
    summ = sum(batteries)

    batteries.sort()

    # The maximum battery is greater than the average, so it can last forever.
    # Reduce the problem from size n to size n - 1.
    while batteries[-1] > summ // n:
      summ -= batteries.pop()
      n -= 1

    # If the maximum battery <= average running time, it won't be waste, and so
    # do smaller batteries.
    return summ // n"
"2142","WITH
  RECURSIVE BusesNeighbors AS (
    SELECT
      bus_id,
      arrival_time,
      IFNULL(LAG(arrival_time) OVER(
        ORDER BY arrival_time), 0
      ) AS prev_arrival_time
    FROM Buses
  )
SELECT
  BusesNeighbors.bus_id,
  COUNT(Passengers.passenger_id) AS passengers_cnt
FROM BusesNeighbors
LEFT JOIN Passengers
  ON (
    BusesNeighbors.prev_arrival_time < Passengers.arrival_time
    AND Passengers.arrival_time <= BusesNeighbors.arrival_time)
GROUP BY 1
ORDER BY 1;"
"2143","class Solution:
  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:
    kMod = 1_000_000_007
    ans = 0
    # {sum, count}, add if choose from nums1, minus if choose from nums2
    dp = collections.Counter()

    for a, b in zip(nums1, nums2):
      newDp = collections.Counter()
      newDp[a] += 1
      newDp[-b] += 1

      for prevSum, count in dp.items():
        # Choose nums1[i]
        newDp[prevSum + a] += count
        newDp[prevSum + a] %= kMod
        # Choose nums2[i]
        newDp[prevSum - b] += count
        newDp[prevSum - b] %= kMod

      dp = newDp
      ans += dp[0]
      ans %= kMod

    return ans"
"2144","class Solution:
  def minimumCost(self, cost: list[int]) -> int:
    return sum(cost) - sum(sorted(cost)[-3::-3])"
"2145","class Solution:
  def numberOfArrays(
      self,
      differences: list[int],
      lower: int,
      upper: int,
  ) -> int:
    prefix = 0
    mn = 0  # Starts from 0.
    mx = 0  # Starts from 0.

    for d in differences:
      prefix += d
      mn = min(mn, prefix)
      mx = max(mx, prefix)

    return max(0, (upper - lower) - (mx - mn) + 1)"
"2146","class Solution:
  def highestRankedKItems(self, grid: list[list[int]],
                          pricing: list[int],
                          start: list[int],
                          k: int) -> list[list[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    low, high = pricing
    row, col = start
    ans = []

    if low <= grid[row][col] <= high:
      ans.append([row, col])
      if k == 1:
        return ans

    q = collections.deque([(row, col)])
    seen = {(row, col)}  # Mark as visited.

    while q:
      neighbors = []
      for _ in range(len(q)):
        i, j = q.popleft()
        for t in range(4):
          x = i + dirs[t]
          y = j + dirs[t + 1]
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if not grid[x][y] or (x, y) in seen:
            continue
          if low <= grid[x][y] <= high:
            neighbors.append([x, y])
          q.append((x, y))
          seen.add((x, y))
      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))
      for neighbor in neighbors:
        if len(ans) < k:
          ans.append(neighbor)
        if len(ans) == k:
          return ans

    return ans"
"2147","class Solution:
  def numberOfWays(self, corridor: str) -> int:
    kMod = 1_000_000_007
    ans = 1
    prevSeat = -1
    numSeats = 0

    for i, c in enumerate(corridor):
      if c == 'S':
        numSeats += 1
        if numSeats > 2 and numSeats % 2 == 1:
          ans = ans * (i - prevSeat) % kMod
        prevSeat = i

    return ans if numSeats > 1 and numSeats % 2 == 0 else 0"
"2148","class Solution:
  def countElements(self, nums: list[int]) -> int:
    mn = min(nums)
    mx = max(nums)
    return sum(mn < num < mx for num in nums)"
"2149","class Solution:
  def rearrangeArray(self, nums: list[int]) -> list[int]:
    ans = []
    pos = []
    neg = []

    for num in nums:
      (pos if num > 0 else neg).append(num)

    for p, n in zip(pos, neg):
      ans += [p, n]

    return ans"
"215","class Solution:
  def findKthLargest(self, nums: list[int], k: int) -> int:
    def quickSelect(l: int, r: int, k: int) -> int:
      randIndex = random.randint(0, r - l) + l
      nums[randIndex], nums[r] = nums[r], nums[randIndex]
      pivot = nums[r]

      nextSwapped = l
      for i in range(l, r):
        if nums[i] >= pivot:
          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]
          nextSwapped += 1
      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]

      count = nextSwapped - l + 1  # Number of nums >= pivot
      if count == k:
        return nums[nextSwapped]
      if count > k:
        return quickSelect(l, nextSwapped - 1, k)
      return quickSelect(nextSwapped + 1, r, k - count)

    return quickSelect(0, len(nums) - 1, k)"
"2150","class Solution:
  def findLonely(self, nums: list[int]) -> list[int]:
    count = collections.Counter(nums)
    return [num for num, freq in count.items()
            if freq == 1 and
            count[num - 1] == 0 and
            count[num + 1] == 0]"
"2151","class Solution:
  def maximumGood(self, statements: list[list[int]]) -> int:
    n = len(statements)

    def isValid(mask: int) -> bool:
      for i in range(n):
        # The i-th person is bad, so no need to check.
        if (mask >> i & 1) == 0:
          continue
        for j in range(n):
          if statements[i][j] == 2:
            continue
          if statements[i][j] != (mask >> j & 1):
            return False
      return True

    return max(mask.bit_count()
               for mask in range(1 << n)
               if isValid(mask))"
"2152","class Solution:
  def minimumLines(self, points: list[list[int]]) -> int:
    n = len(points)
    allCovered = (1 << n) - 1
    maxLines = n // 2 + (n & 1)

    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:
      dx = p[0] - q[0]
      dy = p[1] - q[1]
      if dx == 0:
        return (0, p[0])
      if dy == 0:
        return (p[1], 0)
      d = gcd(dx, dy)
      x = dx // d
      y = dy // d
      return (x, y) if x > 0 else (-x, -y)

    @functools.lru_cache(None)
    def dfs(covered: int) -> int:
      if covered == allCovered:
        return 0

      ans = maxLines

      for i in range(n):
        if covered >> i & 1:
          continue
        for j in range(n):
          if i == j:
            continue
          # Connect the points[i] with the points[j].
          newCovered = covered | 1 << i | 1 << j
          slope = getSlope(points[i], points[j])
          # Mark the points covered by this line.
          for k in range(n):
            if getSlope(points[i], points[k]) == slope:
              newCovered |= 1 << k
          ans = min(ans, 1 + dfs(newCovered))

      return ans

    return dfs(0)"
"2153","WITH
  RECURSIVE BusesNeighbors AS (
    SELECT
      bus_id,
      arrival_time,
      capacity,
      IFNULL(LAG(arrival_time) OVER(
        ORDER BY arrival_time), 0
      ) AS prev_arrival_time
    FROM Buses
  ),
  BusesMetadata AS (
    SELECT
      BusesNeighbors.bus_id,
      BusesNeighbors.arrival_time,
      BusesNeighbors.capacity,
      BusesNeighbors.prev_arrival_time,
      COUNT(Passengers.passenger_id) AS waiting,
      ROW_NUMBER() OVER(
        ORDER BY BusesNeighbors.arrival_time
      ) AS `row_number`
    FROM BusesNeighbors
    LEFT JOIN Passengers
      ON (
        BusesNeighbors.prev_arrival_time < Passengers.arrival_time
        AND Passengers.arrival_time <= BusesNeighbors.arrival_time)
    GROUP BY 1, 2, 3
  ),
  Boarding AS (
    SELECT
      BusesMetadata.`row_number`,
      BusesMetadata.bus_id,
      LEAST(
        BusesMetadata.capacity,
        BusesMetadata.waiting
      ) AS boarded,
      GREATEST(
        0,
        BusesMetadata.waiting - BusesMetadata.capacity
      ) AS not_boarded
    FROM BusesMetadata
    WHERE `row_number` = 1
    UNION ALL
    SELECT
      BusesMetadata.`row_number`,
      BusesMetadata.bus_id,
      LEAST(
        BusesMetadata.capacity,
        Boarding.not_boarded + BusesMetadata.waiting
      ) AS boarded,
      GREATEST(
        0,
        Boarding.not_boarded + BusesMetadata.waiting - BusesMetadata.capacity
      ) AS not_boarded
    FROM BusesMetadata, Boarding
    WHERE BusesMetadata.`row_number` = Boarding.`row_number` + 1
  )
SELECT
  bus_id,
  boarded AS passengers_cnt
FROM Boarding
ORDER BY 1;"
"2154","class Solution:
  def findFinalValue(self, nums: list[int], original: int) -> int:
    seen = [False] * 1001

    for num in nums:
      seen[num] = True

    while original < 1001 and seen[original]:
      original *= 2

    return original"
"2155","class Solution:
  def maxScoreIndices(self, nums: list[int]) -> list[int]:
    zeros = nums.count(0)
    ones = len(nums) - zeros
    ans = [0]  # the division at index 0
    leftZeros = 0
    leftOnes = 0
    maxScore = ones  # `leftZeros` + `rightOnes`

    for i, num in enumerate(nums):
      leftZeros += num == 0
      leftOnes += num == 1
      rightOnes = ones - leftOnes
      score = leftZeros + rightOnes
      if maxScore == score:
        ans.append(i + 1)
      elif maxScore < score:
        maxScore = score
        ans = [i + 1]

    return ans"
"2156","class Solution:
  def subStrHash(
      self,
      s: str,
      power: int,
      modulo: int,
      k: int,
      hashValue: int,
  ) -> str:
    maxPower = pow(power, k, modulo)
    hash = 0

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c) + 1

    for i, c in reversed(list(enumerate(s))):
      hash = (hash * power + val(c)) % modulo
      if i + k < len(s):
        hash = (hash - val(s[i + k]) * maxPower) % modulo
      if hash == hashValue:
        bestLeft = i

    return s[bestLeft:bestLeft + k]"
"2157","class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.sz = [1] * n

  def unionBySize(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.sz[i] < self.sz[j]:
      self.sz[j] += self.sz[i]
      self.id[i] = j
    else:
      self.sz[i] += self.sz[j]
      self.id[j] = i
    self.count -= 1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def groupStrings(self, words: list[str]) -> list[int]:
    uf = UnionFind(len(words))

    def getMask(s: str) -> int:
      mask = 0
      for c in s:
        mask |= 1 << string.ascii_lowercase.index(c)
      return mask

    def getAddedMasks(mask: int):
      for i in range(26):
        if not (mask >> i & 1):
          yield mask | 1 << i

    def getDeletedMasks(mask: int):
      for i in range(26):
        if mask >> i & 1:
          yield mask ^ 1 << i

    maskToIndex = {getMask(word): i for i, word in enumerate(words)}
    deletedMaskToIndex = {}

    for i, word in enumerate(words):
      mask = getMask(word)
      for m in getAddedMasks(mask):
        if m in maskToIndex:
          uf.unionBySize(i, maskToIndex[m])
      for m in getDeletedMasks(mask):
        if m in maskToIndex:
          uf.unionBySize(i, maskToIndex[m])
        if m in deletedMaskToIndex:
          uf.unionBySize(i, deletedMaskToIndex[m])
        else:
          deletedMaskToIndex[m] = i

    return [uf.count, max(uf.sz)]"
"2158","from sortedcontainers import SortedList


class Solution:
  def amountPainted(self, paint: list[list[int]]) -> list[int]:
    minDay = min(s for s, e in paint)
    maxDay = max(e for s, e in paint)
    ans = [0] * len(paint)
    # Stores the indices of paints that are available now.
    runningIndices = SortedList()
    events = []  # (day, index, type)

    for i, (start, end) in enumerate(paint):
      events.append((start, i, 1))  # 1 := entering
      events.append((end, i, -1))  # -1 := leaving

    events.sort()

    i = 0  # events' index
    for day in range(minDay, maxDay):
      while i < len(events) and events[i][0] == day:
        day, index, type = events[i]
        if type == 1:
          runningIndices.add(index)
        else:
          runningIndices.remove(index)
        i += 1
      if runningIndices:
        ans[runningIndices[0]] += 1

    return ans"
"2159","WITH
  FirstCols AS(
    SELECT
      first_col,
      ROW_NUMBER() OVER() AS `row_number`
    FROM Data
    ORDER BY 1
  ),
  SecondCols AS (
    SELECT
      second_col,
      ROW_NUMBER() OVER() AS `row_number`
    FROM Data
    ORDER BY 1 DESC
  )
SELECT
  FirstCols.first_col,
  SecondCols.second_col
FROM FirstCols
INNER JOIN SecondCols
  USING (`row_number`);"
"216","class Solution:
  def combinationSum3(self, k: int, n: int) -> list[list[int]]:
    ans = []

    def dfs(k: int, n: int, s: int, path: list[int]) -> None:
      if k == 0 and n == 0:
        ans.append(path)
        return
      if k == 0 or n < 0:
        return

      for i in range(s, 10):
        dfs(k - 1, n - i, i + 1, path + [i])

    dfs(k, n, 1, [])
    return ans"
"2160","class Solution:
  def minimumSum(self, num: int) -> int:
    s = sorted(str(num))
    return int(s[0] + s[2]) + int(s[1] + s[3])"
"2161","class Solution:
  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:
    return ([num for num in nums if num < pivot] +
            [num for num in nums if num == pivot] +
            [num for num in nums if num > pivot])"
"2162","class Solution:
  def minCostSetTime(
      self,
      startAt: int,
      moveCost: int,
      pushCost: int,
      targetSeconds: int,
  ) -> int:
    ans = math.inf
    mins = 99 if targetSeconds > 5999 else targetSeconds // 60
    secs = targetSeconds - mins * 60

    def getCost(mins: int, secs: int) -> int:
      cost = 0
      curr = str(startAt)
      for c in str(mins * 100 + secs):
        if c == curr:
          cost += pushCost
        else:
          cost += moveCost + pushCost
          curr = c
      return cost

    while secs < 100:
      ans = min(ans, getCost(mins, secs))
      mins -= 1
      secs += 60

    return ans"
"2163","class Solution:
  def minimumDifference(self, nums: list[int]) -> int:
    n = len(nums) // 3
    ans = math.inf
    leftSum = 0
    rightSum = 0
    maxHeap = []  # Left part, as small as possible
    minHeap = []  # Right part, as big as possible
    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)
    minLeftSum = [0] * len(nums)

    for i in range(2 * n):
      heapq.heappush(maxHeap, -nums[i])
      leftSum += nums[i]
      if len(maxHeap) == n + 1:
        leftSum += heapq.heappop(maxHeap)
      if len(maxHeap) == n:
        minLeftSum[i] = leftSum

    for i in range(len(nums) - 1, n - 1, -1):
      heapq.heappush(minHeap, nums[i])
      rightSum += nums[i]
      if len(minHeap) == n + 1:
        rightSum -= heapq.heappop(minHeap)
      if len(minHeap) == n:
        ans = min(ans, minLeftSum[i - 1] - rightSum)

    return ans"
"2164","class Solution:
  def sortEvenOdd(self, nums: list[int]) -> list[int]:
    nums[::2] = sorted(nums[::2])
    nums[1::2] = sorted(nums[1::2])[::-1]
    return nums"
"2165","class Solution:
  def smallestNumber(self, num: int) -> int:
    s = sorted(str(abs(num)), reverse=num < 0)
    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)
    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]
    return int(''.join(s)) * (-1 if num < 0 else 1)"
"2166","class Bitset:
  def __init__(self, size: int):
    self.s = ['0'] * size  # the original
    self.r = ['1'] * size  # the reversed
    self.cnt = 0

  def fix(self, idx: int) -> None:
    if self.s[idx] == '0':
      self.cnt += 1
    self.s[idx] = '1'
    self.r[idx] = '0'

  def unfix(self, idx: int) -> None:
    if self.s[idx] == '1':
      self.cnt -= 1
    self.s[idx] = '0'
    self.r[idx] = '1'

  def flip(self) -> None:
    self.s, self.r = self.r, self.s
    self.cnt = len(self.s) - self.cnt

  def all(self) -> bool:
    return self.cnt == len(self.s)

  def one(self) -> bool:
    return self.cnt

  def count(self) -> int:
    return self.cnt

  def toString(self) -> str:
    return ''.join(self.s)"
"2167","class Solution:
  def minimumTime(self, s: str) -> int:
    n = len(s)
    # left[i] := the minimum time to remove the illegal cars of s[0..i]
    left = [0] * n
    left[0] = int(s[0])
    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally
    # + the time to remove the illegal cars of s[i + 1..n) consecutively
    # Note that the way to remove the illegal cars in the right part
    # doesn't need to be optimal since:
    #   `left | illegal cars | n - 1 - k` will be covered in
    #   `left' | n - 1 - i` later.
    dp = [n] * n
    dp[0] = left[0] + n - 1

    for i in range(1, n):
      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)
      dp[i] = min(dp[i], left[i] + n - 1 - i)

    return min(dp)"
"2168","class Solution:
  def equalDigitFrequency(self, s: str) -> int:
    kBase = 11
    kHash = 1_000_000_007
    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]
    count = collections.Counter()
    pows = [1]  # pows[i] := kBase^i % kHash
    # hash[i] = the hash of the first i letters of s, where hash[i] =
    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % kHash
    hash = [0]

    def val(c: str) -> int:
      return int(c) + 1

    for c in s:
      count[c] += 1
      counts.append(count.copy())
      pows.append(pows[-1] * kBase % kHash)
      hash.append((hash[-1] * kBase + val(c)) % kHash)

    def getRollingHash(l: int, r: int) -> int:
      """"""Returns the rolling hash of s[l..r).""""""
      h = (hash[r] - hash[l] * pows[r - l]) % kHash
      return h + kHash if h < 0 else h

    return len({getRollingHash(i, j + 1)
                for i in range(len(s))
                for j in range(i, len(s))
                if self._isSameFreq(counts, i, j)})

  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:
    count = counts[j].copy()
    if i > 0:
      for c, freq in counts[i - 1].items():
        count[c] -= freq
        if count[c] == 0:
          del count[c]
    return min(count.values()) == max(count.values())"
"2169","class Solution:
  def countOperations(self, num1: int, num2: int) -> int:
    ans = 0

    while num1 and num2:
      if num1 < num2:
        num1, num2 = num2, num1
      ans += num1 // num2
      num1 %= num2

    return ans"
"217","class Solution:
  def containsDuplicate(self, nums: list[int]) -> bool:
    return len(nums) != len(set(nums))"
"2170","class T:
  def __init__(self):
    self.count = collections.Counter()
    self.mx = 0
    self.secondMax = 0
    self.maxFreq = 0
    self.secondMaxFreq = 0


class Solution:
  def minimumOperations(self, nums: list[int]) -> int:
    # 0 := odd indices, 1 := even indices
    ts = [T() for _ in range(2)]

    for i, num in enumerate(nums):
      t = ts[i % 2]
      t.count[num] += 1
      freq = t.count[num]
      if freq > t.maxFreq:
        t.maxFreq = freq
        t.mx = num
      elif freq > t.secondMaxFreq:
        t.secondMaxFreq = freq
        t.secondMax = num

    if ts[0].mx == ts[1].mx:
      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,
                             ts[1].maxFreq + ts[0].secondMaxFreq)
    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)"
"2171","class Solution:
  def minimumRemoval(self, beans: list[int]) -> int:
    n = len(beans)
    summ = sum(beans)
    return min(summ - (n - i) * bean
               for i, bean in enumerate(sorted(beans)))"
"2172","class Solution:
  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:
    n = 2 * numSlots
    nSelected = 1 << n
    # dp[i] := the maximum value, where i is the bitmask of the selected
    # numbers
    dp = [0] * nSelected

    nums += [0] * (n - len(nums))

    for mask in range(1, nSelected):
      selected = mask.bit_count()
      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2
      for i, num in enumerate(nums):
        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.
          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))

    return dp[-1]"
"2173","WITH
  MatchesWithRowNumberInEachPlayer AS (
    SELECT
      *,
      ROW_NUMBER() OVER(
        PARTITION BY player_id
        ORDER BY match_day
      ) AS `row_number`
    FROM Matches
  ),
  `Groups` AS (
    SELECT
      *,
      `row_number` - ROW_NUMBER() OVER(
        PARTITION BY player_id
        ORDER BY match_day
      ) AS group_id
    FROM MatchesWithRowNumberInEachPlayer
    WHERE result = 'Win'
  ),
  ConsecCounts AS (
    SELECT
      player_id,
      COUNT(*) AS consec_count
    FROM `Groups`
    GROUP BY player_id, group_id
  )
SELECT
  Matches.player_id,
  IFNULL(MAX(ConsecCounts.consec_count), 0) AS longest_streak
FROM Matches
LEFT JOIN ConsecCounts
  USING (player_id)
GROUP BY 1;"
"2174","class Solution:
  def removeOnes(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    maxMask = 1 << m * n
    # dp[i] := the minimum number of operations to remove all 1s from the grid,
    # where `i` is the bitmask of the state of the grid
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(maxMask):
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 1:
            nextMask = mask
            # Set the cells in the same row with 0.
            for k in range(n):
              nextMask &= ~(1 << i * n + k)
            # Set the cells in the same column with 0.
            for k in range(m):
              nextMask &= ~(1 << k * n + j)
            dp[mask] = min(dp[mask], 1 + dp[nextMask])

    return dp[self.encode(grid, m, n)]

  def encode(self, grid: list[list[int]], m: int, n: int) -> int:
    encoded = 0
    for i in range(m):
      for j in range(n):
        if grid[i][j]:
          encoded |= 1 << i * n + j
    return encoded"
"2175","SELECT
  TeamPoints.team_id,
  TeamPoints.name,
  CAST(
    RANK() OVER(
      ORDER BY TeamPoints.points DESC, TeamPoints.name
    ) AS SIGNED
  ) -
  CAST(
    RANK() OVER(
      ORDER BY TeamPoints.points + PointsChange.points_change DESC,
        TeamPoints.name
    ) AS SIGNED
  ) AS rank_diff
FROM TeamPoints
INNER JOIN PointsChange
  USING (team_id);"
"2176","class Solution:
  def countPairs(self, nums: list[int], k: int) -> int:
    ans = 0
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    for indices in numToIndices.values():
      gcds = collections.Counter()
      for i in indices:
        gcd_i = math.gcd(i, k)
        for gcd_j, count in gcds.items():
          if gcd_i * gcd_j % k == 0:
            ans += count
        gcds[gcd_i] += 1

    return ans"
"2177","class Solution:
  def sumOfThree(self, num: int) -> list[int]:
    if num % 3:
      return []
    x = num // 3
    return [x - 1, x, x + 1]"
"2178","class Solution:
  def maximumEvenSplit(self, finalSum: int) -> list[int]:
    if finalSum % 2 == 1:
      return []

    ans = []
    needSum = finalSum
    even = 2

    while needSum - even >= even + 2:
      ans.append(even)
      needSum -= even
      even += 2

    return ans + [needSum]"
"2179","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:
    n = len(nums1)
    numToIndex = {num: i for i, num in enumerate(nums1)}
    # Remap each number in `nums2` to the according index in `nums1` as `A`.
    # Rephrase the problem as finding the number of increasing tripets in `A`.
    A = [numToIndex[num] for num in nums2]
    # leftSmaller[i] := the number of A[j] < A[i], where 0 <= j < i
    leftSmaller = [0] * n
    # rightLarger[i] := the number of A[j] > A[i], where i < j < n
    rightLarger = [0] * n
    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.
    tree2 = FenwickTree(n)  # Calculates `rightLarger`.

    for i, a in enumerate(A):
      leftSmaller[i] = tree1.get(a)
      tree1.add(a + 1, 1)

    for i, a in reversed(list(enumerate(A))):
      rightLarger[i] = tree2.get(n) - tree2.get(a)
      tree2.add(a + 1, 1)

    return sum(a * b for a, b in zip(leftSmaller, rightLarger))"
"218","class Solution:
  def getSkyline(self, buildings: list[list[int]]) -> list[list[int]]:
    n = len(buildings)
    if n == 0:
      return []
    if n == 1:
      left, right, height = buildings[0]
      return [[left, height], [right, 0]]

    left = self.getSkyline(buildings[:n // 2])
    right = self.getSkyline(buildings[n // 2:])
    return self._merge(left, right)

  def _merge(self, left: list[list[int]],
             right: list[list[int]]) -> list[list[int]]:
    ans = []
    i = 0  # left's index
    j = 0  # right's index
    leftY = 0
    rightY = 0

    while i < len(left) and j < len(right):
      # Choose the powith smaller x
      if left[i][0] < right[j][0]:
        leftY = left[i][1]  # Update the ongoing `leftY`.
        self._addPoint(ans, left[i][0], max(left[i][1], rightY))
        i += 1
      else:
        rightY = right[j][1]  # Update the ongoing `rightY`.
        self._addPoint(ans, right[j][0], max(right[j][1], leftY))
        j += 1

    while i < len(left):
      self._addPoint(ans, left[i][0], left[i][1])
      i += 1

    while j < len(right):
      self._addPoint(ans, right[j][0], right[j][1])
      j += 1

    return ans

  def _addPoint(self, ans: list[list[int]], x: int, y: int) -> None:
    if ans and ans[-1][0] == x:
      ans[-1][1] = y
      return
    if ans and ans[-1][1] == y:
      return
    ans.append([x, y])"
"2180","class Solution:
  def countEven(self, num: int) -> int:
    return (num - self._getDigitSum(num) % 2) // 2

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"2181","class Solution:
  def mergeNodes(self, head: ListNode | None) -> ListNode | None:
    if not head:
      return None
    if not head.next.val:
      node = ListNode(head.val)
      node.next = self.mergeNodes(head.next.next)
      return node

    next = self.mergeNodes(head.next)
    next.val += head.val
    return next"
"2182","class Solution:
  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
    ans = ''
    count = collections.Counter(s)

    while True:
      addOne = ans and self._shouldAddOne(ans, count)
      c = self._getLargestChar(ans, count)
      if c == ' ':
        break
      repeats = 1 if addOne else min(count[c], repeatLimit)
      ans += c * repeats
      count[c] -= repeats

    return ans

  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:
    for c in reversed(string.ascii_lowercase):
      if count[c]:
        return ans[-1] == c
    return False

  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:
    for c in reversed(string.ascii_lowercase):
      if count[c] and (not ans or ans[-1] != c):
        return c
    return ' '"
"2183","class Solution:
  def countPairs(self, nums: list[int], k: int) -> int:
    ans = 0
    gcds = collections.Counter()

    for num in nums:
      gcd_i = math.gcd(num, k)
      for gcd_j, count in gcds.items():
        if gcd_i * gcd_j % k == 0:
          ans += count
      gcds[gcd_i] += 1

    return ans"
"2184","class Solution:
  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:
    kMod = 1_000_000_007
    # Stores the valid rows in bitmask.
    rows = []
    self._buildRows(width, bricks, 0, rows)

    n = len(rows)
    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom
    dp = [1] * n
    # graph[i] := the valid neighbors of rows[i]
    graph = [[] for _ in range(n)]

    for i, a in enumerate(rows):
      for j, b in enumerate(rows):
        if not a & b:
          graph[i].append(j)

    for _ in range(2, height + 1):
      newDp = [0] * n
      for i in range(n):
        for v in graph[i]:
          newDp[i] += dp[v]
          newDp[i] %= kMod
      dp = newDp

    return sum(dp) % kMod

  def _buildRows(
      self,
      width: int,
      bricks: list[int],
      path: int,
      rows: list[int],
  ):
    for brick in bricks:
      if brick == width:
        rows.append(path)
      elif brick < width:
        newWidth = width - brick
        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)"
"2185","class Solution:
  def prefixCount(self, words: list[str], pref: str) -> int:
    return sum(word.startswith(pref) for word in words)"
"2186","class Solution:
  def minSteps(self, s: str, t: str) -> int:
    count = collections.Counter(s)
    count.subtract(collections.Counter(t))
    return sum([abs(c) for c in count.values()])"
"2187","class Solution:
  def minimumTime(self, time: list[int], totalTrips: int) -> int:
    l = 1
    r = min(time) * totalTrips

    while l < r:
      m = (l + r) // 2
      if sum(m // t for t in time) >= totalTrips:
        r = m
      else:
        l = m + 1

    return l"
"2188","class Solution:
  def minimumFinishTime(
      self,
      tires: list[list[int]],
      changeTime: int,
      numLaps: int,
  ) -> int:
    # singleTire[i] := the minimum time to finish i laps without changing tire
    singleTire = [math.inf] * (numLaps + 1)
    # dp[i] := the minimum time to finish i laps
    dp = [math.inf] * (numLaps + 1)

    for i, (f, r) in enumerate(tires):
      sumSecs = 0
      rPower = 1
      for j in range(1, numLaps + 1):
        # the time to use the same tire for the next lap >=
        # the time to change a new tire + f
        if f * rPower >= changeTime + f:
          break
        sumSecs += f * rPower
        rPower *= r
        singleTire[j] = min(singleTire[j], sumSecs)

    dp[0] = 0
    for i in range(1, numLaps + 1):
      for j in range(1, i + 1):
        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])

    return dp[numLaps] - changeTime"
"2189","class Solution:
  def houseOfCards(self, n: int) -> int:
    # dp[i] := the number of valid result for i cards
    dp = [1] + [0] * n

    for baseCards in range(2, n + 1, 3):
      for i in range(n, baseCards - 1, -1):
        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.
        dp[i] += dp[i - baseCards]

    return dp[n]"
"219","class Solution:
  def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:
    seen = set()

    for i, num in enumerate(nums):
      if i > k:
        seen.remove(nums[i - k - 1])
      if num in seen:
        return True
      seen.add(num)

    return False"
"2190","class Solution:
  def mostFrequent(self, nums: list[int], key: int) -> int:
    count = collections.Counter()

    for a, b in itertools.pairwise(nums):
      if a == key:
        count[b] += 1

    return max(count, key=lambda num: count[num])"
"2191","class Solution:
  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:
    def getMapped(num: int) -> int:
      mapped = []
      for c in str(num):
        mapped.append(str(mapping[int(c)]))
      return int(''.join(mapped))
    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]
    return [num for _, i, num in sorted(A)]"
"2192","class Solution:
  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:
    ans = [set() for _ in range(n)]
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n

    # Build the graph.
    for u, v in edges:
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      for _ in range(len(q)):
        u = q.popleft()
        for v in graph[u]:
          ans[v].add(u)
          ans[v].update(ans[u])
          inDegrees[v] -= 1
          if inDegrees[v] == 0:
            q.append(v)

    return [sorted(nodes) for nodes in ans]"
"2193","class Solution:
  def minMovesToMakePalindrome(self, s: str) -> int:
    ans = 0
    chars = list(s)

    while len(chars) > 1:
      # Greedily match the last digit.
      i = chars.index(chars[-1])
      if i == len(chars) - 1:
        # s[i] is the middle letter.
        ans += i // 2
      else:
        chars.pop(i)
        ans += i  # Swap the matched letter to the left.
      chars.pop()

    return ans"
"2194","class Solution:
  def cellsInRange(self, s: str) -> list[str]:
    ans = []
    startCol, startRow, _, endCol, endRow = s

    for j in range(ord(startCol), ord(endCol) + 1):
      for i in range(int(startRow), int(endRow) + 1):
        ans.append(chr(j) + str(i))

    return ans"
"2195","class Solution:
  def minimalKSum(self, nums: list[int], k: int) -> int:
    ans = 0
    nums.append(0)
    nums.sort()

    for a, b in zip(nums, nums[1:]):
      if a == b:
        continue
      l = a + 1
      r = min(a + k, b - 1)
      ans += (l + r) * (r - l + 1) // 2
      k -= r - l + 1
      if k == 0:
        return ans

    if k > 0:
      l = nums[-1] + 1
      r = nums[-1] + k
      ans += (l + r) * (r - l + 1) // 2

    return ans"
"2196","class Solution:
  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:
    children = set()
    valToNode = {}

    for p, c, isLeft in descriptions:
      parent = valToNode.setdefault(p, TreeNode(p))
      child = valToNode.setdefault(c, TreeNode(c))
      if isLeft:
        parent.left = child
      else:
        parent.right = child
      children.add(c)

    root = (set(valToNode) - set(children)).pop()
    return valToNode[root]"
"2197","class Solution:
  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:
    ans = []

    for num in nums:
      while ans and math.gcd(ans[-1], num) > 1:
        num = math.lcm(ans.pop(), num)
      ans.append(num)

    return ans"
"2198","class Solution:
  def singleDivisorTriplet(self, nums: list[int]) -> int:
    ans = 0
    count = collections.Counter(nums)

    def divisible(summ: int, num: int) -> int:
      return summ % num == 0

    for a in range(1, 101):
      if count[a] == 0:
        continue
      for b in range(a, 101):
        if count[b] == 0:
          continue
        for c in range(b, 101):
          if count[c] == 0:
            continue
          summ = a + b + c
          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:
            continue
          if a == b:
            ans += count[a] * (count[a] - 1) // 2 * count[c]
          elif b == c:
            ans += count[b] * (count[b] - 1) // 2 * count[a]
          else:
            ans += count[a] * count[b] * count[c]

    return ans * 6"
"2199","SELECT
  Posts.post_id,
  IFNULL(
    GROUP_CONCAT(
      DISTINCT Keywords.topic_id
      ORDER BY Keywords.topic_id
    ),
    'Ambiguous!'
  ) AS topic
FROM Posts
LEFT JOIN Keywords
  ON (CONCAT(' ', LOWER(Posts.content), ' ') LIKE CONCAT('% ', LOWER(Keywords.word), ' %'))
GROUP BY 1;"
"22","class Solution:
  def generateParenthesis(self, n):
    ans = []

    def dfs(l: int, r: int, s: list[str]) -> None:
      if l == 0 and r == 0:
        ans.append(''.join(s))
      if l > 0:
        s.append('(')
        dfs(l - 1, r, s)
        s.pop()
      if l < r:
        s.append(')')
        dfs(l, r - 1, s)
        s.pop()

    dfs(n, n, [])
    return ans"
"220","class Solution:
  def containsNearbyAlmostDuplicate(
      self,
      nums: list[int],
      indexDiff: int,
      valueDiff: int,
  ) -> bool:
    if not nums or indexDiff <= 0 or valueDiff < 0:
      return False

    mn = min(nums)
    diff = valueDiff + 1  # In case that `valueDiff` equals 0.
    bucket = {}

    def getKey(num: int) -> int:
      return (num - mn) // diff

    for i, num in enumerate(nums):
      key = getKey(num)
      if key in bucket:  # the current bucket
        return True
      # the left adjacent bucket
      if key - 1 in bucket and num - bucket[key - 1] < diff:
        return True
      # the right adjacent bucket
      if key + 1 in bucket and bucket[key + 1] - num < diff:
        return True
      bucket[key] = num
      if i >= indexDiff:
        del bucket[getKey(nums[i - indexDiff])]

    return False"
"2200","class Solution:
  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:
    n = len(nums)
    ans = []

    j = 0
    for i in range(n):
      # the first index j s.t. nums[j] == key and j >= i - k
      while j < n and (nums[j] != key or j < i - k):
        j += 1
      if j == n:
        break
      if abs(i - j) <= k:
        ans.append(i)

    return ans"
"2201","class Solution:
  def digArtifacts(
      self,
      n: int,
      artifacts: list[list[int]],
      dig: list[list[int]],
  ) -> int:
    digged = set((r, c) for r, c in dig)

    def canExtract(a: list[int]) -> bool:
      for i in range(a[0], a[2] + 1):
        for j in range(a[1], a[3] + 1):
          if (i, j) not in digged:
            return False
      return True

    return sum(canExtract(a) for a in artifacts)"
"2202","class Solution:
  def maximumTop(self, nums: list[int], k: int) -> int:
    n = len(nums)
    # After taking k elements, if we're left something, then we return nums[k]
    # Otherwise, return -1.
    if k == 0 or k == 1:
      return -1 if n == k else nums[k]
    # Remove then add even number of times.
    if n == 1:
      return -1 if k & 1 else nums[0]
    # Take min(n, k - 1) elements and put the largest one back.
    mx = max(nums[:min(n, k - 1)])
    if k >= n:
      return mx
    return max(mx, nums[k])"
"2203","class Solution:
  def minimumWeight(
      self,
      n: int,
      edges: list[list[int]],
      src1: int,
      src2: int,
      dest: int,
  ) -> int:
    graph = [[] for _ in range(n)]
    reversedGraph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      reversedGraph[v].append((u, w))

    fromSrc1 = self._dijkstra(graph, src1)
    fromSrc2 = self._dijkstra(graph, src2)
    fromDest = self._dijkstra(reversedGraph, dest)
    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))
    return -1 if minWeight == math.inf else minWeight

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
  ) -> list[int]:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist"
"2204","class Solution:
  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:
    ans = [0] * n
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    NO_RANK = -2

    # The minRank that u can reach with forward edges
    def getRank(u: int, currRank: int, rank: list[int]) -> int:
      if rank[u] != NO_RANK:  # The rank is already determined
        return rank[u]

      rank[u] = currRank
      minRank = currRank

      for v in graph[u]:
        # Visited or parent (that's why NO_RANK = -2 instead of -1)
        if rank[v] == len(rank) or rank[v] == currRank - 1:
          continue
        nextRank = getRank(v, currRank + 1, rank)
        # NextRank should > currRank if there's no cycle
        if nextRank <= currRank:
          cycle.append(v)
        minRank = min(minRank, nextRank)

      rank[u] = len(rank)  # Mark as visited.
      return minRank

    # rank[i] := the minimum node that node i can reach with forward edges
    # Initialize with NO_RANK = -2 to indicate not visited.
    cycle = []
    getRank(0, 0, [NO_RANK] * n)

    q = collections.deque(cycle)
    seen = set(cycle)

    step = 1
    while q:
      for _ in range(len(q)):
        u = q.popleft()
        for v in graph[u]:
          if v in seen:
            continue
          q.append(v)
          seen.add(v)
          ans[v] = step
      step += 1

    return ans"
"2205","CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT
BEGIN
  RETURN (
    SELECT COUNT(DISTINCT user_id) AS user_cnt
    FROM Purchases
    WHERE
      time_stamp BETWEEN startDate AND endDate
      AND amount >= minAmount
  );
END"
"2206","class Solution:
  def divideArray(self, nums: list[int]) -> bool:
    return all(value % 2 == 0 for value in collections.Counter(nums).values())"
"2207","class Solution:
  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
    ans = 0
    count0 = 0  # the count of the letter pattern[0]
    count1 = 0  # the count of the letter pattern[1]

    for c in text:
      if c == pattern[1]:
        ans += count0
        count1 += 1
      if c == pattern[0]:
        count0 += 1

    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the
    # end of the text.
    return ans + max(count0, count1)"
"2208","class Solution:
  def halveArray(self, nums: list[int]) -> int:
    halfSum = sum(nums) / 2
    ans = 0
    runningSum = 0.0
    maxHeap = [-num for num in nums]

    heapq.heapify(maxHeap)

    while runningSum < halfSum:
      maxValue = -heapq.heappop(maxHeap) / 2
      runningSum += maxValue
      heapq.heappush(maxHeap, -maxValue)
      ans += 1

    return ans"
"2209","class Solution:
  def minimumWhiteTiles(
      self,
      floor: str,
      numCarpets: int,
      carpetLen: int,
  ) -> int:
    n = len(floor)
    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)
    # after covering at most j carpets
    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]

    for i in reversed(range(n)):
      dp[i][0] = int(floor[i]) + dp[i + 1][0]

    for i in reversed(range(n)):
      for j in range(1, numCarpets + 1):
        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0
        skip = int(floor[i]) + dp[i + 1][j]
        dp[i][j] = min(cover, skip)

    return dp[0][numCarpets]"
"221","class Solution:
  def maximalSquare(self, matrix: list[list[str]]) -> int:
    m = len(matrix)
    n = len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    maxLength = 0

    for i in range(m):
      for j in range(n):
        if i == 0 or j == 0 or matrix[i][j] == '0':
          dp[i][j] = 1 if matrix[i][j] == '1' else 0
        else:
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1]
                         [j], dp[i][j - 1]) + 1
        maxLength = max(maxLength, dp[i][j])

    return maxLength * maxLength"
"2210","class Solution:
  def countHillValley(self, nums: list[int]) -> int:
    ans = 0
    left = nums[0]

    for i in range(1, len(nums) - 1):
      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill
              left > nums[i] and nums[i] < nums[i + 1]):  # the valley
        ans += 1
        left = nums[i]

    return ans"
"2211","class Solution:
  def countCollisions(self, directions: str) -> int:
    l = 0
    r = len(directions) - 1

    while l < len(directions) and directions[l] == 'L':
      l += 1

    while r >= 0 and directions[r] == 'R':
      r -= 1

    return sum(c != 'S' for c in directions[l:r + 1])"
"2212","class Solution:
  def maximumBobPoints(
      self,
      numArrows: int,
      aliceArrows: list[int],
  ) -> list[int]:
    allMask = (1 << 12) - 1
    maxPoint = 0
    maxMask = 0

    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:
      point = 0
      for i in range(12):
        if mask >> i & 1:
          leftArrows -= aliceArrows[i] + 1
          point += i
      return leftArrows >= 0, point

    for mask in range(allMask):
      shotable, point = getShotableAndPoint(mask, numArrows)
      if shotable and point > maxPoint:
        maxPoint = point
        maxMask = mask

    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:
      bobsArrows = [0] * 12
      for i in range(12):
        if mask >> i & 1:
          bobsArrows[i] = aliceArrows[i] + 1
          leftArrows -= aliceArrows[i] + 1
      bobsArrows[0] = leftArrows
      return bobsArrows

    return getBobsArrows(maxMask, numArrows)"
"2213","struct SegmentTreeNode {
  int lo;
  int hi;
  char maxLetter;
  char prefixLetter;
  char suffixLetter;
  int maxLength;
  int prefixLength;
  int suffixLength;
  SegmentTreeNode* left;
  SegmentTreeNode* right;
  SegmentTreeNode(int lo, int hi, char maxLetter, char prefixLetter,
                  char suffixLetter, int maxLength, int prefixLength,
                  int suffixLength, SegmentTreeNode* left = nullptr,
                  SegmentTreeNode* right = nullptr)
      : lo(lo),
        hi(hi),
        maxLetter(maxLetter),
        prefixLetter(prefixLetter),
        suffixLetter(suffixLetter),
        maxLength(maxLength),
        prefixLength(prefixLength),
        suffixLength(suffixLength),
        left(left),
        right(right) {}
  ~SegmentTreeNode() {
    delete left;
    delete right;
    left = nullptr;
    right = nullptr;
  }
};

class SegmentTree {
 public:
  explicit SegmentTree(const string& s) : root(build(s, 0, s.length() - 1)) {}
  ~SegmentTree() {
    delete root;
  }

  void update(int i, char val) {
    root = update(root, i, val);
  }

  int getMaxLength() {
    return root->maxLength;
  }

 private:
  SegmentTreeNode* root;

  SegmentTreeNode* build(const string& s, int lo, int hi) const {
    if (lo == hi)
      return new SegmentTreeNode(lo, hi, s[lo], s[lo], s[lo], 1, 1, 1);
    const int mid = (lo + hi) / 2;
    SegmentTreeNode* left = build(s, lo, mid);
    SegmentTreeNode* right = build(s, mid + 1, hi);
    return merge(left, right);
  }

  SegmentTreeNode* update(SegmentTreeNode* root, int i, char c) {
    if (root->lo == i && root->hi == i) {
      root->maxLetter = c;
      root->prefixLetter = c;
      root->suffixLetter = c;
      return root;
    }
    const int mid = (root->lo + root->hi) / 2;
    if (i <= mid) {
      SegmentTreeNode* updatedLeft = update(root->left, i, c);
      return root = merge(updatedLeft, root->right);
    } else {
      SegmentTreeNode* updatedRight = update(root->right, i, c);
      return root = merge(root->left, updatedRight);
    }
  }

  SegmentTreeNode* merge(SegmentTreeNode* left, SegmentTreeNode* right) const {
    // Get `maxLetter` and `maxLength`.
    char maxLetter = ' ';
    int maxLength = 0;
    if (left->maxLength > right->maxLength) {
      maxLetter = left->maxLetter;
      maxLength = left->maxLength;
    } else {
      maxLetter = right->maxLetter;
      maxLength = right->maxLength;
    }
    if (left->suffixLetter == right->prefixLetter &&
        left->suffixLength + right->prefixLength > maxLength) {
      maxLetter = left->suffixLetter;
      maxLength = left->suffixLength + right->prefixLength;
    }

    // Get `prefixLetter` and `prefixLength`.
    char prefixLetter = left->prefixLetter;
    int prefixLength = left->prefixLength;
    if (left->lo + prefixLength == right->lo &&
        left->prefixLetter == right->prefixLetter)
      prefixLength += right->prefixLength;

    // Get `suffixLetter` and `suffixLength`.
    char suffixLetter = right->suffixLetter;
    int suffixLength = right->suffixLength;
    if (right->hi - suffixLength == left->hi &&
        right->suffixLetter == left->suffixLetter)
      suffixLength += left->suffixLength;
    return new SegmentTreeNode(left->lo, right->hi, maxLetter, prefixLetter,
                               suffixLetter, maxLength, prefixLength,
                               suffixLength, left, right);
  }
};

class Solution {
 public:
  vector<int> longestRepeating(string s, string queryLetteracters,
                               vector<int>& queryIndices) {
    vector<int> ans;
    SegmentTree tree(s);

    for (int i = 0; i < queryIndices.size(); ++i) {
      tree.update(queryIndices[i], queryLetteracters[i]);
      ans.push_back(tree.getMaxLength());
    }

    return ans;
  }
};"
"2214","class Solution:
  def minimumHealth(self, damage: list[int], armor: int) -> int:
    return 1 + sum(damage) - min(max(damage), armor)"
"2215","class Solution:
  def findDifference(self, nums1: list[int],
                     nums2: list[int]) -> list[list[int]]:
    set1 = set(nums1)
    set2 = set(nums2)
    return [set1 - set2, set2 - set1]"
"2216","class Solution:
  def minDeletion(self, nums: list[int]) -> int:
    ans = 0

    for i in range(len(nums) - 1):
      # i - ans := the index after deletion
      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:
        ans += 1

    # Add one if the length after deletion is odd
    return ans + ((len(nums) - ans) & 1)"
"2217","class Solution:
  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:
    start = pow(10, (intLength + 1) // 2 - 1)
    end = pow(10, (intLength + 1) // 2)
    mul = pow(10, intLength // 2)

    def reverse(num: int) -> int:
      res = 0
      while num:
        res = res * 10 + num % 10
        num //= 10
      return res

    def getKthPalindrome(query: int) -> int:
      prefix = start + query - 1
      return prefix * mul + reverse(prefix
                                    if intLength % 2 == 0 else prefix // 10)

    return [-1 if start + query > end else getKthPalindrome(query)
            for query in queries]"
"2218","class Solution:
  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""Returns the maximum value of picking k coins from piles[i..n).""""""
      if i == len(piles) or k == 0:
        return 0

      # Pick no coins from the current pile.
      res = dp(i + 1, k)
      val = 0  # the coins picked from the current pile

      # Try to pick 1, 2, ..., k coins from the current pile.
      for j in range(min(len(piles[i]), k)):
        val += piles[i][j]
        res = max(res, val + dp(i + 1, k - j - 1))

      return res

    return dp(0, k)"
"2219","class Solution:
  def maximumSumScore(self, nums: list[int]) -> int:
    ans = -math.inf
    prefix = 0
    summ = sum(nums)

    for num in nums:
      prefix += num
      ans = max(ans, prefix, summ - prefix + num)

    return ans"
"222","class Solution:
  def countNodes(self, root: TreeNode | None) -> int:
    if not root:
      return 0

    left = root
    right = root
    heightL = 0
    heightR = 0

    while left:
      heightL += 1
      left = left.left

    while right:
      heightR += 1
      right = right.right

    if heightL == heightR:  # `root` is a complete tree.
      return pow(2, heightL) - 1
    return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
"2220","class Solution:
  def minBitFlips(self, start: int, goal: int) -> int:
    return (start ^ goal).bit_count()"
"2221","class Solution:
  def triangularSum(self, nums: list[int]) -> int:
    for sz in range(len(nums), 0, -1):
      for i in range(sz - 1):
        nums[i] = (nums[i] + nums[i + 1]) % 10
    return nums[0]"
"2222","class Solution:
  def numberOfWays(self, s: str) -> int:
    ans = 0
    # before[i] := the number of i before the current digit
    before = [0] * 2
    # after[i] := the number of i after the current digit
    after = [0] * 2
    after[0] = s.count('0')
    after[1] = len(s) - after[0]

    for c in s:
      num = int(c)
      after[num] -= 1
      if num == 0:
        ans += before[1] * after[1]
      else:
        ans += before[0] * after[0]
      before[num] += 1

    return ans"
"2223","class Solution:
  def sumScores(self, s: str) -> int:
    n = len(s)
    # https://cp-algorithms.com/string/z-function.html#implementation
    z = [0] * n
    # [l, r] := the indices of the rightmost segment match
    l = 0
    r = 0

    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]

    return sum(z) + n"
"2224","class Solution:
  def convertTime(self, current: str, correct: str) -> int:
    ops = [60, 15, 5, 1]

    def getMinutes(s: str) -> int:
      return int(s[:2]) * 60 + int(s[3:])

    diff = getMinutes(correct) - getMinutes(current)
    ans = 0

    for op in ops:
      ans += diff // op
      diff %= op

    return ans"
"2225","class Solution:
  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:
    ans = [[] for _ in range(2)]
    lossesCount = collections.Counter()

    for winner, loser in matches:
      if winner not in lossesCount:
        lossesCount[winner] = 0
      lossesCount[loser] += 1

    for player, nLosses in lossesCount.items():
      if nLosses < 2:
        ans[nLosses].append(player)

    return [sorted(ans[0]), sorted(ans[1])]"
"2226","class Solution:
  def maximumCandies(self, candies: list[int], k: int) -> int:
    l = 1
    r = sum(candies) // k

    def numChildren(m: int) -> bool:
      return sum(c // m for c in candies)

    while l < r:
      m = (l + r) // 2
      if numChildren(m) < k:
        r = m
      else:
        l = m + 1

    return l if numChildren(l) >= k else l - 1"
"2227","class Encrypter:
  def __init__(self, keys: list[str], values: list[str], dictionary: list[str]):
    self.keyToValue = {k: v for k, v in zip(keys, values)}
    self.decrypt = collections.Counter(self.encrypt(word)
                                       for word in dictionary).__getitem__

  def encrypt(self, word1: str) -> str:
    return ''.join(self.keyToValue[c] for c in word1)"
"2228","SELECT DISTINCT First.user_id
FROM Purchases AS First
INNER JOIN purchases AS Second
  USING (user_id)
WHERE
  First.purchase_id != Second.purchase_id
  AND First.purchase_date <= Second.purchase_date
  AND DATEDIFF(Second.purchase_date, First.purchase_date) <= 7
ORDER BY 1;"
"2229","class Solution:
  def isConsecutive(self, nums: list[int]) -> bool:
    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)"
"223","class Solution:
  def computeArea(self,
                  A: int, B: int, C: int, D: int,
                  E: int, F: int, G: int, H: int) -> int:
    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0
    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0
    return (C - A) * (D - B) + (G - E) * (H - F) - x * y"
"2230","CREATE PROCEDURE getUserIDs(startDate DATE, endDate DATE, minAmount INT)
BEGIN
  SELECT DISTINCT user_id
  FROM Purchases
  WHERE
    time_stamp BETWEEN startDate AND endDate
    AND amount >= minAmount
  ORDER BY 1;
END"
"2231","class Solution:
  def largestInteger(self, num: int) -> int:
    s = str(num)
    ans = 0
    # maxHeap[0] := the odd digits
    # maxHeap[1] := the even digits
    maxHeap = [[] for _ in range(2)]

    for c in s:
      digit = int(c)
      heapq.heappush(maxHeap[digit % 2], -digit)

    for c in s:
      i = int(c) & 1
      ans = (ans * 10 - heapq.heappop(maxHeap[i]))

    return ans"
"2232","class Solution:
  def minimizeResult(self, expression: str) -> str:
    plusIndex = expression.index('+')
    left = expression[:plusIndex]
    right = expression[plusIndex + 1:]
    ans = ''
    mn = math.inf

    # the expression -> a * (b + c) * d
    for i in range(len(left)):
      for j in range(len(right)):
        a = 1 if i == 0 else int(left[:i])
        b = int(left[i:])
        c = int(right[0:j + 1])
        d = 1 if j == len(right) - 1 else int(right[j + 1:])
        val = a * (b + c) * d
        if val < mn:
          mn = val
          ans = (('' if i == 0 else str(a)) +
                 '(' + str(b) + '+' + str(c) + ')' +
                 ('' if j == len(right) - 1 else str(d)))

    return ans"
"2233","class Solution:
  def maximumProduct(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    ans = 1
    minHeap = nums.copy()
    heapq.heapify(minHeap)

    for _ in range(k):
      minNum = heapq.heappop(minHeap)
      heapq.heappush(minHeap, minNum + 1)

    while minHeap:
      ans *= heapq.heappop(minHeap)
      ans %= kMod

    return ans"
"2234","class Solution:
  def maximumBeauty(
      self,
      flowers: list[int],
      newFlowers: int,
      target: int,
      full: int,
      partial: int,
  ) -> int:
    n = len(flowers)

    # If a garden is already complete, clamp it to the target.
    flowers = [min(flower, target) for flower in flowers]
    flowers.sort()

    # All gardens are complete, so nothing we can do.
    if flowers[0] == target:
      return n * full

    # Having many new flowers maximizes the beauty value.
    if newFlowers >= n * target - sum(flowers):
      return max(n * full, (n - 1) * full + (target - 1) * partial)

    ans = 0
    leftFlowers = newFlowers
    # cost[i] := the cost to make flowers[0..i] the same
    cost = [0] * n

    for i in range(1, n):
      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].
      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])

    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)
    while flowers[i] == target:
      i -= 1

    while leftFlowers >= 0:
      # To maximize the minimum number of incomplete flowers, we find the first
      # index j that we can't make flowers[0..j] equal to flowers[j], then we
      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the
      # meantime, evenly increase each of them to seek a bigger minimum value.
      j = min(i + 1, bisect_right(cost, leftFlowers))
      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j
      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)
      leftFlowers -= max(0, target - flowers[i])
      i -= 1

    return ans"
"2235","class Solution:
  sum = operator.add"
"2236","class Solution:
  def checkTree(self, root: TreeNode | None) -> bool:
    return root.val == root.left.val + root.right.val"
"2237","class Solution:
  def meetRequirement(
      self,
      n: int,
      lights: list[list[int]],
      requirement: list[int],
  ) -> int:
    ans = 0
    currBrightness = 0
    change = [0] * (n + 1)

    for position, rg in lights:
      change[max(0, position - rg)] += 1
      change[min(n, position + rg + 1)] -= 1

    for i in range(n):
      currBrightness += change[i]
      if currBrightness >= requirement[i]:
        ans += 1

    return ans"
"2238","WITH
  DriverIds AS (
    SELECT DISTINCT driver_id FROM Rides
  )
SELECT
  DriverIds.driver_id,
  COUNT(Rides.passenger_id) AS cnt
FROM DriverIds
LEFT JOIN Rides
  ON (DriverIds.driver_id = Rides.passenger_id)
GROUP BY 1;"
"2239","class Solution:
  def findClosestNumber(self, nums: list[int]) -> int:
    nums.sort(key=lambda x: (abs(x), -x))
    return nums[0]"
"224","class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    num = 0
    sign = 1
    stack = [sign]  # stack[-1]: the current environment's sign

    for c in s:
      if c.isdigit():
        num = num * 10 + int(c)
      elif c == '(':
        stack.append(sign)
      elif c == ')':
        stack.pop()
      elif c == '+' or c == '-':
        ans += sign * num
        sign = (1 if c == '+' else -1) * stack[-1]
        num = 0

    return ans + sign * num"
"2240","class Solution:
  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
    maxPen = total // cost1
    return sum((total - i * cost1) // cost2
               for i in range(maxPen + 1)) + maxPen + 1"
"2241","class ATM:
  def __init__(self):
    self.banknotes = [20, 50, 100, 200, 500]
    self.bank = [0] * 5

  def deposit(self, banknotesCount: list[int]) -> None:
    for i in range(5):
      self.bank[i] += banknotesCount[i]

  def withdraw(self, amount: int) -> list[int]:
    withdrew = [0] * 5

    for i in reversed(range(5)):
      withdrew[i] = min(self.bank[i], amount // self.banknotes[i])
      amount -= withdrew[i] * self.banknotes[i]

    if amount:
      return [-1]

    for i in range(5):
      self.bank[i] -= withdrew[i]
    return withdrew"
"2242","class Solution:
  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:
    n = len(scores)
    ans = -1
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((scores[v], v))
      graph[v].append((scores[u], u))

    for i in range(n):
      graph[i] = heapq.nlargest(3, graph[i])

    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),
    # and find a (u's child) and b (v's child). That's why we find the 3
    # children that have the highest scores because one of the 3 children is
    # guaranteed to be valid.
    for u, v in edges:
      for scoreA, a in graph[u]:
        for scoreB, b in graph[v]:
          if a != b and a != v and b != u:
            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)

    return ans"
"2243","class Solution:
  def digitSum(self, s: str, k: int) -> str:
    while len(s) > k:
      next = []
      for i in range(0, len(s), k):
        summ = 0
        for j in range(i, min(len(s), i + k)):
          summ += int(s[j])
        next.append(str(summ))
      s = ''.join(next)
    return s"
"2244","class Solution:
  def minimumRounds(self, tasks: list[int]) -> int:
    freqs = collections.Counter(tasks).values()
    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)"
"2245","class Solution:
  def maxTrailingZeros(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]
    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]
    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]
    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]
    leftPrefix2 = [[0] * n for _ in range(m)]
    leftPrefix5 = [[0] * n for _ in range(m)]
    topPrefix2 = [[0] * n for _ in range(m)]
    topPrefix5 = [[0] * n for _ in range(m)]

    def getCount(num: int, factor: int) -> int:
      count = 0
      while num % factor == 0:
        num //= factor
        count += 1
      return count

    for i in range(m):
      for j in range(n):
        leftPrefix2[i][j] = getCount(grid[i][j], 2)
        leftPrefix5[i][j] = getCount(grid[i][j], 5)
        if j:
          leftPrefix2[i][j] += leftPrefix2[i][j - 1]
          leftPrefix5[i][j] += leftPrefix5[i][j - 1]

    for j in range(n):
      for i in range(m):
        topPrefix2[i][j] = getCount(grid[i][j], 2)
        topPrefix5[i][j] = getCount(grid[i][j], 5)
        if i:
          topPrefix2[i][j] += topPrefix2[i - 1][j]
          topPrefix5[i][j] += topPrefix5[i - 1][j]

    ans = 0
    for i in range(m):
      for j in range(n):
        curr2 = getCount(grid[i][j], 2)
        curr5 = getCount(grid[i][j], 5)
        l2 = leftPrefix2[i][j]
        l5 = leftPrefix5[i][j]
        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])
        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])
        t2 = topPrefix2[i][j]
        t5 = topPrefix5[i][j]
        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])
        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])
        ans = max(ans,
                  min(l2 + t2 - curr2, l5 + t5 - curr5),
                  min(r2 + t2 - curr2, r5 + t5 - curr5),
                  min(l2 + d2 - curr2, l5 + d5 - curr5),
                  min(r2 + d2 - curr2, r5 + d5 - curr5))

    return ans"
"2246","class Solution:
  def longestPath(self, parent: list[int], s: str) -> int:
    n = len(parent)
    ans = 0
    graph = [[] for _ in range(n)]

    for i in range(1, n):
      graph[parent[i]].append(i)

    def longestPathDownFrom(u: int) -> int:
      nonlocal ans
      max1 = 0
      max2 = 0

      for v in graph[u]:
        res = longestPathDownFrom(v)
        if s[u] == s[v]:
          continue
        if res > max1:
          max2 = max1
          max1 = res
        elif res > max2:
          max2 = res

      ans = max(ans, 1 + max1 + max2)
      return 1 + max1

    longestPathDownFrom(0)
    return ans"
"2247","class Solution:
  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:
    if k + 1 > n:
      return -1

    graph = [[] for _ in range(n)]

    for u, v, w in highways:
      graph[u].append((v, w))
      graph[v].append((u, w))

    @functools.lru_cache(None)
    def dp(u: int, mask: int) -> int:
      """"""
      Returns the maximum cost of trip starting from u, where `mask` is the
      bitmask of the visited cities.
      """"""
      if mask.bit_count() == k + 1:
        return 0

      res = -1
      for v, w in graph[u]:
        if mask >> v & 1:
          continue
        nextCost = dp(v, mask | 1 << v)
        if nextCost != -1:
          res = max(res, w + nextCost)
      return res

    return max(dp(i, 1 << i) for i in range(n))"
"2248","class Solution:
  def intersection(self, nums: list[list[int]]) -> list[int]:
    count = [0] * 1001

    for A in nums:
      for a in A:
        count[a] += 1

    return [i for i, c in enumerate(count)
            if c == len(nums)]"
"2249","class Solution:
  def countLatticePoints(self, circles: list[list[int]]) -> int:
    return sum(any((xc - x)**2 + (yc - y)**2 <= r**2 for xc, yc, r in circles)
               for x in range(201)
               for y in range(201))"
"225","class MyStack:
  def __init__(self):
    self.q = collections.deque()

  def push(self, x: int) -> None:
    self.q.append(x)
    for _ in range(len(self.q) - 1):
      self.q.append(self.q.popleft())

  def pop(self) -> int:
    return self.q.popleft()

  def top(self) -> int:
    return self.q[0]

  def empty(self) -> bool:
    return not self.q"
"2250","class Solution:
  def countRectangles(
      self,
      rectangles: list[list[int]],
      points: list[list[int]],
  ) -> list[int]:
    ans = []
    yToXs = [[] for _ in range(101)]

    for l, h in rectangles:
      yToXs[h].append(l)

    for xs in yToXs:
      xs.sort()

    for xi, yi in points:
      count = 0
      for y in range(yi, 101):
        xs = yToXs[y]
        count += len(xs) - bisect.bisect_left(xs, xi)
      ans.append(count)

    return ans"
"2251","class Solution:
  def fullBloomFlowers(
      self,
      flowers: list[list[int]],
      persons: list[int],
  ) -> list[int]:
    starts = sorted(s for s, _ in flowers)
    ends = sorted(e for _, e in flowers)
    return [bisect.bisect_right(starts, person) -
            bisect.bisect_left(ends, person)
            for person in persons]"
"2252","CREATE PROCEDURE PivotProducts()
BEGIN
  # Override GROUP_CONCAT length which has a default limit of 1024.
  SET SESSION group_concat_max_len = 1000000;

  SELECT GROUP_CONCAT(
      DISTINCT CONCAT(
        'SUM(IF(store = ""',
        store,
        '"", price, NULL)) AS ',
        store
      )
    ) INTO @stmt
  FROM products;

  SET @query = CONCAT(
    'SELECT product_id, ', @stmt, ' '
    'FROM Products '
    'GROUP BY 1');

  PREPARE final_query FROM @query;
  EXECUTE final_query;
  DEALLOCATE PREPARE final_query;
END"
"2253","CREATE PROCEDURE UnpivotProducts()
BEGIN
  # Override GROUP_CONCAT length which has a default limit of 1024.
  SET SESSION group_concat_max_len = 1000000;

  SELECT GROUP_CONCAT(
      CONCAT(
        'SELECT product_id, ""',
        `column_name`, '"" AS store, ',
        `column_name`, ' AS price ',
        'FROM products ',
        'WHERE ',
        `column_name`, ' IS NOT NULL'
      ) SEPARATOR ' UNION '
    ) INTO @stmt
  FROM `information_schema`.`columns`
  WHERE
    `table_schema` = 'test'
    AND `table_name` = 'Products'
    AND `column_name` != 'product_id';

  PREPARE final_query FROM @stmt;
  EXECUTE final_query;
  DEALLOCATE PREPARE final_query;
END"
"2254","class VideoSharingPlatform:
  def __init__(self):
    self.currVideoId = 0
    self.usedIds = []
    self.videoIdToVideo = {}
    self.videoIdToViews = collections.Counter()
    self.videoIdToLikes = collections.Counter()
    self.videoIdToDislikes = collections.Counter()

  def upload(self, video: str) -> int:
    videoId = self._getVideoId()
    self.videoIdToVideo[videoId] = video
    return videoId

  def remove(self, videoId: int) -> None:
    if videoId in self.videoIdToVideo:
      heapq.heappush(self.usedIds, videoId)
      del self.videoIdToVideo[videoId]
      del self.videoIdToViews[videoId]
      del self.videoIdToLikes[videoId]
      del self.videoIdToDislikes[videoId]

  def watch(self, videoId: int, startMinute: int, endMinute: int) -> str:
    if videoId not in self.videoIdToVideo:
      return '-1'
    self.videoIdToViews[videoId] += 1
    video = self.videoIdToVideo[videoId]
    return video[startMinute:min(endMinute + 1, len(video))]

  def like(self, videoId: int) -> None:
    if videoId in self.videoIdToVideo:
      self.videoIdToLikes[videoId] += 1

  def dislike(self, videoId: int) -> None:
    if videoId in self.videoIdToVideo:
      self.videoIdToDislikes[videoId] += 1

  def getLikesAndDislikes(self, videoId: int) -> list[int]:
    if videoId in self.videoIdToVideo:
      return [self.videoIdToLikes[videoId], self.videoIdToDislikes[videoId]]
    return [-1]

  def getViews(self, videoId: int) -> int:
    if videoId in self.videoIdToVideo:
      return self.videoIdToViews[videoId]
    return -1

  def _getVideoId(self) -> int:
    if not self.usedIds:
      self.currVideoId += 1
      return self.currVideoId - 1
    return heapq.heappop(self.usedIds)"
"2255","class Solution:
  def countPrefixes(self, words: list[str], s: str) -> int:
    return sum(map(s.startswith, words))"
"2256","class Solution:
  def minimumAverageDifference(self, nums: list[int]) -> int:
    n = len(nums)
    ans = 0
    minDiff = inf
    prefix = 0
    suffix = sum(nums)

    for i, num in enumerate(nums):
      prefix += num
      suffix -= num
      prefixAvg = prefix // (i + 1)
      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)
      diff = abs(prefixAvg - suffixAvg)
      if diff < minDiff:
        ans = i
        minDiff = diff

    return ans"
"2257","class Solution:
  def countUnguarded(
      self,
      m: int,
      n: int,
      guards: list[list[int]],
      walls: list[list[int]],
  ) -> int:
    ans = 0
    grid = [[0] * n for _ in range(m)]
    left = [[0] * n for _ in range(m)]
    right = [[0] * n for _ in range(m)]
    up = [[0] * n for _ in range(m)]
    down = [[0] * n for _ in range(m)]

    for row, col in guards:
      grid[row][col] = 'G'

    for row, col in walls:
      grid[row][col] = 'W'

    for i in range(m):
      lastCell = 0
      for j in range(n):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          left[i][j] = lastCell
      lastCell = 0
      for j in range(n - 1, -1, -1):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          right[i][j] = lastCell

    for j in range(n):
      lastCell = 0
      for i in range(m):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          up[i][j] = lastCell
      lastCell = 0
      for i in range(m - 1, -1, -1):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          down[i][j] = lastCell

    for i in range(m):
      for j in range(n):
        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and
                up[i][j] != 'G' and down[i][j] != 'G'):
          ans += 1

    return ans"
"2258","class Solution:
  def maximumMinutes(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kMax = len(grid) * len(grid[0])
    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]
    self._buildFireGrid(grid, fireGrid, dirs)

    ans = -1
    l = 0
    r = kMax

    while l <= r:
      m = (l + r) // 2
      if self._canStayFor(grid, fireGrid, m, dirs):
        ans = m
        l = m + 1
      else:
        r = m - 1

    return 1e9 if ans == kMax else ans

  def _buildFireGrid(
      self,
      grid: list[list[int]],
      fireMinute: list[list[int]],
      dirs: list[int],
  ) -> None:
    minuteFromFire = 0
    q = collections.deque()

    for i in range(len(grid)):
      for j in range(len(grid[0])):
        if grid[i][j] == 1:  # the fire
          q.append((i, j))
          fireMinute[i][j] = 0

    while q:
      minuteFromFire += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):
            continue
          if grid[x][y] == 2:  # the wall
            continue
          if fireMinute[x][y] != -1:
            continue
          fireMinute[x][y] = minuteFromFire
          q.append((x, y))

  def _canStayFor(
      self,
      grid: list[list[int]],
      fireMinute: list[list[int]],
      minute: int, dirs: list[int],
  ) -> bool:
    q = collections.deque([(0, 0)])  # the start position
    seen = {(0, 0)}

    while q:
      minute += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):
            continue
          if grid[x][y] == 2:  # the wall
            continue
          if x == len(grid) - 1 and y == len(grid[0]) - 1:
            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:
              continue
            return True
          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:
            continue
          if seen[x][y]:
            continue
          q.append((x, y))
          seen.add((x, y))

    return False"
"2259",""
"226","class Solution:
  def invertTree(self, root: TreeNode | None) -> TreeNode | None:
    if not root:
      return None

    left = root.left
    right = root.right
    root.left = self.invertTree(right)
    root.right = self.invertTree(left)
    return root"
"2260","class Solution:
  def minimumCardPickup(self, cards: list[int]) -> int:
    ans = math.inf
    lastSeen = {}

    for i, card in enumerate(cards):
      if card in lastSeen:
        ans = min(ans, i - lastSeen[card] + 1)
      lastSeen[card] = i

    return -1 if ans == math.inf else ans"
"2261","class TrieNode:
  def __init__(self):
    self.children: dict[int, TrieNode] = {}
    self.count = 0


class Solution:
  def countDistinct(self, nums: list[int], k: int, p: int) -> int:
    ans = 0
    root = TrieNode()

    def insert(node: TrieNode, i: int, k: int):
      nonlocal ans
      if i == len(nums) or k - (nums[i] % p == 0) < 0:
        return
      if nums[i] not in node.children:
        node.children[nums[i]] = TrieNode()
        ans += 1
      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))

    for i in range(len(nums)):
      insert(root, i, k)

    return ans"
"2262","class Solution:
  def appealSum(self, s: str) -> int:
    ans = 0
    lastSeen = {}

    for i, c in enumerate(s):
      ans += (i - lastSeen.get(c, -1)) * (len(s) - i)
      lastSeen[c] = i

    return ans"
"2263","class Solution:
  def convertArray(self, nums: list[int]) -> int:
    def cost(nums: list[int]) -> int:
      ans = 0
      minHeap = []

      # Greedily make `nums` non-increasing.
      for num in nums:
        if minHeap and minHeap[0] < num:
          ans += num - heapq.heappushpop(minHeap, num)
        heapq.heappush(minHeap, num)

      return ans

    return min(cost(nums), cost([-num for num in nums]))"
"2264","class Solution:
  def largestGoodInteger(self, num: str) -> str:
    return max(num[i - 2:i + 1]
               if num[i] == num[i - 1] == num[i - 2]
               else '' for i in range(2, len(num)))"
"2265","class Solution:
  def averageOfSubtree(self, root: TreeNode | None) -> int:
    ans = 0

    def dfs(root: TreeNode | None) -> tuple[int, int]:
      nonlocal ans
      if not root:
        return (0, 0)
      leftSum, leftCount = dfs(root.left)
      rightSum, rightCount = dfs(root.right)
      summ = root.val + leftSum + rightSum
      count = 1 + leftCount + rightCount
      if summ // count == root.val:
        ans += 1
      return (summ, count)

    dfs(root)
    return ans"
"2266","class Solution:
  def countTexts(self, pressedKeys: str) -> int:
    kMod = 1_000_000_007
    n = len(pressedKeys)
    # dp[i] := the number of possible text messages of pressedKeys[i..n)
    dp = [0] * n + [1]

    def isSame(s: str, i: int, k: int) -> bool:
      """"""Returns True if s[i..i + k) are the same digits.""""""
      if i + k > len(s):
        return False
      for j in range(i + 1, i + k):
        if s[j] != s[i]:
          return False
      return True

    for i in reversed(range(n)):
      dp[i] = dp[i + 1]
      if isSame(pressedKeys, i, 2):
        dp[i] += dp[i + 2]
      if isSame(pressedKeys, i, 3):
        dp[i] += dp[i + 3]
      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and
              isSame(pressedKeys, i, 4)):
        dp[i] += dp[i + 4]
      dp[i] %= kMod

    return dp[0]"
"2267","class Solution:
  def hasValidPath(self, grid: list[list[str]]) -> bool:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> bool:
      """"""
      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],
      where the number of '(' - the number of ')' == k.
      """"""
      if i == len(grid) or j == len(grid[0]):
        return False
      k += 1 if grid[i][j] == '(' else -1
      if k < 0:
        return False
      if i == len(grid) - 1 and j == len(grid[0]) - 1:
        return k == 0
      return dp(i + 1, j, k) | dp(i, j + 1, k)

    return dp(0, 0, 0)"
"2268","class Solution:
  def minimumKeypresses(self, s: str) -> int:
    return sum(c * (i // 9 + 1)
               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))"
"2269","class Solution:
  def divisorSubstrings(self, num: int, k: int) -> int:
    s = str(num)
    ans = 0

    for i in range(len(s) - k + 1):
      x = int(s[i:i + k])
      if x != 0 and num % x == 0:
        ans += 1

    return ans"
"227","class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    prevNum = 0
    currNum = 0
    op = '+'

    for i, c in enumerate(s):
      if c.isdigit():
        currNum = currNum * 10 + int(c)
      if not c.isdigit() and c != ' ' or i == len(s) - 1:
        if op == '+' or op == '-':
          ans += prevNum
          prevNum = currNum if op == '+' else -currNum
        elif op == '*':
          prevNum = prevNum * currNum
        elif op == '/':
          if prevNum < 0:
            prevNum = math.ceil(prevNum / currNum)
          else:
            prevNum = prevNum // currNum
        op = c
        currNum = 0

    return ans + prevNum"
"2270","class Solution:
  def waysToSplitArray(self, nums: list[int]) -> int:
    ans = 0
    prefix = 0
    suffix = sum(nums)

    for i in range(len(nums) - 1):
      prefix += nums[i]
      suffix -= nums[i]
      if prefix >= suffix:
        ans += 1

    return ans"
"2271","class Solution:
  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:
    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):
      return carpetLen

    ans = 0
    prefix = [0] * (len(tiles) + 1)

    tiles.sort()
    starts = [tile[0] for tile in tiles]

    for i, tile in enumerate(tiles):
      length = tile[1] - tile[0] + 1
      prefix[i + 1] = prefix[i] + length

    for i, (s, _) in enumerate(tiles):
      carpetEnd = s + carpetLen - 1
      endIndex = bisect_right(starts, carpetEnd) - 1
      notCover = max(0, tiles[endIndex][1] - carpetEnd)
      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)

    return ans"
"2272","class Solution:
  def largestVariance(self, s: str) -> int:
    # a := the letter with the higher frequency
    # b := the letter with the lower frequency
    def kadane(a: str, b: str) -> int:
      ans = 0
      countA = 0
      countB = 0
      canExtendPrevB = False

      for c in s:
        if c != a and c != b:
          continue
        if c == a:
          countA += 1
        else:
          countB += 1
        if countB > 0:
          # An interval should contain at least one b.
          ans = max(ans, countA - countB)
        elif countB == 0 and canExtendPrevB:
          # edge case: consider the previous b.
          ans = max(ans, countA - 1)
        # Reset if the number of b > the number of a.
        if countB > countA:
          countA = 0
          countB = 0
          canExtendPrevB = True

      return ans

    return max(kadane(a, b)
               for a in string.ascii_lowercase
               for b in string.ascii_lowercase
               if a != b)"
"2273","class Solution:
  def removeAnagrams(self, words: list[str]) -> list[str]:
    ans = []

    def isAnagram(a: str, b: str) -> bool:
      count = collections.Counter(a)
      count.subtract(collections.Counter(b))
      return all(value == 0 for value in count.values())

    i = 0
    while i < len(words):
      j = i + 1
      while j < len(words) and isAnagram(words[i], words[j]):
        j += 1
      ans.append(words[i])
      i = j

    return ans"
"2274","class Solution:
  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:
    ans = 0

    special.sort()

    for a, b in zip(special, special[1:]):
      ans = max(ans, b - a - 1)

    return max(ans, special[0] - bottom, top - special[-1])"
"2275","class Solution:
  def largestCombination(self, candidates: list[int]) -> int:
    return max(sum(c >> i & 1 for c in candidates) for i in range(24))"
"2276","from sortedcontainers import SortedDict


class CountIntervals:
  def __init__(self):
    self.intervals = SortedDict()
    self.cnt = 0

  def add(self, left: int, right: int) -> None:
    while self._isOverlapped(left, right):
      i = self.intervals.bisect_right(right) - 1
      l, r = self.intervals.popitem(i)
      left = min(left, l)
      right = max(right, r)
      self.cnt -= r - l + 1

    self.intervals[left] = right
    self.cnt += right - left + 1

  def count(self) -> int:
    return self.cnt

  def _isOverlapped(self, left: int, right: int) -> bool:
    i = self.intervals.bisect_right(right)
    return i > 0 and self.intervals.peekitem(i - 1)[1] >= left"
"2277","class Solution:
  def closestNode(
      self,
      n: int,
      edges: list[list[int]],
      query: list[list[int]],
  ) -> list[int]:
    tree = [[] for _ in range(n)]
    dist = [[-1] * n for _ in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def fillDist(start: int, u: int, d: int) -> None:
      dist[start][u] = d
      for v in tree[u]:
        if dist[start][v] == -1:
          fillDist(start, v, d + 1)

    for i in range(n):
      fillDist(i, i, 0)

    def findClosest(u: int, end: int, node: int, ans: int) -> int:
      for v in tree[u]:
        if dist[v][end] < dist[u][end]:
          return findClosest(
              v, end, node, ans if dist[ans][node] < dist[v][node] else v)
      return ans

    return [findClosest(start, end, node, start)
            for start, end, node in query]"
"2278","class Solution:
  def percentageLetter(self, s: str, letter: str) -> int:
    return 100 * s.count(letter) // len(s)"
"2279","class Solution:
  def maximumBags(
      self,
      capacity: list[int],
      rocks: list[int],
      additionalRocks: int,
  ) -> int:
    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):
      if d > additionalRocks:
        return i
      additionalRocks -= d
    return len(capacity)"
"228","class Solution:
  def summaryRanges(self, nums: list[int]) -> list[str]:
    ans = []

    i = 0
    while i < len(nums):
      begin = nums[i]
      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:
        i += 1
      end = nums[i]
      if begin == end:
        ans.append(str(begin))
      else:
        ans.append(str(begin) + ""->"" + str(end))
      i += 1

    return ans"
"2280","class Solution:
  def minimumLines(self, stockPrices: list[list[int]]) -> int:
    ans = 0

    stockPrices.sort()

    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:
      dx = p[0] - q[0]
      dy = p[1] - q[1]
      if dx == 0:
        return (0, p[0])
      if dy == 0:
        return (p[1], 0)
      d = gcd(dx, dy)
      return (dx // d, dy // d)

    for i in range(2, len(stockPrices)):
      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])
      b = getSlope(stockPrices[i - 1], stockPrices[i])
      if a != b:
        ans += 1

    return ans + (len(stockPrices) > 1)"
"2281","class Solution:
  def totalStrength(self, strength: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(strength)
    # left[i] := the next index on the left (if any)
    #            s.t. nums[left[i]] <= nums[i]
    left = [-1] * n
    # right[i] := the next index on the right (if any)
    #             s.t. nums[right[i]] < nums[i]
    right = [n] * n
    stack = []

    for i in reversed(range(n)):
      while stack and strength[stack[-1]] >= strength[i]:
        left[stack.pop()] = i
      stack.append(i)

    stack = []

    for i in range(n):
      while stack and strength[stack[-1]] > strength[i]:
        right[stack.pop()] = i
      stack.append(i)

    ans = 0
    prefixOfPrefix = list(itertools.accumulate(
        itertools.accumulate(strength), initial=0))

    # For each strength[i] as the minimum, calculate sum.
    for i, (l, r) in enumerate(zip(left, right)):
      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]
      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]
      leftLen = i - l
      rightLen = r - i
      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % kMod

    return ans % kMod"
"2282","class Solution:
  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:
    m = len(heights)
    n = len(heights[0])
    ans = [[0] * n for _ in range(m)]

    for i, row in enumerate(heights):
      stack = []
      for j, height in enumerate(row):
        hasEqualHeight = False
        while stack and row[stack[-1]] <= height:
          if row[stack[-1]] == height:
            # edge case: [4, 2, 1, 1, 3]
            hasEqualHeight = True
          ans[i][stack.pop()] += 1
        if stack and not hasEqualHeight:
          ans[i][stack[-1]] += 1
        stack.append(j)

    for j, col in enumerate(zip(*heights)):
      stack = []
      for i, height in enumerate(col):
        hasEqualHeight = False
        while stack and col[stack[-1]] <= height:
          if col[stack[-1]] == height:
            hasEqualHeight = True
          ans[stack.pop()][j] += 1
        if stack and not hasEqualHeight:
          ans[stack[-1]][j] += 1
        stack.append(i)

    return ans"
"2283","class Solution:
  def digitCount(self, num: str) -> bool:
    count = collections.Counter(num)
    return all(count[str(i)] == int(digit)
               for i, digit in enumerate(num))"
"2284","class Solution:
  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:
    n = len(messages)
    ans = ''
    maxWordsSent = 0
    count = collections.Counter()  # [sender, # Words sent]

    for message, sender in zip(messages, senders):
      wordsCount = message.count(' ') + 1
      count[sender] += wordsCount
      numWordsSent = count[sender]
      if numWordsSent > maxWordsSent:
        ans = sender
        maxWordsSent = numWordsSent
      elif numWordsSent == maxWordsSent and sender > ans:
        ans = sender

    return ans"
"2285","class Solution:
  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:
    count = [0] * n

    for u, v in roads:
      count[u] += 1
      count[v] += 1

    count.sort()
    return sum((i + 1) * c for i, c in enumerate(count))"
"2286","struct SegmentTreeNode {
  int lo;
  int hi;
  std::unique_ptr<SegmentTreeNode> left;
  std::unique_ptr<SegmentTreeNode> right;
  int mx;
  long sum;
  SegmentTreeNode(int lo, int hi, std::unique_ptr<SegmentTreeNode>&& left,
                  std::unique_ptr<SegmentTreeNode>&& right, int mx, long sum)
      : lo(lo),
        hi(hi),
        left(std::move(left)),
        right(std::move(right)),
        mx(mx),
        sum(sum) {}
};

class SegmentTree {
 public:
  explicit SegmentTree(int n, int m) : m(m), root(std::move(build(0, n - 1))) {}

  vector<int> maxRange(int k, int maxRow) {
    return maxRange(root, k, maxRow);
  }

  long sumRange(int maxRow) {
    return sumRange(root, 0, maxRow);
  }

  // Substracts k from the seats row.
  void substract(int row, int k) {
    substract(root, row, k);
  }

 private:
  const int m;
  std::unique_ptr<SegmentTreeNode> root;

  std::unique_ptr<SegmentTreeNode> build(int l, int r) {
    if (l == r)
      return make_unique<SegmentTreeNode>(l, r, nullptr, nullptr, m, m);
    const int mid = (l + r) / 2;
    std::unique_ptr<SegmentTreeNode> left = build(l, mid);
    std::unique_ptr<SegmentTreeNode> right = build(mid + 1, r);
    return make_unique<SegmentTreeNode>(l, r, std::move(left), std::move(right),
                                        max(left->mx, right->mx),
                                        left->sum + right->sum);
  }

  vector<int> maxRange(std::unique_ptr<SegmentTreeNode>& root, int k,
                       int maxRow) {
    if (root->lo == root->hi) {
      if (root->sum < k || root->lo > maxRow)
        return {};
      return {root->lo, m - static_cast<int>(root->sum)};  // {row, col}
    }
    // Greedily search the left subtree
    if (root->left->mx >= k)
      return maxRange(root->left, k, maxRow);
    return maxRange(root->right, k, maxRow);
  }

  long sumRange(std::unique_ptr<SegmentTreeNode>& root, int i, int j) {
    if (root->lo == i && root->hi == j)
      return root->sum;
    const int mid = (root->lo + root->hi) / 2;
    if (j <= mid)
      return sumRange(root->left, i, j);
    if (i > mid)
      return sumRange(root->right, i, j);
    return sumRange(root->left, i, mid) + sumRange(root->right, mid + 1, j);
  }

  void substract(std::unique_ptr<SegmentTreeNode>& root, int row, int k) {
    if (root == nullptr)
      return;
    if (root->lo == root->hi && root->hi == row) {
      root->mx -= k;
      root->sum -= k;
      return;
    }
    const int mid = (root->lo + root->hi) / 2;
    if (row <= mid)
      substract(root->left, row, k);
    else
      substract(root->right, row, k);
    root->mx = max(root->left->mx, root->right->mx);
    root->sum = root->left->sum + root->right->sum;
  }
};

class BookMyShow {
 public:
  BookMyShow(int n, int m) : tree(n, m), seats(n, m) {}

  vector<int> gather(int k, int maxRow) {
    const vector<int> res = tree.maxRange(k, maxRow);
    if (res.size() == 2) {
      const int row = res[0];
      tree.substract(row, k);
      seats[row] -= k;
    }
    return res;
  }

  bool scatter(int k, int maxRow) {
    if (tree.sumRange(maxRow) < k)
      return false;

    while (k > 0)
      if (seats[minVacantRow] >= k) {
        tree.substract(minVacantRow, k);
        seats[minVacantRow] -= k;
        k = 0;
      } else {
        tree.substract(minVacantRow, seats[minVacantRow]);
        k -= seats[minVacantRow];
        seats[minVacantRow] = 0;
        ++minVacantRow;
      }

    return true;
  }

 private:
  SegmentTree tree;
  vector<int> seats;  // the remaining seats at each row
  int minVacantRow = 0;
};"
"2287","class Solution:
  def rearrangeCharacters(self, s: str, target: str) -> int:
    countS = collections.Counter(s)
    countT = collections.Counter(target)
    return min(countS[c] // countT[c] for c in target)"
"2288","class Solution:
  def discountPrices(self, sentence: str, discount: int) -> str:
    kPrecision = 2
    ans = []

    for word in sentence.split():
      if word[0] == '$' and len(word) > 1:
        digits = word[1:]
        if all(digit.isdigit() for digit in digits):
          val = float(digits) * (100 - discount) / 100
          s = f'{val:.2f}'
          trimmed = s[:s.index('.') + kPrecision + 1]
          ans.append('$' + trimmed)
        else:
          ans.append(word)
      else:
        ans.append(word)

    return ' '.join(ans)"
"2289","class Solution:
  def totalSteps(self, nums: list[int]) -> int:
    # dp[i] := the number of steps to remove nums[i]
    dp = [0] * len(nums)
    stack = []

    for i, num in enumerate(nums):
      step = 1
      while stack and nums[stack[-1]] <= num:
        step = max(step, dp[stack.pop()] + 1)
      if stack:
        dp[i] = step
      stack.append(i)

    return max(dp)"
"229","class Solution:
  def majorityElement(self, nums: list[int]) -> list[int]:
    ans1 = 0
    ans2 = 1
    count1 = 0
    count2 = 0

    for num in nums:
      if num == ans1:
        count1 += 1
      elif num == ans2:
        count2 += 1
      elif count1 == 0:
        ans1 = num
        count1 = 1
      elif count2 == 0:
        ans2 = num
        count2 = 1
      else:
        count1 -= 1
        count2 -= 1

    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]"
"2290","class Solution:
  def minimumObstacles(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)
    dist = [[math.inf] * n for _ in range(m)]
    dist[0][0] = grid[0][0]

    while minHeap:
      d, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return d
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        newDist = d + grid[i][j]
        if newDist < dist[x][y]:
          dist[x][y] = newDist
          heapq.heappush(minHeap, (newDist, x, y))

    return dist[m - 1][n - 1]"
"2291","class Solution:
  def maximumProfit(
      self,
      present: list[int],
      future: list[int],
      budget: int,
  ) -> int:
    # dp[i] := the maximum profit of buying present so far with i budget
    dp = [0] * (budget + 1)

    for p, f in zip(present, future):
      for j in range(budget, p - 1, -1):
        dp[j] = max(dp[j], f - p + dp[j - p])

    return dp[budget]"
"2292","WITH
  OrdersNeighbors AS (
    SELECT
      product_id,
      YEAR(purchase_date) AS curr_year,
      LEAD(YEAR(purchase_date)) OVER(
        PARTITION BY product_id
        ORDER BY YEAR(purchase_date)
      ) AS next_year
    FROM orders
    GROUP BY 1, 2
    HAVING COUNT(order_id) >= 3
  )
SELECT DISTINCT product_id
FROM OrdersNeighbors
WHERE curr_year + 1 = next_year;"
"2293","class Solution:
  def minMaxGame(self, nums: list[int]) -> int:
    if len(nums) == 1:
      return nums[0]

    nextNums = []
    for i in range(len(nums) // 2):
      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else
                      max(nums[2 * i], nums[2 * i + 1]))
    return self.minMaxGame(nextNums)"
"2294","class Solution:
  def partitionArray(self, nums: list[int], k: int) -> int:
    nums.sort()

    ans = 1
    mn = nums[0]

    for i in range(1, len(nums)):
      if mn + k < nums[i]:
        ans += 1
        mn = nums[i]

    return ans"
"2295","class Solution:
  def arrayChange(
      self,
      nums: list[int],
      operations: list[list[int]],
  ) -> list[int]:
    numToIndex = {num: i for i, num in enumerate(nums)}

    for original, replaced in operations:
      index = numToIndex[original]
      nums[index] = replaced
      del numToIndex[original]
      numToIndex[replaced] = index

    return nums"
"2296","class TextEditor:
  def __init__(self):
    self.s = []
    self.stack = []

  def addText(self, text: str) -> None:
    for c in text:
      self.s.append(c)

  def deleteText(self, k: int) -> int:
    numDeleted = min(k, len(self.s))
    for _ in range(numDeleted):
      self.s.pop()
    return numDeleted

  def cursorLeft(self, k: int) -> str:
    while self.s and k > 0:
      self.stack.append(self.s.pop())
      k -= 1
    return self._getString()

  def cursorRight(self, k: int) -> str:
    while self.stack and k > 0:
      self.s.append(self.stack.pop())
      k -= 1
    return self._getString()

  def _getString(self) -> str:
    if len(self.s) < 10:
      return ''.join(self.s)
    return ''.join(self.s[-10:])"
"2297","class Solution:
  def minCost(self, nums: list[int], costs: list[int]) -> int:
    # dp[i] := the minimum cost to jump to i
    dp = [math.inf] * len(nums)
    maxStack = []
    minStack = []

    dp[0] = 0

    for i, num in enumerate(nums):
      while maxStack and num >= nums[maxStack[-1]]:
        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])
      while minStack and num < nums[minStack[-1]]:
        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])
      maxStack.append(i)
      minStack.append(i)

    return dp[-1]"
"2298","SELECT
  SUM(WEEKDAY(submit_date) >= 5) AS weekend_cnt,
  SUM(WEEKDAY(submit_date) < 5) AS working_cnt
FROM Tasks;"
"2299","class Solution:
  def strongPasswordCheckerII(self, password: str) -> bool:
    if len(password) < 8:
      return False
    if not any(c.islower() for c in password):
      return False
    if not any(c.isupper() for c in password):
      return False
    if not any(c.isdigit() for c in password):
      return False
    if not any(""!@#$%^&*()-+"".find(c) != -1 for c in password):
      return False
    return all(a != b for a, b in zip(password, password[1:]))"
"23","from queue import PriorityQueue


class Solution:
  def mergeKLists(self, lists: list[ListNode]) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    pq = PriorityQueue()

    for i, lst in enumerate(lists):
      if lst:
        pq.put((lst.val, i, lst))

    while not pq.empty():
      _, i, minNode = pq.get()
      if minNode.next:
        pq.put((minNode.next.val, i, minNode.next))
      curr.next = minNode
      curr = curr.next

    return dummy.next"
"230","class Solution:
  def kthSmallest(self, root: TreeNode | None, k: int) -> int:
    def countNodes(root: TreeNode | None) -> int:
      if not root:
        return 0
      return 1 + countNodes(root.left) + countNodes(root.right)

    leftCount = countNodes(root.left)

    if leftCount == k - 1:
      return root.val
    if leftCount >= k:
      return self.kthSmallest(root.left, k)
    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k"
"2300","class Solution:
  def successfulPairs(
      self,
      spells: list[int],
      potions: list[int],
      success: int,
  ) -> list[int]:
    potions.sort()

    def firstIndexSuccess(spell: int):
      """"""Returns the first index i s.t. spell * potions[i] >= success.""""""
      l = 0
      r = len(potions)
      while l < r:
        m = (l + r) // 2
        if spell * potions[m] >= success:
          r = m
        else:
          l = m + 1
      return l

    return [len(potions) - firstIndexSuccess(spell) for spell in spells]"
"2301","class Solution:
  def matchReplacement(
      self,
      s: str,
      sub: str,
      mappings: list[list[str]],
  ) -> bool:
    isMapped = [[False] * 128 for _ in range(128)]

    for old, new in mappings:
      isMapped[ord(old)][ord(new)] = True

    for i in range(len(s)):
      if self._canTransform(s, i, sub, isMapped):
        return True

    return False

  def _canTransform(
      self,
      s: str,
      start: int,
      sub: str,
      isMapped: list[list[bool]],
  ) -> bool:
    if start + len(sub) > len(s):
      return False

    for i in range(len(sub)):
      a = sub[i]
      b = s[start + i]
      if a != b and not isMapped[ord(a)][ord(b)]:
        return False

    return True"
"2302","class Solution:
  def countSubarrays(self, nums: list[int], k: int) -> int:
    ans = 0
    summ = 0

    l = 0
    for r, num in enumerate(nums):
      summ += num
      while summ * (r - l + 1) >= k:
        summ -= nums[l]
        l += 1
      ans += r - l + 1

    return ans"
"2303","class Solution:
  def calculateTax(self, brackets: list[list[int]], income: int) -> float:
    ans = 0
    prev = 0

    for upper, percent in brackets:
      if income < upper:
        return ans + (income - prev) * percent / 100.0
      ans += (upper - prev) * percent / 100.0
      prev = upper

    return ans"
"2304","class Solution:
  def minPathCost(
      self,
      grid: list[list[int]],
      moveCost: list[list[int]],
  ) -> int:
    m = len(grid)
    n = len(grid[0])
    # dp[i][j] := the minimum cost to reach grid[i][j]
    dp = [[math.inf] * n for _ in range(m)]
    dp[0] = grid[0]

    for i in range(1, m):
      for j in range(n):
        for k in range(n):
          dp[i][j] = min(dp[i][j], dp[i - 1][k] +
                         moveCost[grid[i - 1][k]][j] + grid[i][j])

    return min(dp[-1])"
"2305","class Solution:
  def distributeCookies(self, cookies: list[int], k: int) -> int:
    ans = math.inf

    def dfs(s: int, children: list[int]) -> None:
      nonlocal ans
      if s == len(cookies):
        ans = min(ans, max(children))
        return

      for i in range(k):
        children[i] += cookies[s]
        dfs(s + 1, children)
        children[i] -= cookies[s]

    dfs(0, [0] * k)
    return ans"
"2306","class Solution:
  def distinctNames(self, ideas: list[str]) -> int:
    ans = 0
    # suffixes[i] := the set of strings omitting the first letter, where the
    # first letter is ('a' + i)
    suffixes = [set() for _ in range(26)]

    for idea in ideas:
      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])

    for i in range(25):
      for j in range(i + 1, 26):
        count = len(suffixes[i] & suffixes[j])
        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)

    return ans"
"2307","class Solution:
  def checkContradictions(
      self,
      equations: list[list[str]],
      values: list[float],
  ) -> bool:
    # Convert `string` to `int` for a better perfermance.
    strToInt = {}

    for u, v in equations:
      strToInt.setdefault(u, len(strToInt))
      strToInt.setdefault(v, len(strToInt))

    graph = [[] for _ in range(len(strToInt))]
    seen = [0.0] * len(graph)

    for i, ((A, B), value) in enumerate(zip(equations, values)):
      u = strToInt[A]
      v = strToInt[B]
      graph[u].append((v, value))
      graph[v].append((u, 1 / value))

    def dfs(u: int, val: float) -> bool:
      if seen[u]:
        return abs(val / seen[u] - 1) > 1e-5

      seen[u] = val
      return any(dfs(v, val / w) for v, w in graph[u])

    for i in range(len(graph)):
      if not seen[i] and dfs(i, 1.0):
        return True

    return False"
"2308","SELECT
  user_id,
  gender
FROM Genders
ORDER BY RANK() OVER(
    PARTITION by gender
    ORDER BY user_id
  ),
  LENGTH(gender) DESC;"
"2309","class Solution:
  def greatestLetter(self, s: str) -> str:
    seen = set(s)

    for i in range(25, -1, -1):
      if (chr(ord('a') + i) in seen and
              chr(ord('A') + i) in seen):
        return chr(ord('A') + i)

    return ''"
"231","class Solution:
  def isPowerOfTwo(self, n: int) -> bool:
    return n >= 0 and n.bit_count() == 1"
"2310","class Solution:
  def minimumNumbers(self, num: int, k: int) -> int:
    if num == 0:
      return 0

    # Assume the size of the set is n, and the numbers in the set are X1, X2,
    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =
    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find
    # the n s.t. n * k % 10 = num % 10
    for i in range(1, 11):
      if i * k > num + 1:
        break
      if i * k % 10 == num % 10:
        return i

    return -1"
"2311","class Solution:
  def longestSubsequence(self, s: str, k: int) -> int:
    oneCount = 0
    num = 0
    pow = 1

    # Take as many 1s as possible from the right.
    for i in reversed(range(len(s))):
      if num + pow > k:
        break
      if s[i] == '1':
        oneCount += 1
        num += pow
      pow *= 2

    return s.count('0') + oneCount"
"2312","class Solution:
  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:
    # dp[i][j] := the maximum money of cutting i x j piece of wood
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for h, w, price in prices:
      dp[h][w] = price

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        for h in range(1, i // 2 + 1):
          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])
        for w in range(1, j // 2 + 1):
          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])

    return dp[m][n]"
"2313","class Solution:
  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:
    @functools.lru_cache(None)
    def dp(root: TreeNode | None, target: bool) -> int:
      """"""Returns the minimum flips to make the subtree root become target.""""""
      if root.val in (0, 1):  # the leaf
        return 0 if root.val == target else 1
      if root.val == 5:  # NOT
        return dp(root.left or root.right, not target)
      if root.val == 2:  # OR
        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]
      elif root.val == 3:  # AND
        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]
      else:  # root.val == 4 XOR
        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]
      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)
                 for leftTarget, rightTarget in nextTargets)

    return dp(root, result)"
"2314","WITH
  RankedWeather AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION by city_id
        ORDER BY degree DESC, day
      ) AS `rank`
    FROM Weather
  )
SELECT city_id, day, degree
FROM RankedWeather
WHERE `rank` = 1;"
"2315","class Solution:
  def countAsterisks(self, s: str) -> int:
    ans = 0
    bars = 0

    for c in s:
      if c == '|':
        bars += 1
      elif c == '*' and bars % 2 == 0:
        ans += 1

    return ans"
"2316","class Solution:
  def countPairs(self, n: int, edges: list[list[int]]) -> int:
    ans = 0
    graph = [[] for _ in range(n)]
    seen = [0] * n
    unreached = n

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    for i in range(n):
      reached = self._dfs(graph, i, seen)
      unreached -= reached
      ans += unreached * reached

    return ans

  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:
    if seen[u]:
      return 0
    seen[u] = True
    return functools.reduce(lambda subtotal, v:
                            subtotal + self._dfs(graph, v, seen), graph[u], 1)"
"2317","class Solution:
  def maximumXOR(self, nums: list[int]) -> int:
    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from
    #    nums[i] since x is arbitrary.
    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1
    #    for an odd number of elements.
    # 3. Therefore, the question is equivalent to: if you can convert any digit
    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).
    # 4. The maximum we can get is of course to make every digit of the answer
    #    to be 1 if possible
    # 5. Therefore, OR(nums[i]) is an approach.
    return functools.reduce(operator.ior, nums)"
"2318","class Solution:
  def distinctSequences(self, n: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(n: int, prev: int, prevPrev: int) -> int:
      """"""
      Returns the number of distinct sequences for n dices with `prev` and
      `prevPrev`.
      """"""
      if n == 0:
        return 1
      res = 0
      for dice in range(1, 7):
        if (dice not in (prev, prevPrev) and
                (prev == 0 or math.gcd(dice, prev) == 1)):
          res += dp(n - 1, dice, prev)
          res %= kMod
      return res

    return dp(n, 0, 0)"
"2319","class Solution:
  def checkXMatrix(self, grid: list[list[int]]) -> bool:
    n = len(grid)

    for i in range(n):
      for j in range(n):
        if i == j or i + j == n - 1:  # in diagonal
          if grid[i][j] == 0:
            return False
        elif grid[i][j]:   # not in diagonal
          return False

    return True"
"232","class MyQueue:
  def __init__(self):
    self.input = []
    self.output = []

  def push(self, x: int) -> None:
    self.input.append(x)

  def pop(self) -> int:
    self.peek()
    return self.output.pop()

  def peek(self) -> int:
    if not self.output:
      while self.input:
        self.output.append(self.input.pop())
    return self.output[-1]

  def empty(self) -> bool:
    return not self.input and not self.output"
"2320","class Solution:
  def countHousePlacements(self, n: int) -> int:
    kMod = 1_000_000_007
    house = 1  # the number of ways ending in a house
    space = 1  # the number of ways ending in a space
    total = house + space

    for _ in range(2, n + 1):
      house = space
      space = total
      total = (house + space) % kMod

    return total**2 % kMod"
"2321","class Solution:
  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:
    def kadane(nums1: list[int], nums2: list[int]) -> int:
      """"""
      Returns the maximum gain of swapping some numbers in `nums1` with some
      numbers in `nums2`.
      """"""
      gain = 0
      maxGain = 0

      for num1, num2 in zip(nums1, nums2):
        gain = max(0, gain + num2 - num1)
        maxGain = max(maxGain, gain)

      return maxGain + sum(nums1)

    return max(kadane(nums1, nums2), kadane(nums2, nums1))"
"2322","class Solution:
  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:
    n = len(nums)
    xors = functools.reduce(operator.xor, nums)
    subXors = nums[:]
    tree = [[] for _ in range(n)]
    children = [{i} for i in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> tuple[int, set[int]]:
      for v in tree[u]:
        if v == prev:
          continue
        vXor, vChildren = dfs(v, u)
        subXors[u] ^= vXor
        children[u] |= vChildren
      return subXors[u], children[u]

    dfs(0, -1)

    ans = math.inf
    for i in range(len(edges)):
      a, b = edges[i]
      if b in children[a]:
        a, b = b, a
      for j in range(i):
        c, d = edges[j]
        if d in children[c]:
          c, d = d, c

        if c in children[a] and a != c:
          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]
        elif a in children[c] and a != c:
          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]
        else:
          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]
        ans = min(ans, max(cands) - min(cands))

    return ans"
"2323","class Solution:
  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:
    ans = 0

    jobs.sort()
    workers.sort()

    for job, worker in zip(jobs, workers):
      ans = max(ans, (job - 1) // worker + 1)

    return ans"
"2324","WITH
  RankedSpending AS (
    SELECT
      Sales.user_id,
      Sales.product_id,
      RANK() OVER(
        PARTITION by user_id
        ORDER BY SUM(Sales.quantity * Product.price) DESC
      ) AS `rank`
    FROM Sales
    INNER JOIN Product
      USING (product_id)
    GROUP BY 1, 2
  )
SELECT user_id, product_id
FROM RankedSpending
WHERE `rank` = 1;"
"2325","class Solution:
  def decodeMessage(self, key: str, message: str) -> str:
    keyToActual = {' ': ' '}
    currChar = 'a'

    for c in key:
      if c not in keyToActual:
        keyToActual[c] = currChar
        currChar = chr(ord(currChar) + 1)

    return ''.join(keyToActual[c] for c in message)"
"2326","class Solution:
  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = [[-1] * n for _ in range(m)]
    x = 0  # the current x position
    y = 0  # the current y position
    d = 0

    curr = head
    while curr:
      ans[x][y] = curr.val
      if (x + dirs[d][0] < 0 or x + dirs[d][0] == m or y + dirs[d][1] < 0 or
              y + dirs[d][1] == n or ans[x + dirs[d][0]][y + dirs[d][1]] != -1):
        d = (d + 1) % 4
      x += dirs[d][0]
      y += dirs[d][1]
      curr = curr.next

    return ans"
"2327","class Solution:
  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
    kMod = 1_000_000_007
    share = 0
    # dp[i] := the number of people know the secret at day i
    dp = [0] * n  # Maps day i to i + 1.
    dp[0] = 1

    for i in range(1, n):
      if i - delay >= 0:
        share += dp[i - delay]
      if i - forget >= 0:
        share -= dp[i - forget]
      share += kMod
      share %= kMod
      dp[i] = share

    # People before day `n - forget - 1` already forget the secret.
    return sum(dp[-forget:]) % kMod"
"2328","class Solution:
  def countPaths(self, grid: list[list[int]]) -> int:
    kMod = 1_000_000_007
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """"""Returns the number of increasing paths starting from (i, j).""""""
      ans = 1  # The current cell contributes 1 length.
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if grid[x][y] <= grid[i][j]:
          continue
        ans += dp(x, y)
        ans %= kMod
      return ans

    return sum(dp(i, j)
               for i in range(m)
               for j in range(n)) % kMod"
"2329","SELECT
  Sales.user_id,
  SUM(Sales.quantity * Product.price) AS spending
FROM Sales
INNER JOIN Product
  USING (product_id)
GROUP BY user_id
ORDER BY spending DESC;"
"233","class Solution:
  def countDigitOne(self, n: int) -> int:
    ans = 0

    pow10 = 1
    while pow10 <= n:
      divisor = pow10 * 10
      quotient = n // divisor
      remainder = n % divisor
      if quotient > 0:
        ans += quotient * pow10
      if remainder >= pow10:
        ans += min(remainder - pow10 + 1, pow10)
      pow10 *= 10

    return ans"
"2330","class Solution:
  def makePalindrome(self, s: str) -> bool:
    change = 0
    l = 0
    r = len(s) - 1

    while l < r:
      if s[l] != s[r]:
        change += 1
        if change > 2:
          return False
      l += 1
      r -= 1

    return True"
"2331","class Solution:
  def evaluateTree(self, root: TreeNode | None) -> bool:
    if root.val < 2:
      return root.val
    if root.val == 2:  # OR
      return self.evaluateTree(root.left) or self.evaluateTree(root.right)
    # AND
    return self.evaluateTree(root.left) and self.evaluateTree(root.right)"
"2332","class Solution:
  def latestTimeCatchTheBus(
      self,
      buses: list[int],
      passengers: list[int],
      capacity: int,
  ) -> int:
    buses.sort()
    passengers.sort()

    if passengers[0] > buses[-1]:
      return buses[-1]

    ans = passengers[0] - 1
    i = 0  # buses' index
    j = 0  # passengers' index

    while i < len(buses):
      # Greedily make passengers catch `buses[i]`.
      arrived = 0
      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:
        if j > 0 and passengers[j] != passengers[j - 1] + 1:
          ans = passengers[j] - 1
        j += 1
        arrived += 1
      # There's room for `buses[i]` to carry a passenger arriving at the
      # `buses[i]`.
      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:
        ans = buses[i]
      i += 1

    return ans"
"2333","class Solution {
 public:
  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1,
                             int k2) {
    const vector<int> diff = getDiff(nums1, nums2);
    int k = k1 + k2;
    if (accumulate(diff.begin(), diff.end(), 0L) <= k)
      return 0;

    unordered_map<int, int> count;
    priority_queue<pair<int, int>> maxHeap;  // (num, freq)

    for (const int d : diff)
      if (d != 0)
        ++count[d];

    for (const auto& [num, freq] : count)
      maxHeap.emplace(num, freq);

    while (k > 0) {
      const auto [maxNum, maxNumFreq] = maxHeap.top();
      maxHeap.pop();
      // Buck decrease in this turn
      const int numDecreased = min(k, maxNumFreq);
      k -= numDecreased;
      if (maxNumFreq > numDecreased)
        maxHeap.emplace(maxNum, maxNumFreq - numDecreased);
      if (!maxHeap.empty() && maxHeap.top().first + 1 == maxNum) {
        const auto [secondMaxNum, secondMaxNumFreq] = maxHeap.top();
        maxHeap.pop();
        maxHeap.emplace(secondMaxNum, secondMaxNumFreq + numDecreased);
      } else if (maxNum > 1) {
        maxHeap.emplace(maxNum - 1, numDecreased);
      }
    }

    long ans = 0;
    while (!maxHeap.empty()) {
      const auto [num, freq] = maxHeap.top();
      maxHeap.pop();
      ans += static_cast<long>(num) * num * freq;
    }

    return ans;
  }

 private:
  vector<int> getDiff(const vector<int>& nums1, const vector<int>& nums2) {
    vector<int> diff;
    for (int i = 0; i < nums1.size(); ++i)
      diff.push_back(abs(nums1[i] - nums2[i]));
    return diff;
  }
};"
"2334","class Solution:
  # Similar to 907. Sum of Subarray Minimums
  def validSubarraySize(self, nums: list[int], threshold: int) -> int:
    n = len(nums)
    ans = 0
    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)
    prev = [-1] * n
    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)
    next = [n] * n
    stack = []

    for i, a in enumerate(nums):
      while stack and nums[stack[-1]] > a:
        index = stack.pop()
        next[index] = i
      if stack:
        prev[i] = stack[-1]
      stack.append(i)

    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):
      k = (i - prevIndex) + (nextIndex - i) - 1
      if num > threshold / k:
        return k

    return -1"
"2335","class Solution:
  def fillCups(self, amount: list[int]) -> int:
    return max(max(amount), (sum(amount) + 1) // 2)"
"2336","class SmallestInfiniteSet {
 public:
  int popSmallest() {
    if (added.empty())
      return curr++;
    const int mn = *added.begin();
    added.erase(added.begin());
    return mn;
  }

  void addBack(int num) {
    if (num < curr)
      added.insert(num);
  }

 private:
  int curr = 1;
  set<int> added;
};"
"2337","class Solution:
  def canChange(self, start: str, target: str) -> bool:
    n = len(start)
    i = 0  # start's index
    j = 0  # target's index

    while i <= n and j <= n:
      while i < n and start[i] == '_':
        i += 1
      while j < n and target[j] == '_':
        j += 1
      if i == n or j == n:
        return i == n and j == n
      if start[i] != target[j]:
        return False
      if start[i] == 'R' and i > j:
        return False
      if start[i] == 'L' and i < j:
        return False
      i += 1
      j += 1

    return True"
"2338","class Solution {
 public:
  int idealArrays(int n, int maxValue) {
    // Since 2^14 > 10^4, the longest strictly increasing array is [1, 2, 4,
    // ..., 2^13]
    const int maxLength = min(14, n);
    const vector<vector<int>> factors = getFactors(maxValue);
    // dp[i][j] := the number of strictly increasing ideal arrays of length i
    // ending in j
    // dp[i][j] := sum(dp[i - 1][k]), where j % k == 0
    // dp[i][0] := sum(dp[i][j]) where 1 <= j <= maxValue
    vector<vector<long>> dp(maxLength + 1, vector<long>(maxValue + 1));
    vector<vector<long>> mem(n, vector<long>(maxLength, -1));
    long ans = 0;

    for (int j = 1; j <= maxValue; ++j)
      dp[1][j] = 1;

    for (int i = 2; i <= maxLength; ++i)
      for (int j = 1; j <= maxValue; ++j)
        for (const int k : factors[j]) {
          dp[i][j] += dp[i - 1][k];
          dp[i][j] %= kMod;
        }

    for (int i = 1; i <= maxLength; ++i)
      for (int j = 1; j <= maxValue; ++j) {
        dp[i][0] += dp[i][j];
        dp[i][0] %= kMod;
      }

    for (int i = 1; i <= maxLength; ++i) {
      // nCk(n - 1, i - 1) := the number of ways to create an ideal array of
      // length n from a strictly increasing array of length i
      ans += dp[i][0] * nCk(n - 1, i - 1, mem);
      ans %= kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  vector<vector<int>> getFactors(int maxValue) {
    vector<vector<int>> factors(maxValue + 1);
    for (int i = 1; i <= maxValue; ++i)
      // Start from i * 2 because of strictly increasing.
      for (int j = i * 2; j <= maxValue; j += i)
        factors[j].push_back(i);
    return factors;
  }

  long nCk(int n, int k, vector<vector<long>>& mem) {
    if (k == 0)
      return 1;
    if (n == k)
      return 1;
    if (mem[n][k] != -1)
      return mem[n][k];
    return mem[n][k] = (nCk(n - 1, k, mem) + nCk(n - 1, k - 1, mem)) % kMod;
  }
};"
"2339","SELECT
  Home.team_name AS home_team,
  Away.team_name AS away_team
FROM Teams AS Home
INNER JOIN Teams AS Away
WHERE Home.team_name != Away.team_name;"
"234","class Solution:
  def isPalindrome(self, head: ListNode) -> bool:
    def reverseList(head: ListNode) -> ListNode:
      prev = None
      curr = head
      while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
      return prev

    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next

    if fast:
      slow = slow.next
    slow = reverseList(slow)

    while slow:
      if slow.val != head.val:
        return False
      slow = slow.next
      head = head.next

    return True"
"2340","class Solution:
  def minimumSwaps(self, nums: list[int]) -> int:
    minIndex = self._getLeftmostMinIndex(nums)
    maxIndex = self._getRightmostMaxIndex(nums)
    swaps = minIndex + (len(nums) - 1 - maxIndex)
    return swaps if minIndex <= maxIndex else swaps - 1

  def _getLeftmostMinIndex(self, nums: list[int]) -> int:
    mn = nums[0]
    minIndex = 0
    for i in range(1, len(nums)):
      if nums[i] < mn:
        mn = nums[i]
        minIndex = i
    return minIndex

  def _getRightmostMaxIndex(self, nums: list[int]) -> int:
    mx = nums[-1]
    maxIndex = len(nums) - 1
    for i in range(len(nums) - 2, -1, -1):
      if nums[i] > mx:
        mx = nums[i]
        maxIndex = i
    return maxIndex"
"2341","class Solution:
  def numberOfPairs(self, nums: list[int]) -> list[int]:
    ans = [0] * 2
    count = collections.Counter(nums)

    for i in range(101):
      ans[0] += count[i] // 2
      ans[1] += count[i] & 1

    return ans"
"2342","class Solution:
  def maximumSum(self, nums: list[int]) -> int:
    kMax = 9 * 9  # 999,999,999
    ans = -1
    count = [[] for _ in range(kMax + 1)]

    for num in nums:
      count[self._getDigitSum(num)].append(num)

    for groupNums in count:
      if len(groupNums) < 2:
        continue
      groupNums.sort(reverse=True)
      ans = max(ans, groupNums[0] + groupNums[1])

    return ans

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"2343","class Solution {
 public:
  vector<int> smallestTrimmedNumbers(vector<string>& nums,
                                     vector<vector<int>>& queries) {
    vector<int> ans;
    for (const vector<int>& query : queries)
      ans.push_back(getKSmallestIndex(nums, query[0], query[1]));
    return ans;
  }

 private:
  int getKSmallestIndex(const vector<string>& nums, int k, int trim) {
    const int startIndex = nums[0].length() - trim;
    vector<pair<string, int>> trimmed;  // (num, index)

    for (int i = 0; i < nums.size(); ++i) {
      const string& num = nums[i];
      trimmed.push_back({num.substr(startIndex), i});
    }

    ranges::sort(trimmed);
    return trimmed[k - 1].second;
  }
};"
"2344","class Solution:
  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:
    gcd = functools.reduce(math.gcd, numsDivide)

    for i, num in enumerate(sorted(nums)):
      if gcd % num == 0:
        return i

    return -1"
"2345","class Solution:
  def visibleMountains(self, peaks: list[list[int]]) -> int:
    count = collections.Counter((x, y) for x, y in peaks)
    peaks = sorted([k for k, v in count.items() if v == 1])
    stack = []

    # Returns True if `peak1` is hidden by `peak2`
    def isHidden(peak1: list[int], peak2: list[int]) -> bool:
      x1, y1 = peak1
      x2, y2 = peak2
      return x1 - y1 >= x2 - y2 and x1 + y1 <= x2 + y2

    for i, peak in enumerate(peaks):
      while stack and isHidden(peaks[stack[-1]], peak):
        stack.pop()
      if stack and isHidden(peak, peaks[stack[-1]]):
        continue
      stack.append(i)

    return len(stack)"
"2346","SELECT
  student_id,
  department_id,
  ROUND(
    100 * PERCENT_RANK() OVER(
      PARTITION BY department_id
      ORDER BY mark DESC
    ),
    2
  ) AS percentage
FROM Students;"
"2347","class Solution:
  def bestHand(self, ranks: list[int], suits: list[str]) -> str:
    if all(suit == suits[0] for suit in suits):
      return 'Flush'

    match max(Counter(ranks).values()):
      case 5 | 4 | 3:
        return 'Three of a Kind'
      case 2:
        return 'Pair'
      case _:
        return 'High Card'"
"2348","class Solution:
  def zeroFilledSubarray(self, nums: list[int]) -> int:
    ans = 0
    indexBeforeZero = -1

    for i, num in enumerate(nums):
      if num:
        indexBeforeZero = i
      else:
        ans += i - indexBeforeZero

    return ans"
"2349","from sortedcontainers import SortedSet


class NumberContainers:
  def __init__(self):
    self.numberToIndices = collections.defaultdict(SortedSet)
    self.indexToNumber = {}

  def change(self, index: int, number: int) -> None:
    if index in self.indexToNumber:
      originalNumber = self.indexToNumber[index]
      self.numberToIndices[originalNumber].remove(index)
      if len(self.numberToIndices[originalNumber]) == 0:
        del self.numberToIndices[originalNumber]
    self.indexToNumber[index] = number
    self.numberToIndices[number].add(index)

  def find(self, number: int) -> int:
    if number in self.numberToIndices:
      return self.numberToIndices[number][0]
    return -1"
"235","class Solution:
  def lowestCommonAncestor(
      self,
      root: 'TreeNode',
      p: 'TreeNode',
      q: 'TreeNode',
  ) -> 'TreeNode':
    if root.val > max(p.val, q.val):
      return self.lowestCommonAncestor(root.left, p, q)
    if root.val < min(p.val, q.val):
      return self.lowestCommonAncestor(root.right, p, q)
    return root"
"2350","class Solution:
  def shortestSequence(self, rolls: list[int], k: int) -> int:
    ans = 1  # the the next target length
    seen = set()

    for roll in rolls:
      seen.add(roll)
      if len(seen) == k:
        # Have all combinations that form `ans` length, and we are going to
        # extend the sequence to `ans + 1` length.
        ans += 1
        seen.clear()

    return ans"
"2351","class Solution:
  def repeatedCharacter(self, s: str) -> str:
    seen = [False] * 26

    for c in s:
      if seen[string.ascii_lowercase.index(c)]:
        return c
      seen[string.ascii_lowercase.index(c)] = True"
"2352","class Solution:
  def equalPairs(self, grid: list[list[int]]) -> int:
    n = len(grid)
    ans = 0

    for i in range(n):
      for j in range(n):
        k = 0
        while k < n:
          if grid[i][k] != grid[k][j]:
            break
          k += 1
        if k == n:  # R[i] == C[j]
          ans += 1

    return ans"
"2353","from sortedcontainers import SortedSet


class FoodRatings:
  def __init__(self, foods: list[str], cuisines: list[str], ratings: list[int]):
    self.cuisineToRatingAndFoods = collections.defaultdict(
        lambda: SortedSet(key=lambda x: (-x[0], x[1])))
    self.foodToCuisine = {}
    self.foodToRating = {}

    for food, cuisine, rating in zip(foods, cuisines, ratings):
      self.cuisineToRatingAndFoods[cuisine].add((rating, food))
      self.foodToCuisine[food] = cuisine
      self.foodToRating[food] = rating

  def changeRating(self, food: str, newRating: int) -> None:
    cuisine = self.foodToCuisine[food]
    oldRating = self.foodToRating[food]
    ratingAndFoods = self.cuisineToRatingAndFoods[cuisine]
    ratingAndFoods.remove((oldRating, food))
    ratingAndFoods.add((newRating, food))
    self.foodToRating[food] = newRating

  def highestRated(self, cuisine: str) -> str:
    return self.cuisineToRatingAndFoods[cuisine][0][1]"
"2354","class Solution:
  def countExcellentPairs(self, nums: list[int], k: int) -> int:
    count = collections.Counter(map(int.bit_count, set(nums)))
    return sum(count[i] * count[j]
               for i in count
               for j in count
               if i + j >= k)"
"2355","class Solution:
  def maximumBooks(self, books: list[int]) -> int:
    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of
    # books[i]
    dp = [0] * len(books)
    stack = []  # the possible indices we can reach

    for i, book in enumerate(books):
      # We may take all of books[j], where books[j] < books[i] - (i - j).
      while stack and books[stack[-1]] >= book - (i - stack[-1]):
        stack.pop()
      # We can now take books[j + 1..i].
      j = stack[-1] if stack else -1
      lastPicked = book - (i - j) + 1
      if lastPicked > 1:
        # book + (book - 1) + ... + (book - (i - j) + 1)
        dp[i] = (book + lastPicked) * (i - j) // 2
      else:
        # 1 + 2 + ... + book
        dp[i] = book * (book + 1) // 2
      if j >= 0:
        dp[i] += dp[j]
      stack.append(i)

    return max(dp)"
"2356","SELECT
  teacher_id,
  COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY 1;"
"2357","class Solution:
  def minimumOperations(self, nums: list[int]) -> int:
    return len(set(nums) - {0})"
"2358","class Solution:
  def maximumGroups(self, grades: list[int]) -> int:
    # Sort grades, then we can seperate the students into groups of sizes 1, 2,
    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and
    # size. So, we can rephrase the problem into:
    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n

    #  1 + 2 + 3 + ... + k <= n
    #         k(k + 1) // 2 <= n
    #              k^2 + k <= 2n
    #   (k + 0.5)^2 - 0.25 <= 2n
    #          (k + 0.5)^2 <= 2n + 0.25
    #                    k <= sqrt(2n + 0.25) - 0.5
    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)"
"2359","class Solution:
  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:
    kMax = 10000
    dist1 = self._getDist(edges, node1)
    dist2 = self._getDist(edges, node2)
    minDist = kMax
    ans = -1

    for i, (d1, d2) in enumerate(zip(dist1, dist2)):
      if min(d1, d2) >= 0:
        maxDist = max(d1, d2)
        if maxDist < minDist:
          minDist = maxDist
          ans = i

    return ans

  def _getDist(self, edges: list[int], u: int) -> list[int]:
    dist = [-1] * len(edges)
    d = 0
    while u != -1 and dist[u] == -1:
      dist[u] = d
      d += 1
      u = edges[u]
    return dist"
"236","class Solution:
  def lowestCommonAncestor(
      self,
      root: 'TreeNode',
      p: 'TreeNode',
      q: 'TreeNode',
  ) -> 'TreeNode':
    if not root or root == p or root == q:
      return root
    left = self.lowestCommonAncestor(root.left, p, q)
    right = self.lowestCommonAncestor(root.right, p, q)
    if left and right:
      return root
    return left or right"
"2360","class Solution:
  def longestCycle(self, edges: list[int]) -> int:
    ans = -1
    time = 1
    timeVisited = [0] * len(edges)

    for i, edge in enumerate(edges):
      if timeVisited[i]:
        continue
      startTime = time
      u = i
      while u != -1 and not timeVisited[u]:
        timeVisited[u] = time
        time += 1
        u = edges[u]  # Move to the next node.
      if u != -1 and timeVisited[u] >= startTime:
        ans = max(ans, time - timeVisited[u])

    return ans"
"2361","class Solution:
  def minimumCosts(
      self,
      regular: list[int],
      express: list[int],
      expressCost: int,
  ) -> list[int]:
    n = len(regular)
    ans = [0] * n
    # the minimum cost to reach the current stop in a regular route
    dpReg = 0
    # the minimum cost to reach the current stop in an express route
    dpExp = expressCost

    for i in range(n):
      prevReg = dpReg
      prevExp = dpExp
      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])
      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])
      ans[i] = min(dpReg, dpExp)

    return ans"
"2362","WITH
  HighestPriceInvoice AS (
    SELECT
      Purchases.invoice_id,
      SUM(Purchases.quantity * Products.price) AS price
    FROM Purchases
    INNER JOIN Products
      USING (product_id)
    GROUP BY 1
    ORDER BY 2 DESC, 1
    LIMIT 1
  )
SELECT
  Products.product_id,
  Purchases.quantity,
  Purchases.quantity * Products.price AS price
FROM HighestPriceInvoice
INNER JOIN Purchases
  USING (invoice_id)
INNER JOIN Products
  USING (product_id);"
"2363","class Solution:
  def mergeSimilarItems(self, items1: list[list[int]],
                        items2: list[list[int]]) -> list[list[int]]:
    return sorted(
        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())"
"2364","class Solution:
  def countBadPairs(self, nums: list[int]) -> int:
    ans = 0
    count = collections.Counter()  # (nums[i] - i)

    for i, num in enumerate(nums):
      #     count[nums[i] - i] := the number of good pairs
      # i - count[nums[i] - i] := the number of bad pairs
      ans += i - count[num - i]
      count[num - i] += 1

    return ans"
"2365","class Solution:
  def taskSchedulerII(self, tasks: list[int], space: int) -> int:
    taskToNextAvailable = collections.defaultdict(int)
    ans = 0

    for task in tasks:
      ans = max(ans + 1, taskToNextAvailable[task])
      taskToNextAvailable[task] = ans + space + 1

    return ans"
"2366","class Solution:
  def minimumReplacement(self, nums: list[int]) -> int:
    ans = 0
    mx = nums[-1]

    for i in range(len(nums) - 2, -1, -1):
      ops = (nums[i] - 1) // mx
      ans += ops
      mx = nums[i] // (ops + 1)

    return ans"
"2367","class Solution:
  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:
    kMax = 200
    ans = 0
    count = [False] * (kMax + 1)

    for num in nums:
      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:
        ans += 1
      count[num] = True

    return ans"
"2368","class Solution:
  def reachableNodes(
      self,
      n: int,
      edges: list[list[int]],
      restricted: list[int],
  ) -> int:
    tree = [[] for _ in range(n)]
    seen = set(restricted)

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int) -> int:
      if u in seen:
        return 0
      seen.add(u)
      return 1 + sum(dfs(v) for v in tree[u])

    return dfs(0)"
"2369","class Solution:
  def validPartition(self, nums: list[int]) -> bool:
    n = len(nums)
    # dp[i] := True if there's a valid partition for the first i numbers
    dp = [False] * (n + 1)
    dp[0] = True
    dp[2] = nums[0] == nums[1]

    for i in range(3, n + 1):
      dp[i] = (
          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (
          dp[i - 3]
          and (
              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])
              or (
                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums
                  [i - 1])))

    return dp[n]"
"237","class Solution:
  def deleteNode(self, node):
    node.val = node.next.val
    node.next = node.next.next"
"2370","class Solution:
  def longestIdealString(self, s: str, k: int) -> int:
    # dp[i] := the longest subsequence that ends in ('a' + i)
    dp = [0] * 26

    for c in s:
      i = string.ascii_lowercase.index(c)
      dp[i] = 1 + self._getMaxReachable(dp, i, k)

    return max(dp)

  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:
    first = max(0, i - k)
    last = min(25, i + k)
    maxReachable = 0
    for j in range(first, last + 1):
      maxReachable = max(maxReachable, dp[j])
    return maxReachable"
"2371","class Solution:
  def minScore(self, grid: list[list[int]]) -> list[list[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    valAndIndices = []
    rows = [0] * m  # rows[i] := the maximum used number so far
    cols = [0] * n  # cols[j] := the maximum used number so far

    for i in range(m):
      for j in range(n):
        valAndIndices.append((grid[i][j], i, j))

    valAndIndices.sort()

    for _, i, j in valAndIndices:
      nextAvailable = max(rows[i], cols[j]) + 1
      ans[i][j] = nextAvailable
      rows[i] = nextAvailable
      cols[j] = nextAvailable

    return ans"
"2372","SELECT
  Salesperson.salesperson_id,
  Salesperson.name,
  SUM(IFNULL(Sales.price, 0)) AS total
FROM Salesperson
LEFT JOIN Customer
  USING (salesperson_id)
LEFT JOIN Sales
  USING (customer_id)
GROUP BY 1;"
"2373","class Solution:
  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:
    n = len(grid)
    ans = [[0] * (n - 2) for _ in range(n - 2)]

    for i in range(n - 2):
      for j in range(n - 2):
        for x in range(i, i + 3):
          for y in range(j, j + 3):
            ans[i][j] = max(ans[i][j], grid[x][y])

    return ans"
"2374","class Solution:
  def edgeScore(self, edges: list[int]) -> int:
    scores = [0] * len(edges)
    for i, edge in enumerate(edges):
      scores[edge] += i
    return scores.index(max(scores))"
"2375","class Solution:
  def smallestNumber(self, pattern: str) -> str:
    ans = []
    stack = ['1']

    for c in pattern:
      maxSorFar = stack[-1]
      if c == 'I':
        while stack:
          maxSorFar = max(maxSorFar, stack[-1])
          ans.append(stack.pop())
      stack.append(chr(ord(maxSorFar) + 1))

    while stack:
      ans.append(stack.pop())

    return ''.join(ans)"
"2376","class Solution:
  # Same as 1012. Numbers With Repeated Digits
  def countSpecialNumbers(self, n: int) -> int:
    s = str(n)

    @functools.lru_cache(None)
    def dp(i: int, used: int, isTight: bool) -> int:
      """"""
      Returns the number of special integers, considering the i-th digit, where
      `used` is the bitmask of the used digits, and `isTight` indicates if the
      current digit is tightly bound.
      """"""
      if i == len(s):
        return 1

      res = 0
      maxDigit = int(s[i]) if isTight else 9

      for d in range(maxDigit + 1):
        # `d` is used.
        if used >> d & 1:
          continue
        # Use `d` now.
        nextIsTight = isTight and (d == maxDigit)
        if used == 0 and d == 0:  # Don't count leading 0s as used.
          res += dp(i + 1, used, nextIsTight)
        else:
          res += dp(i + 1, used | 1 << d, nextIsTight)

      return res

    return dp(0, 0, True) - 1  # - 0"
"2377","SELECT
  country,
  gold_medals,
  silver_medals,
  bronze_medals
FROM Olympic
ORDER BY
  gold_medals DESC,
  silver_medals DESC,
  bronze_medals DESC,
  country;"
"2378","class Solution:
  def maxScore(self, edges: list[list[int]]) -> int:
    n = len(edges)
    graph = [[] for _ in range(n)]

    for i, (parent, weight) in enumerate(edges):
      if parent != -1:
        graph[parent].append((i, weight))

    takeRoot, notTakeRoot = self._dfs(graph, 0)
    return max(takeRoot, notTakeRoot)

  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:
    """"""
    Returns (the maximum sum at u if we take one u->v edge,
             the maximum sum at u if we don't take any child edge).
    """"""
    bestEdge = 0
    notTakeU = 0

    for v, w in graph[u]:
      takeV, notTakeV = self._dfs(graph, v)
      bestEdge = max(bestEdge, w + notTakeV - takeV)
      notTakeU += takeV

    return (bestEdge + notTakeU, notTakeU)"
"2379","class Solution:
  def minimumRecolors(self, blocks: str, k: int) -> int:
    countB = 0
    maxCountB = 0

    for i, block in enumerate(blocks):
      if block == 'B':
        countB += 1
      if i >= k and blocks[i - k] == 'B':
        countB -= 1
      maxCountB = max(maxCountB, countB)

    return k - maxCountB"
"238","class Solution:
  def productExceptSelf(self, nums: list[int]) -> list[int]:
    n = len(nums)
    ans = [1] * n

    # Use ans as the prefix product array.
    for i in range(1, n):
      ans[i] = ans[i - 1] * nums[i - 1]

    suffix = 1  # suffix product
    for i, num in reversed(list(enumerate(nums))):
      ans[i] *= suffix
      suffix *= num

    return ans"
"2380","class Solution:
  def secondsToRemoveOccurrences(self, s: str) -> int:
    ans = 0
    zeros = 0

    for c in s:
      if c == '0':
        zeros += 1
      elif zeros > 0:  # c == '1'
        ans = max(ans + 1, zeros)

    return ans"
"2381","class Solution:
  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:
    ans = []
    currShift = 0
    timeline = [0] * (len(s) + 1)

    for start, end, direction in shifts:
      diff = 1 if direction else -1
      timeline[start] += diff
      timeline[end + 1] -= diff

    for i, c in enumerate(s):
      currShift = (currShift + timeline[i]) % 26
      num = (string.ascii_lowercase.index(c) + currShift + 26) % 26
      ans.append(chr(ord('a') + num))

    return ''.join(ans)"
"2382","class Solution:
  def maximumSegmentSum(
      self,
      nums: list[int],
      removeQueries: list[int],
  ) -> list[int]:
    n = len(nums)
    maxSum = 0
    ans = [0] * n
    # For the segment [l, r], record its sum in summ[l] and summ[r]
    summ = [0] * n
    # For the segment [l, r], record its count in count[l] and count[r]
    count = [0] * n

    for i in reversed(range(n)):
      ans[i] = maxSum
      j = removeQueries[i]

      # Calculate `segmentSum`.
      leftSum = summ[j - 1] if j > 0 else 0
      rightSum = summ[j + 1] if j + 1 < n else 0
      segmentSum = nums[j] + leftSum + rightSum

      # Calculate `segmentCount`.
      leftCount = count[j - 1] if j > 0 else 0
      rightCount = count[j + 1] if j + 1 < n else 0
      segmentCount = 1 + leftCount + rightCount

      # Update `summ` and `count` of the segment [l, r].
      l = j - leftCount
      r = j + rightCount
      summ[l] = segmentSum
      summ[r] = segmentSum
      count[l] = segmentCount
      count[r] = segmentCount
      maxSum = max(maxSum, segmentSum)

    return ans"
"2383","class Solution:
  def minNumberOfHours(
      self,
      initialEnergy: int,
      initialExperience: int,
      energy: list[int],
      experience: list[int],
  ) -> int:
    return (self._getRequiredEnergy(initialEnergy, energy) +
            self._getRequiredExperience(initialExperience, experience))

  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:
    return max(0, sum(energy) + 1 - initialEnergy)

  def _getRequiredExperience(
      self,
      currentExperience: int,
      experience: list[int],
  ) -> int:
    requiredExperience = 0
    for e in experience:
      if e >= currentExperience:
        requiredExperience += e + 1 - currentExperience
        currentExperience += e + 1 - currentExperience
      currentExperience += e
    return requiredExperience"
"2384","class Solution:
  def largestPalindromic(self, num: str) -> str:
    count = collections.Counter(num)
    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')
    mid = self._getMid(count)
    return (firstHalf + mid + firstHalf[::-1]) or '0'

  def _getMid(self, count: dict[str, int]) -> str:
    for c in '9876543210':
      if count[c] & 1:
        return c
    return ''"
"2385","class Solution:
  def amountOfTime(self, root: TreeNode | None, start: int) -> int:
    ans = -1
    graph = self._getGraph(root)
    q = collections.deque([start])
    seen = {start}

    while q:
      ans += 1
      for _ in range(len(q)):
        u = q.popleft()
        if u not in graph:
          continue
        for v in graph[u]:
          if v in seen:
            continue
          q.append(v)
          seen.add(v)

    return ans

  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:
    graph = collections.defaultdict(list)
    q = collections.deque([(root, -1)])  # (node, parent)

    while q:
      node, parent = q.popleft()
      if parent != -1:
        graph[parent].append(node.val)
        graph[node.val].append(parent)
      if node.left:
        q.append((node.left, node.val))
      if node.right:
        q.append((node.right, node.val))

    return graph"
"2386","class Solution:
  def kSum(self, nums: list[int], k: int) -> int:
    maxSum = sum(num for num in nums if num > 0)
    absNums = sorted(abs(num) for num in nums)
    # (the next maximum sum, the next index i)
    maxHeap = [(-(maxSum - absNums[0]), 0)]
    nextMaxSum = maxSum

    for _ in range(k - 1):
      nextMaxSum, i = heapq.heappop(maxHeap)
      nextMaxSum *= -1
      if i + 1 < len(absNums):
        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))
        heapq.heappush(
            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))

    return nextMaxSum"
"2387","class Solution:
  def matrixMedian(self, grid: list[list[int]]) -> int:
    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1
    l = 1
    r = int(1e6)

    while l < r:
      m = (l + r) // 2
      if (sum(bisect.bisect_right(row, m) for row in grid) >=
              noGreaterThanMedianCount):
        r = m
      else:
        l = m + 1

    return l"
"2388","WITH
  CoffeeShoptWithRowNumber AS (
    SELECT *, ROW_NUMBER() OVER() AS `row_number`
    FROM CoffeeShop
  ),
  CoffeeShoptWithRowNumberAndGroupId AS (
    SELECT
      *,
      SUM(drink IS NOT NULL) OVER(
        ORDER BY `row_number`
      ) AS group_id
    FROM CoffeeShoptWithRowNumber
  )
SELECT
  id,
  FIRST_VALUE(drink) OVER(
    PARTITION by group_id
    ORDER BY `row_number`
  ) AS drink
FROM CoffeeShoptWithRowNumberAndGroupId;"
"2389","class Solution:
  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:
    nums.sort()

    def numOfElementsLessThan(query: int) -> int:
      summ = 0
      for i, num in enumerate(nums):
        summ += num
        if summ > query:
          return i
      return len(nums)

    return [numOfElementsLessThan(query) for query in queries]"
"239","class Solution:
  def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:
    ans = []
    maxQ = collections.deque()

    for i, num in enumerate(nums):
      while maxQ and maxQ[-1] < num:
        maxQ.pop()
      maxQ.append(num)
      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds
        maxQ.popleft()
      if i >= k - 1:
        ans.append(maxQ[0])

    return ans"
"2390","class Solution:
  def removeStars(self, s: str) -> str:
    ans = []
    for c in s:
      if c == '*':
        ans.pop()
      else:
        ans.append(c)
    return ''.join(ans)"
"2391","class Solution:
  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:
    prefix = list(itertools.accumulate(travel))

    def getTime(c: str) -> int:
      characterCount = 0
      lastIndex = -1
      for i, s in enumerate(garbage):
        if any(g == c for g in s):
          lastIndex = i
        characterCount += s.count(c)
      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])

    return getTime('M') + getTime('P') + getTime('G')"
"2392","class Solution:
  def buildMatrix(self, k: int, rowConditions: list[list[int]],
                  colConditions: list[list[int]]) -> list[list[int]]:
    rowOrder = self._topologicalSort(rowConditions, k)
    if not rowOrder:
      return []

    colOrder = self._topologicalSort(colConditions, k)
    if not colOrder:
      return []

    ans = [[0] * k for _ in range(k)]
    nodeToRowIndex = [0] * (k + 1)

    for i, node in enumerate(rowOrder):
      nodeToRowIndex[node] = i

    for j, node in enumerate(colOrder):
      i = nodeToRowIndex[node]
      ans[i][j] = node

    return ans

  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:
    order = []
    graph = [[] for _ in range(n + 1)]
    inDegrees = [0] * (n + 1)

    # Build the graph.
    for u, v in conditions:
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])

    while q:
      u = q.popleft()
      order.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return order if len(order) == n else []"
"2393","class Solution:
  def countSubarrays(self, nums: list[int]) -> int:
    ans = 0

    j = -1
    for i, num in enumerate(nums):
      if i > 0 and num <= nums[i - 1]:
        j = i - 1
      ans += i - j

    return ans"
"2394","SELECT Employees.employee_id
FROM Employees
LEFT JOIN Logs
  USING (employee_id)
GROUP BY Employees.employee_id, Employees.needed_hours
HAVING (
    SUM(
      CEIL(
        IFNULL(
          TIMESTAMPDIFF(SECOND, LOGS.in_time, LOGS.out_time),
          0
        ) / 60
      )
    ) / 60
  ) < Employees.needed_hours;"
"2395","class Solution:
  def findSubarrays(self, nums: list[int]) -> bool:
    seen = set()

    for a, b in zip(nums, nums[1:]):
      summ = a + b
      if summ in seen:
        return True
      seen.add(summ)

    return False"
"2396","class Solution:
  def isStrictlyPalindromic(self, n: int) -> bool:
    return False"
"2397","class Solution:
  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:
    ans = 0

    def dfs(colIndex: int, leftColsCount: int, mask: int):
      nonlocal ans
      if leftColsCount == 0:
        ans = max(ans, self._getAllZerosRowCount(matrix, mask))
        return

      if colIndex == len(matrix[0]):
        return

      # Choose this column.
      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)
      # Don't choose this column.
      dfs(colIndex + 1, leftColsCount, mask)

    dfs(0, numSelect, 0)
    return ans

  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:
    count = 0
    for row in matrix:
      isAllZeros = True
      for i, num in enumerate(row):
        if num == 1 and (mask >> i & 1) == 0:
          isAllZeros = False
          break
      if isAllZeros:
        count += 1
    return count"
"2398","class Solution:
  def maximumRobots(
      self,
      chargeTimes: list[int],
      runningCosts: list[int],
      budget: int,
  ) -> int:
    cost = 0
    maxQ = collections.deque()  # Stores `chargeTimes[i]`.

    j = 0  # window's range := [i..j], so k = i - j + 1
    for i, (chargeTime, runningCost) in enumerate(
            zip(chargeTimes, runningCosts)):
      cost += runningCost
      while maxQ and maxQ[-1] < chargeTime:
        maxQ.pop()
      maxQ.append(chargeTime)
      if maxQ[0] + (i - j + 1) * cost > budget:
        if maxQ[0] == chargeTimes[j]:
          maxQ.popleft()
        cost -= runningCosts[j]
        j += 1

    return len(chargeTimes) - j"
"2399","class Solution:
  def checkDistances(self, s: str, distance: list[int]) -> bool:
    firstSeenIndex = [-1] * 26

    for i, c in enumerate(s):
      j = string.ascii_lowercase.index(c)
      prevIndex = firstSeenIndex[j]
      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:
        return False
      firstSeenIndex[j] = i

    return True"
"24","class Solution:
  def swapPairs(self, head: ListNode) -> ListNode:
    def getLength(head: ListNode) -> int:
      length = 0
      while head:
        length += 1
        head = head.next
      return length

    length = getLength(head)
    dummy = ListNode(0, head)
    prev = dummy
    curr = head

    for _ in range(length // 2):
      next = curr.next
      curr.next = next.next
      next.next = prev.next
      prev.next = next
      prev = curr
      curr = curr.next

    return dummy.next"
"240","class Solution:
  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:
    r = 0
    c = len(matrix[0]) - 1

    while r < len(matrix) and c >= 0:
      if matrix[r][c] == target:
        return True
      if target < matrix[r][c]:
        c -= 1
      else:
        r += 1

    return False"
"2400","class Solution:
  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
    # leftStep + rightStep = k
    # rightStep - leftStep = endPos - startPos
    #        2 * rightStep = k + endPos - startPos
    #            rightStep = (k + endPos - startPos) // 2
    val = k + endPos - startPos
    if val < 0 or val % 2 == 1:
      return 0
    rightStep = val // 2
    leftStep = k - rightStep
    if leftStep < 0:
      return 0
    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))

  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)
  def _nCk(self, n: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := C(n so far, i)
    dp = [1] + [0] * k

    for _ in range(n):  # Calculate n times.
      for j in range(k, 0, -1):
        dp[j] += dp[j - 1]
        dp[j] %= kMod

    return dp[k]"
"2401","class Solution:
  def longestNiceSubarray(self, nums: list[int]) -> int:
    ans = 0
    used = 0

    l = 0
    for r, num in enumerate(nums):
      while used & num:
        used ^= nums[l]
        l += 1
      used |= num
      ans = max(ans, r - l + 1)

    return ans"
"2402","class Solution:
  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:
    count = [0] * n

    meetings.sort()

    occupied = []  # (endTime, roomId)
    availableRoomIds = [i for i in range(n)]
    heapq.heapify(availableRoomIds)

    for start, end in meetings:
      # Push meetings ending before this `meeting` in occupied to the
      # `availableRoomsIds`.
      while occupied and occupied[0][0] <= start:
        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])
      if availableRoomIds:
        roomId = heapq.heappop(availableRoomIds)
        count[roomId] += 1
        heapq.heappush(occupied, (end, roomId))
      else:
        newStart, roomId = heapq.heappop(occupied)
        count[roomId] += 1
        heapq.heappush(occupied, (newStart + (end - start), roomId))

    return count.index(max(count))"
"2403","class Solution:
  def minimumTime(self, power: list[int]) -> int:
    n = len(power)
    maxMask = 1 << n
    # dp[i] := the minimum number of days needed to defeat the monsters, where
    # i is the bitmask of the monsters
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(1, maxMask):
      currentGain = mask.bit_count()
      for i in range(n):
        if mask >> i & 1:
          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +
                         int(math.ceil(power[i] / currentGain)))

    return dp[-1]"
"2404","class Solution:
  def mostFrequentEven(self, nums: list[int]) -> int:
    ans = -1
    count = collections.Counter()

    for num in nums:
      if num % 2 == 1:
        continue
      count[num] += 1
      newCount = count[num]
      maxCount = count[ans]
      if newCount > maxCount or newCount == maxCount and num < ans:
        ans = num

    return ans"
"2405","class Solution:
  def partitionString(self, s: str) -> int:
    ans = 1
    used = 0

    for c in s:
      i = string.ascii_lowercase.index(c)
      if used >> i & 1:
        used = 1 << i
        ans += 1
      else:
        used |= 1 << i

    return ans"
"2406","class Solution:
  # Similar to 253. Meeting Rooms II
  def minGroups(self, intervals: list[list[int]]) -> int:
    minHeap = []  # Stores `right`s.

    for left, right in sorted(intervals):
      # There's no overlap, so we can reuse the same group.
      if minHeap and left > minHeap[0]:
        heapq.heappop(minHeap)
      heapq.heappush(minHeap, right)

    return len(minHeap)"
"2407","struct SegmentTreeNode {
  int lo;
  int hi;
  int maxLength;
  std::unique_ptr<SegmentTreeNode> left;
  std::unique_ptr<SegmentTreeNode> right;
  // maxLength := the maximum length of LIS ending in [lo..hi]
  SegmentTreeNode(int lo, int hi, int maxLength,
                  std::unique_ptr<SegmentTreeNode> left = nullptr,
                  std::unique_ptr<SegmentTreeNode> right = nullptr)
      : lo(lo),
        hi(hi),
        maxLength(maxLength),
        left(std::move(left)),
        right(std::move(right)) {}
};

class SegmentTree {
 public:
  explicit SegmentTree() : root(make_unique<SegmentTreeNode>(0, 1e5 + 1, 0)) {}

  void updateRange(int i, int j, int maxLength) {
    update(root, i, j, maxLength);
  }

  // Returns the maximum length of LIS ending in [i..j].
  int queryRange(int i, int j) {
    return query(root, i, j);
  }

 private:
  std::unique_ptr<SegmentTreeNode> root;

  void update(std::unique_ptr<SegmentTreeNode>& root, int i, int j,
              int maxLength) {
    if (root->lo == i && root->hi == j) {
      root->maxLength = maxLength;
      root->left = nullptr;
      root->right = nullptr;
      return;
    }
    const int mid = root->lo + (root->hi - root->lo) / 2;
    if (root->left == nullptr) {
      root->left = make_unique<SegmentTreeNode>(root->lo, mid, root->maxLength);
      root->right =
          make_unique<SegmentTreeNode>(mid + 1, root->hi, root->maxLength);
    }
    if (j <= mid)
      update(root->left, i, j, maxLength);
    else if (i > mid)
      update(root->right, i, j, maxLength);
    else {
      update(root->left, i, mid, maxLength);
      update(root->right, mid + 1, j, maxLength);
    }
    root->maxLength = merge(root->left->maxLength, root->right->maxLength);
  }

  int query(std::unique_ptr<SegmentTreeNode>& root, int i, int j) {
    if (root->left == nullptr)
      return root->maxLength;
    if (root->lo == i && root->hi == j)
      return root->maxLength;
    const int mid = root->lo + (root->hi - root->lo) / 2;
    if (j <= mid)
      return query(root->left, i, j);
    if (i > mid)
      return query(root->right, i, j);
    return merge(query(root->left, i, mid), query(root->right, mid + 1, j));
  }

  int merge(int left, int right) const {
    return max(left, right);
  };
};

class Solution {
 public:
  int lengthOfLIS(vector<int>& nums, int k) {
    int ans = 1;
    SegmentTree tree;

    for (const int num : nums) {
      const int left = max(1, num - k);
      const int right = num - 1;
      // the maximum length of LIS ending in [left..right] + the current number
      const int maxLength = tree.queryRange(left, right) + 1;
      ans = max(ans, maxLength);
      tree.updateRange(num, num, maxLength);
    }

    return ans;
  }
};"
"2408","class SQL:
  def __init__(self, names: list[str], columns: list[int]):
    self.db: dict[str, list[list[str]]] = collections.defaultdict(list)

  def insertRow(self, name: str, row: list[str]) -> None:
    self.db[name].append(row)

  def deleteRow(self, name: str, rowId: int) -> None:
    pass

  def selectCell(self, name: str, rowId: int, columnId: int) -> str:
    return self.db[name][rowId - 1][columnId - 1]"
"2409","class Solution:
  def countDaysTogether(
      self,
      arriveAlice: str,
      leaveAlice: str,
      arriveBob: str,
      leaveBob: str,
  ) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def toDays(s: str) -> int:
      month = int(s[:2])
      day = int(s[3:])
      prevDays = 0
      for m in range(1, month):
        prevDays += days[m]
      return prevDays + day

    arriveA = toDays(arriveAlice)
    leaveA = toDays(leaveAlice)
    arriveB = toDays(arriveBob)
    leaveB = toDays(leaveBob)
    ans = 0

    for day in range(1, 366):
      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:
        ans += 1

    return ans"
"241","class Solution:
  @functools.lru_cache(None)
  def diffWaysToCompute(self, expression: str) -> list[int]:
    ans = []

    for i, c in enumerate(expression):
      if c in '+-*':
        for a in self.diffWaysToCompute(expression[:i]):
          for b in self.diffWaysToCompute(expression[i + 1:]):
            ans.append(eval(str(a) + c + str(b)))

    return ans or [int(expression)]"
"2410","class Solution:
  def matchPlayersAndTrainers(
      self,
      players: list[int],
      trainers: list[int],
  ) -> int:
    ans = 0

    players.sort()
    trainers.sort()

    for i, trainer in enumerate(trainers):
      if players[ans] <= trainer:
        ans += 1
        if ans == len(players):
          return ans

    return ans"
"2411","class Solution:
  def smallestSubarrays(self, nums: list[int]) -> list[int]:
    kMaxBit = 30
    ans = [1] * len(nums)
    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1
    closest = [0] * kMaxBit

    for i in reversed(range(len(nums))):
      for j in range(kMaxBit):
        if nums[i] >> j & 1:
          closest[j] = i
        ans[i] = max(ans[i], closest[j] - i + 1)

    return ans"
"2412","class Solution:
  def minimumMoney(self, transactions: list[list[int]]) -> int:
    ans = 0
    losses = 0

    # Before picking the final transaction, perform any transaction that raises
    # the required money.
    for cost, cashback in transactions:
      losses += max(0, cost - cashback)

    # Now, pick a transaction to be the final one.
    for cost, cashback in transactions:
      if cost > cashback:
        # The losses except this transaction: losses - (cost - cashback), so
        # add the cost of this transaction = losses - (cost - cashback) + cost.
        ans = max(ans, losses + cashback)
      else:
        # The losses except this transaction: losses, so add the cost of this
        # transaction = losses + cost.
        ans = max(ans, losses + cost)

    return ans"
"2413","class Solution:
  def smallestEvenMultiple(self, n: int) -> int:
    return n * (n % 2 + 1)"
"2414","class Solution:
  def longestContinuousSubstring(self, s: str) -> int:
    ans = 1
    runningLen = 1

    for a, b in zip(s, s[1:]):
      if ord(a) + 1 == ord(b):
        runningLen += 1
        ans = max(ans, runningLen)
      else:
        runningLen = 1

    return ans"
"2415","class Solution:
  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:
    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:
      if not left:
        return
      if isOddLevel:
        left.val, right.val = right.val, left.val
      dfs(left.left, right.right, not isOddLevel)
      dfs(left.right, right.left, not isOddLevel)

    dfs(root.left, root.right, True)
    return root"
"2416","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.count = 0


class Solution:
  def sumPrefixScores(self, words: list[str]) -> list[int]:
    root = TrieNode()

    def insert(word: str) -> None:
      node: TrieNode = root
      for c in word:
        node = node.children.setdefault(c, TrieNode())
        node.count += 1

    for word in words:
      insert(word)

    def getScore(word: str) -> int:
      node: TrieNode = root
      score = 0
      for c in word:
        node = node.children[c]
        score += node.count
      return score

    return [getScore(word) for word in words]"
"2417","class Solution:
  def closestFair(self, n: int) -> int:
    digitsCount = len(str(n))
    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else
            self._getOddDigits(digitsCount))

  def _getOddDigits(self, digitsCount: int) -> int:
    zeros = (digitsCount + 1) // 2
    ones = (digitsCount - 1) // 2
    return int('1' + '0' * zeros + '1' * ones)

  def _getEvenDigits(self, n: int) -> int:
    digitsCount = len(str(n))
    maxNum = int('1' + '0' * digitsCount)
    for num in range(n, maxNum):
      if self._isValidNum(num):
        return num
    return self._getOddDigits(digitsCount + 1)

  def _isValidNum(self, num: int) -> bool:
    count = 0
    for c in str(num):
      count += 1 if int(c) % 2 == 0 else -1
    return count == 0"
"2418","class Solution:
  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:
    return [height for _, height in
            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]"
"2419","class Solution:
  def longestSubarray(self, nums: list[int]) -> int:
    ans = 0
    maxIndex = 0
    sameNumLength = 0

    for i, num in enumerate(nums):
      if nums[i] == nums[maxIndex]:
        sameNumLength += 1
        ans = max(ans, sameNumLength)
      elif nums[i] > nums[maxIndex]:
        maxIndex = i
        sameNumLength = 1
        ans = 1
      else:
        sameNumLength = 0

    return ans"
"242","class Solution:
  def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
      return False

    count = collections.Counter(s)
    count.subtract(collections.Counter(t))
    return all(freq == 0 for freq in count.values())"
"2420","class Solution:
  # Same as 2100. Find Good Days to Rob the Bank
  def goodIndices(self, nums: list[int], k: int) -> list[int]:
    n = len(nums)
    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i
    inc = [1] * n  # 1 + the number of continuous increasing numbers after i

    for i in range(1, n):
      if nums[i - 1] >= nums[i]:
        dec[i] = dec[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if nums[i] <= nums[i + 1]:
        inc[i] = inc[i + 1] + 1

    return [i for i in range(k, n - k)
            if dec[i - 1] >= k and inc[i + 1] >= k]"
"2421","class UnionFind {
  public UnionFind(int n) {
    id = new int[n];
    rank = new int[n];
    for (int i = 0; i < n; ++i)
      id[i] = i;
  }

  public void unionByRank(int u, int v) {
    final int i = find(u);
    final int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  public int find(int u) {
    return id[u] == u ? u : (id[u] = find(id[u]));
  }

  private int[] id;
  private int[] rank;
}

class Solution {
  public int numberOfGoodPaths(int[] vals, int[][] edges) {
    final int n = vals.length;
    int ans = n;
    UnionFind uf = new UnionFind(n);
    List<Integer>[] tree = new List[n];
    Map<Integer, List<Integer>> valToNodes = new TreeMap<>();

    for (int i = 0; i < n; ++i)
      tree[i] = new ArrayList<>();

    for (int[] edge : edges) {
      final int u = edge[0];
      final int v = edge[1];
      if (vals[v] <= vals[u])
        tree[u].add(v);
      if (vals[u] <= vals[v])
        tree[v].add(u);
    }

    for (int i = 0; i < vals.length; ++i) {
      valToNodes.putIfAbsent(vals[i], new ArrayList<>());
      valToNodes.get(vals[i]).add(i);
    }

    for (Map.Entry<Integer, List<Integer>> entry : valToNodes.entrySet()) {
      final int val = entry.getKey();
      List<Integer> nodes = entry.getValue();
      for (final int u : nodes)
        for (final int v : tree[u])
          uf.unionByRank(u, v);
      Map<Integer, Integer> rootCount = new HashMap<>();
      for (final int u : nodes)
        rootCount.merge(uf.find(u), 1, Integer::sum);
      // For each group, C(count, 2) := count * (count - 1) / 2
      for (final int count : rootCount.values())
        ans += count * (count - 1) / 2;
    }

    return ans;
  }
}"
"2422","class Solution:
  def minimumOperations(self, nums: list[int]) -> int:
    ans = 0
    l = 0
    r = len(nums) - 1
    leftSum = nums[0]
    rightSum = nums[-1]

    while l < r:
      if leftSum < rightSum:
        l += 1
        leftSum += nums[l]
        ans += 1
      elif leftSum > rightSum:
        r -= 1
        rightSum += nums[r]
        ans += 1
      else:  # leftSum == rightSum
        l += 1
        r -= 1
        leftSum = nums[l]
        rightSum = nums[r]

    return ans"
"2423","class Solution:
  def equalFrequency(self, word: str) -> bool:
    count = collections.Counter(word)

    # Try to remove each letter, then check if the frequency of all the letters
    # in `word` are equal.
    for c in word:
      count[c] -= 1
      if count[c] == 0:
        del count[c]
      if min(count.values()) == max(count.values()):
        return True
      count[c] += 1

    return False"
"2424","class LUPrefix:
  def __init__(self, n: int):
    self.seen = set()
    self.longestPrefix = 0

  def upload(self, video: int) -> None:
    self.seen.add(video)
    while self.longestPrefix + 1 in self.seen:
      self.longestPrefix += 1

  def longest(self) -> int:
    return self.longestPrefix"
"2425","class Solution:
  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:
    xors1 = functools.reduce(operator.xor, nums1)
    xors2 = functools.reduce(operator.xor, nums2)
    # If the size of nums1 is m and the size of nums2 is n, then each number in
    # nums1 is repeated n times and each number in nums2 is repeated m times.
    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)"
"2426","class Solution {
 public:
  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {
    // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff
    // nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff
    // Define A[i] := nums1[i] - nums2[i] -> A[i] <= A[j] + diff
    vector<int> A;

    for (int i = 0; i < nums1.size(); ++i)
      A.push_back(nums1[i] - nums2[i]);

    long ans = 0;
    mergeSort(A, 0, A.size() - 1, diff, ans);
    return ans;
  }

 private:
  void mergeSort(vector<int>& A, int l, int r, int diff, long& ans) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(A, l, m, diff, ans);
    mergeSort(A, m + 1, r, diff, ans);
    merge(A, l, m, r, diff, ans);
  }

  void merge(vector<int>& A, int l, int m, int r, int diff, long& ans) {
    const int lo = m + 1;
    int hi = m + 1;  // the first index s.t. A[i] <= A[hi] + diff

    // For each index i in the range [l, m], add `r - hi + 1` to `ans`.
    for (int i = l; i <= m; ++i) {
      while (hi <= r && A[i] > A[hi] + diff)
        ++hi;
      ans += r - hi + 1;
    }

    vector<int> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (A[i] < A[j])
        sorted[k++] = A[i++];
      else
        sorted[k++] = A[j++];

    // Put the possible remaining left part into the sorted array.
    while (i <= m)
      sorted[k++] = A[i++];

    // Put the possible remaining right part into the sorted array.
    while (j <= r)
      sorted[k++] = A[j++];

    copy(sorted.begin(), sorted.end(), A.begin() + l);
  }
};"
"2427","class Solution:
  def commonFactors(self, a: int, b: int) -> int:
    gcd = math.gcd(a, b)
    return sum(a % i == 0 and b % i == 0
               for i in range(1, gcd + 1))"
"2428","class Solution:
  def maxSum(self, grid: list[list[int]]) -> int:
    return max(
        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +
        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]
        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))"
"2429","class Solution:
  def minimizeXor(self, num1: int, num2: int) -> int:
    kMaxBit = 30
    bits = num2.bit_count()
    # Can turn off all the bits in `num1`.
    if num1.bit_count() == bits:
      return num1

    ans = 0

    # Turn off the MSB if we have `bits` quota.
    for i in reversed(range(kMaxBit)):
      if num1 >> i & 1:
        ans |= 1 << i
        bits -= 1
        if bits == 0:
          return ans

    # Turn on the LSB if we still have `bits`.
    for i in range(kMaxBit):
      if (num1 >> i & 1) == 0:
        ans |= 1 << i
        bits -= 1
        if bits == 0:
          return ans

    return ans"
"243","class Solution:
  def shortestDistance(
      self,
      wordsDict: list[str],
      word1: str,
      word2: str,
  ) -> int:
    ans = len(wordsDict)
    index1 = -1  # wordsdict[index1] == word1
    index2 = -1  # wordsdict[index2] == word2

    for i, word in enumerate(wordsDict):
      if word == word1:
        index1 = i
        if index2 != -1:
          ans = min(ans, index1 - index2)
      if word == word2:
        index2 = i
        if index1 != -1:
          ans = min(ans, index2 - index1)

    return ans"
"2430","class Solution:
  def deleteString(self, s: str) -> int:
    n = len(s)
    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)
    lcs = [[0] * (n + 1) for _ in range(n + 1)]
    # dp[i] := the maximum number of operations needed to delete s[i..n)
    dp = [1] * n

    for i in reversed(range(n)):
      for j in range(i + 1, n):
        if s[i] == s[j]:
          lcs[i][j] = lcs[i + 1][j + 1] + 1
        if lcs[i][j] >= j - i:
          dp[i] = max(dp[i], dp[j] + 1)

    return dp[0]"
"2431","class Solution:
  def maxTastiness(
      self,
      price: list[int],
      tastiness: list[int],
      maxAmount: int,
      maxCoupons: int,
  ) -> int:
    # dp[j][k] := the maximum tastiness of price so far with j amount of money and k coupons
    dp = [[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)]

    for p, t in zip(price, tastiness):
      for j in range(maxAmount, p // 2 - 1, -1):
        for k in range(maxCoupons, -1, -1):
          buyWithCoupon = 0 if k == 0 else dp[j - p // 2][k - 1] + t
          buyWithoutCoupon = 0 if j < p else dp[j - p][k] + t
          dp[j][k] = max(dp[j][k], buyWithCoupon, buyWithoutCoupon)

    return dp[maxAmount][maxCoupons]"
"2432","class Solution:
  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:
    ans = logs[0][0]
    maxWorkingTime = logs[0][1]

    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):
      workingTime = leaveTime - prevLeaveTime
      if workingTime > maxWorkingTime:
        ans = id
        maxWorkingTime = workingTime
      elif workingTime == maxWorkingTime:
        ans = min(ans, id)

    return ans"
"2433","class Solution:
  def findArray(self, pref: list[int]) -> list[int]:
    ans = [0] * len(pref)

    ans[0] = pref[0]
    for i in range(1, len(ans)):
      ans[i] = pref[i] ^ pref[i - 1]

    return ans"
"2434","class Solution:
  def robotWithString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    stack = []

    for c in s:
      stack.append(c)
      count[c] -= 1
      minChar = self._getMinChar(count)
      while stack and stack[-1] <= minChar:
        ans.append(stack.pop())

    return ''.join(ans + stack[::-1])

  def _getMinChar(self, count: list[int]) -> str:
    for c in string.ascii_lowercase:
      if count[c]:
        return c
    return 'a'"
"2435","class Solution:
  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:
    kMod = 1_000_000_007
    m = len(grid)
    n = len(grid[0])

    @functools.lru_cache(None)
    def dp(i: int, j: int, summ: int) -> int:
      """"""
      Returns the number of paths to (i, j), where the sum / k == `summ`.
      """"""
      if i == m or j == n:
        return 0
      if i == m - 1 and j == n - 1:
        return 1 if (summ + grid[i][j]) % k == 0 else 0
      newSum = (summ + grid[i][j]) % k
      return (dp(i + 1, j, newSum) + dp(i, j + 1, newSum)) % kMod

    return dp(0, 0, 0)"
"2436","class Solution:
  def minimumSplits(self, nums: list[int]) -> int:
    ans = 1
    gcd = nums[0]

    for num in nums:
      newGcd = math.gcd(gcd, num)
      if newGcd > 1:
        gcd = newGcd
      else:
        gcd = num
        ans += 1

    return ans"
"2437","class Solution:
  def countTime(self, time: str) -> int:
    ans = 1
    if time[3] == '?':
      ans *= 6
    if time[4] == '?':
      ans *= 10

    if time[0] == '?' and time[1] == '?':
      return ans * 24
    if time[0] == '?':
      return ans * 3 if time[1] < '4' else ans * 2
    if time[1] == '?':
      return ans * 4 if time[0] == '2' else ans * 10
    return ans"
"2438","class Solution:
  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:
    kMod = 1_000_000_007
    kMaxBit = 30
    ans = []
    powers = [1 << i for i in range(kMaxBit) if n >> i & 1]

    for left, right in queries:
      prod = 1
      for i in range(left, right + 1):
        prod *= powers[i]
        prod %= kMod
      ans.append(prod)

    return ans"
"2439","class Solution:
  def minimizeArrayValue(self, nums: list[int]) -> int:
    ans = 0
    prefix = 0

    for i, num in enumerate(nums):
      prefix += num
      prefixAvg = math.ceil(prefix / (i + 1))
      ans = max(ans, prefixAvg)

    return ans"
"244","class WordDistance:
  def __init__(self, wordsDict: list[str]):
    self.wordToIndices = collections.defaultdict(list)
    for i, word in enumerate(wordsDict):
      self.wordToIndices[word].append(i)

  def shortest(self, word1: str, word2: str) -> int:
    indices1 = self.wordToIndices[word1]
    indices2 = self.wordToIndices[word2]
    ans = math.inf

    i = 0
    j = 0
    while i < len(indices1) and j < len(indices2):
      ans = min(ans, abs(indices1[i] - indices2[j]))
      if indices1[i] < indices2[j]:
        i += 1
      else:
        j += 1

    return ans"
"2440","class Solution:
  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:
    kMax = 1_000_000_000
    n = len(nums)
    summ = sum(nums)
    tree = [[] for _ in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, target: int, seen: set[bool]) -> int:
      """"""
      Returns the sum of the subtree rooted at u substracting the sum of the
      deleted subtrees.
      """"""
      summ = nums[u]
      seen.add(u)

      for v in tree[u]:
        if v in seen:
          continue
        summ += dfs(v, target, seen)
        if summ > target:
          return kMax

      # Delete the tree that has sum == target.
      if summ == target:
        return 0
      return summ

    for i in range(n, 1, -1):
      # Split the tree into i parts, i.e. delete (i - 1) edges.
      if summ % i == 0 and dfs(0, summ // i, set()) == 0:
        return i - 1

    return 0"
"2441","class Solution:
  def findMaxK(self, nums: list[int]) -> int:
    ans = -1
    seen = set()

    for num in nums:
      if -num in seen:
        ans = max(ans, abs(num))
      else:
        seen.add(num)

    return ans"
"2442","class Solution {
 public:
  int countDistinctIntegers(vector<int>& nums) {
    unordered_set<int> numsSet{nums.begin(), nums.end()};

    for (const int num : nums)
      numsSet.insert(reversed(num));

    return numsSet.size();
  }

 private:
  int reversed(int num) {
    int ans = 0;
    while (num > 0) {
      ans = ans * 10 + num % 10;
      num /= 10;
    }
    return ans;
  }
};"
"2443","class Solution {
 public:
  bool sumOfNumberAndReverse(int num) {
    for (int i = num / 2; i <= num; ++i)
      if (num == i + reversed(i))
        return true;
    return false;
  }

 private:
  int reversed(int num) {
    int ans = 0;
    while (num > 0) {
      ans = ans * 10 + num % 10;
      num /= 10;
    }
    return ans;
  }
};"
"2444","class Solution:
  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:
    ans = 0
    j = -1
    prevMinKIndex = -1
    prevMaxKIndex = -1

    for i, num in enumerate(nums):
      if num < minK or num > maxK:
        j = i
      if num == minK:
        prevMinKIndex = i
      if num == maxK:
        prevMaxKIndex = i
      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the
      # start of the subarray s.t. nums[k..i] satisfies the conditions.
      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)

    return ans"
"2445","class Solution:
  def numberOfNodes(self, n: int, queries: list[int]) -> int:
    # flipped[i] := True if we should flip all the values in the subtree rooted
    # at i
    flipped = [False] * (n + 1)

    for query in queries:
      flipped[query] = flipped[query] ^ True

    def dfs(label: int, value: int) -> int:
      if label > n:
        return 0
      value ^= flipped[label]
      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)

    return dfs(1, 0)"
"2446",""
"2447","class Solution:
  def subarrayGCD(self, nums: list[int], k: int) -> int:
    ans = 0
    gcds = collections.Counter()

    for num in nums:
      if num % k == 0:
        nextGcds = collections.defaultdict(int)
        nextGcds[num] += 1
        for prevGcd, count in gcds.items():
          nextGcds[math.gcd(prevGcd, num)] += count
        ans += nextGcds.get(k, 0)
        gcds = nextGcds
      else:
        # The GCD streak stops, so fresh start from the next number.
        gcds.clear()

    return ans"
"2448","class Solution:
  def minCost(self, nums: list[int], cost: list[int]) -> int:
    ans = 0
    l = min(nums)
    r = max(nums)

    def getCost(target: int) -> int:
      return sum(abs(num - target) * c for num, c in zip(nums, cost))

    while l < r:
      m = (l + r) // 2
      cost1 = getCost(m)
      cost2 = getCost(m + 1)
      ans = min(cost1, cost2)
      if cost1 < cost2:
        r = m
      else:
        l = m + 1

    return ans"
"2449","class Solution:
  def makeSimilar(self, nums: list[int], target: list[int]) -> int:
    nums.sort(key=lambda x: (x % 2, x))
    target.sort(key=lambda x: (x % 2, x))
    return sum(abs(a - b) for a, b in zip(nums, target)) // 4"
"245","class Solution:
  def shortestWordDistance(
      self,
      wordsDict: list[str],
      word1: str,
      word2: str,
  ) -> int:
    isSame = word1 == word2
    ans = math.inf
    # If word1 == word2, index1 is the newest index.
    index1 = len(wordsDict)
    # If word1 == word2, index2 is the previous index.
    index2 = -len(wordsDict)

    for i, word in enumerate(wordsDict):
      if word == word1:
        if isSame:
          index2 = index1
        index1 = i
      elif word == word2:
        index2 = i
      ans = min(ans, abs(index1 - index2))

    return ans"
"2450","class Solution:
  def countDistinctStrings(self, s: str, k: int) -> int:
    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can
    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.
    return pow(2, len(s) - k + 1, 1_000_000_007)"
"2451","class Solution:
  def oddString(self, words: list[str]) -> str:
    def getDiff(s: str) -> list[int]:
      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]

    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]
    diffTupleCount = collections.Counter()

    for _, diffTuple in wordAndDiffTuples:
      diffTupleCount[diffTuple] += 1

    for word, diffTuple in wordAndDiffTuples:
      if diffTupleCount[diffTuple] == 1:
        return word"
"2452","class Solution:
  def twoEditWords(
      self,
      queries: list[str],
      dictionary: list[str],
  ) -> list[str]:
    return [query for query in queries
            if any(sum(a != b for a, b in zip(query, word)) < 3
                   for word in dictionary)]"
"2453","class Solution:
  def destroyTargets(self, nums: list[int], space: int) -> int:
    count = collections.Counter([num % space for num in nums])
    maxCount = max(count.values())
    return min(num for num in nums if count[num % space] == maxCount)"
"2454","class Solution:
  def secondGreaterElement(self, nums: list[int]) -> list[int]:
    ans = [-1] * len(nums)
    # a decreasing stack that stores indices that met the first greater number.
    prevStack = []
    # a decreasing stack that stores indices.
    currStack = []

    for i, num in enumerate(nums):
      # Indices in prevStack meet the second greater num.
      while prevStack and nums[prevStack[-1]] < num:
        ans[prevStack.pop()] = num
      # Push indices that meet the first greater number from `currStack` to
      # `prevStack`. We need a temporary array to make the indices in the
      # `prevStack` increasing.
      decreasingIndices = []
      while currStack and nums[currStack[-1]] < num:
        decreasingIndices.append(currStack.pop())
      while decreasingIndices:
        prevStack.append(decreasingIndices.pop())
      currStack.append(i)

    return ans"
"2455","class Solution:
  def averageValue(self, nums: list[int]) -> int:
    summ = 0
    count = 0

    for num in nums:
      if num % 6 == 0:
        summ += num
        count += 1

    return 0 if count == 0 else summ // count"
"2456","class Creator:
  def __init__(self, popularity: int, videoId: str, maxView: int):
    self.popularity = popularity  # the popularity sum
    self.videoId = videoId        # the video id that has the maximum view
    self.maxView = maxView        # the maximum view of the creator


class Solution:
  def mostPopularCreator(self, creators: list[str],
                         ids: list[str],
                         views: list[int]) -> list[list[str]]:
    ans = []
    maxPopularity = 0
    nameToCreator = {}

    for name, id, view in zip(creators, ids, views):
      if name not in nameToCreator:
        nameToCreator[name] = Creator(view, id, view)
        maxPopularity = max(maxPopularity, view)
        continue
      creator = nameToCreator[name]
      creator.popularity += view
      maxPopularity = max(maxPopularity, creator.popularity)
      if (creator.maxView < view or
              creator.maxView == view and creator.videoId > id):
        creator.videoId = id
        creator.maxView = view

    for name, creator in nameToCreator.items():
      if creator.popularity == maxPopularity:
        ans.append([name, creator.videoId])

    return ans"
"2457","class Solution:
  def makeIntegerBeautiful(self, n: int, target: int) -> int:
    ans = 0
    power = 1

    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.
    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.
    while sum(map(int, str(n))) > target:
      # the cost to turn off the last digit
      ans += power * (10 - n % 10)
      n = n // 10 + 1
      power *= 10

    return ans"
"2458","class Solution:
  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:
    @lru_cache(None)
    def height(root: TreeNode | None) -> int:
      if not root:
        return 0
      return 1 + max(height(root.left), height(root.right))

    # valToMaxHeight[val] := the maximum height without the node with `val`
    valToMaxHeight = {}

    # maxHeight := the maximum height without the current node `root`
    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:
      if not root:
        return
      valToMaxHeight[root.val] = maxHeight
      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))
      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))

    dfs(root, 0, 0)
    return [valToMaxHeight[query] for query in queries]"
"2459","class Solution:
  def sortArray(self, nums: list[int]) -> int:
    n = len(nums)
    numToIndex = [0] * n

    for i, num in enumerate(nums):
      numToIndex[num] = i

    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:
      ops = 0
      num = 1
      # If zeroInBeginning, the correct index of each num is num.
      # If not zeroInBeginning, the correct index of each num is num - 1.
      offset = 0 if zeroInBeginning else 1
      while num < n:
        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.
        if (zeroInBeginning and numToIndex[0] == 0 or
                not zeroInBeginning and numToIndex[0] == n - 1):
          while numToIndex[num] == num - offset:  # num is in correct position
            num += 1
            if num == n:
              return ops
          numInWrongIndex = num
        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not
        # in nums[2] because nums[2] == 0.
        else:
          numInWrongIndex = numToIndex[0] + offset
        numToIndex[0], numToIndex[numInWrongIndex] = (
            numToIndex[numInWrongIndex], numToIndex[0])
        ops += 1

    return min(minOps(numToIndex.copy(), True),
               minOps(numToIndex.copy(), False))"
"246","class Solution:
  def isStrobogrammatic(self, num: str) -> bool:
    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    l = 0
    r = len(num) - 1

    while l <= r:
      if num[r] not in rotated:
        return False
      if num[l] != rotated[num[r]]:
        return False
      l += 1
      r -= 1

    return True"
"2460","class Solution:
  def applyOperations(self, nums: list[int]) -> list[int]:
    j = 0
    for i in range(len(nums)):
      if i + 1 < len(nums) and nums[i] == nums[i + 1]:
        nums[i] *= 2
        nums[i + 1] = 0
      if nums[i] > 0:
        nums[i], nums[j] = nums[j], nums[i]
        j += 1
    return nums"
"2461","class Solution:
  def maximumSubarraySum(self, nums: list[int], k: int) -> int:
    ans = 0
    summ = 0
    distinct = 0
    count = collections.Counter()

    for i, num in enumerate(nums):
      summ += num
      count[num] += 1
      if count[num] == 1:
        distinct += 1
      if i >= k:
        count[nums[i - k]] -= 1
        if count[nums[i - k]] == 0:
          distinct -= 1
        summ -= nums[i - k]
      if i >= k - 1 and distinct == k:
        ans = max(ans, summ)

    return ans"
"2462","class Solution:
  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:
    ans = 0
    i = 0
    j = len(costs) - 1
    minHeapL = []  # First half
    minHeapR = []  # Second half

    for _ in range(k):
      while len(minHeapL) < candidates and i <= j:
        heapq.heappush(minHeapL, costs[i])
        i += 1
      while len(minHeapR) < candidates and i <= j:
        heapq.heappush(minHeapR, costs[j])
        j -= 1
      if not minHeapL:
        ans += heapq.heappop(minHeapR)
      elif not minHeapR:
        ans += heapq.heappop(minHeapL)
      # Both `minHeapL` and `minHeapR` are not empty.
      elif minHeapL[0] <= minHeapR[0]:
        ans += heapq.heappop(minHeapL)
      else:
        ans += heapq.heappop(minHeapR)

    return ans"
"2463","class Solution:
  def minimumTotalDistance(
      self,
      robot: list[int],
      factory: list[list[int]],
  ) -> int:
    robot.sort()
    factory.sort()

    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """"""
      Returns the minimum distance to fix robot[i..n) with factory[j..n), where
      factory[j] already fixed k robots.
      """"""
      if i == len(robot):
        return 0
      if j == len(factory):
        return math.inf
      skipFactory = dp(i, j + 1, 0)
      position, limit = factory[j]
      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)
                    if limit > k else math.inf)
      return min(skipFactory, useFactory)

    return dp(0, 0, 0)"
"2464","class Solution:
  def validSubarraySplit(self, nums: list[int]) -> int:
    # dp[i] := the minimum number of subarrays to validly split nums[0..i]
    dp = [math.inf] * len(nums)

    for i, num in enumerate(nums):
      for j in range(i + 1):
        if math.gcd(nums[j], num) > 1:
          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)

    return -1 if dp[-1] == math.inf else dp[-1]"
"2465","class Solution:
  def distinctAverages(self, nums: list[int]) -> int:
    n = len(nums)
    sums = set()

    nums.sort()

    for i in range(n // 2):
      sums.add(nums[i] + nums[n - 1 - i])

    return len(sums)"
"2466","class Solution:
  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    # dp[i] := the number of good strings with length i
    dp = [1] + [0] * high

    for i in range(1, high + 1):
      if i >= zero:
        dp[i] = (dp[i] + dp[i - zero]) % kMod
      if i >= one:
        dp[i] = (dp[i] + dp[i - one]) % kMod
      if i >= low:
        ans = (ans + dp[i]) % kMod

    return ans"
"2467","class Solution:
  def mostProfitablePath(
      self,
      edges: list[list[int]],
      bob: int,
      amount: list[int],
  ) -> int:
    n = len(amount)
    tree = [[] for _ in range(n)]
    parent = [0] * n
    aliceDist = [-1] * n

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    # Fills `parent` and `aliceDist`.
    def dfs(u: int, prev: int, d: int) -> None:
      parent[u] = prev
      aliceDist[u] = d
      for v in tree[u]:
        if aliceDist[v] == -1:
          dfs(v, u, d + 1)

    dfs(0, -1, 0)

    # Modify amount athe path from node bob to node 0.
    # For each node,
    #   1. If Bob reaches earlier than Alice does, change the amount to 0.
    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.
    u = bob
    bobDist = 0
    while u != 0:
      if bobDist < aliceDist[u]:
        amount[u] = 0
      elif bobDist == aliceDist[u]:
        amount[u] //= 2
      u = parent[u]
      bobDist += 1

    return self._getMoney(tree, 0, -1, amount)

  def _getMoney(
      self,
      tree: list[list[int]],
      u: int,
      prev: int,
      amount: list[int],
  ) -> int:
    # a leaf node
    if len(tree[u]) == 1 and tree[u][0] == prev:
      return amount[u]

    maxPath = -math.inf
    for v in tree[u]:
      if v != prev:
        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))

    return amount[u] + maxPath"
"2468","class Solution:
  def splitMessage(self, message: str, limit: int) -> list[str]:
    kMessageLength = len(message)

    def sz(num: int):
      return len(str(num))

    b = 1
    # the total length of a: initialized with the length of ""1""
    aLength = sz(1)

    # the total length of b := b * sz(b)
    # The total length of ""</>"" := b * 3
    while b * limit < b * (sz(b) + 3) + aLength + kMessageLength:
      # If the length of the last suffix ""<b/b>"" := sz(b) * 2 + 3 >= limit,
      # then it's impossible that the length of ""*<b/b>"" <= limit.
      if sz(b) * 2 + 3 >= limit:
        return []
      b += 1
      aLength += sz(b)

    ans = []

    i = 0
    for a in range(1, b + 1):
      # the length of ""<a/b>"" := sz(a) + sz(b) + 3
      j = limit - (sz(a) + sz(b) + 3)
      ans.append(f'{message[i:i + j]}<{a}/{b}>')
      i += j

    return ans"
"2469","class Solution:
  def convertTemperature(self, celsius: float) -> list[float]:
    return [celsius + 273.15, celsius * 1.8 + 32]"
"247","class Solution:
  def findStrobogrammatic(self, n: int) -> list[str]:
    def helper(n: int, k: int) -> list[str]:
      if n == 0:
        return ['']
      if n == 1:
        return ['0', '1', '8']

      ans = []

      for inner in helper(n - 2, k):
        if n < k:
          ans.append('0' + inner + '0')
        ans.append('1' + inner + '1')
        ans.append('6' + inner + '9')
        ans.append('8' + inner + '8')
        ans.append('9' + inner + '6')

      return ans

    return helper(n, n)"
"2470","class Solution:
  def subarrayLCM(self, nums: list[int], k: int) -> int:
    ans = 0

    for i, runningLcm in enumerate(nums):
      for j in range(i, len(nums)):
        runningLcm = math.lcm(runningLcm, nums[j])
        if runningLcm > k:
          break
        if runningLcm == k:
          ans += 1

    return ans"
"2471","class Solution:
  def minimumOperations(self, root: TreeNode | None) -> int:
    ans = 0
    q = collections.deque([root])

    # e.g. vals = [7, 6, 8, 5]
    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.
    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).
    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.
    while q:
      vals = []
      for _ in range(len(q)):
        node = q.popleft()
        vals.append(node.val)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      # O(n^2logn), which is not great and leads to TLE.
      ids = [sorted(vals).index(val) for val in vals]
      for i in range(len(ids)):
        while ids[i] != i:
          j = ids[i]
          ids[i] = ids[j]
          ids[j] = j
          ans += 1

    return ans"
"2472","class Solution:
  def maxPalindromes(self, s: str, k: int) -> int:
    n = len(s)
    # dp[i] := the maximum number of substrings in the first i chars of s
    dp = [0] * (n + 1)

    def isPalindrome(l: int, r: int) -> bool:
      """"""Returns True is s[i..j) is a palindrome.""""""
      if l < 0:
        return False
      while l < r:
        if s[l] != s[r]:
          return False
        l += 1
        r -= 1
      return True

    # If a palindrome is a subof another palindrome, then considering
    # the longer palindrome won't increase the number of non-overlapping
    # palindromes. So, we only need to consider the shorter one. Also,
    # considering palindromes with both k length and k + 1 length ensures that
    # we look for both even and odd length palindromes.
    for i in range(k, n + 1):
      dp[i] = dp[i - 1]
      # Consider palindrome with length k.
      if isPalindrome(i - k, i - 1):
        dp[i] = max(dp[i], 1 + dp[i - k])
      # Consider palindrome with length k + 1.
      if isPalindrome(i - k - 1, i - 1):
        dp[i] = max(dp[i], 1 + dp[i - k - 1])

    return dp[n]"
"2473","class Solution:
  def minCost(
      self,
      n: int,
      roads: list[list[int]],
      appleCost: list[int],
      k: int,
  ) -> list[int]:
    graph = [[] for _ in range(n)]

    for u, v, w in roads:
      graph[u - 1].append((v - 1, w))
      graph[v - 1].append((u - 1, w))

    def dijkstra(i: int) -> int:
      forwardCost = [math.inf] * n
      totalCost = [math.inf] * n
      forwardCost[i] = 0
      q = collections.deque([i])

      while q:
        u = q.popleft()
        for v, w in graph[u]:
          nextCost = forwardCost[u] + w
          if nextCost >= forwardCost[v]:
            continue
          forwardCost[v] = nextCost
          # Take apple at city v and return back to city i.
          totalCost[v] = (k + 1) * nextCost + appleCost[v]
          q.append(v)

      return min(appleCost[i], min(totalCost))

    return [dijkstra(i) for i in range(n)]"
"2474","WITH
  YearlyOrders AS (
    SELECT
      customer_id,
      YEAR(order_date) AS year,
      SUM(price) AS price
    FROM Orders
    GROUP BY 1, 2
  )
SELECT CurrYear.customer_id
FROM YearlyOrders AS CurrYear
LEFT JOIN YearlyOrders AS NextYear
  ON (
    CurrYear.customer_id = NextYear.customer_id
    AND CurrYear.year + 1 = NextYear.year
    AND CurrYear.price < NextYear.price)
GROUP BY 1
HAVING COUNT(*) - COUNT(NextYear.customer_id) = 1;"
"2475","# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.
#
# What we want is:
#   cnt[a] * cnt[b] * cnt[c]
#   cnt[a] * cnt[b] * cnt[d]
#   cnt[a] * cnt[c] * cnt[d]
#   cnt[b] * cnt[c] * cnt[d]
#
# The above combinations can be reduced as:
#
# prev                       | curr   | next
#
# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])
# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])
# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])
# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)

class Solution:
  def unequalTriplets(self, nums: list[int]) -> int:
    ans = 0
    prev = 0
    next = len(nums)

    for freq in collections.Counter(nums).values():
      next -= freq
      ans += prev * freq * next
      prev += freq

    return ans"
"2476","class Solution:
  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:
    sortedVals = []
    self._inorder(root, sortedVals)

    def getClosestPair(query: int) -> list[int]:
      i = bisect_left(sortedVals, query)
      # query is presented in the tree, so just use [query, query].
      if i != len(sortedVals) and sortedVals[i] == query:
        return [query, query]
      # query isn't presented in the tree, so find the cloest one if possible.
      return [-1 if i == 0 else sortedVals[i - 1],
              -1 if i == len(sortedVals) else sortedVals[i]]

    return [getClosestPair(query) for query in queries]

  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:
    """"""Walks the BST to collect the sorted numbers.""""""
    if not root:
      return
    self._inorder(root.left, sortedVals)
    sortedVals.append(root.val)
    self._inorder(root.right, sortedVals)"
"2477","class Solution:
  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:
    ans = 0
    tree = [[] for _ in range(len(roads) + 1)]

    for u, v in roads:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> int:
      nonlocal ans
      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)
      if u > 0:
        # the number of cars needed
        ans += int(math.ceil(people / seats))
      return people

    dfs(0, -1)
    return ans"
"2478","class Solution:
  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
    def isPrime(c: str) -> bool:
      return c in '2357'

    if not isPrime(s[0]) or isPrime(s[-1]):
      return 0

    kMod = 1_000_000_007

    @lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""
      Returns the number of beautiful partitions of s[i..n) with k bars (|)
      left.
      """"""
      if i <= len(s) and k == 0:
        return 1
      if i >= len(s):
        return 0

      # Don't split between s[i - 1] and s[i].
      ans = dp(i + 1, k) % kMod

      # Split between s[i - 1] and s[i].
      if isPrime(s[i]) and not isPrime(s[i - 1]):
        ans += dp(i + minLength, k - 1)

      return ans % kMod

    return dp(minLength, k - 1)"
"2479","class TrieNode:
  def __init__(self):
    self.children: list[TrieNode | None] = [None] * 2


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]

  def getMaxXor(self, num: int) -> int:
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      toggleBit = bit ^ 1
      if node.children[toggleBit]:
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:  # There's nothing in the Bit Trie.
        return 0
    return maxXor


class Solution:
  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:
    ans = 0
    tree = [[] for _ in range(n)]
    treeSums = [0] * n

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    # Gets the tree sum rooted at node u.
    def getTreeSum(u: int, prev: int) -> int:
      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)
      treeSums[u] = treeSum
      return treeSum

    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:
      nonlocal ans
      for v in tree[u]:
        if v == prev:
          continue
        # Preorder to get the ans.
        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))
        # Recursively call on the subtree rooted at node v.
        dfs(v, u, bitTrie)
        # Postorder to insert the tree sum rooted at node v.
        bitTrie.insert(treeSums[v])

    getTreeSum(0, -1)
    maxBit = int(math.log2(max(treeSums[1:])))
    # Similar to 421. Maximum XOR of Two Numbers in an Array
    dfs(0, -1, BitTrie(maxBit))
    return ans"
"248","class Solution:
  def strobogrammaticInRange(self, low: str, high: str) -> int:
    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]
    ans = 0

    def dfs(s: list[str], l: int, r: int) -> None:
      nonlocal ans
      if l > r:
        if len(s) == len(low) and ''.join(s) < low:
          return
        if len(s) == len(high) and ''.join(s) > high:
          return
        ans += 1
        return

      for leftDigit, rightDigit in pairs:
        if l == r and leftDigit != rightDigit:
          continue
        s[l] = leftDigit
        s[r] = rightDigit
        if len(s) > 1 and s[0] == '0':
          continue
        dfs(s, l + 1, r - 1)

    for n in range(len(low), len(high) + 1):
      dfs([' '] * n, 0, n - 1)

    return ans"
"2480","SELECT
  A.symbol AS metal,
  B.symbol AS nonmetal
FROM Elements AS A, Elements AS B
WHERE
  A.type = 'Metal'
  AND B.type = 'Nonmetal'"
"2481","class Solution:
  def numberOfCuts(self, n: int) -> int:
    if n == 1:
      return 0
    return n // 2 if n % 2 == 0 else n"
"2482","class Solution:
  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    onesRow = [row.count(1) for row in grid]
    onesCol = [col.count(1) for col in zip(*grid)]

    for i in range(m):
      for j in range(n):
        ans[i][j] = (onesRow[i] + onesCol[j] -
                     (n - onesRow[i]) - (m - onesCol[j]))

    return ans"
"2483","class Solution:
  def bestClosingTime(self, customers: str) -> int:
    # Instead of computing the minimum penalty, we can compute the maximum profit.
    ans = 0
    profit = 0
    maxProfit = 0

    for i, customer in enumerate(customers):
      profit += 1 if customer == 'Y' else -1
      if profit > maxProfit:
        maxProfit = profit
        ans = i + 1

    return ans"
"2484","class Solution:
  def countPalindromes(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0

    for a in range(10):
      for b in range(10):
        pattern = f'{a}{b}.{b}{a}'
        # dp[i] := the number of subsequences of pattern[i..n) in s, where
        # pattern[2] can be any character
        dp = [0] * 5 + [1]
        for c in s:
          for i, p in enumerate(pattern):
            if p == '.' or p == c:
              dp[i] += dp[i + 1]
        ans += dp[0]
        ans %= kMod

    return ans"
"2485","class Solution:
  def pivotInteger(self, n: int) -> int:
    # 1 + 2 + ... + x = x + ... + n
    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2
    #         x + x^2 = nx - x^2 + x + n^2 - nx + n
    #         2 * x^2 = n^2 + n
    #               x = sqrt((n^2 + n) // 2)
    y = (n * n + n) // 2
    x = math.isqrt(y)
    return x if x * x == y else -1"
"2486","class Solution:
  def appendCharacters(self, s: str, t: str) -> int:
    i = 0  # t's index

    for c in s:
      if c == t[i]:
        i += 1
        if i == len(t):
          return 0

    return len(t) - i"
"2487","class Solution:
  def removeNodes(self, head: ListNode | None) -> ListNode | None:
    if not head:
      return None
    head.next = self.removeNodes(head.next)
    return head.next if head.next and head.val < head.next.val else head"
"2488","class Solution:
  def countSubarrays(self, nums: list[int], k: int) -> int:
    kIndex = nums.index(k)
    ans = 0
    count = collections.Counter()

    balance = 0
    for i in range(kIndex, -1, -1):
      if nums[i] < k:
        balance -= 1
      elif nums[i] > k:
        balance += 1
      count[balance] += 1

    balance = 0
    for i in range(kIndex, len(nums)):
      if nums[i] < k:
        balance -= 1
      elif nums[i] > k:
        balance += 1
      # The subarray that has balance == 0 or 1 having median equal to k.
      # So, add count[0 - balance] and count[1 - balance] to `ans`.
      ans += count[-balance] + count[1 - balance]

    return ans"
"2489","class Solution:
  def fixedRatio(self, s: str, num1: int, num2: int) -> int:
    # Let x := the number of 0s and y := the number of 1s in the subarray.
    # We want x : y = num1 : num2, so our goal is to find number of subarrays
    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count
    # map to record the count of the running x * num2 - y * num1. If the
    # running x * num2 - y * num1 = prefix, then add count[prefix] to the
    # `ans`.
    ans = 0
    prefix = 0
    prefixCount = collections.Counter({0: 1})

    for c in s:
      if c == '0':
        prefix += num2
      else:  # c == '1'
        prefix -= num1
      ans += prefixCount[prefix]
      prefixCount[prefix] += 1

    return ans"
"249","class Solution:
  def groupStrings(self, strings: list[str]) -> list[list[str]]:
    keyToStrings = collections.defaultdict(list)

    def getKey(s: str) -> str:
      """"""
      Returns the key of 's' by pairwise calculation of differences.
      e.g. getKey(""abc"") -> ""1,1"" because diff(a, b) = 1 and diff(b, c) = 1.
      """"""
      diffs = []

      for i in range(1, len(s)):
        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26
        diffs.append(str(diff))

      return ','.join(diffs)

    for s in strings:
      keyToStrings[getKey(s)].append(s)

    return keyToStrings.values()"
"2490","class Solution:
  def isCircularSentence(self, sentence: str) -> bool:
    for i, c in enumerate(sentence):
      if c == ' ' and sentence[i - 1] != sentence[i + 1]:
        return False
    return sentence[0] == sentence[-1]"
"2491","class Solution:
  def dividePlayers(self, skill: list[int]) -> int:
    n = len(skill)
    teamSkill = sum(skill) // (n // 2)
    ans = 0
    count = collections.Counter(skill)

    for s, freq in count.items():
      requiredSkill = teamSkill - s
      if count[requiredSkill] != freq:
        return -1
      ans += s * requiredSkill * freq

    return ans // 2"
"2492","class Solution:
  def minScore(self, n: int, roads: list[list[int]]) -> int:
    ans = math.inf
    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]
    q = collections.deque([1])
    seen = {1}

    for u, v, distance in roads:
      graph[u].append((v, distance))
      graph[v].append((u, distance))

    while q:
      u = q.popleft()
      for v, d in graph[u]:
        ans = min(ans, d)
        if v in seen:
          continue
        q.append(v)
        seen.add(v)

    return ans"
"2493","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int magnificentSets(int n, vector<vector<int>>& edges) {
    vector<vector<int>> graph(n);
    UnionFind uf(n);
    unordered_map<int, int> rootToGroupSize;

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      graph[u].push_back(v);
      graph[v].push_back(u);
      uf.unionByRank(u, v);
    }

    for (int i = 0; i < n; ++i) {
      const int newGroupSize = bfs(graph, i);
      if (newGroupSize == -1)
        return -1;
      const int root = uf.find(i);
      auto& groupSize = rootToGroupSize[root];
      groupSize = max(groupSize, newGroupSize);
    }

    int ans = 0;
    for (const auto& [_, groupSize] : rootToGroupSize)
      ans += groupSize;

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int u) {
    int step = 0;
    queue<int> q{{u}};
    unordered_map<int, int> nodeToStep{{u, 1}};

    while (!q.empty()) {
      ++step;
      for (int sz = q.size(); sz > 0; --sz) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (!nodeToStep.contains(v)) {
            q.push(v);
            nodeToStep[v] = step + 1;
          } else if (nodeToStep[v] == step) {
            // There is an odd number of edges in the cycle.
            return -1;
          }
        }
      }
    }

    return step;
  }
};"
"2494","WITH
  HallEventsWithIsNewEvent AS (
    SELECT
      hall_id,
      start_day,
      end_day,
      IFNULL(
        start_day > MAX(end_day) OVER(
          PARTITION BY hall_id
          ORDER BY start_day,
            end_day DESC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ),
        1
      ) AS is_new_event
    FROM HallEvents
  ),
  HallEventsWithGroupId AS (
    SELECT
      hall_id,
      start_day,
      end_day,
      SUM(is_new_event) OVER(
        PARTITION BY hall_id
        ORDER BY start_day, end_day DESC
      ) AS group_id
    FROM HallEventsWithIsNewEvent
  )
SELECT
  hall_id,
  MIN(start_day) AS start_day,
  MAX(end_day) AS end_day
FROM HallEventsWithGroupId
GROUP BY hall_id, group_id;"
"2495","class Solution:
  def evenProduct(self, nums: list[int]) -> int:
    ans = 0
    numsBeforeEven = 0  # inclusively

    # e.g. nums = [1, 0, 1, 1, 0].
    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number
    # between index 1 to index 3 (the one before next 0) will contribute 2 to
    # `ans`.
    for i, num in enumerate(nums):
      if num % 2 == 0:
        numsBeforeEven = i + 1
      ans += numsBeforeEven

    return ans"
"2496","class Solution:
  def maximumValue(self, strs: list[str]) -> int:
    return max(len(s) if any(c.isalpha() for c in s) else int(s)
               for s in strs)"
"2497","class Solution:
  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:
    n = len(vals)
    ans = -math.inf
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((v, vals[v]))
      graph[v].append((u, vals[u]))

    for i, starSum in enumerate(vals):
      maxHeap = []
      for _, val in graph[i]:
        if val > 0:
          heapq.heappush(maxHeap, -val)
      j = 0
      while j < k and maxHeap:
        starSum -= heapq.heappop(maxHeap)
        j += 1
      ans = max(ans, starSum)

    return ans"
"2498","class Solution:
  def maxJump(self, stones: list[int]) -> int:
    # Let's denote the forwarding path as F and the backwarding path as B.
    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between
    # F1 and F2 increase, resulting a larger `ans`.
    if len(stones) == 2:
      return stones[1] - stones[0]
    return max(stones[i] - stones[i - 2]
               for i in range(2, len(stones)))"
"2499","class Solution:
  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:
    n = len(nums1)
    ans = 0
    maxFreq = 0
    maxFreqNum = 0
    shouldBeSwapped = 0
    conflictedNumCount = [0] * (n + 1)

    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`
    # and `maxFreqNum`.
    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      if num1 == num2:
        conflictedNum = num1
        conflictedNumCount[conflictedNum] += 1
        if conflictedNumCount[conflictedNum] > maxFreq:
          maxFreq = conflictedNumCount[conflictedNum]
          maxFreqNum = conflictedNum
        shouldBeSwapped += 1
        ans += i

    # Collect the indices with num1 != num2 that contribute less cost.
    # This can be greedily achieved by iterating from 0 to n - 1.
    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be
      # successfully distributed, so no need to collectextra spaces.
      if maxFreq * 2 <= shouldBeSwapped:
        break
      if num1 == num2:
        continue
      # The numbers == `maxFreqNum` worsen the result since they increase the
      # `maxFreq`.
      if num1 == maxFreqNum or num2 == maxFreqNum:
        continue
      shouldBeSwapped += 1
      ans += i

    return -1 if maxFreq * 2 > shouldBeSwapped else ans"
"25","class Solution:
  def reverseKGroup(self, head: ListNode | None, k: int) -> ListNode | None:
    if not head:
      return None

    tail = head

    for _ in range(k):
      # There are less than k nodes in the list, do nothing.
      if not tail:
        return head
      tail = tail.next

    newHead = self._reverse(head, tail)
    head.next = self.reverseKGroup(tail, k)
    return newHead

  def _reverse(
      self,
      head: ListNode | None,
      tail: ListNode | None,
  ) -> ListNode | None:
    """"""Reverses [head, tail).""""""
    prev = None
    curr = head
    while curr != tail:
      next = curr.next
      curr.next = prev
      prev = curr
      curr = next
    return prev"
"250","class Solution:
  def countUnivalSubtrees(self, root: TreeNode | None) -> int:
    ans = 0

    def isUnival(root: TreeNode | None, val: int) -> bool:
      nonlocal ans
      if not root:
        return True

      if isUnival(root.left, root.val) & isUnival(root.right, root.val):
        ans += 1
        return root.val == val

      return False

    isUnival(root, math.inf)
    return ans"
"2500","class Solution:
  def deleteGreatestValue(self, grid: list[list[int]]) -> int:
    for row in grid:
      row.sort()
    return sum(max(col) for col in zip(*grid))"
"2501","class Solution {
 public:
  int longestSquareStreak(vector<int>& nums) {
    nums.erase(std::unique(nums.begin(), nums.end()), nums.end());
    ranges::sort(nums, greater<>());

    const int maxNum = ranges::max(nums);
    // dp[i] := the longest square streak starts with i
    vector<int> dp(maxNum + 1);

    for (const int num : nums) {
      dp[num] = 1;
      const long squaredNum = static_cast<long>(num) * num;
      if (squaredNum <= maxNum)
        dp[num] += dp[squaredNum];
    }

    const int ans = ranges::max(dp);
    return ans < 2 ? -1 : ans;
  }
};"
"2502","class Allocator:
  def __init__(self, n: int):
    self.memory = [0] * n
    self.mIDToIndices = [[] for _ in range(1001)]

  def allocate(self, size: int, mID: int) -> int:
    consecutiveFree = 0
    for i, m in enumerate(self.memory):
      consecutiveFree = consecutiveFree + 1 if m == 0 else 0
      if consecutiveFree == size:
        for j in range(i - consecutiveFree + 1, i + 1):
          self.memory[j] = mID
          self.mIDToIndices[mID].append(j)
        return i - consecutiveFree + 1
    return -1

  def free(self, mID: int) -> int:
    indices = self.mIDToIndices[mID]
    freedUnits = len(indices)
    for index in indices:
      self.memory[index] = 0
    indices.clear()
    return freedUnits"
"2503","from dataclasses import dataclass


@dataclass(frozen=True)
class IndexedQuery:
  queryIndex: int
  query: int

  def __iter__(self):
    yield self.queryIndex
    yield self.query


class Solution:
  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    ans = [0] * len(queries)
    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)
    seen = {(0, 0)}
    accumulate = 0

    for queryIndex, query in sorted([IndexedQuery(i, query)
                                     for i, query in enumerate(queries)],
                                    key=lambda x: x.query):
      while minHeap:
        val, i, j = heapq.heappop(minHeap)
        if val >= query:
          # The smallest neighbor is still larger than `query`, so no need to
          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.
          heapq.heappush(minHeap, (val, i, j))
          break
        accumulate += 1
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          heapq.heappush(minHeap, (grid[x][y], x, y))
          seen.add((x, y))
      ans[queryIndex] = accumulate

    return ans"
"2504","SELECT
  person_id,
  CONCAT(name, '(', LEFT(profession, 1), ')') name
FROM Person
ORDER BY 1 DESC;"
"2505","class Solution:
  def subsequenceSumOr(self, nums: list[int]) -> int:
    ans = 0
    prefix = 0

    for num in nums:
      prefix += num
      ans |= num | prefix

    return ans"
"2506","class Solution:
  def similarPairs(self, words: list[str]) -> int:
    return sum(set(words[i]) == set(words[j])
               for i in range(len(words))
               for j in range(i + 1, len(words)))"
"2507","class Solution:
  def smallestValue(self, n: int) -> int:
    def getPrimeSum(n: int) -> int:
      primeSum = 0
      for i in range(2, n + 1):
        while n % i == 0:
          n //= i
          primeSum += i
      return primeSum

    primeSum = getPrimeSum(n)
    while n != primeSum:
      n = primeSum
      primeSum = getPrimeSum(n)
    return n"
"2508","class Solution:
  def isPossible(self, n: int, edges: list[list[int]]) -> bool:
    graph = [set() for _ in range(n)]

    for u, v in edges:
      graph[u - 1].add(v - 1)
      graph[v - 1].add(u - 1)

    oddNodes = [i for i, neighbor in enumerate(
        graph) if len(neighbor) % 2 == 1]
    if not oddNodes:
      return True
    if len(oddNodes) == 2:
      a, b = oddNodes
      return any(a not in graph[i] and b not in graph[i] for i in range(n))
    if len(oddNodes) == 4:
      a, b, c, d = oddNodes
      return ((b not in graph[a] and d not in graph[c]) or
              (c not in graph[a] and d not in graph[b]) or
              (d not in graph[a] and c not in graph[b]))
    return False"
"2509","class Solution:
  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:
    def getCycleLength(a: int, b: int):
      cycleLength = 1
      while a != b:
        if a > b:
          a //= 2
        else:
          b //= 2
        cycleLength += 1
      return cycleLength

    return [getCycleLength(*query) for query in queries]"
"251","class Vector2D:
  def __init__(self, vec: list[list[int]]):
    self.vec = []
    self.i = 0

    for A in vec:
      self.vec += A

  def next(self) -> int:
    ans = self.vec[self.i]
    self.i += 1
    return ans

  def hasNext(self) -> bool:
    return self.i < len(self.vec)"
"2510","class Solution:
  def isThereAPath(self, grid: list[list[int]]) -> bool:
    m = len(grid)
    n = len(grid[0])
    if m + n - 1 & 1:
      return False

    @functools.lru_cache(None)
    def dp(i: int, j: int, summ: int) -> bool:
      """"""
      Returns 1 if there's a path to grid[i][j] s.t.
      `summ` = (the number of 0s - the number of 1s).
      """"""
      if i == m or j == n:
        return False
      summ += 1 if grid[i][j] == 0 else -1
      if i == m - 1 and j == n - 1:
        return summ == 0
      return dp(i + 1, j, summ) or dp(i, j + 1, summ)

    return dp(0, 0, 0)"
"2511","class Solution:
  def captureForts(self, forts: list[int]) -> int:
    ans = 0

    j = 0
    for i, fort in enumerate(forts):
      if fort != 0:  # -1 or 1
        if fort == -forts[j]:
          ans = max(ans, i - j - 1)
        j = i

    return ans"
"2512","class Solution:
  def topStudents(
      self,
      positive_feedback: list[str],
      negative_feedback: list[str],
      report: list[str],
      student_id: list[int],
      k: int,
  ) -> list[int]:
    scoreAndIds = []
    pos = set(positive_feedback)
    neg = set(negative_feedback)

    for sid, r in zip(student_id, report):
      score = 0
      for word in r.split():
        if word in pos:
          score += 3
        if word in neg:
          score -= 1
      scoreAndIds.append((-score, sid))

    return [sid for _, sid in sorted(scoreAndIds)[:k]]"
"2513","class Solution:
  def minimizeSet(
      self,
      divisor1: int,
      divisor2: int,
      uniqueCnt1: int,
      uniqueCnt2: int,
  ) -> int:
    divisorLcm = math.lcm(divisor1, divisor2)
    l = 0
    r = 2**31 - 1

    def isPossible(m: int) -> bool:
      """"""
      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and
      take uniqueCnt2 integers from [1..m] to arr2.
      """"""
      cnt1 = m - m // divisor1
      cnt2 = m - m // divisor2
      totalCnt = m - m // divisorLcm
      return (cnt1 >= uniqueCnt1 and
              cnt2 >= uniqueCnt2 and
              totalCnt >= uniqueCnt1 + uniqueCnt2)

    while l < r:
      m = (l + r) // 2
      if isPossible(m):
        r = m
      else:
        l = m + 1

    return l"
"2514","class Solution:
  def countAnagrams(self, s: str) -> int:
    ans = 1

    for word in s.split():
      ans = ans * math.factorial(len(word))
      count = collections.Counter(word)
      for freq in count.values():
        ans //= math.factorial(freq)

    return ans % 1_000_000_007"
"2515","class Solution:
  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:
    n = len(words)

    for i in range(n):
      if words[(startIndex + i + n) % n] == target:
        return i
      if words[(startIndex - i + n) % n] == target:
        return i

    return -1"
"2516","class Solution:
  def takeCharacters(self, s: str, k: int) -> int:
    n = len(s)
    ans = n
    count = collections.Counter(s)
    if any(count[c] < k for c in 'abc'):
      return -1

    l = 0
    for r, c in enumerate(s):
      count[c] -= 1
      while count[c] < k:
        count[s[l]] += 1
        l += 1
      ans = min(ans, n - (r - l + 1))

    return ans"
"2517","class Solution:
  def maximumTastiness(self, price: list[int], k: int) -> int:
    price.sort()

    def cantPick(m: int) -> bool:
      """"""Returns True if we can't pick k distinct candies for m tastiness.""""""
      baskets = 0
      prevPrice = -m
      for p in price:
        if p >= prevPrice + m:
          prevPrice = p
          baskets += 1
      return baskets < k

    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,
                           key=lambda m: cantPick(m))
    return l - 1"
"2518","class Solution:
  def countPartitions(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    summ = sum(nums)
    ans = pow(2, len(nums), kMod)  # 2^n % kMod
    dp = [1] + [0] * k

    for num in nums:
      for i in range(k, num - 1, -1):
        dp[i] += dp[i - num]
        dp[i] %= kMod

    # Substract the cases that're not satisfied.
    for i in range(k):
      if summ - i < k:  # Both group1 and group2 < k.
        ans -= dp[i]
      else:
        ans -= dp[i] * 2

    return ans % kMod"
"2519","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def kBigIndices(self, nums: list[int], k: int) -> int:
    n = len(nums)
    leftTree = FenwickTree(n)
    rightTree = FenwickTree(n)
    # left[i] := the number of `nums` < nums[i] with index < i
    left = [0] * n
    # right[i] := the number of `nums` < nums[i] with index > i
    right = [0] * n

    for i, num in enumerate(nums):
      left[i] = leftTree.get(num - 1)
      leftTree.add(num, 1)

    for i in range(n - 1, -1, -1):
      right[i] = rightTree.get(nums[i] - 1)
      rightTree.add(nums[i], 1)

    return sum(l >= k and r >= k for l, r in zip(left, right))"
"252","class Solution:
  def canAttendMeetings(self, intervals: list[list[int]]) -> bool:
    intervals.sort()

    for i in range(1, len(intervals)):
      if intervals[i - 1][1] > intervals[i][0]:
        return False

    return True"
"2520","class Solution:
  def countDigits(self, num: int) -> int:
    return sum(num % int(d) == 0 for d in str(num))"
"2521","class Solution:
  def distinctPrimeFactors(self, nums: list[int]) -> int:
    primes = set()

    for num in nums:
      self._addPrimeFactors(primes, num)

    return len(primes)

  def _addPrimeFactors(self, primes: set[int], num: int) -> None:
    for divisor in range(2, num + 1):
      if num % divisor == 0:
        primes.add(divisor)
        while num % divisor == 0:
          num //= divisor"
"2522","class Solution:
  def minimumPartition(self, s: str, k: int) -> int:
    ans = 1
    curr = 0

    for c in s:
      curr = curr * 10 + int(c)
      if curr > k:
        curr = int(c)
        ans += 1
      if curr > k:
        return -1

    return ans"
"2523","class Solution:
  def closestPrimes(self, left: int, right: int) -> list[int]:
    isPrime = self._sieveEratosthenes(right + 1)
    primes = [i for i in range(left, right + 1) if isPrime[i]]

    if len(primes) < 2:
      return [-1, -1]

    minDiff = math.inf
    num1 = -1
    num2 = -1

    for a, b in zip(primes, primes[1:]):
      diff = b - a
      if diff < minDiff:
        minDiff = diff
        num1 = a
        num2 = b

    return [num1, num2]

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"2524","class Solution:
  def maxFrequencyScore(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    count = collections.Counter(nums[:k])
    summ = self._getInitialSumm(count, kMod)
    ans = summ

    for i in range(k, len(nums)):
      # Remove the leftmost number that's out-of-window.
      leftNum = nums[i - k]
      summ = (summ - pow(leftNum, count[leftNum], kMod) + kMod) % kMod
      # After decreasing its frequency, if it's still > 0, then add it back.
      count[leftNum] -= 1
      if count[leftNum] > 0:
        summ = (summ + pow(leftNum, count[leftNum], kMod)) % kMod
      # Otherwise, remove it from the count map.
      else:
        del count[leftNum]
      # Add the current number. Similarly, remove the current score like above.
      rightNum = nums[i]
      if count[rightNum] > 0:
        summ = (summ - pow(rightNum, count[rightNum], kMod) + kMod) % kMod
      count[rightNum] += 1
      summ = (summ + pow(rightNum, count[rightNum], kMod)) % kMod
      ans = max(ans, summ)

    return ans

  def _getInitialSumm(self, count: dict[int, int], kMod: int) -> int:
    summ = 0
    for num, freq in count.items():
      summ = (summ + pow(num, freq, kMod)) % kMod
    return summ"
"2525","class Solution:
  def categorizeBox(
      self,
      length: int,
      width: int,
      height: int,
      mass: int,
  ) -> str:
    isBulky = (length >= 10000 or
               width >= 10000 or height >= 10000 or
               length * width * height >= 1_000_000_000)
    isHeavy = mass >= 100
    if isBulky and isHeavy:
      return 'Both'
    if isBulky:
      return 'Bulky'
    if isHeavy:
      return 'Heavy'
    return 'Neither'"
"2526","class DataStream:
  def __init__(self, value: int, k: int):
    self.value = value
    self.k = k
    self.q = deque()
    self.count = 0

  def consec(self, num: int) -> bool:
    if len(self.q) == self.k and self.q.popleft() == self.value:
      self.count -= 1
    if num == self.value:
      self.count += 1
    self.q.append(num)
    return self.count == self.k"
"2527","class Solution:
  def xorBeauty(self, nums: list[int]) -> int:
    return functools.reduce(operator.xor, nums)"
"2528","class Solution:
  def maxPower(self, stations: list[int], r: int, k: int) -> int:
    n = len(stations)
    left = min(stations)
    right = sum(stations) + k + 1

    def check(
            stations: list[int],
            additionalStations: int, minPower: int) -> bool:
      """"""Returns True if each city can have at least `minPower`.""""""
      # Initilaize `power` as the 0-th city's power - stations[r].
      power = sum(stations[:r])

      for i in range(n):
        if i + r < n:
          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).
        if power < minPower:
          requiredPower = minPower - power
          # There're not enough stations to plant.
          if requiredPower > additionalStations:
            return False
          # Greedily plant `requiredPower` power stations in the farthest place
          # to cover as many cities as possible.
          stations[min(n - 1, i + r)] += requiredPower
          additionalStations -= requiredPower
          power += requiredPower
        if i - r >= 0:
          power -= stations[i - r]

      return True

    while left < right:
      mid = (left + right) // 2
      if check(stations.copy(), k, mid):
        left = mid + 1
      else:
        right = mid

    return left - 1"
"2529","class Solution:
  def maximumCount(self, nums: list[int]) -> int:
    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))"
"253","class Solution:
  def minMeetingRooms(self, intervals: list[list[int]]) -> int:
    n = len(intervals)
    ans = 0
    starts = []
    ends = []

    for start, end in intervals:
      starts.append(start)
      ends.append(end)

    starts.sort()
    ends.sort()

    j = 0
    for i in range(n):
      if starts[i] < ends[j]:
        ans += 1
      else:
        j += 1

    return ans"
"2530","class Solution:
  def maxKelements(self, nums: list[int], k: int) -> int:
    ans = 0
    maxHeap = [-num for num in nums]
    heapq.heapify(maxHeap)

    for _ in range(k):
      num = -heapq.heappop(maxHeap)
      ans += num
      heapq.heappush(maxHeap, -math.ceil(num / 3))

    return ans"
"2531","class Solution:
  def isItPossible(self, word1: str, word2: str) -> bool:
    count1 = collections.Counter(word1)
    count2 = collections.Counter(word2)
    distinct1 = len(count1)
    distinct2 = len(count2)

    for a in count1:
      for b in count2:
        if a == b:
          # Swapping the same letters won't change the number of distinct
          # letters in each string, so just check if `distinct1 == distinct2`.
          if distinct1 == distinct2:
            return True
          continue
        # The calculation is meaningful only when a != b
        # Swap a in word1 with b in word2.
        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)
        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)
        if distinctAfterSwap1 == distinctAfterSwap2:
          return True

    return False"
"2532","class Solution:
  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:
    ans = 0
    # (leftToRight + rightToLeft, i)
    leftBridgeQueue = [
        (-leftToRight - rightToLeft, -i) for i,
        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]
    rightBridgeQueue = []
    # (time to be idle, i)
    leftWorkers = []
    rightWorkers = []

    heapq.heapify(leftBridgeQueue)

    while n > 0 or rightBridgeQueue or rightWorkers:
      # Idle left workers get on the left bridge.
      while leftWorkers and leftWorkers[0][0] <= ans:
        i = heapq.heappop(leftWorkers)[1]
        leftWorkers.pop()
        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))
      # Idle right workers get on the right bridge.
      while rightWorkers and rightWorkers[0][0] <= ans:
        i = heapq.heappop(rightWorkers)[1]
        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))
      if rightBridgeQueue:
        # If the bridge is free, the worker waiting on the right side of the
        # bridge gets to cross the bridge. If more than one worker is waiting
        # on the right side, the one with the lowest efficiency crosses first.
        i = -heapq.heappop(rightBridgeQueue)[1]
        ans += time[i][2]
        heapq.heappush(leftWorkers, (ans + time[i][3], i))
      elif leftBridgeQueue and n > 0:
        # If the bridge is free and no worker is waiting on the right side, and
       # at least one box remains at the old warehouse, the worker on the left
       # side of the river gets to cross the bridge. If more than one worker
       # is waiting on the left side, the one with the lowest efficiency
       # crosses first.
        i = -heapq.heappop(leftBridgeQueue)[1]
        ans += time[i][0]
        heapq.heappush(rightWorkers, (ans + time[i][1], i))
        n -= 1
      else:
        # Advance the time of the last crossing worker.
        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,
                  rightWorkers[0][0] if rightWorkers else math.inf)

    return ans"
"2533","class Solution:
  def goodBinaryStrings(
      self,
      minLength: int,
      maxLength: int,
      oneGroup: int,
      zeroGroup: int,
  ) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of good binary strings with length i
    dp = [1] + [0] * maxLength

    for i in range(maxLength + 1):
      # There are good binary strings with length i, so we can append
      # consecutive 0s or 1s after it.
      if dp[i] > 0:
        appendZeros = i + zeroGroup
        if appendZeros <= maxLength:
          dp[appendZeros] += dp[i]
          dp[appendZeros] %= kMod
        appendOnes = i + oneGroup
        if appendOnes <= maxLength:
          dp[appendOnes] += dp[i]
          dp[appendOnes] %= kMod

    return sum(dp[minLength:]) % kMod"
"2534","class Solution {
 public:
  vector<int> timeTaken(vector<int>& arrival, vector<int>& state) {
    const int n = arrival.size();
    vector<int> ans(n);
    // qs[0] := enter, qs[1] := exit
    vector<queue<int>> qs(2);
    int time = 0;
    int d = 1;

    for (int i = 0; i < n; ++i) {
      popQueues(time, d, arrival[i], qs, ans);
      // If the door was not used in the previous second, then the person who
      // wants to exit goes first.
      if (arrival[i] > time) {
        time = arrival[i];  // Forward `time` to now.
        d = 1;
      }
      qs[state[i]].push(i);
    }

    popQueues(time, d, 200'000, qs, ans);
    return ans;
  }

 private:
  void popQueues(int& time, int& d, int arrivalTime, vector<queue<int>>& qs,
                 vector<int>& ans) {
    while (arrivalTime > time && (!qs[0].empty() || !qs[1].empty())) {
      if (qs[d].empty())
        d ^= 1;
      ans[qs[d].front()] = time, qs[d].pop();
      ++time;
    }
  }
};"
"2535","class Solution:
  def differenceOfSum(self, nums: list[int]) -> int:
    elementSum = sum(nums)
    digitSum = self._getAllDigitSum(nums)
    return abs(elementSum - digitSum)

  def _getAllDigitSum(self, nums: list[int]) -> int:
    return sum(self._getDigitSum(num) for num in nums)

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"2536","class Solution {
 public:
  vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {
    vector<vector<int>> ans(n, vector<int>(n));
    vector<vector<int>> prefix(n, vector<int>(n + 1));

    for (const vector<int>& query : queries) {
      const int row1 = query[0];
      const int col1 = query[1];
      const int row2 = query[2];
      const int col2 = query[3];
      for (int i = row1; i <= row2; ++i) {
        ++prefix[i][col1];
        --prefix[i][col2 + 1];
      }
    }

    for (int i = 0; i < n; ++i) {
      int sum = 0;
      for (int j = 0; j < n; ++j) {
        sum += prefix[i][j];
        ans[i][j] = sum;
      }
    }

    return ans;
  }
};"
"2537","class Solution {
 public:
  long long countGood(vector<int>& nums, int k) {
    long ans = 0;
    int pairs = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      // Since there're count[r] nums[r]s, including nums[r] to the window will
      // increase the number of good subarrays by count[r].
      pairs += count[nums[r]]++;
      while (pairs >= k)
        pairs -= --count[nums[l++]];
      // nums[0..r], nums[1..r], ..., nums[l - 1..r] are good subarrays, so add
      // l to `ans`.
      ans += l;
    }

    return ans;
  }
};"
"2538","class Solution:
  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:
    ans = 0
    tree = [[] for _ in range(n)]
    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def maxSum(u: int, prev: int) -> int:
      maxChildSum = 0
      for v in tree[u]:
        if v != prev:
          maxChildSum = max(maxChildSum, maxSum(v, u))
      maxSums[u] = price[u] + maxChildSum
      return maxSums[u]

    # Precalculate `maxSums`.
    maxSum(0, -1)

    def reroot(u: int, prev: int, parentSum: int) -> None:
      nonlocal ans
      # Get the top two subtree sums and the top one node index.
      maxSubtreeSum1 = 0
      maxSubtreeSum2 = 0
      maxNode = -1
      for v in tree[u]:
        if v == prev:
          continue
        if maxSums[v] > maxSubtreeSum1:
          maxSubtreeSum2 = maxSubtreeSum1
          maxSubtreeSum1 = maxSums[v]
          maxNode = v
        elif maxSums[v] > maxSubtreeSum2:
          maxSubtreeSum2 = maxSums[v]

      if len(tree[u]) == 1:
        ans = max(ans, parentSum, maxSubtreeSum1)

      for v in tree[u]:
        if v == prev:
          continue
        nextParentSum = (
            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else
            price[u] + max(parentSum, maxSubtreeSum1))
        reroot(v, u, nextParentSum)

    reroot(0, -1, 0)
    return ans"
"2539","class Solution:
  def countGoodSubsequences(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = collections.Counter(s)

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    @functools.lru_cache(None)
    def nCk(n: int, k: int) -> int:
      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod

    for freq in range(1, max(count.values()) + 1):
      numSubseqs = 1  # """"
      for charFreq in count.values():
        if charFreq >= freq:
          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % kMod
      ans += numSubseqs - 1  # Minus """".
      ans %= kMod

    return ans"
"254","class Solution:
  def getFactors(self, n: int) -> list[list[int]]:
    ans = []

    def dfs(n: int, s: int, path: list[int]) -> None:
      if n <= 1:
        if len(path) > 1:
          ans.append(path.copy())
        return

      for i in range(s, n + 1):
        if n % i == 0:
          path.append(i)
          dfs(n // i, i, path)
          path.pop()

    dfs(n, 2, [])  # The minimum factor is 2.
    return ans"
"2540","class Solution:
  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:
    i = 0  # nums1's index
    j = 0  # nums2's index

    while i < len(nums1) and j < len(nums2):
      if nums1[i] == nums2[j]:
        return nums1[i]
      if nums1[i] < nums2[j]:
        i += 1
      else:
        j += 1

    return -1"
"2541","class Solution:
  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:
    if k == 0:
      return 0 if nums1 == nums2 else -1

    ans = 0
    opsDiff = 0  # the number of increments - number of decrements

    for num1, num2 in zip(nums1, nums2):
      diff = num1 - num2
      if diff == 0:
        continue
      if diff % k != 0:
        return -1
      ops = diff // k
      opsDiff += ops
      ans += abs(ops)

    return ans // 2 if opsDiff == 0 else -1"
"2542","class Solution:
  # Same as 1383. Maximum Performance of a Team
  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:
    ans = 0
    summ = 0
    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order
    A = sorted([(num2, num1)
               for num1, num2 in zip(nums1, nums2)], reverse=True)
    minHeap = []

    for num2, num1 in A:
      heapq.heappush(minHeap, num1)
      summ += num1
      if len(minHeap) > k:
        summ -= heapq.heappop(minHeap)
      if len(minHeap) == k:
        ans = max(ans, summ * num2)

    return ans"
"2543","class Solution:
  def isReachable(self, targetX: int, targetY: int) -> bool:
    return math.gcd(targetX, targetY).bit_count() == 1"
"2544","class Solution:
  def alternateDigitSum(self, n: int) -> int:
    ans = 0
    sign = 1

    while n > 0:
      sign *= -1
      ans += n % 10 * sign
      n //= 10

    return sign * ans"
"2545","class Solution:
  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:
    return sorted(score, key=lambda x: -x[k])"
"2546","class Solution:
  def makeStringsEqual(self, s: str, target: str) -> bool:
    return ('1' in s) == ('1' in target)"
"2547","class Solution:
  def minCost(self, nums: list[int], k: int) -> int:
    kMax = 1001
    n = len(nums)
    # trimmedLength[i][j] := trimmed(nums[i..j]).length
    trimmedLength = [[0] * n for _ in range(n)]
    # dp[i] := the minimum cost to split nums[i..n)
    dp = [math.inf] * n + [0]

    for i in range(n):
      length = 0
      count = [0] * kMax
      for j in range(i, n):
        count[nums[j]] += 1
        if count[nums[j]] == 2:
          length += 2
        elif count[nums[j]] > 2:
          length += 1
        trimmedLength[i][j] = length

    dp[n] = 0

    for i in range(n - 1, -1, -1):
      for j in range(i, n):
        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])

    return dp[0]"
"2548","class Solution:
  def maxPrice(self, items: list[list[int]], capacity: int) -> float:
    ans = 0

    # Sort items based on price//weight.
    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):
      # The bag is filled.
      if capacity <= weight:
        return ans + price * capacity / weight
      ans += price
      capacity -= weight

    return -1"
"2549","class Solution:
  def distinctIntegers(self, n: int) -> int:
    return max(n - 1, 1)"
"255","class Solution:
  def verifyPreorder(self, preorder: list[int]) -> list[int]:
    low = -math.inf
    stack = []

    for p in preorder:
      if p < low:
        return False
      while stack and stack[-1] < p:
        low = stack.pop()
      stack.append(p)

    return True"
"2550","class Solution:
  def monkeyMove(self, n: int) -> int:
    kMod = 1_000_000_007
    res = pow(2, n, kMod) - 2
    return res + kMod if res < 0 else res"
"2551","class Solution:
  def putMarbles(self, weights: list[int], k: int) -> int:
    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a
    # cut after weights[i], then weights[i] and weights[i + 1] will be added to
    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will
    # be counted. So, the goal is to find the max//min k - 1 weights[i] +
    # weights[i + 1].

    # weights[i] + weights[i + 1]
    A = [a + b for a, b in itertools.pairwise(weights)]
    return sum(heapq.nlargest(k - 1, A)) - sum(heapq.nsmallest(k - 1, A))"
"2552","class Solution:
  def countQuadruplets(self, nums: list[int]) -> int:
    ans = 0
    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <
    # nums[j]. Keep this information for l to use later.
    dp = [0] * len(nums)

    # k can be treated as l.
    for k in range(2, len(nums)):
      numLessThanK = 0
      # j can be treated as i.
      for j in range(k):
        if nums[j] < nums[k]:
          numLessThanK += 1  # nums[i] < nums[k]
          # nums[j] < nums[l], so we should add dp[j] since we find a new
          # quadruplets for (i, j, k, l).
          ans += dp[j]
        elif nums[j] > nums[k]:
          dp[j] += numLessThanK

    return ans"
"2553","class Solution:
  def separateDigits(self, nums: list[int]) -> list[int]:
    return [int(c) for num in nums for c in str(num)]"
"2554","class Solution:
  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:
    ans = 0
    summ = 0
    bannedSet = set(banned)

    for i in range(1, n + 1):
      if i not in bannedSet and summ + i <= maxSum:
        ans += 1
        summ += i

    return ans"
"2555","class Solution:
  def maximizeWin(self, prizePositions: list[int], k: int) -> int:
    ans = 0
    # dp[i] := the maximum number of prizes to choose the first i
    # `prizePositions`
    dp = [0] * (len(prizePositions) + 1)

    j = 0
    for i, prizePosition in enumerate(prizePositions):
      while prizePosition - prizePositions[j] > k:
        j += 1
      covered = i - j + 1
      dp[i + 1] = max(dp[i], covered)
      ans = max(ans, dp[j] + covered)

    return ans"
"2556","class Solution:
  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:
    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).
    # Also marks the visited path as 0 except (m - 1, n - 1).
    def hasPath(i: int, j: int) -> bool:
      if i == len(grid) or j == len(grid[0]):
        return False
      if i == len(grid) - 1 and j == len(grid[0]) - 1:
        return True
      if grid[i][j] == 0:
        return False

      grid[i][j] = 0
      # Go down first. Since we use OR logic, we'll only mark one path.
      return hasPath(i + 1, j) or hasPath(i, j + 1)

    if not hasPath(0, 0):
      return True
    # Reassign (0, 0) as 1.
    grid[0][0] = 1
    return not hasPath(0, 0)"
"2557","class Solution:
  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:
    bannedSet = set(banned)
    l = 1
    r = n

    while l < r:
      m = (l + r + 1) // 2
      if self._getSum(bannedSet, m) > maxSum:
        r = m - 1
      else:
        l = m

    return l - sum(b <= l for b in banned)

  # Returns sum([1..m]) - sum(bannedSet).
  def _getSum(self, bannedSet: set[int], m: int) -> int:
    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)"
"2558","class Solution:
  def pickGifts(self, gifts: list[int], k: int) -> int:
    maxHeap = [-gift for gift in gifts]
    heapq.heapify(maxHeap)

    for _ in range(k):
      squaredMax = math.isqrt(-heapq.heappop(maxHeap))
      heapq.heappush(maxHeap, -squaredMax)

    return -sum(maxHeap)"
"2559","class Solution:
  def vowelStrings(
      self,
      words: list[str],
      queries: list[list[int]],
  ) -> list[int]:
    kVowels = 'aeiou'
    # prefix[i] := the number of the first i words that start with and end in a vowel
    prefix = [0] * (len(words) + 1)

    for i, word in enumerate(words):
      prefix[i + 1] += prefix[i] + (word[0] in kVowels and word[-1] in kVowels)

    return [prefix[r + 1] - prefix[l]
            for l, r in queries]"
"256","class Solution:
  def minCost(self, costs: list[list[int]]) -> list[list[int]]:
    for i in range(1, len(costs)):
      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

    return min(costs[-1])"
"2560","class Solution:
  def minCapability(self, nums: list[int], k: int) -> int:
    def numStolenHouses(capacity: int) -> int:
      stolenHouses = 0
      i = 0
      while i < len(nums):
        if nums[i] <= capacity:
          stolenHouses += 1
          i += 1
        i += 1
      return stolenHouses

    return bisect.bisect_left(range(max(nums)), k,
                              key=lambda m: numStolenHouses(m))"
"2561","class Solution:
  def minCost(self, basket1: list[int], basket2: list[int]) -> int:
    swapped = []
    count = collections.Counter(basket1)
    count.subtract(collections.Counter(basket2))

    for num, freq in count.items():
      if freq % 2 != 0:
        return -1
      swapped += [num] * abs(freq // 2)

    swapped.sort()
    minNum = min(min(basket1), min(basket2))
    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]
    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.
    # That's why we take min(2 * minNum, num) in the below.
    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])"
"2562","class Solution {
 public:
  long long findTheArrayConcVal(vector<int>& nums) {
    long ans = 0;

    for (int i = 0, j = nums.size() - 1; i <= j; ++i, --j) {
      ans += nums[j];
      if (i < j)
        ans += nums[i] * pow(10, static_cast<int>(log10(nums[j])) + 1);
    }

    return ans;
  }
};"
"2563","class Solution:
  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:
    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j
    # degrades to i != j and we can sort the array.
    nums.sort()

    def countLess(summ: int) -> int:
      res = 0
      i = 0
      j = len(nums) - 1
      while i < j:
        while i < j and nums[i] + nums[j] > summ:
          j -= 1
        res += j - i
        i += 1
      return res

    return countLess(upper) - countLess(lower - 1)"
"2564","class Solution:
  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:
    kMaxBit = 30
    # {val: [left, right]} := s[left..right]'s decimal value = val
    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])

    for left, c in enumerate(s):
      val = 0
      if c == '0':
        # edge case: Save the index of the first 0.
        if 0 not in valToLeftAndRight:
          valToLeftAndRight[0] = [left, left]
        continue
      for right in range(left, min(len(s), left + kMaxBit)):
        val = val * 2 + int(s[right])
        if val not in valToLeftAndRight:
          valToLeftAndRight[val] = [left, right]

    return [valToLeftAndRight[first, right]
            for first, right in queries]"
"2565","class Solution:
  def minimumScore(self, s: str, t: str) -> int:
    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].
    #          -1 := impossible
    leftmost = [-1] * len(t)
    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).
    #           -1 := impossible
    rightmost = [-1] * len(t)

    j = 0  # t's index
    for i in range(len(s)):
      if s[i] == t[j]:
        leftmost[j] = i
        j += 1
        if j == len(t):
          break

    j = len(t) - 1  # t's index
    for i in reversed(range(len(s))):
      if s[i] == t[j]:
        rightmost[j] = i
        j -= 1
        if j == -1:
          break

    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced
    # from the above loop).
    ans = j + 1

    j = 0
    for i in range(len(t)):
      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since
      # no need to consider any larger i.
      if leftmost[i] == -1:
        break
      # While t[0..i] + t[j:] is not a subsequence of s, increase j.
      while j < len(t) and leftmost[i] >= rightmost[j]:
        j += 1
      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.
      # If i == j that means t is a subsequence of s, so just return 0.
      if i == j:
        return 0
      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.
      ans = min(ans, j - i - 1)

    return ans"
"2566","class Solution:
  def minMaxDifference(self, num: int) -> int:
    s = str(num)
    to9 = s[self._firstNotNineIndex(s)]
    to0 = s[0]
    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))

  def _firstNotNineIndex(self, s: str) -> int:
    for i, c in enumerate(s):
      if c != '9':
        return i
    return 0"
"2567","class Solution:
  def minimizeSum(self, nums: list[int]) -> int:
    nums.sort()
    # Can always change the number to any other number in `nums`, so `low` becomes 0.
    # Thus, rephrase the problem as finding the minimum `high`.
    highOfChangingTwoMins = nums[-1] - nums[2]
    highOfChangingTwoMaxs = nums[-3] - nums[0]
    highOfChangingMinAndMax = nums[-2] - nums[1]
    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,
               highOfChangingMinAndMax)"
"2568","class Solution:
  def minImpossibleOR(self, nums: list[int]) -> int:
    ans = 1
    numsSet = set(nums)

    while ans in numsSet:
      ans <<= 1

    return ans"
"2569","class LazySegmentTree {
 public:
  explicit LazySegmentTree(const vector<int>& nums) {
    const int n = nums.size();
    tree.resize(4 * n);
    lazy.resize(4 * n);
    build(nums, 0, 0, n - 1);
  }

  //            i := index of the current node
  // [start, end] := range of the current node
  //       [l, r] := range of the query
  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i])
      propogate(i, start, end);
    if (start > r || end < l)
      return;
    if (start >= l && end <= r) {
      flip(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];
  }

  int getTreeSum() const {
    return tree[0];
  }

 private:
  vector<int> tree;
  vector<bool> lazy;

  void build(const vector<int>& nums, int i, int start, int end) {
    if (start == end) {
      tree[i] = nums[start];
      return;
    }
    const int mid = (start + end) / 2;
    build(nums, 2 * i + 1, start, mid);
    build(nums, 2 * i + 2, mid + 1, end);
    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];
  }

  void propogate(int i, int start, int end) {
    flip(i, start, end);
    lazy[i] = false;
  }

  void flip(int i, int start, int end) {
    tree[i] = (end - start + 1) - tree[i];  // Flip 0/1.
    if (start < end) {
      lazy[2 * i + 1] = !lazy[2 * i + 1];
      lazy[2 * i + 2] = !lazy[2 * i + 2];
    }
  }
};

class Solution {
 public:
  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,
                                vector<vector<int>>& queries) {
    vector<long long> ans;
    LazySegmentTree tree(nums1);
    long sumNums2 = accumulate(nums2.begin(), nums2.end(), 0L);

    for (const vector<int>& query : queries) {
      const int type = query[0];
      const int l = query[1];
      const int r = query[2];
      if (type == 1) {
        tree.updateRange(0, 0, nums1.size() - 1, l, r);
      } else if (type == 2) {
        sumNums2 += static_cast<long>(l) * tree.getTreeSum();
      } else {  // type == 3
        ans.push_back(sumNums2);
      }
    }

    return ans;
  }
};"
"257","class Solution:
  def binaryTreePaths(self, root: TreeNode | None) -> list[str]:
    ans = []

    def dfs(root: TreeNode | None, path: list[str]) -> None:
      if not root:
        return
      if not root.left and not root.right:
        ans.append(''.join(path) + str(root.val))
        return

      path.append(str(root.val) + '->')
      dfs(root.left, path)
      dfs(root.right, path)
      path.pop()

    dfs(root, [])
    return ans"
"2570","class Solution:
  def mergeArrays(self, nums1: list[list[int]],
                  nums2: list[list[int]]) -> list[list[int]]:
    count = [0] * (1001)
    self._addCount(nums1, count)
    self._addCount(nums2, count)
    return [[i, c] for i, c in enumerate(count) if c > 0]

  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:
    for id_, val in nums:
      count[id_] += val"
"2571","class Solution:
  def minOperations(self, n: int) -> int:
    # The strategy is that when the end of n is
    #   1. consecutive 1s, add 1 (2^0).
    #   2. single 1, substract 1 (2^0).
    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.
    #
    # e.g.
    #
    #         n = 0b101
    # n -= 2^0 -> 0b100
    # n -= 2^2 -> 0b0
    #         n = 0b1011
    # n += 2^0 -> 0b1100
    # n -= 2^2 -> 0b1000
    # n -= 2^3 -> 0b0
    ans = 0

    while n > 0:
      if (n & 3) == 3:
        n += 1
        ans += 1
      elif n % 2 == 1:
        n -= 1
        ans += 1
      else:
        n >>= 1

    return ans"
"2572","class Solution:
  def squareFreeSubsets(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

    def getMask(num: int) -> int:
      """"""
      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)
           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)
           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)
      """"""
      mask = 0
      for i, prime in enumerate(primes):
        rootCount = 0
        while num % prime == 0:
          num //= prime
          rootCount += 1
        if rootCount >= 2:
          return -1
        if rootCount == 1:
          mask |= 1 << i
      return mask << 1

    masks = [getMask(num) for num in nums]

    @functools.lru_cache(None)
    def dp(i: int, used: int) -> int:
      if i == len(masks):
        return 1
      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0
      skip = dp(i + 1, used)
      return (pick + skip) % kMod

    # -1 means that we take no number.
    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.
    return (dp(0, 1) - 1 + kMod) % kMod"
"2573","class Solution {
 public:
  string findTheString(vector<vector<int>>& lcp) {
    const int n = lcp.size();
    constexpr char nonLetter = 'a' - 1;
    char c = nonLetter;
    vector<char> word(n, nonLetter);

    for (int i = 0; i < n; ++i) {
      if (word[i] != nonLetter)  // There's a candidate already.
        continue;
      if (++c > 'z')  // Run out of letters, so return """".
        return """";
      // No need to consider [0..i - 1] since they were considered.
      for (int j = i; j < n; ++j)
        if (lcp[i][j] > 0)
          word[j] = c;
    }

    // Check if `word` is valid.
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        const int nextLcp = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;
        const int currLcp = word[i] == word[j] ? 1 + nextLcp : 0;
        if (lcp[i][j] != currLcp)
          return """";
      }

    string ans;
    for (const char c : word)
      ans += c;
    return ans;
  }
};"
"2574","class Solution:
  def leftRigthDifference(self, nums: list[int]) -> list[int]:
    ans = []
    leftSum = 0
    rightSum = sum(nums)

    for num in nums:
      rightSum -= num
      ans.append(abs(leftSum - rightSum))
      leftSum += num

    return ans"
"2575","class Solution:
  def divisibilityArray(self, word: str, m: int) -> list[int]:
    ans = []
    prevRemainder = 0

    for c in word:
      remainder = (prevRemainder * 10 + int(c)) % m
      ans.append(1 if remainder == 0 else 0)
      prevRemainder = remainder

    return ans"
"2576","class Solution:
  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:
    nums.sort()

    def isPossible(m: int) -> bool:
      for i in range(m):
        if 2 * nums[i] > nums[-m + i]:
          return False
      return True

    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,
                           key=lambda m: not isPossible(m))
    return (l - 1) * 2"
"2577","class Solution:
  def minimumTime(self, grid: list[list[int]]) -> int:
    if grid[0][1] > 1 and grid[1][0] > 1:
      return -1

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    minHeap = [(0, 0, 0)]  # (time, i, j)
    seen = {(0, 0)}

    while minHeap:
      time, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return time
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0
        nextTime = max(time + 1, grid[x][y] + extraWait)
        heapq.heappush(minHeap, (nextTime, x, y))
        seen.add((x, y))"
"2578","class Solution:
  def splitNum(self, num: int) -> int:
    s = ''.join(sorted(str(num)))
    return sum(map(int, (s[::2], s[1::2])))"
"2579","class Solution:
  def coloredCells(self, n: int) -> int:
    return n**2 + (n - 1)**2"
"258","class Solution:
  def addDigits(self, num: int) -> int:
    return 0 if num == 0 else 1 + (num - 1) % 9"
"2580","class Solution:
  def countWays(self, ranges: list[list[int]]) -> int:
    kMod = 1_000_000_007
    ans = 1
    prevEnd = -1

    for start, end in sorted(ranges):
      if start > prevEnd:
        ans = ans * 2 % kMod
      prevEnd = max(prevEnd, end)

    return ans"
"2581","class Solution:
  def rootCount(
      self,
      edges: list[list[int]],
      guesses: list[list[int]],
      k: int,
  ) -> int:
    ans = 0
    n = len(edges) + 1
    graph = [[] for _ in range(n)]
    guessGraph = [set() for _ in range(n)]
    parent = [0] * n

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    for u, v in guesses:
      guessGraph[u].add(v)

    def dfs(u: int, prev: int) -> None:
      parent[u] = prev
      for v in graph[u]:
        if v != prev:
          dfs(v, u)

    # Precalculate `parent`.
    dfs(0, -1)

    # Calculate `correctGuess` for tree rooted at 0.
    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))

    def reroot(u: int, prev: int, correctGuess: int) -> None:
      nonlocal ans
      if u != 0:
        # The tree is rooted at u, so a guess edge (u, prev) will match the new
        # `parent` relationship.
        if prev in guessGraph[u]:
          correctGuess += 1
        # A guess edge (prev, u) matching the old `parent` relationship will no
        # longer be True.
        if u in guessGraph[prev]:
          correctGuess -= 1
      if correctGuess >= k:
        ans += 1
      for v in graph[u]:
        if v != prev:
          reroot(v, u, correctGuess)

    reroot(0, -1, correctGuess)
    return ans"
"2582","class Solution:
  def passThePillow(self, n: int, time: int) -> int:
    # Repeat every (n - 1) * 2 seconds.
    time %= (n - 1) * 2
    if time < n:  # Go forward from 1.
      return 1 + time
    return n - (time - (n - 1))  # Go backward from n."
"2583","class Solution:
  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:
    levelSums = []

    def dfs(root: TreeNode | None, level: int) -> None:
      if not root:
        return
      if len(levelSums) == level:
        levelSums.append(0)
      levelSums[level] += root.val
      dfs(root.left, level + 1)
      dfs(root.right, level + 1)

    dfs(root, 0)
    if len(levelSums) < k:
      return -1

    return sorted(levelSums, reverse=True)[k - 1]"
"2584","class Solution:
  def findValidSplit(self, nums: list[int]) -> int:
    leftPrimeFactors = collections.Counter()
    rightPrimeFactors = collections.Counter()

    def getPrimeFactors(num: int) -> list[int]:
      """"""Gets the prime factors under sqrt(10^6).""""""
      primeFactors = []
      for divisor in range(2, min(1000, num) + 1):
        if num % divisor == 0:
          primeFactors.append(divisor)
          while num % divisor == 0:
            num //= divisor
      # Handle the case that `num` contains a prime factor > 1000.
      if num > 1:
        primeFactors.append(num)
      return primeFactors

    for num in nums:
      for primeFactor in getPrimeFactors(num):
        rightPrimeFactors[primeFactor] += 1

    for i in range(len(nums) - 1):
      for primeFactor in getPrimeFactors(nums[i]):
        rightPrimeFactors[primeFactor] -= 1
        if rightPrimeFactors[primeFactor] == 0:
          # rightPrimeFactors[primeFactor] == 0, so no need to track
          # leftPrimeFactors[primeFactor].
          del rightPrimeFactors[primeFactor]
          del leftPrimeFactors[primeFactor]
        else:
          # Otherwise, need to track leftPrimeFactors[primeFactor].
          leftPrimeFactors[primeFactor] += 1
      if not leftPrimeFactors:
        return i

    return -1"
"2585","class Solution:
  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:
    kMod = 1_000_000_007
    # dp[i][j] := the number of ways to earn j points with the first i types
    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]
    dp[0][0] = 1

    for i in range(1, len(types) + 1):
      count = types[i - 1][0]
      mark = types[i - 1][1]
      for j in range(target + 1):
        for solved in range(count + 1):
          if j - solved * mark >= 0:
            dp[i][j] += dp[i - 1][j - solved * mark]
            dp[i][j] %= kMod

    return dp[len(types)][target]"
"2586","class Solution:
  def vowelStrings(self, words: list[str], left: int, right: int) -> int:
    kVowels = 'aeiou'
    return sum(word[0] in kVowels and word[-1] in kVowels
               for word in words[left:right + 1])"
"2587","class Solution:
  def maxScore(self, nums: list[int]) -> int:
    return sum(num > 0
               for num in itertools.accumulate(sorted(nums, reverse=True)))"
"2588","class Solution:
  def beautifulSubarrays(self, nums: list[int]) -> int:
    # A subarray is beautiful if xor(subarray) = 0.
    ans = 0
    prefix = 0
    prefixCount = collections.Counter({0: 1})

    for num in nums:
      prefix ^= num
      ans += prefixCount[prefix]
      prefixCount[prefix] += 1

    return ans"
"2589","class Solution:
  def findMinimumTime(self, tasks: list[list[int]]) -> int:
    kMax = 2000
    running = [False] * (kMax + 1)

    # Sort tasks by end.
    for start, end, duration in sorted(tasks, key=lambda x: x[1]):
      neededDuration = (duration -
                        sum(running[i] for i in range(start, end + 1)))
      # Greedily run the task as late as possible so that later tasks can run
      # simultaneously.
      i = end
      while neededDuration > 0:
        if not running[i]:
          running[i] = True
          neededDuration -= 1
        i -= 1

    return sum(running)"
"259","class Solution:
  def threeSumSmaller(self, nums: list[int], target: int) -> int:
    if len(nums) < 3:
      return 0

    ans = 0

    nums.sort()

    for i in range(len(nums) - 2):
      l = i + 1
      r = len(nums) - 1
      while l < r:
        if nums[i] + nums[l] + nums[r] < target:
          # (nums[i], nums[l], nums[r])
          # (nums[i], nums[l], nums[r - 1])
          # ...,
          # (nums[i], nums[l], nums[l + 1])
          ans += r - l
          l += 1
        else:
          r -= 1

    return ans"
"2590","from dataclasses import dataclass


@dataclass(frozen=True)
class Task:
  taskDescription: str
  dueDate: int
  tags: list[str]


class TodoList:
  def __init__(self):
    self.taskId = 0
    self.taskIds = set()
    self.userIdToTaskIdToTasks: dict[int, dict[int, list[Task]]] = {}

  def addTask(self, userId: int, taskDescription: str, dueDate: int,
              tags: list[str]) -> int:
    self.taskId += 1
    taskIdToTasks = self.userIdToTaskIdToTasks.setdefault(userId, {})
    taskIdToTasks[self.taskId] = Task(taskDescription, dueDate, tags)
    self.taskIds.add(self.taskId)
    return self.taskId

  def getAllTasks(self, userId: int) -> list[str]:
    return [task.taskDescription
            for task in self._getTasksSortedByDueDate(userId)]

  def getTasksForTag(self, userId: int, tag: str) -> list[str]:
    return [task.taskDescription
            for task in self._getTasksSortedByDueDate(userId)
            if tag in task.tags]

  def completeTask(self, userId: int, taskId: int) -> None:
    if taskId not in self.taskIds:
      return
    if userId not in self.userIdToTaskIdToTasks:
      return
    taskIdToTasks = self.userIdToTaskIdToTasks[userId]
    if taskId not in taskIdToTasks:
      return
    del taskIdToTasks[taskId]

  def _getTasksSortedByDueDate(self, userId: int) -> list[Task]:
    if userId not in self.userIdToTaskIdToTasks:
      return []
    taskIdToTasks = self.userIdToTaskIdToTasks[userId]
    return sorted(
        [task for task in taskIdToTasks.values()],
        key=lambda x: x.dueDate)"
"2591","class Solution:
  def distMoney(self, money: int, children: int) -> int:
    # Everyone must receive at least 1 dollar.
    money -= children
    if money < 0:
      return -1

    count7 = money // 7
    remaining = money % 7

    # Distribute 8 dollars to every child.
    if count7 == children and remaining == 0:
      return count7

    # Need to move 1 dollar from the last child with 4 dollars to one of other
    # children. That's why we need to substract 1.
    if count7 == children - 1 and remaining == 3:
      return count7 - 1

    # Though there might be child with 4 dollars, since count7 < children - 1,
    # we have 'extra' spot to move money to if needed.
    return min(children - 1, count7)"
"2592","class Solution:
  def maximizeGreatness(self, nums: list[int]) -> int:
    ans = 0

    nums.sort()

    for num in nums:
      if num > nums[ans]:
        ans += 1

    return ans"
"2593","class Solution:
  def findScore(self, nums: list[int]) -> int:
    ans = 0
    seen = set()

    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):
      if i in seen:
        continue
      seen.add(i - 1)
      seen.add(i + 1)
      seen.add(i)
      ans += num

    return ans"
"2594","class Solution:
  def repairCars(self, ranks: list[int], cars: int) -> int:
    def numCarsFixed(minutes: int) -> int:
      #    r * n^2 = minutes
      # -> n = sqrt(minutes / r)
      return sum(math.isqrt(minutes // rank) for rank in ranks)

    return bisect.bisect_left(
        range(min(ranks) * cars**2), cars,
        key=lambda m: numCarsFixed(m))"
"2595","class Solution:
  def evenOddBit(self, n: int) -> list[int]:
    ans = [0] * 2
    i = 0  # 0 := even, 1 := odd

    while n > 0:
      ans[i] += n & 1
      n >>= 1
      i ^= 1

    return ans"
"2596","class Solution:
  def checkValidGrid(self, grid: list[list[int]]) -> bool:
    if grid[0][0] != 0:
      return False

    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    n = len(grid)
    i = 0
    j = 0

    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:
      """"""
      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.
      """"""
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x >= n or y < 0 or y >= n:
          continue
        if grid[x][y] == target:
          return (x, y)
      return (-1, -1)

    for target in range(1, n * n):
      x, y = nextGrid(i, j, target)
      if x == -1 and y == -1:
        return False
      # Move (x, y) to (i, j).
      i = x
      j = y

    return True"
"2597","# e.g. nums = [2, 3, 4, 4], k = 2
#
# subset[0] = [2, 4, 4']
# subset[1] = [1]
# count = {2: 1, 4: 2, 1: 1}
#
# Initially, skip = len([]) = 0, pick = len([]) = 0
#
# * For values in subset[0]:
#   After 2:
#     skip = skip + pick = len([]) = 0
#     pick = (2^count[2] - 1) * (1 + skip + pick)
#          = len([[2]]) * len([[]])
#          = len([[2]]) = 1
#   After 4:
#     skip = skip + pick = len([[2]]) = 1
#     pick = (2^count[4] - 1) * (1 + skip)
#          = len([[4], [4'], [4, 4']]) * len([[]])
#          = len([[4], [4'], [4, 4']]) = 3
#
# * For values in subset[1]:
#   After 1:
#     skip = skip + pick
#          = len([[2], [4], [4'], [4, 4']]) = 4
#     pick = (2^count[1] - 1) * (1 + skip + pick)
#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])
#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5
#
# So, ans = skip + pick = 9

class Solution:
  def beautifulSubsets(self, nums: list[int], k: int) -> int:
    count = collections.Counter(nums)
    modToSubset = collections.defaultdict(set)

    for num in nums:
      modToSubset[num % k].add(num)

    prevNum = -k
    skip = 0
    pick = 0

    for subset in modToSubset.values():
      for num in sorted(subset):
        nonEmptyCount = 2**count[num] - 1
        skip, pick = (skip + pick,
                      nonEmptyCount *
                      (1 + skip + (0 if num - prevNum == k else pick)))
        prevNum = num

    return skip + pick"
"2598","class Solution:
  def findSmallestInteger(self, nums: list[int], value: int) -> int:
    count = collections.Counter([num % value for num in nums])

    for i in range(len(nums)):
      if count[i % value] == 0:
        return i
      count[i % value] -= 1

    return len(nums)"
"2599","class Solution:
  def makePrefSumNonNegative(self, nums: list[int]) -> int:
    ans = 0
    prefix = 0
    minHeap = []

    for num in nums:
      prefix += num
      if num < 0:
        heapq.heappush(minHeap, num)
      while prefix < 0:
        prefix -= heapq.heappop(minHeap)
        ans += 1

    return ans"
"26","class Solution:
  def removeDuplicates(self, nums: list[int]) -> int:
    i = 0

    for num in nums:
      if i < 1 or num > nums[i - 1]:
        nums[i] = num
        i += 1

    return i"
"260","class Solution:
  def singleNumber(self, nums: list[int]) -> list[int]:
    xors = functools.reduce(operator.xor, nums)
    lowbit = xors & -xors
    ans = [0, 0]

    # Seperate `nums` into two groups by `lowbit`.
    for num in nums:
      if num & lowbit:
        ans[0] ^= num
      else:
        ans[1] ^= num

    return ans"
"2600","class Solution:
  def kItemsWithMaximumSum(
      self,
      numOnes: int,
      numZeros: int,
      numNegOnes: int,
      k: int,
  ) -> int:
    if k <= numOnes:
      return k
    if k <= numOnes + numZeros:
      return numOnes
    return numOnes - (k - numOnes - numZeros)"
"2601","class Solution:
  def primeSubOperation(self, nums: list[int]) -> bool:
    kMax = 1000
    primes = self._sieveEratosthenes(kMax)

    prevNum = 0
    for num in nums:
      # Make nums[i] the smallest as possible and still > nums[i - 1].
      i = bisect.bisect_left(primes, num - prevNum)
      if i > 0:
        num -= primes[i - 1]
      if num <= prevNum:
        return False
      prevNum = num

    return True

  def _sieveEratosthenes(self, n: int) -> list[int]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return [i for i in range(n) if isPrime[i]]"
"2602","class Solution:
  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:
    n = len(nums)
    nums.sort()
    prefix = list(itertools.accumulate(nums, initial=0))
    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]
    return [(query * i - prefix[i]) +
            (prefix[-1] - prefix[i] - query * (n - i))
            for query, i in splits]"
"2603","class Solution:
  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:
    n = len(coins)
    tree = [set() for _ in range(n)]
    leavesToBeRemoved = collections.deque()

    for u, v in edges:
      tree[u].add(v)
      tree[v].add(u)

    for u in range(n):
      # Remove the leaves that don't have coins.
      while len(tree[u]) == 1 and coins[u] == 0:
        v = tree[u].pop()
        tree[v].remove(u)
        u = v  # Walk up to its parent.
      # After trimming leaves without coins, leaves with coins may satisfy
      # `leavesToBeRemoved`.
      if len(tree[u]) == 1:  # coins[u] must be 1.
        leavesToBeRemoved.append(u)

    # Remove each remaining leaf node and its parent. The remaining nodes are
    # the ones that must be visited.
    for _ in range(2):
      for _ in range(len(leavesToBeRemoved)):
        u = leavesToBeRemoved.popleft()
        if tree[u]:
          v = tree[u].pop()
          tree[v].remove(u)
          if len(tree[v]) == 1:  # It's a leaf.
            leavesToBeRemoved.append(v)

    return sum(len(children) for children in tree)"
"2604","class Solution:
  def minimumTime(self, hens: list[int], grains: list[int]) -> int:
    hens.sort()
    grains.sort()

    def canEat(time: int) -> bool:
      """"""Returns True if `hens` can eat all `grains` within `time`.""""""
      i = 0  # grains[i] := next grain to be ate
      for hen in hens:
        rightMoves = time
        if grains[i] < hen:
          # `hen` needs go back to eat `grains[i]`.
          leftMoves = hen - grains[i]
          if leftMoves > time:
            return False
          leftThenRight = time - 2 * leftMoves
          rightThenLeft = (time - leftMoves) // 2
          rightMoves = max(0, leftThenRight, rightThenLeft)
        i = bisect.bisect_right(grains, hen + rightMoves)
        if i == len(grains):
          return True
      return False

    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))
    return bisect.bisect_left(range(maxMoves), True, key=lambda m: canEat(m))"
"2605","class Solution:
  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:
    return min(a if a == b else min(a, b) * 10 + max(a, b)
               for a in nums1
               for b in nums2)"
"2606","class Solution:
  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:
    ans = 0
    cost = 0
    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i

    for c, val in zip(chars, vals):
      costs[string.ascii_lowercase.index(c)] = val

    for c in s:
      cost = max(0, cost + costs[string.ascii_lowercase.index(c)])
      ans = max(ans, cost)

    return ans"
"2607","class Solution:
  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:
    # If the sum of each subarray of length k is equal, then `arr` must have a
    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have
    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==
    # arr[(i + k) % n] for every i.
    n = len(arr)
    ans = 0
    seen = [0] * n

    for i in range(n):
      groups = []
      j = i
      while not seen[j]:
        groups.append(arr[j])
        seen[j] = True
        j = (j + k) % n
      groups.sort()
      for num in groups:
        ans += abs(num - groups[len(groups) // 2])

    return ans"
"2608","class Solution:
  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:
    kInf = 1001
    ans = kInf
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    def bfs(i: int) -> int:
      """"""Returns the length of the minimum cycle by starting BFS from node `i`.

      Returns `kInf` if there's no cycle.
      """"""
      dist = [kInf] * n
      q = collections.deque([i])
      dist[i] = 0
      while q:
        u = q.popleft()
        for v in graph[u]:
          if dist[v] == kInf:
            dist[v] = dist[u] + 1
            q.append(v)
          elif dist[v] + 1 != dist[u]:   # v is not a parent u.
            return dist[v] + dist[u] + 1
      return kInf

    ans = min(map(bfs, range(n)))
    return -1 if ans == kInf else ans"
"2609","class Solution:
  def findTheLongestBalancedSubstring(self, s: str) -> int:
    ans = 0

    i = 0
    while i < len(s):
      zeros = 0
      ones = 0
      while i < len(s) and s[i] == '0':
        zeros += 1
        i += 1
      while i < len(s) and s[i] == '1':
        ones += 1
        i += 1
      ans = max(ans, min(zeros, ones))

    return ans * 2"
"261","class Solution:
  def validTree(self, n: int, edges: list[list[int]]) -> bool:
    if n == 0 or len(edges) != n - 1:
      return False

    graph = [[] for _ in range(n)]
    q = collections.deque([0])
    seen = {0}

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    while q:
      u = q.popleft()
      for v in graph[u]:
        if v not in seen:
          q.append(v)
          seen.add(v)

    return len(seen) == n"
"2610","class Solution:
  def findMatrix(self, nums: list[int]) -> list[list[int]]:
    # The number of rows we need equals the maximum frequency.
    ans = []
    count = [0] * (len(nums) + 1)

    for num in nums:
      count[num] += 1
      # Construct `ans` on demand.
      if count[num] > len(ans):
        ans.append([])
      ans[count[num] - 1].append(num)

    return ans"
"2611","class Solution:
  def miceAndCheese(
      self,
      reward1: list[int],
      reward2: list[int],
      k: int,
  ) -> int:
    return (sum(reward2) +
            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))"
"2612","from sortedcontainers import SortedList


class Solution:
  def minReverseOperations(
      self,
      n: int,
      p: int,
      banned: list[int],
      k: int,
  ) -> list[int]:
    bannedSet = set(banned)
    ans = [-1] * n
    # unseen[i] := the unseen numbers that % 2 == i
    unseen = [SortedList(), SortedList()]

    for num in range(n):
      if num != p and num not in bannedSet:
        unseen[num % 2].add(num)

    # Perform BFS from `p`.
    q = collections.deque([p])
    ans[p] = 0

    while q:
      u = q.popleft()
      lo = max(u - k + 1, k - 1 - u)
      hi = min(u + k - 1, n - 1 - (u - (n - k)))
      # Choose the correct set of numbers.
      nums = unseen[lo % 2]
      i = nums.bisect_left(lo)
      while i < len(nums) and nums[i] <= hi:
        num = nums[i]
        ans[num] = ans[u] + 1
        q.append(num)
        nums.pop(i)

    return ans"
"2613","class SegmentTree {
 public:
  explicit SegmentTree(const vector<int>& nums)
      : maxNum(nums.size()), nums(std::move(nums)), tree(4 * maxNum, -1) {}

  // Updates the value of the node to be the index of the smaller number between
  // the old value stored at the node and the new value `index`, where `i` is
  // the index of the element in the `nums` array.
  void update(int i, int numIndex) {
    update(0, 0, maxNum, i, numIndex);
  }

  // Returns the index k s.t. `nums[k]` is maximum number in the range [i, j].
  int query(int i, int j) const {
    return query(0, 0, maxNum, i, j);
  }

 private:
  // default node value for non-overlapping queries
  static constexpr int kDefaultValue = -1;
  const int maxNum;
  const vector<int> nums;  // nums2 + nums1 or nums2 - nums1
  vector<int> tree;        // tree[i] := the minimum index stored in this node

  void update(int treeIndex, int lo, int hi, int i, int numIndex) {
    if (lo == hi) {
      tree[treeIndex] = merge(tree[treeIndex], numIndex);
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, numIndex);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, numIndex);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return kDefaultValue;
    const int mid = (lo + hi) / 2;
    return merge(query(2 * treeIndex + 1, lo, mid, i, j),
                 query(2 * treeIndex + 2, mid + 1, hi, i, j));
  }

  // Returns the better index. Index i is better than index j if
  // (nums[i] > nums[j]) or (nums[i] == nums[j] && i < j).
  int merge(const int& i, const int& j) const {
    if (i == -1)
      return j;
    if (j == -1)
      return i;
    if (nums[i] > nums[j])
      return i;
    if (nums[j] > nums[i])
      return j;
    return min(i, j);
  }
};

class Solution {
 public:
  vector<int> beautifulPair(vector<int>& nums1, vector<int>& nums2) {
    // The goal is to find the lexicographically smallest beautiful pair (i, j)
    // s.t. |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest.
    //
    // Sort `nums2` and store the order in `indices`.
    // To minimize |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|, since we
    // already have sorted `nums2`, we can always have nums2[i] > nums2[j] while
    // iterating the array. So we only need to consider the following 2 cases:
    //
    // * nums1[i] >= nums1[j]:
    //   The value will be nums1[i] - nums1[j] + nums2[i] - nums2[j]
    //                   = (nums2[i] + nums1[i]) - (nums2[j] + nums1[j])
    //   Just find max (nums2[j] + nums1[j]) s.t. 0 <= nums1[j] <= nums1[i].
    //
    // * nums1[i] <= nums1[j]:
    //   The value will be nums1[j] - nums1[i] + nums2[i] - nums2[j]
    //                   = (nums2[i] - nums1[i]) - (nums2[j] - nums1[j])
    //   Just find max (nums2[j] - nums1[j]) s.t. nums1[i] <= nums1[j] <= n.
    constexpr int kInf = 1'000'000'000;
    const int n = nums1.size();
    vector<int> ans(2, n);
    vector<int> nums2PlusNums1;
    vector<int> nums2MinusNums1;
    vector<int> indices;
    int minBeauty = INT_MAX;

    for (int i = 0; i < n; ++i) {
      nums2PlusNums1.push_back(nums2[i] + nums1[i]);
      nums2MinusNums1.push_back(nums2[i] - nums1[i]);
      indices.push_back(i);
    }

    ranges::sort(indices,
                 [&nums2](int i, int j) { return nums2[i] < nums2[j]; });

    SegmentTree tree1(nums2PlusNums1);
    SegmentTree tree2(nums2MinusNums1);

    for (const int i : indices) {
      const int num = nums1[i];
      // For case nums1[i] >= nums1[j], find index j s.t. (nums2[j] + nums1[j])
      // is the maximum in the range [0, nums1[i]].
      int j = tree1.query(0, num);
      if (j >= 0)
        updateAns(nums2PlusNums1, i, j, minBeauty, ans);
      tree1.update(num, i);
      // For case nums1[i] <= nums1[j], find index j s.t. (nums2[j] - nums1[j])
      // is the maximum in the range [nums1[i], n].
      j = tree2.query(num, n);
      if (j >= 0)
        updateAns(nums2MinusNums1, i, j, minBeauty, ans);
      tree2.update(num, i);
    }

    return ans;
  }

 private:
  void updateAns(const vector<int>& nums, int i, int j, int& minBeauty,
                 vector<int>& ans) {
    // beauty := |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|
    const int beauty = nums[i] - nums[j];
    const vector<int> nextAns = {min(i, j), max(i, j)};
    if (beauty < minBeauty) {
      minBeauty = beauty;
      ans = nextAns;
    } else if (beauty == minBeauty) {
      ans = min(ans, nextAns);
    }
  }
};"
"2614","class Solution:
  def diagonalPrime(self, nums: list[list[int]]) -> int:
    def isPrime(n: int) -> bool:
      if n <= 1:
        return False
      for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
          return False
      return True

    primes1 = [row[i]
               for i, row in enumerate(nums) if isPrime(row[i])]
    primes2 = [row[-i - 1]
               for i, row in enumerate(nums) if isPrime(row[-i - 1])]
    return max(max(primes1) if primes1 else 0,
               max(primes2) if primes2 else 0)"
"2615","class Solution:
  def distance(self, nums: list[int]) -> list[int]:
    ans = [0] * len(nums)
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    for indices in numToIndices.values():
      n = len(indices)
      if n == 1:
        continue
      sumSoFar = sum(indices)
      prevIndex = 0
      for i in range(n):
        sumSoFar += (i - 1) * (indices[i] - prevIndex)
        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)
        ans[indices[i]] = sumSoFar
        prevIndex = indices[i]

    return ans"
"2616","class Solution:
  def minimizeMax(self, nums: list[int], p: int) -> int:
    nums.sort()

    def numPairs(maxDiff: int) -> int:
      """"""
      Returns the number of pairs that can be obtained if the difference between
      each pair <= `maxDiff`.
      """"""
      pairs = 0
      i = 1
      while i < len(nums):
        # Greedily pair nums[i] with nums[i - 1].
        if nums[i] - nums[i - 1] <= maxDiff:
          pairs += 1
          i += 2
        else:
          i += 1
      return pairs

    return bisect.bisect_left(range(0, nums[-1] - nums[0]), p,
                              key=lambda m: numPairs(m))"
"2617","class SegmentTree {
 public:
  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}

  // Updates nums[i] to val.
  void update(int i, int val) {
    update(0, 0, n - 1, i, val);
  }

  // Returns min(nums[i..j]).
  int query(int i, int j) const {
    return query(0, 0, n - 1, i, j);
  }

 private:
  const int kInf;    // the invalid value
  const int n;       // the size of the input array
  vector<int> tree;  // the segment tree

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      tree[treeIndex] = val;
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, val);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return kInf;
    const int mid = (lo + hi) / 2;
    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),
                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));
  }

  int merge(int left, int right) const {
    return min(left, right);
  }
};

class Solution {
 public:
  int minimumVisitedCells(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const int kInf = (m + n) * 2 - 1;
    vector<SegmentTree> rows(m, SegmentTree(n, kInf));
    vector<SegmentTree> cols(n, SegmentTree(m, kInf));

    // The min # cells to visit (m - 1, n - 1) from (m - 1, n - 1) is 1.
    rows[m - 1].update(n - 1, 1);
    cols[n - 1].update(m - 1, 1);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        // There's no k s.t. j < k <= 0 + j.
        // There's no k s.t. i < k <= 0 + i.
        if (grid[i][j] == 0)
          continue;
        const int moveRight = rows[i].query(j + 1, grid[i][j] + j);
        const int moveDown = cols[j].query(i + 1, grid[i][j] + i);
        const int minMove = min(kInf, min(moveRight, moveDown) + 1);
        rows[i].update(j, minMove);
        cols[j].update(i, minMove);
      }

    const int res = rows[0].query(0, 0);
    return res == kInf ? -1 : res;
  }
};"
"2618","function checkIfInstanceOf(obj: any, classFunction: any): boolean {
  while (obj != null) {
    if (obj.constructor === classFunction) {
      return true;
    }
    obj = Object.getPrototypeOf(obj);
  }
  return false;
}"
"2619","declare global {
  interface Array<T> {
    last(): T | -1;
  }
}

Array.prototype.last = function () {
  return this.length === 0 ? -1 : this[this.length - 1];
};

export {};"
"262","SELECT
  Trips.request_at AS Day,
  ROUND(SUM(Trips.status != 'completed') / COUNT(*), 2) AS 'Cancellation Rate'
FROM Trips
INNER JOIN Users AS Clients
  ON (Trips.client_id = Clients.users_id)
INNER JOIN Users AS Drivers
  ON (Trips.driver_id = Drivers.users_id)
WHERE Clients.banned = 'No'
  AND Drivers.banned = 'No'
  AND Trips.request_at BETWEEN '2013-10-01' AND '2013-10-03'
GROUP BY 1;"
"2620","function createCounter(n: number): () => number {
  return function () {
    return n++;
  };
}"
"2621","async function sleep(millis: number): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(resolve, millis);
  });
}"
"2622","interface TTLValue {
  value: number;
  timer: ReturnType<typeof setTimeout>;
}

class TimeLimitedCache {
  private cache = new Map<number, TTLValue>();

  set(key: number, value: number, duration: number): boolean {
    const exists = this.cache.has(key);
    if (exists) {
      clearTimeout(this.cache.get(key).timer);
    }
    this.cache.set(key, {
      value,
      timer: setTimeout(() => this.cache.delete(key), duration),
    });
    return exists;
  }

  get(key: number): number {
    return this.cache.has(key) ? this.cache.get(key).value : -1;
  }

  count(): number {
    return this.cache.size;
  }
}"
"2623","type Fn = (...params: number[]) => number;

function memoize(fn: Fn): Fn {
  const cache: Record<string, number> = {};
  return function (...args) {
    const key = args.join(' ');
    return cache[key] === undefined ? (cache[key] = fn(...args)) : cache[key];
  };
}"
"2624","declare global {
  interface Array<T> {
    snail(rowsCount: number, colsCount: number): number[][];
  }
}

Array.prototype.snail = function (
  rowsCount: number,
  colsCount: number
): number[][] {
  if (rowsCount * colsCount != this.length) {
    return [];
  }
  const ans: number[][] = [];
  for (let i = 0; i < rowsCount; ++i) {
    ans.push([]);
  }
  for (let i = 0; i < rowsCount; ++i)
    for (let j = 0; j < colsCount; ++j) {
      const k = j * rowsCount + (j % 2 == 0 ? i : rowsCount - 1 - i);
      ans[i][j] = this[k];
    }
  return ans;
};"
"2625","type MultiDimensionalArray = (number | MultiDimensionalArray)[];

var flat = function (
  arr: MultiDimensionalArray,
  n: number
): MultiDimensionalArray {
  function dfs(arr: number | MultiDimensionalArray, n: number) {
    if (typeof arr === 'number') {
      ans.push(arr);
    } else if (n === 0) {
      for (const element of arr) {
        ans.push(element);
      }
    } else {
      for (const element of arr) {
        dfs(element, n - 1);
      }
    }
  }
  const ans: MultiDimensionalArray = [];
  dfs(arr, n);
  return ans;
};"
"2626","type Fn = (accum: number, curr: number) => number;

function reduce(nums: number[], fn: Fn, init: number): number {
  let ans = init;
  for (const num of nums) {
    ans = fn(ans, num);
  }
  return ans;
}"
"2627","type F = (...args: number[]) => void;

function debounce(fn: F, t: number): F {
  let timeout: ReturnType<typeof setTimeout> | undefined;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), t);
  };
}"
"2628","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function areDeeplyEqual(o1: JSONValue, o2: JSONValue): boolean {
  if (o1 === o2) {
    return true;
  }
  if (o1 === null || o1 === undefined || o2 === null || o2 === undefined) {
    return false;
  }
  if (typeof o1 !== 'object' || typeof o2 !== 'object') {
    return false;
  }
  if (Array.isArray(o1) !== Array.isArray(o2)) {
    return false;
  }
  if (Object.keys(o1).length != Object.keys(o2).length) {
    return false;
  }
  for (const key in o1) {
    if (!areDeeplyEqual(o1[key], o2[key])) {
      return false;
    }
  }
  return true;
}"
"2629","type F = (x: number) => number;

function compose(functions: F[]): F {
  return function (x) {
    return functions.reduceRight((val, f) => f(val), x);
  };
}"
"263","class Solution:
  def isUgly(self, n: int) -> bool:
    if n == 0:
      return False

    for prime in 2, 3, 5:
      while n % prime == 0:
        n //= prime

    return n == 1"
"2630","type Fn = (...params: any) => any;

function memoize(fn: Fn): Fn {
  const root = new Map(); // trie
  const ansKey = {};
  return function (...params) {
    let node = root;
    for (const param of params) {
      let next = node.get(param);
      if (next === undefined) {
        next = new Map();
        node.set(param, next);
      }
      node = next;
    }

    // Check if `ansKey` has been set.
    if (node.has(ansKey)) return node.get(ansKey);
    const ans = fn(...params);
    node.set(ansKey, ans);
    return ans;
  };
}"
"2631","declare global {
  interface Array<T> {
    groupBy(fn: (item: T) => string): Record<string, T[]>;
  }
}

Array.prototype.groupBy = function (fn) {
  const ans: Record<string, any[]> = {};
  for (const item of this) {
    const key = fn(item);
    if (ans[key] === undefined) {
      ans[key] = [];
    }
    ans[key].push(item);
  }
  return ans;
};"
"2632","function curry(fn: Function): Function {
  return function curried(...args: any[]): any {
    return args.length >= fn.length
      ? fn.apply(this, args)
      : curried.bind(this, ...args);
  };
}"
"2633","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function jsonStringify(object: JSONValue): string {
  if (object === null) {
    return 'null';
  }
  if (typeof object === 'boolean' || typeof object === 'number') {
    return String(object);
  }
  if (typeof object === 'string') {
    return `""${object}""`;
  }
  if (Array.isArray(object)) {
    const elems = object.map((elem) => jsonStringify(elem));
    return `[${elems.join(',')}]`;
  }
  // typeof object === 'object'
  const pairs = Object.keys(object).map(
    (key) => `""${key}"":${jsonStringify(object[key])}`
  );
  return `{${pairs.join(',')}}`;
}"
"2634","type Fn = (n: number, i: number) => any;

function filter(arr: number[], fn: Fn): number[] {
  const ans: number[] = [];
  arr.forEach((a, index) => {
    if (fn(a, index)) {
      ans.push(a);
    }
  });
  return ans;
}"
"2635","function map(arr: number[], fn: (n: number, i: number) => number): number[] {
  const ans: number[] = [];
  arr.forEach((a, index) => {
    ans.push(fn(a, index));
  });
  return ans;
}"
"2636","type F = () => Promise<any>;

function promisePool(functions: F[], n: number): Promise<any> {
  const next = () => functions[n++]?.().then(next);
  return Promise.all(functions.slice(0, n).map((f) => f().then(next)));
}"
"2637","type Fn = (...params: any[]) => Promise<any>;

function timeLimit(fn: Fn, t: number): Fn {
  return async function (...args) {
    const p1 = new Promise((_, reject) => {
      setTimeout(() => reject('Time Limit Exceeded'), t);
    });
    const p2 = fn(...args);
    return Promise.race([p1, p2]);
  };
}"
"2638","class Solution:
  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:
    modToSubset = collections.defaultdict(set)

    for num in nums:
      modToSubset[num % k].add(num)

    prevNum = -k
    skip = 0
    pick = 0

    for subset in modToSubset.values():
      for num in sorted(subset):
        skip, pick = (skip + pick,
                      1 + skip + (0 if num - prevNum == k else pick))
        prevNum = num

    return 1 + skip + pick"
"2639","class Solution:
  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:
    return [max(map(len, map(str, col))) for col in zip(*grid)]"
"264","class Solution:
  def nthUglyNumber(self, n: int) -> int:
    nums = [1]
    i2 = 0
    i3 = 0
    i5 = 0

    while len(nums) < n:
      next2 = nums[i2] * 2
      next3 = nums[i3] * 3
      next5 = nums[i5] * 5
      next = min(next2, next3, next5)
      if next == next2:
        i2 += 1
      if next == next3:
        i3 += 1
      if next == next5:
        i5 += 1
      nums.append(next)

    return nums[-1]"
"2640","class Solution:
  def findPrefixScore(self, nums: list[int]) -> list[int]:
    conver = []
    mx = 0

    for num in nums:
      mx = max(mx, num)
      conver.append(num + mx)

    return itertools.accumulate(conver)"
"2641","class Solution:
  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:
    levelSums = []

    def dfs(root: TreeNode | None, level: int) -> None:
      if not root:
        return
      if len(levelSums) == level:
        levelSums.append(0)
      levelSums[level] += root.val
      dfs(root.left, level + 1)
      dfs(root.right, level + 1)

    def replace(
        root: TreeNode | None,
        level: int, curr: TreeNode | None,
    ) -> TreeNode | None:
      nextLevel = level + 1
      nextLevelCousinsSum = (
          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -
          (root.left.val if root.left else 0) -
          (root.right.val if root.right else 0))
      if root.left:
        curr.left = TreeNode(nextLevelCousinsSum)
        replace(root.left, level + 1, curr.left)
      if root.right:
        curr.right = TreeNode(nextLevelCousinsSum)
        replace(root.right, level + 1, curr.right)
      return curr

    dfs(root, 0)
    return replace(root, 0, TreeNode(0))"
"2642","class Graph:
  def __init__(self, n: int, edges: list[list[int]]):
    self.graph = [[] for _ in range(n)]
    for edge in edges:
      self.addEdge(edge)

  def addEdge(self, edge: list[int]):
    u, v, w = edge
    self.graph[u].append((v, w))

  def shortestPath(self, node1: int, node2: int) -> int:
    dist = [math.inf] * len(self.graph)

    dist[node1] = 0
    minHeap = [(dist[node1], node1)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if u == node2:
        return d
      for v, w in self.graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return -1"
"2643","class Solution:
  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:
    ans = [0, 0]

    for i, row in enumerate(mat):
      ones = row.count(1)
      if ones > ans[1]:
        ans[0] = i
        ans[1] = ones

    return ans"
"2644","class Solution:
  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:
    ans = -1
    maxScore = -1

    for divisor in divisors:
      score = sum([1 for num in nums if num % divisor == 0])
      if score > maxScore:
        ans = divisor
        maxScore = score
      elif score == maxScore:
        ans = min(ans, divisor)

    return ans"
"2645","class Solution:
  def addMinimum(self, word: str) -> int:
    letters = ['a', 'b', 'c']
    ans = 0
    i = 0

    while i < len(word):
      for c in letters:
        if i < len(word) and word[i] == c:
          i += 1
        else:
          ans += 1

    return ans"
"2646","class Solution:
  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],
                        trips: list[list[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    # count[i] := the number of times i is traversed
    count = [0] * n

    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:
      path.append(u)
      if u == end:
        for i in path:
          count[i] += 1
        return
      for v in graph[u]:
        if v != prev:
          dfsCount(v, u, end,  path)
      path.pop()

    for start, end in trips:
      dfsCount(start, -1, end, [])

    @functools.lru_cache(None)
    def dfs(u: int, prev: int, parentHalved: bool) -> int:
      """"""
      Returns the minimum price sum for the i-th node, where its parent is
      halved parent or not halved not.
      """"""
      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)
                                                  for v in graph[u]
                                                  if v != prev)
      if parentHalved:  # Can't halve this node if its parent was halved.
        return sumWithFullNode
      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)
                                                           for v in graph[u]
                                                           if v != prev)
      return min(sumWithFullNode, sumWithHalvedNode)

    return dfs(0, -1, False)"
"2647","class Solution:
  def colorRed(self, n: int) -> list[list[int]]:
    ans = []
    tipSize = n % 4

    # The tip of the triangle is always painted red.
    if tipSize >= 1:
      ans.append([1, 1])

    # Pamost right and most left elements at the following rows.
    for i in range(2, tipSize + 1):
      ans.append([i, 1])
      ans.append([i, 2 * i - 1])

    # Pa4-row chunks.
    for i in range(tipSize + 1, n, 4):
      # Fill the first row of the chunk.
      ans.append([i, 1])
      # Fill the second row.
      for j in range(1, i + 1):
        ans.append([i + 1, 2 * j + 1])
      # Fill the third row.
      ans.append([i + 2, 2])
      # Fill the fourth row.
      for j in range(i + 2 + 1):
        ans.append([i + 3, 2 * j + 1])

    return ans"
"2648","function* fibGenerator(): Generator<number, any, number> {
  const arr = [0, 0, 1];
  while (true) {
    yield arr[1];
    arr[0] = arr[1];
    arr[1] = arr[2];
    arr[2] = arr[0] + arr[1];
  }
}"
"2649","type MultidimensionalArray = (MultidimensionalArray | number)[];

function* inorderTraversal(
  arr: MultidimensionalArray
): Generator<number, void, unknown> {
  for (const item of arr) {
    if (typeof item === 'number') {
      yield item;
    } else {
      yield* inorderTraversal(item);
    }
  }
}"
"265","class Solution:
  def minCostII(self, costs: list[list[int]]) -> int:
    prevIndex = -1  # the previous minimum index
    prevMin1 = 0  # the minimum cost so far
    prevMin2 = 0  # the second minimum cost so far

    for cost in costs:  # O(n)
      # the painted index that will achieve the minimum cost after painting the
      # current house
      index = -1
      # the minimum cost after painting the current house
      min1 = math.inf
      # the second minimum cost after painting the current house
      min2 = math.inf
      for i, cst in enumerate(cost):   # O(k)
        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)
        if theCost < min1:
          index = i
          min2 = min1
          min1 = theCost
        elif theCost < min2:  # min1 <= theCost < min2
          min2 = theCost

      prevIndex = index
      prevMin1 = min1
      prevMin2 = min2

    return prevMin1"
"2650","function cancellable<T>(
  generator: Generator<Promise<any>, T, unknown>
): [() => void, Promise<T>] {
  let cancel = () => {};
  const cancelPromise = new Promise<never>((_, reject) => {
    cancel = () => reject('Cancelled');
  });

  const promise = (async (): Promise<T> => {
    let next = generator.next();
    while (!next.done) {
      try {
        next = generator.next(await Promise.race([next.value, cancelPromise]));
      } catch (e) {
        next = generator.throw(e);
      }
    }
    return next.value;
  })();

  return [cancel, promise];
}"
"2651","class Solution:
  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:
    return (arrivalTime + delayedTime) % 24"
"2652","class Solution:
  def sumOfMultiples(self, n: int) -> int:
    ans = 0
    for i in range(1, n + 1):
      if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
        ans += i
    return ans"
"2653","class Solution:
  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:
    ans = []
    count = [0] * 50  # count[i] := the frequency of (i + 50)

    for i, num in enumerate(nums):
      if num < 0:
        count[num + 50] += 1
      if i - k >= 0 and nums[i - k] < 0:
        count[nums[i - k] + 50] -= 1
      if i + 1 >= k:
        ans.append(self._getXthSmallestNum(count, x))

    return ans

  def _getXthSmallestNum(self, count: list[int], x: int) -> int:
    prefix = 0
    for i in range(50):
      prefix += count[i]
      if prefix >= x:
        return i - 50
    return 0"
"2654","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    n = len(nums)
    ones = nums.count(1)
    if ones > 0:
      return n - ones

    # the minimum operations to make the shortest subarray with a gcd == 1
    minOps = math.inf

    for i, g in enumerate(nums):
      for j in range(i + 1, n):
        g = math.gcd(g, nums[j])
        if g == 1:   # gcd(nums[i..j]:== 1
          minOps = min(minOps, j - i)
          break

    # After making the shortest subarray with `minOps`, need additional n - 1
    # operations to make the other numbers to 1.
    return -1 if minOps == math.inf else minOps + n - 1"
"2655","class Solution:
  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:
    ans = []
    start = 0

    for l, r in sorted(ranges):
      if start < l:
        ans.append([start, l - 1])
      if start <= r:
        start = r + 1

    if start < n:
      ans.append([start, n - 1])

    return ans"
"2656","class Solution:
  def maximizeSum(self, nums: list[int], k: int) -> int:
    return max(nums) * k + k * (k - 1) // 2"
"2657","class Solution:
  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:
    n = len(A)
    prefixCommon = 0
    ans = []
    count = [0] * (n + 1)

    for a, b in zip(A, B):
      count[a] += 1
      if count[a] == 2:
        prefixCommon += 1
      count[b] += 1
      if count[b] == 2:
        prefixCommon += 1
      ans.append(prefixCommon)

    return ans"
"2658","class Solution:
  def findMaxFish(self, grid: list[list[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return 0
      if grid[i][j] == 0:
        return 0
      caughtFish = grid[i][j]
      grid[i][j] = 0  # Mark 0 as visited
      return (caughtFish +
              dfs(i + 1, j) + dfs(i - 1, j) +
              dfs(i, j + 1) + dfs(i, j - 1))

    return max(dfs(i, j)
               for i in range(len(grid))
               for j in range(len(grid[0])))"
"2659","class Solution:
  def countOperationsToEmptyArray(self, nums: list[int]) -> int:
    n = len(nums)
    ans = n
    numToIndex = {}

    for i, num in enumerate(nums):
      numToIndex[num] = i

    nums.sort()

    for i in range(1, n):
      # On the i-th step we've already removed the i - 1 smallest numbers and
      # can ignore them. If an element nums[i] has smaller index in origin
      # array than nums[i - 1], we should rotate the whole left array n - i
      # times to set nums[i] element on the first position.
      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:
        ans += n - i

    return ans"
"266","class Solution:
  def canPermutePalindrome(self, s: str) -> bool:
    seen = set()

    for c in s:
      if c in seen:
        seen.remove(c)
      else:
        seen.add(c)

    return len(seen) <= 1"
"2660","class Solution:
  def isWinner(self, player1: list[int], player2: list[int]) -> int:
    def getScore(player: list[int]) -> int:
      kInvalid = -3
      score = 0
      last10 = kInvalid
      for i, p in enumerate(player):
        score += p if i - last10 > 2 else p * 2
        if p == 10:
          last10 = i
      return score

    score1 = getScore(player1)
    score2 = getScore(player2)
    if score1 > score2:
      return 1
    if score2 > score1:
      return 2
    return 0"
"2661","class Solution:
  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    # rows[i] := the number of painted grid in the i-th row
    rows = [0] * m
    # cols[j] := the number of painted grid in the j-th column
    cols = [0] * n
    # numToRow[num] := the i-th row of `num` in `mat`
    numToRow = [0] * (m * n + 1)
    # numToCol[num] := the j-th column of `num` in `mat`
    numToCol = [0] * (m * n + 1)

    for i, row in enumerate(mat):
      for j, num in enumerate(row):
        numToRow[num] = i
        numToCol[num] = j

    for i, a in enumerate(arr):
      rows[numToRow[a]] += 1
      if rows[numToRow[a]] == n:
        return i
      cols[numToCol[a]] += 1
      if cols[numToCol[a]] == m:
        return i"
"2662","class Solution:
  def minimumCost(
      self,
      start: list[int],
      target: list[int],
      specialRoads: list[list[int]],
  ) -> int:
    return self.dijkstra(specialRoads, *start, *target)

  def dijkstra(
      self,
      specialRoads: list[list[int]],
      srcX: int,
      srcY: int,
      dstX: int,
      dstY: int,
  ) -> int:
    n = len(specialRoads)
    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)
    dist = [math.inf] * n
    minHeap = []  # (d, u), where u := the i-th specialRoads

    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)
    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):
      d = abs(x1 - srcX) + abs(y1 - srcY) + cost
      dist[u] = d
      heapq.heappush(minHeap, (dist[u], u))

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      _, _, ux2, uy2, _ = specialRoads[u]
      for v in range(n):
        if v == u:
          continue
        vx1, vy1, _, _, vcost = specialRoads[v]
        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)
        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost
        if newDist < dist[v]:
          dist[v] = newDist
          heapq.heappush(minHeap, (dist[v], v))

    ans = abs(dstX - srcX) + abs(dstY - srcY)
    for u in range(n):
      _, _, x2, y2, _ = specialRoads[u]
      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).
      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))

    return ans"
"2663","class Solution:
  def smallestBeautifulString(self, s: str, k: int) -> str:
    chars = list(s)

    for i in reversed(range(len(chars))):
      chars[i] = chr(ord(chars[i]) + 1)
      while self._containsPalindrome(chars, i):
        chars[i] = chr(ord(chars[i]) + 1)
      if chars[i] < chr(ord('a') + k):
        # If s[i] is among the first k letters, then change the letters after
        # s[i] to the smallest ones that don't form any palindrome substring.
        return self._changeSuffix(chars, i + 1)

    return ''

  def _containsPalindrome(self, chars: list[str], i: int) -> bool:
    """"""Returns True if chars[0..i] contains palindrome.""""""
    return ((i > 0 and chars[i] == chars[i - 1]) or
            (i > 1 and chars[i] == chars[i - 2]))

  def _changeSuffix(self, chars: list[str], i: int) -> str:
    """"""
    Returns a string, where replacing sb[i..n) with the smallest possible
    letters don't form any palindrome substring.
    """"""
    for j in range(i, len(chars)):
      chars[j] = 'a'
      while self._containsPalindrome(chars, j):
        chars[j] = chr(ord(chars[j]) + 1)
    return ''.join(chars)"
"2664","class Solution:
  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    ans = [[-1] * n for _ in range(m)]

    def dfs(i: int, j: int, step: int) -> bool:
      if step == m * n:
        return True
      if i < 0 or i >= m or j < 0 or j >= n:
        return False
      if ans[i][j] != -1:
        return False
      ans[i][j] = step
      for dx, dy in dirs:
        if dfs(i + dx, j + dy, step + 1):
          return True
      ans[i][j] = -1
      return False

    dfs(r, c, 0)
    return ans"
"2665","type ReturnObj = {
  increment: () => number;
  decrement: () => number;
  reset: () => number;
};

function createCounter(init: number): ReturnObj {
  let cur = init;
  return {
    increment: () => ++cur,
    decrement: () => --cur,
    reset: () => (cur = init),
  };
}"
"2666","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type OnceFn = (...args: JSONValue[]) => JSONValue | undefined;

function once(fn: Function): OnceFn {
  let isCalled = false;
  return function (...args) {
    if (isCalled) {
      return;
    }
    isCalled = true;
    return fn(...args);
  };
}"
"2667","function createHelloWorld() {
  return function (..._): string {
    return 'Hello World';
  };
}"
"2668","SELECT
  emp_id,
  firstname,
  lastname,
  MAX(salary) AS salary,
  department_id
FROM Salary
GROUP BY 1
ORDER BY 1;"
"2669","SELECT
  artist,
  COUNT(id) AS occurrences
FROM Spotify
GROUP BY 1
ORDER BY 2 DESC, 1;"
"267","class Solution:
  def generatePalindromes(self, s: str) -> list[str]:
    count = collections.Counter(s)

    # Count odd ones.
    odd = sum(value & 1 for value in count.values())

    # Can't form any palindrome.
    if odd > 1:
      return []

    ans = []
    candidates = []
    mid = ''

    # Get the mid and the candidates characters.
    for key, value in count.items():
      if value % 2 == 1:
        mid += key
      for _ in range(value // 2):
        candidates.append(key)

    def dfs(used: list[bool], path: list[str]) -> None:
      """"""Generates all the unique palindromes from the candidates.""""""
      if len(path) == len(candidates):
        ans.append(''.join(path) + mid + ''.join(reversed(path)))
        return

      for i, candidate in enumerate(candidates):
        if used[i]:
          continue
        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:
          continue
        used[i] = True
        path.append(candidate)
        dfs(used, path)
        path.pop()
        used[i] = False

    # Backtrack to generate the ans strings.
    dfs([False] * len(candidates), [])
    return ans"
"2670","class Solution:
  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:
    kMax = 50
    ans = []
    prefixCount = [0] * (kMax + 1)
    suffixCount = [0] * (kMax + 1)
    distinctPrefix = 0
    distinctSuffix = 0

    for num in nums:
      if suffixCount[num] == 0:
        distinctSuffix += 1
      suffixCount[num] += 1

    for num in nums:
      if prefixCount[num] == 0:
        distinctPrefix += 1
      prefixCount[num] += 1
      if suffixCount[num] == 1:
        distinctSuffix -= 1
      suffixCount[num] -= 1
      ans.append(distinctPrefix - distinctSuffix)

    return ans"
"2671","class FrequencyTracker:
  def __init__(self):
    self.count = collections.Counter()
    self.freqCount = collections.Counter()

  def add(self, number: int) -> None:
    if self.count[number] > 0:
      self.freqCount[self.count[number]] -= 1
    self.count[number] += 1
    self.freqCount[self.count[number]] += 1

  def deleteOne(self, number: int) -> None:
    if self.count[number] == 0:
      return
    self.freqCount[self.count[number]] -= 1
    self.count[number] -= 1
    self.freqCount[self.count[number]] += 1

  def hasFrequency(self, frequency: int) -> bool:
    return self.freqCount[frequency] > 0"
"2672","class Solution:
  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:
    ans = []
    arr = [0] * n
    sameColors = 0

    for i, color in queries:
      if i + 1 < n:
        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:
          sameColors -= 1
        if arr[i + 1] == color:
          sameColors += 1
      if i > 0:
        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:
          sameColors -= 1
        if arr[i - 1] == color:
          sameColors += 1
      arr[i] = color
      ans.append(sameColors)

    return ans"
"2673","class Solution:
  def minIncrements(self, n: int, cost: list[int]) -> int:
    ans = 0

    for i in range(n // 2 - 1, -1, -1):
      l = i * 2 + 1
      r = i * 2 + 2
      ans += abs(cost[l] - cost[r])
      # Record the information in the parent from the children. So, there's need to actually
      # update the values in the children.
      cost[i] += max(cost[l], cost[r])

    return ans"
"2674","class Solution:
  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:
    slow = list
    fast = list

    # Point `slow` to the last node in the first half.
    while fast.next != list and fast.next.next != list:
      slow = slow.next
      fast = fast.next.next

    # Circle back the second half.
    secondHead = slow.next
    if fast.next == list:
      fast.next = secondHead
    else:
      fast.next.next = secondHead

    # Circle back the first half.
    slow.next = list

    return [list, secondHead]"
"2675","function jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {
  const isObject = (o: any) => o !== null && typeof o === 'object';

  // Returns the keys of a JSON-like object by recursively unwrapping the nests.
  const getKeys = (json: any): string[] => {
    if (!isObject(json)) {
      return [''];
    }
    return Object.keys(json).reduce((acc: string[], currKey: string) => {
      return (
        acc.push(
          ...getKeys(json[currKey]).map((nextKey: string) =>
            nextKey === '' ? currKey : `${currKey}.${nextKey}`
          )
        ),
        acc
      );
    }, []);
  };

  const sortedKeys: string[] = [
    ...arr.reduce((acc: Set<string>, curr: any) => {
      getKeys(curr).forEach((key: string) => acc.add(key));
      return acc;
    }, new Set<string>()),
  ].sort();

  // Returns the value of `obj` keyed by `nestedKey`.
  const getValue = (
    obj: any,
    nestedKey: string
  ): string | number | boolean | null => {
    let value: any = obj;
    for (const key of nestedKey.split('.')) {
      if (!isObject(value) || !(key in value)) {
        return '';
      }
      value = value[key];
    }
    return isObject(value) ? '' : value;
  };

  const matrix: (string | number | boolean | null)[][] = [sortedKeys];
  arr.forEach((obj: any) => {
    matrix.push(
      sortedKeys.map((nestedKey: string) => getValue(obj, nestedKey))
    );
  });

  return matrix;
}"
"2676","type F = (...args: any[]) => void;

function throttle(fn: F, t: number): F {
  let timeout: ReturnType<typeof setTimeout> | undefined;
  let nextTimeToCallFn = 0;
  return function (...args) {
    const delay = Math.max(0, nextTimeToCallFn - Date.now());
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn(...args);
      nextTimeToCallFn = Date.now() + t;
    }, delay);
  };
}"
"2677","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function chunk(arr: Obj[], size: number): Obj[][] {
  const ans: Obj[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    ans.push(arr.slice(i, i + size));
  }
  return ans;
}"
"2678","class Solution:
  def countSeniors(self, details: list[str]) -> int:
    return sum(int(detail[11:13]) > 60 for detail in details)"
"2679","class Solution:
  def matrixSum(self, nums: list[list[int]]) -> int:
    for row in nums:
      row.sort()

    return sum(max(col) for col in zip(*nums))"
"268","class Solution:
  def missingNumber(self, nums: list[int]) -> int:
    ans = len(nums)

    for i, num in enumerate(nums):
      ans ^= i ^ num

    return ans"
"2680","class Solution:
  def maximumOr(self, nums: list[int], k: int) -> int:
    n = len(nums)
    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]
    prefix = [0] * n
    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]
    suffix = [0] * n

    for i in range(1, n):
      prefix[i] = prefix[i - 1] | nums[i - 1]

    for i in range(n - 2, -1, -1):
      suffix[i] = suffix[i + 1] | nums[i + 1]

    # For each num, greedily shift it left by k bits.
    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))"
"2681","class Solution:
  def sumOfPower(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    ans = 0
    summ = 0

    for num in sorted(nums):
      ans += (num + summ) * num**2
      ans %= kMod
      summ = (summ * 2 + num) % kMod

    return ans"
"2682","class Solution:
  def circularGameLosers(self, n: int, k: int) -> list[int]:
    seen = [False] * n
    friendIndex = 0
    turn = 1

    while not seen[friendIndex]:
      seen[friendIndex] = True
      friendIndex += turn * k
      friendIndex %= n
      turn += 1

    return [friendIndex + 1
            for friendIndex in range(n)
            if not seen[friendIndex]]"
"2683","class Solution:
  def doesValidArrayExist(self, derived: list[int]) -> bool:
    return functools.reduce(operator.xor, derived) == 0"
"2684","class Solution:
  def maxMoves(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # dp[i][j] := the maximum number of moves you can perform from (i, j)
    dp = [[0] * n for _ in range(m)]

    for j in range(n - 2, -1, -1):
      for i in range(m):
        if grid[i][j + 1] > grid[i][j]:
          dp[i][j] = 1 + dp[i][j + 1]
        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])
        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])

    return max(dp[i][0] for i in range(m))"
"2685","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n
    self.nodeCount = [1] * n
    self.edgeCount = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    self.edgeCount[i] += 1
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
      self.edgeCount[j] += self.edgeCount[i]
      self.nodeCount[j] += self.nodeCount[i]
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
      self.edgeCount[i] += self.edgeCount[j]
      self.nodeCount[i] += self.nodeCount[j]
    else:
      self.id[i] = j
      self.edgeCount[j] += self.edgeCount[i]
      self.nodeCount[j] += self.nodeCount[i]
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]

  def isComplete(self, u):
    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]


class Solution:
  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:
    ans = 0
    uf = UnionFind(n)
    parents = set()

    for u, v in edges:
      uf.unionByRank(u, v)

    for i in range(n):
      parent = uf.find(i)
      if parent not in parents and uf.isComplete(parent):
        ans += 1
        parents.add(parent)

    return ans"
"2686","SELECT
  order_date,
  ROUND(
    AVG(order_date = customer_pref_delivery_date) * 100,
    2
  ) AS immediate_percentage
FROM Delivery
GROUP BY 1
ORDER BY 1;"
"2687","SELECT bike_number, MAX(end_time) AS end_time
FROM Bikes
GROUP BY 1;"
"2688","WITH
  UsersWithRowNumber AS (
    SELECT
      *,
      ROW_NUMBER() OVER(ORDER BY created_at) AS `row_number`
    FROM Users
  )
SELECT DISTINCT(First.user_id)
FROM UsersWithRowNumber AS First
INNER JOIN UsersWithRowNumber AS Second
  USING (user_id)
WHERE
  First.`row_number` < Second.`row_number`
  AND DATEDIFF(Second.created_at, First.created_at) <= 7"
"2689","class Solution:
  def getKthCharacter(self, root: object | None, k: int) -> str:
    """""":type root: RopeTreeNode | None""""""
    while root.len > 0:
      leftLen = (0 if not root.left
                 else max(root.left.len, len(root.left.val)))
      if leftLen >= k:
        root = root.left
      else:
        root = root.right
        k -= leftLen
    return root.val[k - 1]"
"269","class Solution:
  def alienOrder(self, words: list[str]) -> str:
    graph = {}
    inDegrees = [0] * 26

    self._buildGraph(graph, words, inDegrees)
    return self._topology(graph, inDegrees)

  def _buildGraph(
      self,
      graph: dict[str, set[str]],
      words: list[str],
      inDegrees: list[int],
  ) -> None:
    # Create a node for each character in each word.
    for word in words:
      for c in word:
        if c not in graph:
          graph[c] = set()

    for first, second in zip(words, words[1:]):
      length = min(len(first), len(second))
      for j in range(length):
        u = first[j]
        v = second[j]
        if u != v:
          if v not in graph[u]:
            graph[u].add(v)
            inDegrees[string.ascii_lowercase.index(v)] += 1
          break  # The order of characters after this are meaningless.
        # First = 'ab', second = 'a' . invalid
        if j == length - 1 and len(first) > len(second):
          graph.clear()
          return

  def _topology(self, graph: dict[str, set[str]], inDegrees: list[int]) -> str:
    s = ''
    q = collections.deque()

    for c in graph:
      if inDegrees[string.ascii_lowercase.index(c)] == 0:
        q.append(c)

    while q:
      u = q.pop()
      s += u
      for v in graph[u]:
        inDegrees[string.ascii_lowercase.index(v)] -= 1
        if inDegrees[string.ascii_lowercase.index(v)] == 0:
          q.append(v)

    # Words = ['z', 'x', 'y', 'x']
    return s if len(s) == len(graph) else ''"
"2690","function createInfiniteObject(): Record<string, () => string> {
  return new Proxy(
    {},
    {
      get: (_, prop: string) => () => prop,
    }
  );
}"
"2691","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type InputObj = Record<string, JSONValue> | Array<JSONValue>;

type RecursiveHandler = {
  set: (target: any, prop: string, value: any) => boolean;
  get: (target: any, prop: string) => unknown;
};

const isObject = (o: any) => o !== null && typeof o === 'object';

// Access history of properties
class AccessHistory {
  value: JSONValue | null = null;
  props: Map<string, AccessHistory> = new Map();
}

class ImmutableHelper {
  private obj: InputObj;

  constructor(obj: InputObj) {
    this.obj = obj;
  }

  produce(mutator: (obj: InputObj) => void): InputObj {
    // Creates a proxied object to track property access history.
    function createProxiedObj(
      obj: InputObj,
      accessHistory: AccessHistory
    ): InputObj {
      const handler: RecursiveHandler = {
        // 'set' trap intercepts property assignment.
        set(_, prop, value) {
          if (!accessHistory.props.has(prop)) {
            accessHistory.props.set(prop, new AccessHistory());
          }
          accessHistory.props.get(prop)!.value = value;
          return true;
        },
        // 'get' trap intercepts property access.
        get(_, prop) {
          if (accessHistory.value !== null) {
            return accessHistory.value;
          }
          if (!accessHistory.props.has(prop)) {
            accessHistory.props.set(prop, new AccessHistory());
          }
          if (accessHistory.props.get(prop)!.value !== null) {
            return accessHistory.props.get(prop)!.value;
          }
          if (isObject(obj[prop])) {
            // Recursively create a proxed object for object property.
            return createProxiedObj(
              obj[prop] as InputObj,
              accessHistory.props.get(prop)! as AccessHistory
            );
          }
          return obj[prop];
        },
      };
      return new Proxy(obj, handler);
    }

    // Returns true if there are mutated properties in the access history;
    // otherwise, returns false and deletes the unnecessary properties.
    function deleteUnmutatedProps(accessHistory: AccessHistory): boolean {
      if (accessHistory.value !== null) {
        return true;
      }
      let hasMutation = false;
      for (const [prop, childAccessHistory] of [...accessHistory.props]) {
        if (deleteUnmutatedProps(childAccessHistory)) {
          hasMutation = true;
        } else {
          accessHistory.props.delete(prop);
        }
      }
      return hasMutation;
    }

    // Function to transform the original object based on the access history
    function transform(obj: InputObj, accessHistory: AccessHistory): InputObj {
      if (accessHistory.value !== null) {
        return accessHistory.value as InputObj;
      }
      if (accessHistory.props.size === 0) {
        return obj;
      }
      if (!isObject(obj)) {
        return obj;
      }
      let clone = Array.isArray(obj) ? [...obj] : { ...obj };
      for (const [prop, childAccessHistory] of [...accessHistory.props]) {
        clone[prop] = transform(obj[prop] as InputObj, childAccessHistory);
      }
      return clone;
    }

    const accessHistory = new AccessHistory();
    const proxiedObj = createProxiedObj(this.obj, accessHistory);
    // Apply the mutator function on the proxied object. This will also record
    // the property access history in `accessHistory`.
    mutator(proxiedObj);
    // Simplify the access history.
    deleteUnmutatedProps(accessHistory);
    // Transform the original object based on the simplified access history.
    return transform(this.obj, accessHistory);
  }
}"
"2692","type RecursiveHandler = {
  set: <T extends object>(target: T, prop: string, value: any) => boolean;
  get: <T extends object>(target: T, prop: string) => any;
  apply: <T extends Function>(target: T, thisArg: any, argArray?: any) => any;
};

function makeImmutable<T extends object | Function>(obj: T): T {
  // a set of mutating array methods
  const methods = new Set([
    'pop',
    'push',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse',
  ]);

  const handler: RecursiveHandler = {
    // 'set' trap prevents modifications of the object properties.
    set(target, prop, _) {
      throw Array.isArray(target)
        ? `Error Modifying Index: ${String(prop)}`
        : `Error Modifying: ${String(prop)}`;
    },
    // 'get' trap returns object properties or creates new proxies for nested
    // objects or functions
    get(target, prop) {
      // If the property is 'prototype', null, or not an object/function, return
      // it directly. We exclude 'prototype' to avoid potential issues with
      // inheritance Objects and functions are wrapped in a new proxy to
      // preserve immutability at all depths.
      const key = prop as keyof typeof target;
      return prop === 'prototype' ||
        target[key] === null ||
        (typeof target[key] !== 'object' && typeof target[key] !== 'function')
        ? target[key]
        : new Proxy(target[key], this);
    },
    // 'apply' trap prevents call of mutating methods and apply function calls.
    apply(target, thisArg, argumentsList) {
      if (methods.has((target as any).name))
        throw `Error Calling Method: ${(target as any).name}`;
      return target.apply(thisArg, argumentsList);
    },
  };

  return new Proxy(obj, handler) as T;
}"
"2693","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

declare global {
  interface Function {
    callPolyfill(
      context: Record<string, JSONValue>,
      ...args: JSONValue[]
    ): JSONValue;
  }
}

Function.prototype.callPolyfill = function (context, ...args): JSONValue {
  const fn = this;
  Object.defineProperty(context, '__fn__', {
    value: fn,
    enumerable: false,
  });
  const ans = (context.__fn__ as any)(...args);
  delete context.__fn__;
  return typeof ans !== 'undefined' ? ans : undefined;
};"
"2694","type Callback = (...args: any[]) => any;
type Subscription = {
  unsubscribe: () => void;
};

class EventEmitter {
  private eventToCallbacks: Map<string, Callback[]>;

  constructor() {
    this.eventToCallbacks = new Map();
  }

  subscribe(eventName: string, callback: Callback): Subscription {
    if (!this.eventToCallbacks.has(eventName))
      this.eventToCallbacks.set(eventName, []);

    const callbacks = this.eventToCallbacks.get(eventName);
    callbacks?.push(callback);

    return {
      unsubscribe: () => {
        const index = callbacks?.indexOf(callback);
        if (index !== undefined && index !== -1) {
          callbacks?.splice(index, 1);
        }
      },
    };
  }

  emit(eventName: string, args: any[] = []): any[] {
    const callbacks = this.eventToCallbacks.get(eventName);
    if (callbacks === undefined) {
      return [];
    }
    return callbacks.map((callback) => callback(...args));
  }
}"
"2695","class ArrayWrapper {
  private nums: number[];

  constructor(nums: number[]) {
    this.nums = nums;
  }

  valueOf(): number {
    return this.nums.reduce((sum, num) => sum + num, 0);
  }

  toString(): string {
    return '[' + this.nums.join(',') + ']';
  }
}"
"2696","class Solution:
  def minLength(self, s: str) -> int:
    stack = []

    def match(c: str) -> bool:
      return stack and stack[-1] == c

    for c in s:
      if c == 'B' and match('A'):
        stack.pop()
      elif c == 'D' and match('C'):
        stack.pop()
      else:
        stack.append(c)

    return len(stack)"
"2697","class Solution:
  def makeSmallestPalindrome(self, s: str) -> str:
    chars = list(s)
    i = 0
    j = len(s) - 1

    while i < j:
      minChar = min(chars[i], chars[j])
      chars[i] = minChar
      chars[j] = minChar
      i += 1
      j -= 1

    return ''.join(chars)"
"2698","class Solution:
  def punishmentNumber(self, n: int) -> int:
    def isPossible(
            accumulate: int, running: int, numChars: list[str],
            s: int, target: int) -> bool:
      """"""
      Returns True if the sum of any split of `numChars` equals to the target.
      """"""
      if s == len(numChars):
        return target == accumulate + running
      d = int(numChars[s])
      return (
          # Keep growing `running`.
          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or
          # Start a new `running`.
          isPossible(accumulate + running, d, numChars, s + 1, target)
      )

    return sum(i * i
               for i in range(1, n + 1)
               if isPossible(0, 0, str(i * i), 0, i))"
"2699","class Solution:
  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:
    kMax = 2_000_000_000
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      if w == -1:
        continue
      graph[u].append((v, w))
      graph[v].append((u, w))

    distToDestination = self._dijkstra(graph, source, destination)
    if distToDestination < target:
      return []
    if distToDestination == target:
      # Change the weights of negative edges to an impossible value.
      for edge in edges:
        if edge[2] == -1:
          edge[2] = kMax
      return edges

    for i, (u, v, w) in enumerate(edges):
      if w != -1:
        continue
      edges[i][2] = 1
      graph[u].append((v, 1))
      graph[v].append((u, 1))
      distToDestination = self._dijkstra(graph, source, destination)
      if distToDestination <= target:
        edges[i][2] += target - distToDestination
        # Change the weights of negative edges to an impossible value.
        for j in range(i + 1, len(edges)):
          if edges[j][2] == -1:
            edges[j][2] = kMax
        return edges

    return []

  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist[dst]"
"27","class Solution:
  def removeElement(self, nums: list[int], val: int) -> int:
    i = 0

    for num in nums:
      if num != val:
        nums[i] = num
        i += 1

    return i"
"270","class Solution:
  def closestValue(self, root: TreeNode | None, target: float) -> int:
    # If target < root.val, search the left subtree.
    if target < root.val and root.left:
      left = self.closestValue(root.left, target)
      if abs(left - target) <= abs(root.val - target):
        return left

    # If target > root.val, search the right subtree.
    if target > root.val and root.right:
      right = self.closestValue(root.right, target)
      if abs(right - target) < abs(root.val - target):
        return right

    return root.val"
"2700","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function objDiff(obj1: Obj, obj2: Obj): Obj {
  if (obj1 === obj2) {
    return {};
  }
  if (obj1 === null || obj2 === null) {
    return [obj1, obj2];
  }
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return [obj1, obj2];
  }
  if (Array.isArray(obj1) !== Array.isArray(obj2)) {
    return [obj1, obj2];
  }
  const ans = {};
  for (const key in obj1) {
    if (key in obj2) {
      const subDiff = objDiff(obj1[key], obj2[key]);
      if (Object.keys(subDiff).length > 0) {
        ans[key] = subDiff;
      }
    }
  }
  return ans;
}"
"2701","WITH
  IncreasingTransactions AS (
    SELECT
      Curr.customer_id,
      Curr.transaction_date
    FROM Transactions AS Curr
    LEFT JOIN Transactions AS Next
      USING (customer_id)
    WHERE
      Curr.amount < Next.amount
      AND DATEDIFF(Next.transaction_date, Curr.transaction_date) = 1
  ),
  IncreasingTransactionsWithGroupId AS (
    SELECT
      *,
      TO_DAYS(transaction_date) - ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY transaction_date
      ) AS group_id
    FROM IncreasingTransactions
  ),
  IncreasingTransactionsWithCountDays AS (
    SELECT
      customer_id,
      MIN(transaction_date) AS consecutive_start,
      COUNT(*) AS count_days
    FROM IncreasingTransactionsWithGroupId
    GROUP BY customer_id, group_id
  )
SELECT
  customer_id,
  consecutive_start,
  DATE_ADD(consecutive_start, INTERVAL count_days DAY) AS consecutive_end
FROM IncreasingTransactionsWithCountDays
WHERE count_days >= 2
ORDER BY 1;"
"2702","class Solution:
  def minOperations(self, nums: list[int], x: int, y: int) -> int:
    def isPossible(m: int) -> bool:
      """"""
      Returns True if it's possible to make all `nums` <= 0 using m operations.
      """"""
      # If we want m operations, first decrease all the numbers by y * m. Then
      # we have m operations to select indices to decrease them by x - y.
      return sum(max(0, math.ceil((num - y * m) / (x - y)))
                 for num in nums) <= m

    return bisect.bisect_left(range(max(nums)), True,
                              key=isPossible)"
"2703","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function argumentsLength(...args: JSONValue[]): number {
  return args.length;
}"
"2704","type ToBeOrNotToBe = {
  toBe: (val: any) => boolean;
  notToBe: (val: any) => boolean;
};

function expect(val: any): ToBeOrNotToBe {
  return {
    toBe: function (val2: any) {
      if (val === val2) {
        return true;
      }
      throw 'Not Equal';
    },
    notToBe: function (val2: any) {
      if (val !== val2) {
        return true;
      }
      throw 'Equal';
    },
  };
}"
"2705","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function compactObject(obj: Obj): Obj {
  return dfs(obj) as Obj;
}

function dfs(value: JSONValue): JSONValue {
  if (value === null) {
    return null;
  }
  if (Array.isArray(value)) {
    return value.filter(Boolean).map(dfs);
  }
  if (typeof value === 'object') {
    for (const key of Object.keys(value)) {
      if (Boolean(value[key])) {
        value[key] = dfs(value[key]);
      } else {
        delete value[key];
      }
    }
  }
  return value;
}"
"2706","class Solution:
  def buyChoco(self, prices: list[int], money: int) -> int:
    min1 = math.inf
    min2 = math.inf

    for price in prices:
      if price <= min1:
        min2 = min1
        min1 = price
      elif price < min2:
        min2 = price

    minCost = min1 + min2
    return money if minCost > money else money - minCost"
"2707","class Solution:
  # Similar to 139. Word Break
  def minExtraChar(self, s: str, dictionary: list[str]) -> int:
    n = len(s)
    dictionarySet = set(dictionary)
    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally
    dp = [0] + [n] * n

    for i in range(1, n + 1):
      for j in range(i):
        if s[j:i] in dictionarySet:
          dp[i] = min(dp[i], dp[j])
        else:
          dp[i] = min(dp[i], dp[j] + i - j)

    return dp[n]"
"2708","class Solution:
  def maxStrength(self, nums: list[int]) -> int:
    posProd = 1
    negProd = 1
    maxNeg = -math.inf
    negCount = 0
    hasPos = False
    hasZero = False

    for num in nums:
      if num > 0:
        posProd *= num
        hasPos = True
      elif num < 0:
        negProd *= num
        maxNeg = max(maxNeg, num)
        negCount += 1
      else:  # num == 0
        hasZero = True

    if negCount == 0 and not hasPos:
      return 0
    if negCount % 2 == 0:
      return negProd * posProd
    if negCount >= 3:
      return negProd // maxNeg * posProd
    if hasPos:
      return posProd
    if hasZero:
      return 0
    return maxNeg"
"2709","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.sz = [1] * n

  def unionBySize(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.sz[i] < self.sz[j]:
      self.sz[j] += self.sz[i]
      self.id[i] = j
    else:
      self.sz[i] += self.sz[j]
      self.id[j] = i

  def getSize(self, i: int) -> int:
    return self.sz[i]

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def canTraverseAllPairs(self, nums: list[int]) -> bool:
    n = len(nums)
    mx = max(nums)
    maxPrimeFactor = self._sieveEratosthenes(mx + 1)
    primeToFirstIndex = collections.defaultdict(int)
    uf = UnionFind(n)

    for i, num in enumerate(nums):
      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):
        if prime_factor in primeToFirstIndex:
          uf.unionBySize(primeToFirstIndex[prime_factor], i)
        else:
          primeToFirstIndex[prime_factor] = i

    return any(uf.getSize(i) == n for i in range(n))

  def _sieveEratosthenes(self, n: int) -> list[int]:
    """"""Gets the minimum prime factor of i, where 1 < i <= n.""""""
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:  # `i` is prime.
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:
    primeFactors = []
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.append(divisor)
      while num % divisor == 0:
        num //= divisor
    return primeFactors"
"271","class Codec:
  def encode(self, strs: list[str]) -> str:
    """"""Encodes a list of strings to a single string.""""""
    return ''.join(str(len(s)) + '/' + s for s in strs)

  def decode(self, s: str) -> list[str]:
    """"""Decodes a single string to a list of strings.""""""
    decoded = []

    i = 0
    while i < len(s):
      slash = s.find('/', i)
      length = int(s[i:slash])
      i = slash + length + 1
      decoded.append(s[slash + 1:i])

    return decoded"
"2710","class Solution:
  def removeTrailingZeros(self, num: str) -> str:
    return num.rstrip('0')"
"2711","class Solution:
  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]

    def fillInDiagonal(i: int, j: int) -> None:
      topLeft = set()
      bottomRight = set()

      # Fill in the diagonal from the top-left to the bottom-right.
      while i < len(grid) and j < len(grid[0]):
        ans[i][j] = len(topLeft)
        # Post-addition, so this information can be utilized in subsequent cells.
        topLeft.add(grid[i][j])
        i += 1
        j += 1

      i -= 1
      j -= 1

      # Fill in the diagonal from the bottom-right to the top-left.
      while i >= 0 and j >= 0:
        ans[i][j] = abs(ans[i][j] - len(bottomRight))
        # Post-addition, so this information can be utilized in subsequent cells.
        bottomRight.add(grid[i][j])
        i -= 1
        j -= 1

    for i in range(m):
      fillInDiagonal(i, 0)

    for j in range(1, n):
      fillInDiagonal(0, j)

    return ans"
"2712","class Solution:
  def minimumCost(self, s: str) -> int:
    n = len(s)
    ans = 0

    for i in range(1, n):
      if s[i] != s[i - 1]:
        # Invert s[0..i - 1] or s[i..n - 1].
        ans += min(i, n - i)

    return ans"
"2713","class Solution:
  def maxIncreasingCells(self, mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    rows = [0] * m  # rows[i] := the maximum path length for the i-th row
    cols = [0] * n  # cols[j] := the maximum path length for the j-th column
    valToIndices = collections.defaultdict(list)
    # maxPathLength[i][j] := the maximum path length from mat[i][j]
    maxPathLength = [[0] * n for _ in range(m)]
    # Sort all the unique values in the matrix in non-increasing order.
    decreasingSet = set()

    for i in range(m):
      for j in range(n):
        val = mat[i][j]
        valToIndices[val].append((i, j))
        decreasingSet.add(val)

    for val in sorted(decreasingSet, reverse=True):
      for i, j in valToIndices[val]:
        maxPathLength[i][j] = max(rows[i], cols[j]) + 1
      for i, j in valToIndices[val]:
        rows[i] = max(rows[i], maxPathLength[i][j])
        cols[j] = max(cols[j], maxPathLength[i][j])

    return max(max(rows), max(cols))"
"2714","class Solution:
  # Similar to 787. Cheapest Flights Within K Stops
  def shortestPathWithHops(
      self,
      n: int,
      edges: list[list[int]],
      s: int,
      d: int,
      k: int,
  ) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, s, d, k)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      dst: int,
      k: int,
  ) -> int:
    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]

    dist[src][k] = 0
    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)

    while minHeap:
      d, u, hops = heapq.heappop(minHeap)
      if u == dst:
        return d
      if dist[u][hops] > d:
        continue
      for v, w in graph[u]:
        # Go from u -> v with w cost.
        if d + w < dist[v][hops]:
          dist[v][hops] = d + w
          heapq.heappush(minHeap, (dist[v][hops], v, hops))
        # Hop from u -> v with 0 cost.
        if hops > 0 and d < dist[v][hops - 1]:
          dist[v][hops - 1] = d
          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))"
"2715","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => void;

function cancellable(fn: Fn, args: JSONValue[], t: number): Function {
  const timer = setTimeout(() => fn(...args), t);
  return function () {
    clearTimeout(timer);
  };
}"
"2716","class Solution:
  def minimizedStringLength(self, s: str) -> int:
    return len({*s})"
"2717","class Solution:
  def semiOrderedPermutation(self, nums: list[int]) -> int:
    n = len(nums)
    index1 = nums.index(1)
    indexN = nums.index(n)
    return index1 + (n - 1 - indexN) - int(index1 > indexN)"
"2718","class Solution:
  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:
    ans = 0
    # seen[0] := row, seen[1] := col
    seen = [[False] * n for _ in range(2)]
    # notSet[0] = row, notSet[1] := col
    notSet = [n] * 2

    # Late queries dominate.
    for type, index, val in reversed(queries):
      if not seen[type][index]:
        ans += val * notSet[type ^ 1]
        seen[type][index] = True
        notSet[type] -= 1

    return ans"
"2719","class Solution {
 public:
  int count(string num1, string num2, int min_sum, int max_sum) {
    const string num1WithLeadingZeros =
        string(num2.length() - num1.length(), '0') + num1;
    vector<vector<vector<vector<int>>>> mem(
        num2.length(),
        vector<vector<vector<int>>>(
            max_sum + 1, vector<vector<int>>(2, vector<int>(2, -1))));
    return (count(num1WithLeadingZeros, num2, 0, max_sum, true, true, mem) -
            count(num1WithLeadingZeros, num2, 0, min_sum - 1, true, true, mem) +
            kMod) %
           kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of valid integers, considering the i-th digit, where
  // `sum` is the maximum digit sum, `isTight1` indicates if the current digit
  // is tightly bound for `num1` and `isTight2` indicates if the current digit
  // is tightly bound for `num2`
  int count(const string& num1, const string& num2, int i, int sum,
            bool isTight1, bool isTight2,
            vector<vector<vector<vector<int>>>>& mem) {
    if (sum < 0)
      return 0;
    if (i == num2.length())
      return 1;
    if (mem[i][sum][isTight1][isTight2] != -1)
      return mem[i][sum][isTight1][isTight2];

    int res = 0;

    const int minDigit = isTight1 ? num1[i] - '0' : 0;
    const int maxDigit = isTight2 ? num2[i] - '0' : 9;
    for (int d = minDigit; d <= maxDigit; ++d) {
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(num1, num2, i + 1, sum - d, nextIsTight1, nextIsTight2, mem);
      res %= kMod;
    }

    return mem[i][sum][isTight1][isTight2] = res;
  }
};"
"272","class Solution:
  def closestKValues(
      self,
      root: TreeNode | None,
      target: float,
      k: int,
  ) -> list[int]:
    dq = collections.deque()

    def inorder(root: TreeNode | None) -> None:
      if not root:
        return

      inorder(root.left)
      dq.append(root.val)
      inorder(root.right)

    inorder(root)

    while len(dq) > k:
      if abs(dq[0] - target) > abs(dq[-1] - target):
        dq.popleft()
      else:
        dq.pop()

    return list(dq)"
"2720","WITH
  TwoWayFriends AS (
    SELECT user1, user2 FROM Friends
    UNION ALL
    SELECT user2, user1 FROM Friends
  )
SELECT
  user1,
  ROUND(
    100 * (COUNT(DISTINCT user2) / (COUNT(*) OVER())),
    2
  ) AS percentage_popularity
FROM TwoWayFriends
GROUP BY 1
ORDER BY 1;"
"2721","type Fn<T> = () => Promise<T>;

function promiseAll<T>(functions: Fn<T>[]): Promise<T[]> {
  return new Promise((resolve, reject) => {
    const ans: T[] = [];
    let resolveCount = 0;
    functions.forEach((fn, index) => {
      fn()
        .then((val) => {
          ans[index] = val;
          if (++resolveCount === functions.length) {
            resolve(ans);
          }
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
}"
"2722","type JSONValue =
  | {}
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

type Item = { [key: string]: JSONValue } & {
  id: number;
};

function join(arr1: Item[], arr2: Item[]): Item[] {
  const idToObj: { [key: number]: Item } = {};
  for (const item of arr1) {
    idToObj[item.id] = item;
  }
  for (const item of arr2) {
    if (idToObj[item.id] === undefined) {
      idToObj[item.id] = item;
    } else {
      for (const key of Object.keys(item)) {
        idToObj[item.id][key] = item[key];
      }
    }
  }
  const ans = Object.values(idToObj);
  ans.sort((a, b) => a.id - b.id);
  return ans;
}"
"2723","type P = Promise<number>;

async function addTwoPromises(promise1: P, promise2: P): P {
  const results = await Promise.all([promise1, promise2]);
  return results[0] + results[1];
}"
"2724","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (value: JSONValue) => number;

function sortBy(arr: JSONValue[], fn: Fn): JSONValue[] {
  arr.sort((a, b) => fn(a) - fn(b));
  return arr;
}"
"2725","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => void;

function cancellable(fn: Fn, args: JSONValue[], t: number): Function {
  fn(...args);
  const timer = setInterval(() => fn(...args), t);
  return function () {
    clearInterval(timer);
  };
}"
"2726","class Calculator {
  private cur: number;

  constructor(value: number) {
    this.cur = value;
  }

  add(value: number): Calculator {
    this.cur += value;
    return this;
  }

  subtract(value: number): Calculator {
    this.cur -= value;
    return this;
  }

  multiply(value: number): Calculator {
    this.cur *= value;
    return this;
  }

  divide(value: number): Calculator {
    if (value === 0) throw new Error('Division by zero is not allowed');
    this.cur /= value;
    return this;
  }

  power(value: number): Calculator {
    this.cur **= value;
    return this;
  }

  getResult(): number {
    return this.cur;
  }
}"
"2727","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | JSONValue[];

function isEmpty(obj: Obj): boolean {
  if (Array.isArray(obj)) {
    return obj.length === 0;
  }
  return Object.keys(obj).length === 0;
}"
"2728","# Definition for a street.
# class Street:
#   def openDoor(self):
#     pass
#   def closeDoor(self):
#     pass
#   def isDoorOpen(self):
#     pass
#   def moveRight(self):
#     pass
#   def moveLeft(self):
#     pass

class Solution:
  def houseCount(self, street: Optional['Street'], k: int) -> int:
    for _ in range(k):
      if street.isDoorOpen():
        street.closeDoor()
      street.moveRight()

    for ans in range(k + 1):
      if street.isDoorOpen():
        return ans
      street.openDoor()
      street.moveRight()"
"2729","class Solution:
  def isFascinating(self, n):
    s = str(n) + str(2 * n) + str(3 * n)
    return ''.join(sorted(s)) == '123456789'"
"273","class Solution:
  def numberToWords(self, num: int) -> str:
    if num == 0:
      return 'Zero'

    belowTwenty = ['',        'One',       'Two',      'Three',
                   'Four',    'Five',      'Six',      'Seven',
                   'Eight',   'Nine',      'Ten',      'Eleven',
                   'Twelve',  'Thirteen',  'Fourteen', 'Fifteen',
                   'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']
    tens = ['',      'Ten',   'Twenty',  'Thirty', 'Forty',
            'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']

    def helper(num: int) -> str:
      if num < 20:
        s = belowTwenty[num]
      elif num < 100:
        s = tens[num // 10] + ' ' + belowTwenty[num % 10]
      elif num < 1000:
        s = helper(num // 100) + ' Hundred ' + helper(num % 100)
      elif num < 1000000:
        s = helper(num // 1000) + ' Thousand ' + helper(num % 1000)
      elif num < 1000000000:
        s = helper(num // 1000000) + ' Million ' + helper(num % 1000000)
      else:
        s = helper(num // 1000000000) + ' Billion ' + helper(num % 1000000000)
      return s.strip()

    return helper(num)"
"2730","class Solution:
  def longestSemiRepetitiveSubstring(self, s: str) -> int:
    ans = 1
    prevStart = 0
    start = 0

    for i in range(1, len(s)):
      if s[i] == s[i - 1]:
        if prevStart > 0:
          start = prevStart
        prevStart = i
      ans = max(ans, i - start + 1)

    return ans"
"2731","class Solution:
  def sumDistance(self, nums: list[int], s: str, d: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    prefix = 0
    pos = sorted([num - d if c == 'L' else num + d
                  for num, c in zip(nums, s)])

    for i, p in enumerate(pos):
      ans = ((ans + i * p - prefix) % kMod + kMod) % kMod
      prefix = ((prefix + p) % kMod + kMod) % kMod

    return ans"
"2732","class Solution:
  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:
    kMaxBit = 30
    maskToIndex = {}

    def getMask(row: list[int]) -> int:
      mask = 0
      for i, num in enumerate(row):
        if num == 1:
          mask |= 1 << i
      return mask

    for i, row in enumerate(grid):
      mask = getMask(row)
      if mask == 0:
        return [i]
      for prevMask in range(1, kMaxBit):
        if (mask & prevMask) == 0 and prevMask in maskToIndex:
          return [maskToIndex[prevMask], i]
      maskToIndex[mask] = i

    return []"
"2733","class Solution:
  def findNonMinOrMax(self, nums: list[int]) -> int:
    return -1 if len(nums) < 3 else sorted(nums[:3])[1]"
"2734","class Solution:
  def smallestString(self, s: str) -> str:
    chars = list(s)
    n = len(s)
    i = 0

    while i < n and chars[i] == 'a':
      i += 1
    if i == n:
      chars[-1] = 'z'
      return ''.join(chars)

    while i < n and s[i] != 'a':
      chars[i] = chr(ord(chars[i]) - 1)
      i += 1

    return ''.join(chars)"
"2735","class Solution:
  def minCost(self, nums: list[int], x: int) -> int:
    n = len(nums)
    ans = math.inf
    # minCost[i] := the minimum cost to collect the i-th type
    minCost = [math.inf] * n

    for rotate in range(n):
      for i in range(n):
        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])
      ans = min(ans, sum(minCost) + rotate * x)

    return ans"
"2736","from dataclasses import dataclass


@dataclass(frozen=True)
class Pair:
  x: int
  y: int

  def __iter__(self):
    yield self.x
    yield self.y


@dataclass(frozen=True)
class IndexedQuery:
  queryIndex: int
  minX: int
  minY: int

  def __iter__(self):
    yield self.queryIndex
    yield self.minX
    yield self.minY


class Solution:
  def maximumSumQueries(
      self,
      nums1: list[int],
      nums2: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    pairs = sorted([Pair(nums1[i], nums2[i])
                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)
    ans = [0] * len(queries)
    stack = []  # [(y, x + y)]

    pairsIndex = 0
    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])
                                          for i, query in enumerate(queries)],
                                         key=lambda x: -x.minX):
      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:
        # x + y is a better candidate. Given that x is decreasing, the
        # condition ""x + y >= stack[-1][1]"" suggests that y is relatively
        # larger, thereby making it a better candidate.
        x, y = pairs[pairsIndex]
        while stack and x + y >= stack[-1][1]:
          stack.pop()
        if not stack or y > stack[-1][0]:
          stack.append((y, x + y))
        pairsIndex += 1
      j = self._firstGreaterEqual(stack, minY)
      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]

    return ans

  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:
    l = 0
    r = len(A)
    while l < r:
      m = (l + r) // 2
      if A[m][0] >= target:
        r = m
      else:
        l = m + 1
    return l"
"2737","class Solution:
  def minimumDistance(
      self,
      n: int,
      edges: list[list[int]],
      s: int,
      marked: list[int],
  ) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))

    dist = self._dijkstra(graph, s)
    ans = min(dist[u] for u in marked)
    return -1 if ans == math.inf else ans

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
  ) -> list[int]:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist"
"2738","SELECT 'bull' AS word, SUM(content LIKE '% bull %') AS count
FROM Files
UNION ALL
SELECT 'bear' AS word, SUM(content LIKE '% bear %') AS count
FROM Files;"
"2739","class Solution:
  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
    # M  M M M M  A  M M M M   A
    # 1 [2 3 4 5] 6 [7 8 9 10] 11
    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10"
"274","class Solution:
  def hIndex(self, citations: list[int]) -> int:
    n = len(citations)

    citations.sort()

    for i, citation in enumerate(citations):
      if citation >= n - i:
        return n - i

    return 0"
"2740","class Solution:
  def findValueOfPartition(self, nums: list[int]) -> int:
    return min(b - a for a, b in itertools.pairwise(sorted(nums)))"
"2741","class Solution:
  def specialPerm(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    maxMask = 1 << len(nums)

    @functools.lru_cache(None)
    def dp(prev: int, mask: int) -> int:
      """"""
      Returns the number of special permutations, where the previous number is
      nums[i] and `mask` is the bitmask of the used numbers.
      """"""
      if mask == maxMask - 1:
        return 1

      res = 0

      for i, num in enumerate(nums):
        if mask >> i & 1:
          continue
        if num % nums[prev] == 0 or nums[prev] % num == 0:
          res += dp(i, mask | 1 << i)
          res %= kMod

      return res

    return sum(dp(i, 1 << i)
               for i in range(len(nums))) % kMod"
"2742","class Solution:
  def paintWalls(self, cost: list[int], time: list[int]) -> int:
    kMax = 500_000_000
    n = len(cost)
    # dp[i] := the minimum cost to paint i walls by the painters so far
    dp = [0] + [kMax] * n

    for c, t in zip(cost, time):
      for walls in range(n, 0, -1):
        dp[walls] = min(dp[walls], dp[max(walls - t - 1, 0)] + c)

    return dp[n]"
"2743","class Solution:
  def numberOfSpecialSubstrings(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] == 2:
        count[s[l]] -= 1
        l += 1
      ans += r - l + 1

    return ans"
"2744","class Solution:
  def maximumNumberOfStringPairs(self, words: list[str]) -> int:
    ans = 0
    seen = [False] * (26 * 26)

    def val(c: str) -> int:
      return string.ascii_lowercase.index(c)

    for word in words:
      if seen[val(word[1]) * 26 + val(word[0])]:
        ans += 1
      seen[val(word[0]) * 26 + val(word[1])] = True

    return ans"
"2745","class Solution:
  def longestString(self, x: int, y: int, z: int) -> int:
    # 'AB' can always be easily appended within the string.
    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'
    # If x == y, we repeat the pattern 'AABBAABB...AABB'.
    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'
    mn = min(x, y)
    if x == y:
      return (mn * 2 + z) * 2
    return (mn * 2 + 1 + z) * 2"
"2746","class Solution:
  def minimizeConcatenatedLength(self, words: list[str]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, first: str, last: str) -> int:
      """"""
      Returns the minimum concatenated length of the first i words starting with
      `first` and ending in `last`.
      """"""
      if i == len(words):
        return 0
      nextFirst = words[i][0]
      nextLast = words[i][-1]
      return len(words[i]) + min(
          # join(words[i - 1], words[i])
          dp(i + 1, first, nextLast) - (last == nextFirst),
          # join(words[i], words[i - 1])
          dp(i + 1, nextFirst, last) - (first == nextLast)
      )

    return len(words[0]) + dp(1, words[0][0], words[0][-1])"
"2747","from dataclasses import dataclass


@dataclass(frozen=True)
class IndexedQuery:
  queryIndex: int
  query: int

  def __iter__(self):
    yield self.queryIndex
    yield self.query


class Solution:
  def countServers(
      self,
      n: int,
      logs: list[list[int]],
      x: int,
      queries: list[int],
  ) -> list[int]:
    ans = [0] * len(queries)
    count = [0] * (n + 1)

    logs.sort(key=lambda x: x[1])

    i = 0
    j = 0
    servers = 0

    # For each query, we care about logs[i..j].
    for queryIndex, query in sorted([IndexedQuery(i, query)
                                     for i, query in enumerate(queries)],
                                    key=lambda x: x.query):
      while j < len(logs) and logs[j][1] <= query:
        count[logs[j][0]] += 1
        if count[logs[j][0]] == 1:
          servers += 1
        j += 1
      while i < len(logs) and logs[i][1] < query - x:
        count[logs[i][0]] -= 1
        if count[logs[i][0]] == 0:
          servers -= 1
        i += 1
      ans[queryIndex] = n - servers

    return ans"
"2748","class Solution:
  def countBeautifulPairs(self, nums: list[int]) -> int:
    def firstDigit(num: int) -> int:
      return int(str(num)[0])

    def lastDigit(num: int) -> int:
      return num % 10

    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1
               for i in range(len(nums))
               for j in range(i + 1, len(nums)))"
"2749","class Solution:
  def makeTheIntegerZero(self, num1: int, num2: int) -> int:
    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +
    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +
    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].
    # Note that for any number x, we can use ""x's bit count"" operations to make
    # x equal to 0. Additionally, we can also use x operations to deduct x by
    # 2^0 (x times), which also results in 0.

    for ops in range(61):
      target = num1 - ops * num2
      if target.bit_count() <= ops <= target:
        return ops

    return -1"
"275","class Solution:
  def hIndex(self, citations: list[int]) -> int:
    n = len(citations)
    return n - bisect.bisect_left(range(n), n,
                                  key=lambda m: citations[m] + m)"
"2750","class Solution:
  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:
    if 1 not in nums:
      return 0

    kMod = 1_000_000_007
    prev = -1  # the previous index of 1
    ans = 1

    for i, num in enumerate(nums):
      if num == 1:
        if prev != -1:
          ans *= i - prev
          ans %= kMod
        prev = i

    return ans"
"2751","from dataclasses import dataclass


@dataclass
class Robot:
  index: int
  position: int
  health: int
  direction: str


class Solution:
  def survivedRobotsHealths(
      self,
      positions: list[int],
      healths: list[int],
      directions: str,
  ) -> list[int]:
    robots = sorted([Robot(index, position, health, direction)
                     for index, (position, health, direction) in
                     enumerate(zip(positions, healths, directions))],
                    key=lambda x: x.position)
    stack: list[Robot] = []  # running robots

    for robot in robots:
      if robot.direction == 'R':
        stack.append(robot)
        continue
      # Collide with robots going right if any.
      while stack and stack[-1].direction == 'R' and robot.health > 0:
        if stack[-1].health == robot.health:
          stack.pop()
          robot.health = 0
        elif stack[-1].health < robot.health:
          stack.pop()
          robot.health -= 1
        else:  # stack[-1].health > robot.health
          stack[-1].health -= 1
          robot.health = 0
      if robot.health > 0:
        stack.append(robot)

    stack.sort(key=lambda robot: robot.index)
    return [robot.health for robot in stack]"
"2752","WITH
  TransactionsWithGroupId AS (
    SELECT
      customer_id,
      TO_DAYS(transaction_date) - ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY transaction_date
      ) AS group_id
    FROM Transactions
  ),
  RankedCustomers AS (
    SELECT
      customer_id,
      RANK() OVER(ORDER BY COUNT(*) DESC) AS `rank`
    FROM TransactionsWithGroupId
    GROUP BY customer_id, group_id
  )
SELECT customer_id
FROM RankedCustomers
WHERE `rank` = 1
ORDER BY 1;"
"2753","# Definition for a street.
# class Street:
#   def closeDoor(self):
#     pass
#   def isDoorOpen(self):
#     pass
#   def moveRight(self):
#     pass
class Solution:
  def houseCount(self, street: Optional['Street'], k: int) -> int:
    ans = 0

    # Go to the first open door.
    while not street.isDoorOpen():
      street.moveRight()

    street.moveRight()

    for count in range(k):
      # Each time we encounter an open door, there's a possibility that it's the
      # first open door we intentionally left open.
      if street.isDoorOpen():
        ans = count + 1
        street.closeDoor()
      street.moveRight()

    return ans"
"2754","type Fn = (...args) => any;

declare global {
  interface Function {
    bindPolyfill(obj: Record<any, any>): Fn;
  }
}

Function.prototype.bindPolyfill = function (obj): Fn {
  return (...newArgs) => this.call(obj, ...newArgs);
};"
"2755","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function deepMerge(obj1: JSONValue, obj2: JSONValue): JSONValue {
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return obj2;
  }
  if (obj1 === null || obj2 === null) {
    return obj2;
  }
  if (Array.isArray(obj1) !== Array.isArray(obj2)) {
    return obj2;
  }
  const ans = obj1;
  for (const key in obj2) {
    if (key in ans) {
      ans[key] = deepMerge(ans[key], obj2[key]);
    } else {
      ans[key] = obj2[key];
    }
  }
  return ans;
}"
"2756","type QueryMultipleFn = (keys: string[]) => Promise<string[]>;

type ThrottledRequest = {
  key: string;
  resolve: (result: string) => void;
};

class QueryBatcher {
  private readonly queryMultiple: QueryMultipleFn;
  private readonly throttleTime: number;
  private isThrottling: boolean;
  private throttledRequests: ThrottledRequest[];

  constructor(queryMultiple: QueryMultipleFn, t: number) {
    this.queryMultiple = queryMultiple;
    this.throttleTime = t;
    this.isThrottling = false;
    this.throttledRequests = [];
  }

  async getValue(key: string): Promise<string> {
    if (this.throttleTime === 0) {
      const results = await this.queryMultiple([key]);
      return results[0];
    }
    if (this.isThrottling) {
      return new Promise<string>((resolve) => {
        this.throttledRequests.push({ key, resolve });
      });
    }
    this.isThrottling = true;
    setTimeout(() => this.deThrottle(), this.throttleTime);
    const results = await this.queryMultiple([key]);
    return results[0];
  }

  // De-throttles and processes any pending requests.
  private deThrottle(): void {
    const throttledRequests = this.throttledRequests;
    if (throttledRequests.length === 0) {
      this.isThrottling = false;
    } else {
      const keys = throttledRequests.map((req) => req.key);
      this.queryMultiple(keys).then((results) => {
        results.forEach((result, index) => {
          throttledRequests[index].resolve(result);
        });
      });
      setTimeout(() => this.deThrottle(), this.throttleTime);
      this.throttledRequests = [];
    }
  }
}"
"2757","function* cycleGenerator(
  arr: number[],
  startIndex: number
): Generator<number, void, number> {
  const n = arr.length;
  let index = startIndex;
  while (true) {
    const jump = yield arr[index];
    index = (index + (jump % n) + n) % n;
  }
}"
"2758","declare global {
  interface Date {
    nextDay(): string;
  }
}

Date.prototype.nextDay = function () {
  const today = new Date(this.getTime());
  today.setDate(today.getDate() + 1);
  return today.toISOString().split('T')[0];
};"
"2759","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

class JSONParser {
  private str: string;
  private i: number;

  constructor(str: string) {
    this.str = str;
    this.i = 0;
  }

  public parse(): JSONValue {
    return this.parseValue();
  }

  private parseValue(): JSONValue {
    switch (this.str[this.i]) {
      case '{':
        return this.parseObject();
      case '[':
        return this.parseArray();
      case 't': // true
      case 'f': // false
      case 'n': // null
        return this.parseLiteral();
      case '""':
        return this.parseString();
      default:
        return this.parseNumber();
    }
  }

  private parseObject(): JSONValue {
    ++this.i;

    const ans: JSONValue = {};

    while (this.i < this.str.length && this.str[this.i] !== '}') {
      const key = this.parseString();
      this.expectChar(':');
      const value = this.parseValue();

      ans[key] = value;
      if (this.str[this.i] === ',') {
        ++this.i;
      }
    }

    ++this.i;
    return ans;
  }

  private parseArray(): JSONValue[] {
    ++this.i;

    const ans: JSONValue[] = [];

    while (this.i < this.str.length && this.str[this.i] !== ']') {
      const value = this.parseValue();
      ans.push(value);
      if (this.str[this.i] === ',') {
        ++this.i;
      }
    }

    ++this.i;
    return ans;
  }

  private parseLiteral(): boolean | null {
    if (this.str.startsWith('true', this.i)) {
      this.i += 4;
      return true;
    }
    if (this.str.startsWith('false', this.i)) {
      this.i += 5;
      return false;
    }
    if (this.str.startsWith('null', this.i)) {
      this.i += 4;
      return null;
    }
    throw new Error(`Unexpected token at position ${this.i}`);
  }

  private parseString(): string {
    let ans = '';
    ++this.i;

    while (this.i < this.str.length && this.str[this.i] !== '""') {
      ans += this.str[this.i];
      ++this.i;
    }

    ++this.i;
    return ans;
  }

  private parseNumber(): number {
    let start = this.i;

    if (this.str[this.i] === '-') {
      ++this.i;
    }

    while (this.i < this.str.length && this.isDigit(this.str[this.i])) {
      ++this.i;
    }

    if (this.str[this.i] === '.') {
      ++this.i;
      while (this.i < this.str.length && this.isDigit(this.str[this.i])) {
        ++this.i;
      }
    }

    return Number(this.str.slice(start, this.i));
  }

  private isDigit(n: string): boolean {
    return n >= '0' && n <= '9';
  }

  private expectChar(char: string): void {
    if (this.str[this.i] !== char) {
      throw new Error(`Expected '${char}' at position ${this.i}`);
    }
    ++this.i;
  }
}

function jsonParse(str: string): JSONValue {
  const parser = new JSONParser(str);
  return parser.parse();
}"
"276","class Solution:
  def numWays(self, n: int, k: int) -> int:
    if n == 0:
      return 0
    if n == 1:
      return k
    if n == 2:
      return k * k

    # dp[i] := the number of ways to pan posts with k colors
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = k
    dp[2] = k * k

    for i in range(3, n + 1):
      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)

    return dp[n]"
"2760","class Solution:
  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:
    ans = 0
    dp = 0

    def isOddEven(a: int, b: int) -> bool:
      return a % 2 != b % 2

    for i, num in enumerate(nums):
      if num > threshold:
        dp = 0
      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):
        # Increase the size of the subarray.
        dp += 1
      else:
        # Start a new subarray if the start is valid.
        dp = 1 if num % 2 == 0 else 0
      ans = max(ans, dp)

    return ans"
"2761","class Solution:
  def findPrimePairs(self, n: int) -> list[list[int]]:
    isPrime = self._sieveEratosthenes(n + 1)
    return [[i, n - i] for i in range(2, n // 2 + 1)
            if isPrime[i] and isPrime[n - i]]

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime


j"
"2762","class Solution:
  def continuousSubarrays(self, nums: list[int]) -> int:
    ans = 1  # [nums[0]]
    left = nums[0] - 2
    right = nums[0] + 2
    l = 0

    # nums[l..r] is a valid window.
    for r in range(1, len(nums)):
      if left <= nums[r] <= right:
        left = max(left, nums[r] - 2)
        right = min(right, nums[r] + 2)
      else:
        # nums[r] is out-of-bounds, so reconstruct the window.
        left = nums[r] - 2
        right = nums[r] + 2
        l = r
        # If we consistently move leftward in each iteration, it implies that
        # the entire left subarray satisfies the given condition. For every
        # subarray with l in the range [0, r], the condition is met, preventing
        # the code from reaching the final ""else"" condition. Instead, it stops
        # at the ""if"" condition.
        while nums[r] - 2 <= nums[l] <= nums[r] + 2:
          left = max(left, nums[l] - 2)
          right = min(right, nums[l] + 2)
          l -= 1
        l += 1
      # nums[l..r], num[l + 1..r], ..., nums[r]
      ans += r - l + 1

    return ans"
"2763","class Solution:
  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead
  # of determining the number of gaps in each subarray, let's find out how many
  # subarrays contain each gap.
  def sumImbalanceNumbers(self, nums: list[int]) -> int:
    n = len(nums)
    # Note that to avoid double counting, only `left` needs to check nums[i].
    # This adjustment ensures that i represents the position of the leftmost
    # element of nums[i] within the subarray.

    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1
    left = [0] * n
    # right[i] := the minimum index r s.t. nums[r] = nums[i]
    right = [0] * n

    numToIndex = [-1] * (n + 2)
    for i, num in enumerate(nums):
      left[i] = max(numToIndex[num], numToIndex[num + 1])
      numToIndex[num] = i

    numToIndex = [n] * (n + 2)
    for i in range(n - 1, -1, -1):
      right[i] = numToIndex[nums[i] + 1]
      numToIndex[nums[i]] = i

    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.
    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]
    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)
    # subarrays satisfying this condition.
    #
    # Subtract n * (n + 1) / 2 to account for the overcounting of elements
    # initially assumed to have a gap. This adjustment is necessary as the
    # maximum element of every subarray does not have a gap.
    return sum((i - left[i]) * (right[i] - i)
               for i in range(n)) - n * (n + 1) // 2"
"2764","class Solution:
  def isPreorder(self, nodes: list[list[int]]) -> bool:
    stack = []  # Stores `id`s.

    for id, parentId in nodes:
      if parentId == -1:
        stack.append(id)
        continue
      while stack and stack[-1] != parentId:
        stack.pop()
      if not stack:
        return False
      stack.append(id)

    return True"
"2765","class Solution:
  def alternatingSubarray(self, nums: list[int]) -> int:
    ans = 1
    dp = 1

    for i in range(1, len(nums)):
      targetDiff = -1 if dp % 2 == 0 else 1
      # Append nums[i] to the current alternating subarray.
      if nums[i] - nums[i - 1] == targetDiff:
        dp += 1
      # Reset the alternating subarray to nums[i - 1..i].
      elif nums[i] - nums[i - 1] == 1:
        dp = 2
      # Reset the alternating subarray to nums[i].
      else:
        dp = 1
      ans = max(ans, dp)

    return -1 if ans == 1 else ans"
"2766","class Solution:
  def relocateMarbles(
      self,
      nums: list[int],
      moveFrom: list[int],
      moveTo: list[int],
  ) -> list[int]:
    numsSet = set(nums)

    for f, t in zip(moveFrom, moveTo):
      numsSet.remove(f)
      numsSet.add(t)

    return sorted(numsSet)"
"2767","class Solution:
  def minimumBeautifulSubstrings(self, s: str) -> int:
    n = len(s)
    # dp[i] := the minimum number of beautiful substrings for the first i chars
    dp = [0] + [n + 1] * n

    for i in range(1, n + 1):
      if s[i - 1] == '0':
        continue
      num = 0  # the number of s[i - 1..j - 1]
      for j in range(i, n + 1):
        num = (num << 1) + int(s[j - 1])
        if self._isPowerOfFive(num):
          dp[j] = min(dp[j], dp[i - 1] + 1)

    return -1 if dp[n] == n + 1 else dp[n]

  def _isPowerOfFive(self, num: int) -> bool:
    while num % 5 == 0:
      num //= 5
    return num == 1"
"2768","class Solution:
  def countBlackBlocks(
      self,
      m: int,
      n: int,
      coordinates: list[list[int]],
  ) -> list[int]:
    ans = [0] * 5
    # count[i * n + j] := the number of black cells in
    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)
    count = collections.Counter()

    for x, y in coordinates:
      for i in range(x, x + 2):
        for j in range(y, y + 2):
          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the
          # current black cell (x, y).
          if 0 < i < m and 0 < j < n:
            count[(i, j)] += 1

    for freq in count.values():
      ans[freq] += 1

    ans[0] = (m - 1) * (n - 1) - sum(ans)
    return ans"
"2769","class Solution:
  def theMaximumAchievableX(self, num: int, t: int) -> int:
    return num + 2 * t"
"277","# The knows API is already defined for you.
# Returns a bool, whether a knows b
# Def knows(a: int, b: int) -> bool:


class Solution:
  def findCelebrity(self, n: int) -> int:
    candidate = 0

    # Everyone knows the celebrity.
    for i in range(1, n):
      if knows(candidate, i):
        candidate = i

    # The candidate knows nobody and everyone knows the celebrity.
    for i in range(n):
      if i < candidate and knows(candidate, i) or not knows(i, candidate):
        return -1
      if i > candidate and not knows(i, candidate):
        return -1

    return candidate"
"2770","class Solution:
  def maximumJumps(self, nums: list[int], target: int) -> int:
    n = len(nums)
    # dp[i] := the maximum number of jumps to reach i from 0
    dp = [-1] * n
    dp[0] = 0

    for j in range(1, n):
      for i in range(j):
        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:
          dp[j] = max(dp[j], dp[i] + 1)

    return dp[-1]"
"2771","class Solution:
  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:
    ans = 1
    dp1 = 1  # the longest subarray that ends in nums1[i] so far
    dp2 = 1  # the longest subarray that ends in nums2[i] so far

    for i in range(1, len(nums1)):
      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1
      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1
      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1
      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1
      dp1 = max(dp11, dp21)
      dp2 = max(dp12, dp22)
      ans = max(ans, dp1, dp2)

    return ans"
"2772","class Solution:
  def checkArray(self, nums: list[int], k: int) -> bool:
    if k == 1:
      return True

    needDecrease = 0
    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].
    dq = collections.deque()

    for i, num in enumerate(nums):
      if i >= k:
        needDecrease -= dq.popleft()
      if nums[i] < needDecrease:
        return False
      decreasedNum = nums[i] - needDecrease
      dq.append(decreasedNum)
      needDecrease += decreasedNum

    return dq[-1] == 0"
"2773","class Solution:
  def heightOfTree(self, root: TreeNode | None) -> int:
    if not root:
      return 0
    # a leaf node
    if root.left and root.left.right == root:
      return 0
    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))"
"2774","declare global {
  interface Array<T> {
    upperBound(target: number): number;
  }
}

Array.prototype.upperBound = function (target): number {
  let l = 0;
  let r = this.length - 1;
  while (l < r) {
    const m = (l + r + 1) >> 1;
    if (this[m] > target) {
      r = m - 1;
    } else {
      l = m;
    }
  }
  return this[l] == target ? l : -1;
};"
"2775","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Value =
  | undefined
  | null
  | boolean
  | number
  | string
  | Value[]
  | { [key: string]: Value };

type Obj1 = Record<string, Value> | Array<Value>;
type Obj2 = Record<string, JSONValue> | Array<JSONValue>;

function undefinedToNull(obj: Obj1): Obj2 {
  if (obj === undefined || obj === null) {
    return null;
  }
  if (
    typeof obj === 'boolean' ||
    typeof obj === 'number' ||
    typeof obj === 'string'
  ) {
    return obj;
  }
  for (const key in obj) {
    obj[key] = undefinedToNull(obj[key]);
  }
  return obj;
}"
"2776","type CallbackFn = (
  next: (data: number, error: string) => void,
  ...args: number[]
) => void;
type Promisified = (...args: number[]) => Promise<number>;

function promisify(fn: CallbackFn): Promisified {
  return async function (...args: number[]): Promise<number> {
    return new Promise((resolve, reject) =>
      fn((data, err) => (err ? reject(err) : resolve(data)), ...args)
    );
  };
}"
"2777","// Similar to 2758. Next Day
function* dateRangeGenerator(
  start: string,
  end: string,
  step: number
): Generator<string> {
  const startDate = new Date(start);
  const endDate = new Date(end);
  let currentDate = startDate;
  while (currentDate <= endDate) {
    yield currentDate.toISOString().split('T')[0];
    currentDate.setDate(currentDate.getDate() + step);
  }
}"
"2778","class Solution:
  def sumOfSquares(self, nums: list[int]) -> int:
    return sum(num**2 for i, num in enumerate(nums)
               if len(nums) % (i + 1) == 0)"
"2779","class Solution:
  def maximumBeauty(self, nums: list[int], k: int) -> int:
    nums.sort()

    # l and r track the maximum window instead of the valid window.
    l = 0
    for r in range(len(nums)):
      if nums[r] - nums[l] > 2 * k:
        l += 1

    return r - l + 1"
"278","class Solution:
  def firstBadVersion(self, n: int) -> int:
    l = 1
    r = n

    while l < r:
      m = (l + r) >> 1
      if isBadVersion(m):
        r = m
      else:
        l = m + 1

    return l"
"2780","class Solution:
  def minimumIndex(self, nums: list[int]) -> int:
    count1 = collections.Counter()
    count2 = collections.Counter(nums)

    for i, num in enumerate(nums):
      count1[num] = count1[num] + 1
      count2[num] = count2[num] - 1
      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:
        return i

    return -1"
"2781","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.isWord = False


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str, l: int, r: int) -> bool:
    node: TrieNode = self.root
    for i in range(l, r):
      if word[i] not in node.children:
        return False
      node = node.children[word[i]]
    return node.isWord


class Solution:
  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:
    ans = 0
    trie = Trie()

    for s in forbidden:
      trie.insert(s)

    # r is the rightmost index to make word[l..r] a valid substring.
    r = len(word) - 1
    for l in range(len(word) - 1, -1, -1):
      for end in range(l, min(l + 10, r + 1)):
        if trie.search(word, l, end + 1):
          r = end - 1
          break
      ans = max(ans, r - l + 1)

    return ans"
"2782","# Definition for a category handler.
# class CategoryHandler:
#   def haveSameCategory(self, a: int, b: int) -> bool:
#     pass

class Solution:
  def numberOfCategories(
      self,
      n: int,
      categoryHandler: Optional['CategoryHandler'],
  ) -> int:
    ans = 0

    for i in range(n):
      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):
        ans += 1

    return ans"
"2783","SELECT
  Flights.flight_id,
  LEAST(Flights.capacity, COUNT(Passengers.flight_id)) AS booked_cnt,
  GREATEST(0, COUNT(Passengers.flight_id) - Flights.capacity) AS waitlist_cnt
FROM Flights
LEFT JOIN Passengers
  USING (flight_id)
GROUP BY 1
ORDER BY 1;"
"2784","class Solution:
  def isGood(self, nums: list[int]) -> bool:
    n = len(nums) - 1
    count = collections.Counter(nums)
    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2"
"2785","class Solution:
  def sortVowels(self, s: str) -> str:
    kVowels = 'aeiouAEIOU'
    ans = []
    vowels = sorted([c for c in s if c in kVowels])

    i = 0  # vowels' index
    for c in s:
      if c in kVowels:
        ans.append(vowels[i])
        i += 1
      else:
        ans.append(c)

    return ''.join(ans)"
"2786","class Solution:
  def maxScore(self, nums: list[int], x: int) -> int:
    # Note that we always need to take nums[0], so the initial definition might
    # not hold true.

    # dp0 := the maximum score so far with `nums` ending in an even number
    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)
    # dp0 := the maximum score so far with `nums` ending in an odd number
    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)

    for i in range(1, len(nums)):
      if nums[i] % 2 == 0:
        dp0 = nums[i] + max(dp0, dp1 - x)
      else:
        dp1 = nums[i] + max(dp1, dp0 - x)

    return max(dp0, dp1)"
"2787","class Solution:
  def numberOfWays(self, n: int, x: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to express i
    dp = [1] + [0] * n

    for a in range(1, n + 1):
      ax = a**x
      if ax > n:
        break
      for i in range(n, ax - 1, -1):
        dp[i] += dp[i - ax]
        dp[i] %= kMod

    return dp[n]"
"2788","class Solution:
  def splitWordsBySeparator(
      self,
      words: list[str],
      separator: str,
  ) -> list[str]:
    return [splitWord
            for word in words
            for splitWord in word.split(separator)
            if splitWord]"
"2789","class Solution:
  def maxArrayValue(self, nums: list[int]) -> int:
    ans = nums[-1]

    for i in range(len(nums) - 2, -1, -1):
      if nums[i] > ans:
        ans = nums[i]
      else:
        ans += nums[i]

    return ans"
"279","class Solution:
  def numSquares(self, n: int) -> int:
    dp = [n] * (n + 1)  # 1^2 x n
    dp[0] = 0  # no way
    dp[1] = 1  # 1^2

    for i in range(2, n + 1):
      j = 1
      while j * j <= i:
        dp[i] = min(dp[i], dp[i - j * j] + 1)
        j += 1

    return dp[n]"
"2790","class Solution:
  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:
    ans = 1  # the next target length
    availableLimits = 0

    for usageLimit in sorted(usageLimits):
      availableLimits += usageLimit
      # Can create groups 1, 2, ..., ans.
      if availableLimits >= ans * (ans + 1) // 2:
        ans += 1

    return ans - 1"
"2791","class Solution:
  def countPalindromePaths(self, parent: list[int], s: str) -> int:
    # A valid (u, v) has at most 1 letter with odd frequency on its path. The
    # frequency of a letter on the u-v path is equal to the sum of its
    # frequencies on the root-u and root-v paths substract twice of its
    # frequency on the root-LCA(u, v) path. Considering only the parity
    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it
    # possible to calculate both parts easily using a simple DFS.
    tree = [[] for _ in parent]
    maskToCount = collections.Counter({0: 1})

    for i in range(1, len(parent)):
      tree[parent[i]].append(i)

    # mask := 26 bits that represent the parity of each character in the alphabet
    # on the path from node 0 to node u
    def dfs(u: int, mask: int) -> int:
      res = 0
      if u > 0:
        mask ^= 1 << (ord(s[u]) - ord('a'))
        # Consider any u-v path with 1 bit set.
        for i in range(26):
          res += maskToCount[mask ^ (1 << i)]
        # Consider u-v path with 0 bit set.
        res += maskToCount[mask ^ 0]
        maskToCount[mask] += 1
      for v in tree[u]:
        res += dfs(v, mask)
      return res

    return dfs(0, 0)"
"2792","class Solution:
  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:
    ans = 0

    def dfs(root: TreeNode | None) -> list[int]:
      nonlocal ans
      if not root:
        return []

      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]
      if len(kSmallest) == k and root.val > kSmallest[-1]:
        ans += 1

      return kSmallest + [root.val]

    dfs(root)
    return ans"
"2793","SELECT
  Passengers.passenger_id,
  IF(
    RANK() OVER(
      PARTITION BY Passengers.flight_id
      ORDER BY Passengers.booking_time
    ) <= Flights.capacity,
    'Confirmed',
    'Waitlist'
  ) AS status
FROM Passengers
INNER JOIN Flights
  USING (flight_id)
ORDER BY 1;"
"2794","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function createObject(
  keysArr: JSONValue[],
  valuesArr: JSONValue[]
): Record<string, JSONValue> {
  let ans: Record<string, JSONValue> = {};
  keysArr.forEach((key, index) => {
    let stringKey: string = typeof key === 'string' ? key : String(key);
    if (!(stringKey in ans)) {
      ans[stringKey] = valuesArr[index];
    }
  });
  return ans;
}"
"2795","type FulfilledObj = {
  status: 'fulfilled';
  value: string;
};
type RejectedObj = {
  status: 'rejected';
  reason: string;
};
type Obj = FulfilledObj | RejectedObj;

function promiseAllSettled(functions: Function[]): Promise<Obj[]> {
  return new Promise((resolve) => {
    const results: Obj[] = Array.from({ length: functions.length });
    let count = 0;
    functions.forEach((fn, index) => {
      fn()
        .then((value) => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch((reason) => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          if (++count === functions.length) {
            resolve(results);
          }
        });
    });
  });
}"
"2796","declare global {
  interface String {
    replicate(times: number): string;
  }
}

String.prototype.replicate = function (times): string {
  return Array(times).fill(this).join('');
};"
"2797","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => JSONValue;

function partial(fn: Fn, args: JSONValue[]): Fn {
  return function (...restArgs) {
    return fn(
      ...args
        .map((arg) => (arg === '_' ? restArgs.shift() : arg))
        .concat(restArgs)
    );
  };
}"
"2798","class Solution:
  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:
    return sum(hour >= target for hour in hours)"
"2799","class Solution:
  def countCompleteSubarrays(self, nums: list[int]) -> int:
    ans = 0
    distinct = len(set(nums))
    count = collections.Counter()

    l = 0
    for num in nums:
      count[num] += 1
      while len(count) == distinct:
        count[nums[l]] -= 1
        if count[nums[l]] == 0:
          del count[nums[l]]
        l += 1
      # Assume nums[r] = num,
      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.
      ans += l

    return ans"
"28","class Solution:
  def strStr(self, haystack: str, needle: str) -> int:
    m = len(haystack)
    n = len(needle)

    for i in range(m - n + 1):
      if haystack[i:i + n] == needle:
        return i

    return -1"
"280","class Solution:
  def wiggleSort(self, nums: list[int]) -> None:
    # 1. If i is even, then nums[i] <= nums[i - 1].
    # 2. If i is odd, then nums[i] >= nums[i - 1].
    for i in range(1, len(nums)):
      if (i % 2 == 0 and nums[i] > nums[i - 1] or
              i % 2 == 1 and nums[i] < nums[i - 1]):
        nums[i], nums[i - 1] = nums[i - 1], nums[i]"
"2800","class Solution:
  def minimumString(self, a: str, b: str, c: str) -> str:
    def merge(a: str, b: str) -> str:
      """"""Merges a and b.""""""
      if a in b:  # a is a substring of b.
        return b
      for i in range(len(a)):
        aSuffix = a[i:]
        bPrefix = b[:len(aSuffix)]
        if aSuffix == bPrefix:
          return a + b[len(bPrefix):]
      return a + b

    abc = merge(a, merge(b, c))
    acb = merge(a, merge(c, b))
    bac = merge(b, merge(a, c))
    bca = merge(b, merge(c, a))
    cab = merge(c, merge(a, b))
    cba = merge(c, merge(b, a))
    return self._getMin([abc, acb, bac, bca, cab, cba])

  def _getMin(self, words: list[str]) -> str:
    """"""Returns the lexicographically smallest string.""""""

    def getMin(a: str, b: str) -> str:
      """"""Returns the lexicographically smaller string.""""""
      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b

    res = words[0]
    for i in range(1, len(words)):
      res = getMin(res, words[i])
    return res"
"2801","class Solution:
  def countSteppingNumbers(self, low: str, high: str) -> int:
    kMod = 1_000_000_007
    low = '0' * (len(high) - len(low)) + low

    @functools.lru_cache(None)
    def dp(
        i: int,
        prevDigit: int,
        isLeadingZero: bool,
        isTight1: bool,
        isTight2: bool,
    ) -> int:
      """"""
      Returns the number of valid integers, considering the i-th digit, where
      `prevDigit` is the previous digit, `isTight1` indicates if the current
      digit is tightly bound for `low`, and `isTight2` indicates if the current
      digit is tightly bound for `high`.
      """"""
      if i == len(high):
        return 1

      res = 0
      minDigit = int(low[i]) if isTight1 else 0
      maxDigit = int(high[i]) if isTight2 else 9

      for d in range(minDigit, maxDigit + 1):
        nextIsTight1 = isTight1 and (d == minDigit)
        nextIsTight2 = isTight2 and (d == maxDigit)
        if isLeadingZero:
          # Can place any digit in [minDigit, maxDigit].
          res += dp(i + 1, d, isLeadingZero and d ==
                    0, nextIsTight1, nextIsTight2)
        elif abs(d - prevDigit) == 1:
          res += dp(i + 1, d, False, nextIsTight1, nextIsTight2)
        res %= kMod

      return res

    return dp(0, -1, True, True, True)"
"2802","class Solution:
  def kthLuckyNumber(self, k: int) -> str:
    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')"
"2803","function* factorial(n: number): Generator<number> {
  if (n === 0) {
    yield 1;
  }
  let fact = 1;
  for (let i = 1; i <= n; ++i) {
    fact *= i;
    yield fact;
  }
}"
"2804","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Callback = (
  currentValue: JSONValue,
  index: number,
  array: JSONValue[]
) => any;
type Context = Record<string, JSONValue>;

Array.prototype.forEach = function (
  callback: Callback,
  context: Context
): void {
  for (let i = 0; i < this.length; ++i) {
    callback.call(context, this[i], i, this);
  }
};"
"2805","let id = 0;
const idToTimeout = {};

function customInterval(fn: Function, delay: number, period: number): number {
  ++id;
  (function callFnWithCountPlusOne(count: number): void {
    const timeout = setTimeout(() => {
      fn();
      callFnWithCountPlusOne(count + 1);
    }, delay + period * count);
    idToTimeout[id] = timeout;
  })(0);
  return id;
}

function customClearInterval(id: number): void {
  clearTimeout(idToTimeout[id]);
}"
"2806","class Solution:
  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:
    return 100 - ((purchaseAmount + 5) // 10) * 10"
"2807","class Solution:
  def insertGreatestCommonDivisors(
      self, head: ListNode | None
  ) -> ListNode | None:
    curr = head
    while curr.next:
      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)
      curr.next = inserted
      curr = inserted.next
    return head"
"2808","class Solution:
  def minimumSeconds(self, nums: list[int]) -> int:
    n = len(nums)
    ans = n
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    def getSeconds(i: int, j: int) -> int:
      """"""Returns the number of seconds required to make nums[i..j] the same.""""""
      return (i - j) // 2

    for indices in numToIndices.values():
      seconds = getSeconds(indices[0] + n, indices[-1])
      for i in range(1, len(indices)):
        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))
      ans = min(ans, seconds)

    return ans"
"2809","class Solution:
  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:
    n = len(nums1)
    # dp[j] := the maximum reduced value if we do j operations on the numbers
    # so far
    dp = [0] * (n + 1)
    sum1 = sum(nums1)
    sum2 = sum(nums2)

    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):
      for j in range(i, 0, -1):
        dp[j] = max(
            # the maximum reduced value if we do j operations on the first
            # i - 1 numbers
            dp[j],
            # the maximum reduced value if we do j - 1 operations on the first
            # i - 1 numbers + making the i-th number of `nums1` to 0 at the
            # j-th operation
            dp[j - 1] + num2 * j + num1
        )

    for op in range(n + 1):
      if sum1 + sum2 * op - dp[op] <= x:
        return op

    return -1"
"281","class ZigzagIterator:
  def __init__(self, v1: list[int], v2: list[int]):
    def vals():
      for i in itertools.count():
        for v in v1, v2:
          if i < len(v):
            yield v[i]
    self.vals = vals()
    self.n = len(v1) + len(v2)

  def next(self):
    self.n -= 1
    return next(self.vals)

  def hasNext(self):
    return self.n > 0"
"2810","class Solution:
  def finalString(self, s: str) -> str:
    dq = collections.deque()
    inversed = False

    for c in s:
      if c == 'i':
        inversed = not inversed
      elif inversed:
        dq.appendleft(c)
      else:
        dq.append(c)

    return ''.join(reversed(dq)) if inversed else ''.join(dq)"
"2811","class Solution:
  def canSplitArray(self, nums: list[int], m: int) -> bool:
    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))"
"2812","class Solution:
  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:
    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    n = len(grid)
    distToThief = self._getDistToThief(grid)

    def hasValidPath(safeness: int) -> bool:
      if distToThief[0][0] < safeness:
        return False

      q = collections.deque([(0, 0)])
      seen = {(0, 0)}

      while q:
        i, j = q.popleft()
        if distToThief[i][j] < safeness:
          continue
        if i == n - 1 and j == n - 1:
          return True
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == n or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))

      return False

    return bisect.bisect_left(range(n * 2), True,
                              key=lambda m: not hasValidPath(m)) - 1

  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:
    n = len(grid)
    distToThief = [[0] * n for _ in range(n)]
    q = collections.deque()
    seen = set()

    for i in range(n):
      for j in range(n):
        if grid[i][j] == 1:
          q.append((i, j))
          seen.add((i, j))

    dist = 0
    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        distToThief[i][j] = dist
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == n or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))
      dist += 1

    return distToThief"
"2813","class Solution:
  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:
    ans = 0
    totalProfit = 0
    seenCategories = set()
    decreasingDuplicateProfits = []

    items.sort(reverse=True)

    for i in range(k):
      profit, category = items[i]
      totalProfit += profit
      if category in seenCategories:
        decreasingDuplicateProfits.append(profit)
      else:
        seenCategories.add(category)

    ans = totalProfit + len(seenCategories)**2

    for i in range(k, len(items)):
      profit, category = items[i]
      if category not in seenCategories and decreasingDuplicateProfits:
        # If this is a new category we haven't seen before, it's worth
        # considering taking it and replacing the one with the least profit
        # since it will increase the distinct_categories and potentially result
        # in a larger total_profit + distinct_categories^2.
        totalProfit -= decreasingDuplicateProfits.pop()
        totalProfit += profit
        seenCategories.add(category)
        ans = max(ans, totalProfit + len(seenCategories)**2)

    return ans"
"2814","class Solution:
  def minimumSeconds(self, land: list[list[str]]) -> int:
    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(land)
    n = len(land[0])
    floodDist = self._getFloodDist(land)
    startPos = self._getStartPos(land, 'S')

    q = collections.deque([startPos])
    seen = {startPos}

    step = 1
    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if land[x][y] == 'D':
            return step
          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))
      step += 1

    return -1

  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:
    m = len(land)
    n = len(land[0])
    dist = [[math.inf] * n for _ in range(m)]
    q = collections.deque()
    seen = set()

    for i, row in enumerate(land):
      for j, cell in enumerate(row):
        if cell == '*':
          q.append((i, j))
          seen.add((i, j))

    d = 0
    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        dist[i][j] = d
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if land[x][y] in 'XD' or (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))
      d += 1

    return dist

  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:
    for i, row in enumerate(land):
      for j, cell in enumerate(row):
        if cell == c:
          return i, j"
"2815","class Solution:
  def maxSum(self, nums: list[int]) -> int:
    ans = 0
    # maxNum[i] := the maximum num we met so far with the maximum digit i
    maxNum = [0] * 10

    def getMaxDigit(num: int) -> int:
      maxDigit = 0
      while num > 0:
        maxDigit = max(maxDigit, num % 10)
        num //= 10
      return maxDigit

    for num in nums:
      d = getMaxDigit(num)
      if maxNum[d] > 0:
        ans = max(ans, num + maxNum[d])
      maxNum[d] = max(maxNum[d], num)

    return -1 if ans == 0 else ans"
"2816","class Solution:
  def doubleIt(self, head: ListNode | None) -> ListNode | None:
    if head.val >= 5:
      head = ListNode(0, head)

    curr = head

    while curr:
      curr.val *= 2
      curr.val %= 10
      if curr.next and curr.next.val >= 5:
        curr.val += 1
      curr = curr.next

    return head"
"2817","from sortedcontainers import SortedSet


class Solution:
  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:
    ans = math.inf
    seen = SortedSet()

    for i in range(x, len(nums)):
      seen.add(nums[i - x])
      it = seen.bisect_left(nums[i])
      if it != len(seen):
        ans = min(ans, seen[it] - nums[i])
      if it != 0:
        ans = min(ans, nums[i] - seen[it - 1])

    return ans"
"2818","class Solution:
  def maximumScore(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 1
    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)
    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]
    # left[i] := the next index on the left (if any)
    #            s.t. primeScores[left[i]] >= primeScores[i]
    left = [-1] * n
    # right[i] := the next index on the right (if any)
    #             s.t. primeScores[right[i]] > primeScores[i]
    right = [n] * n
    stack = []

    # Find the next indices on the left where `primeScores` are greater or equal.
    for i in reversed(range(n)):
      while stack and primeScores[stack[-1]] <= primeScores[i]:
        left[stack.pop()] = i
      stack.append(i)

    stack = []

    # Find the next indices on the right where `primeScores` are greater.
    for i in range(n):
      while stack and primeScores[stack[-1]] < primeScores[i]:
        right[stack.pop()] = i
      stack.append(i)

    numAndIndexes = [(num, i) for i, num in enumerate(nums)]

    def modPow(x: int, n: int) -> int:
      if n == 0:
        return 1
      if n % 2 == 1:
        return x * modPow(x, n - 1) % kMod
      return modPow(x * x % kMod, n // 2)

    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):
      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]
      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will
      # be chosen.
      rangeCount = (i - left[i]) * (right[i] - i)
      actualCount = min(rangeCount, k)
      k -= actualCount
      ans *= modPow(num, actualCount)
      ans %= kMod

    return ans

  def _sieveEratosthenes(self, n: int) -> list[int]:
    """"""Gets the minimum prime factor of i, where 2 <= i <= n.""""""
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:  # `i` is prime.
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:
    primeFactors = set()
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.add(divisor)
      while num % divisor == 0:
        num //= divisor
    return len(primeFactors)"
"2819","class Solution:
  def minimumRelativeLosses(
      self,
      prices: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    ans = []

    prices.sort()

    prefix = list(itertools.accumulate(prices, initial=0))

    for k, m in queries:
      countFront = self._getCountFront(k, m, prices)
      countBack = m - countFront
      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))

    return ans

  def _getCountFront(
      self,
      k: int,
      m: int,
      prices: list[int],
  ) -> int:
    """"""Returns `countFront` for query (k, m).

    Returns `countFront` for query (k, m) s.t. picking the first `countFront`
    and the last `m - countFront` chocolates is optimal.

    Define loss[i] := the relative loss of picking `prices[i]`.
    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.
       Thus, loss[i] = prices[i] - 0 = prices[i].
    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.
       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].
    By observation, we deduce that it is always better to pick from the front
    or the back since loss[i] is increasing for 1. and is decreasing for 2.

    Assume that picking `left` chocolates from the left and `right = m - left`
    chocolates from the right is optimal. Therefore, we are selecting
    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.

    To determine the optimal `left` in each iteration, we simply compare
    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,
    it's worth increasing `left`.
    """"""
    n = len(prices)
    countNoGreaterThanK = bisect.bisect_right(prices, k)
    l = 0
    r = min(countNoGreaterThanK, m)

    while l < r:
      mid = (l + r) // 2
      right = m - mid
      # Picking prices[mid] is better than picking prices[n - right].
      if prices[mid] < 2 * k - prices[n - right]:
        l = mid + 1
      else:
        r = mid

    return l

  def _getRelativeLoss(
      self,
      countFront: int,
      countBack: int,
      k: int,
      prefix: list[int],
  ) -> int:
    """"""
    Returns the relative loss of picking `countFront` and `countBack` 
    chocolates.
    """"""
    lossFront = prefix[countFront]
    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])
    return lossFront + lossBack"
"282","class Solution:
  def addOperators(self, num: str, target: int) -> list[str]:
    ans = []

    def dfs(start: int, prev: int, eval: int, path: list[str]) -> None:
      if start == len(num):
        if eval == target:
          ans.append(''.join(path))
        return

      for i in range(start, len(num)):
        if i > start and num[start] == '0':
          return
        s = num[start:i + 1]
        curr = int(s)
        if start == 0:
          path.append(s)
          dfs(i + 1, curr, curr, path)
          path.pop()
        else:
          for op in ['+', '-', '*']:
            path.append(op + s)
            if op == '+':
              dfs(i + 1, curr, eval + curr, path)
            elif op == '-':
              dfs(i + 1, -curr, eval - curr, path)
            else:
              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)
            path.pop()

    dfs(0, 0, 0, [])
    return ans"
"2820","WITH 
  VoterToValue AS (
    SELECT
      voter,
      1 / COUNT(*) AS value
    FROM Votes
    GROUP BY voter
  ),
  RankedCandidates AS (
    SELECT
      candidate,
      RANK() OVER(ORDER BY SUM(value) DESC) AS `rank`
    FROM Votes
    INNER JOIN VoterToValue
      USING (voter)
    WHERE candidate IS NOT NULL
    GROUP BY 1
  )
SELECT candidate
FROM RankedCandidates
WHERE `rank` = 1
ORDER BY 1;"
"2821","type Fn = () => Promise<any>;

function delayAll(functions: Fn[], ms: number): Fn[] {
  return functions.map((fn) => {
    return async () => {
      await new Promise((resolve) => setTimeout(resolve, ms));
      try {
        const result = await fn();
        return Promise.resolve(result);
      } catch (error) {
        return Promise.reject(error);
      }
    };
  });
}"
"2822","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function invertObject(obj: Obj): Record<string, JSONValue> {
  const ans: Record<string, JSONValue> = {};

  for (const [key, value] of Object.entries(obj)) {
    const valueKey = value as string;
    if (ans.hasOwnProperty(valueKey)) {
      const curr = ans[valueKey];
      if (!Array.isArray(curr)) {
        ans[valueKey] = [curr];
      }
      (ans[valueKey] as JSONValue[]).push(key);
    } else {
      ans[valueKey] = key;
    }
  }

  return ans;
}"
"2823","type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function deepFilter(obj: Obj, fn: Function): Obj | undefined {
  if (obj === null || typeof obj !== 'object') {
    return fn(obj) ? obj : undefined;
  }
  if (Array.isArray(obj)) {
    const ans = (obj as Obj[])
      .map((item) => deepFilter(item, fn))
      .filter((item) => item !== undefined);
    return ans.length > 0 ? ans : undefined;
  }
  let ans = {};
  for (const [key, value] of Object.entries(obj)) {
    const ans = deepFilter(value as Obj, fn);
    if (ans !== undefined) {
      ans[key] = ans;
    }
  }
  return Object.keys(ans).length > 0 ? ans : undefined;
}"
"2824","class Solution:
  def countPairs(self, nums: list[int], target: int) -> int:
    return sum(nums[i] + nums[j] < target
               for i in range(len(nums))
               for j in range(i + 1, len(nums)))"
"2825","class Solution:
  def canMakeSubsequence(self, str1: str, str2: str) -> bool:
    i = 0  # str2's index

    for c in str1:
      if c == str2[i] or chr(
              ord('a') + (string.ascii_lowercase.index(c) + 1) % 26) == str2[i]:
        i += 1
        if i == len(str2):
          return True

    return False"
"2826","class Solution:
  def minimumOperations(self, nums: list[int]) -> int:
    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]
    dp = [0] * 4

    for num in nums:
      dp[num] += 1  # Append num to the sequence so far.
      dp[2] = max(dp[2], dp[1])
      dp[3] = max(dp[3], dp[2])

    return len(nums) - dp[3]"
"2827","class Solution {
 public:
  int numberOfBeautifulIntegers(int low, int high, int k) {
    const string lowString = to_string(low);
    const string highString = to_string(high);
    const string lowWithLeadingZeros =
        string(highString.length() - lowString.length(), '0') + lowString;
    vector<vector<vector<vector<vector<vector<int>>>>>> mem(
        highString.length(),
        vector<vector<vector<vector<vector<int>>>>>(
            10, vector<vector<vector<vector<int>>>>(
                    10, vector<vector<vector<int>>>(
                            k, vector<vector<int>>(2, vector<int>(2, -1))))));
    return count(lowWithLeadingZeros, highString, k, 0, 0, 0, 0, true, true,
                 true, mem);
  }

 private:
  // Returns the number of beautiful integers, considering the i-th digit with
  // counts of even `even` digits and odd `odd` digits, where the current number
  // modulo k equals remainder, `isTight1` indicates if the current digit is
  // tightly bound for `low` and `isTight2` indicates if the current digit is
  // tightly bound for `high`
  int count(const string& low, const string& high, int k, int i, int even,
            int odd, int remainder, bool isLeadingZero, bool isTight1,
            bool isTight2,
            vector<vector<vector<vector<vector<vector<int>>>>>>& mem) {
    if (i == high.length())
      return !isLeadingZero && even == odd && remainder == 0;
    if (mem[i][even][odd][remainder][isTight1][isTight2] != -1)
      return mem[i][even][odd][remainder][isTight1][isTight2];

    int res = 0;
    const int minDigit = isTight1 ? low[i] - '0' : 0;
    const int maxDigit = isTight2 ? high[i] - '0' : 9;

    for (int d = minDigit; d <= maxDigit; ++d) {
      const int nextEven = even + ((!isLeadingZero || d > 0) && d % 2 == 0);
      const int nextOdd = odd + (d % 2 == 1);
      const int nextRemainder = (remainder * 10 + d) % k;
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(low, high, k, i + 1, nextEven, nextOdd, nextRemainder,
                   isLeadingZero && d == 0, nextIsTight1, nextIsTight2, mem);
    }

    return mem[i][even][odd][remainder][isTight1][isTight2] = res;
  }
};"
"2828","class Solution:
  def isAcronym(self, words: list[str], s: str) -> bool:
    return (len(words) == len(s) and
            all(word[0] == c for word, c in zip(words, s)))"
"2829","class Solution:
  def minimumSum(self, n: int, k: int) -> int:
    # These are the unique pairs that sum up to k:
    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).
    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then
    # choose k, k + 1, ... if necessary, as selecting any number in the range
    # [ceil(k // 2), k - 1] will result in a pair summing up to k.

    def trapezoid(a: int, b: int) -> int:
      """"""Returns sum(a..b).""""""
      return (a + b) * (b - a + 1) // 2

    mid = k // 2  # floor(k // 2)
    if n <= mid:
      return trapezoid(1, n)
    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))"
"283","class Solution:
  def moveZeroes(self, nums: list[int]) -> None:
    j = 0
    for num in nums:
      if num != 0:
        nums[j] = num
        j += 1

    for i in range(j, len(nums)):
      nums[i] = 0"
"2830","class Solution:
  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:
    # dp[i] := the maximum amount of gold of selling the first i houses
    dp = [0] * (n + 1)
    endToStartAndGolds = [[] for _ in range(n)]

    for start, end, gold in offers:
      endToStartAndGolds[end].append((start, gold))

    for end in range(1, n + 1):
      # Get at least the same gold as selling the first `end - 1` houses.
      dp[end] = dp[end - 1]
      for start, gold in endToStartAndGolds[end - 1]:
        dp[end] = max(dp[end], dp[start] + gold)

    return dp[n]"
"2831","class Solution:
  def longestEqualSubarray(self, nums: list[int], k: int) -> int:
    ans = 0
    count = collections.Counter()

    # l and r track the maximum window instead of the valid window.
    l = 0
    for r, num in enumerate(nums):
      count[num] += 1
      ans = max(ans, count[num])
      if r - l + 1 - k > ans:
        count[nums[l]] -= 1
        l += 1

    return ans"
"2832","class Solution:
  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:
    ans = [0] * len(nums)
    stack = []  # a decreasing stack

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):
        index = stack.pop()
        left = stack[-1] if stack else -1
        ans[index] = i - left - 1
      stack.append(i)

    return ans"
"2833","class Solution:
  def furthestDistanceFromOrigin(self, moves: str) -> int:
    return abs(moves.count('L') - moves.count('R')) + moves.count('_')"
"2834","class Solution:
  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array
  def minimumPossibleSum(self, n: int, target: int) -> int:
    # These are the unique pairs that sum up to k (target):
    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).
    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then
    # choose k, k + 1, ... if necessary, as selecting any number in the range
    # [ceil(k // 2), k - 1] will result in a pair summing up to k.
    kMod = 1_000_000_007

    def trapezoid(a: int, b: int) -> int:
      """"""Returns sum(a..b).""""""
      return (a + b) * (b - a + 1) // 2

    mid = target // 2  # floor(k // 2)
    if n <= mid:
      return trapezoid(1, n)
    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % kMod"
"2835","class Solution:
  def minOperations(self, nums: list[int], target: int) -> int:
    kNoMissingBit = 31
    maxBit = 31
    ans = 0
    minMissingBit = kNoMissingBit
    # count[i] := the number of occurrences of 2^i
    count = collections.Counter(int(math.log2(num)) for num in nums)

    for bit in range(maxBit):
      # Check if `bit` is in the target.
      if target >> bit & 1:
        # If there are available bits, use one bit.
        if count[bit] > 0:
          count[bit] -= 1
        else:
          minMissingBit = min(minMissingBit, bit)
      # If we previously missed a bit and there are available bits.
      if minMissingBit != kNoMissingBit and count[bit] > 0:
        count[bit] -= 1
        # Count the operations to break `bit` into `minMissingBit`.
        ans += bit - minMissingBit
        minMissingBit = kNoMissingBit  # Set it to an the invalid value.
      # Combining smaller numbers costs nothing.
      count[bit + 1] += count[bit] // 2

    # Check if all target bits have been covered, otherwise return -1.
    return ans if minMissingBit == maxBit else -1"
"2836","class Solution:
  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:
    n = len(receiver)
    m = int(math.log2(k)) + 1
    ans = 0
    # jump[i][j] := the the node you reach after jumping 2^j steps from i
    jump = [[0] * m for _ in range(n)]
    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i
    summ = [[0] * m for _ in range(n)]

    for i in range(n):
      jump[i][0] = receiver[i]
      summ[i][0] = receiver[i]

    # Calculate binary lifting.
    for j in range(1, m):
      for i in range(n):
        midNode = jump[i][j - 1]
        #   the the node you reach after jumping 2^j steps from i
        # = the node you reach after jumping 2^(j - 1) steps from i
        # + the node you reach after jumping another 2^(j - 1) steps
        jump[i][j] = jump[midNode][j - 1]
        #   the sum of the first 2^j nodes you reach when jumping from i
        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i
        # + the sum of another 2^(j - 1) nodes you reach
        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]

    for i in range(n):
      currSum = i
      currPos = i
      for j in range(m):
        if (k >> j) & 1 == 1:
          currSum += summ[currPos][j]
          currPos = jump[currPos][j]
      ans = max(ans, currSum)

    return ans"
"2837","SELECT
  Users.user_id,
  Users.name,
  SUM(IFNULL(Rides.distance, 0)) AS 'traveled distance'
FROM Users
LEFT JOIN Rides
  USING (user_id)
GROUP BY 1
ORDER BY 1;"
"2838","class Solution:
  def maximumCoins(
      self,
      heroes: list[int],
      monsters: list[int],
      coins: list[int]
  ) -> list[int]:
    monsterAndCoins = sorted(list(zip(monsters, coins)))
    coinsPrefix = list(itertools.accumulate(
        (coin for _, coin in monsterAndCoins),
        initial=0))
    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]
            for hero in heroes]

  def _firstGreaterEqual(
      self,
      monsterAndCoins: list[tuple[int, int]],
      hero: int,
  ) -> int:
    l, r = 0, len(monsterAndCoins)
    while l < r:
      m = (l + r) // 2
      if monsterAndCoins[m][0] > hero:
        r = m
      else:
        l = m + 1
    return l"
"2839","class Solution:
  def canBeEqual(self, s1: str, s2: str) -> bool:
    def swappedStrings(s: str) -> list[str]:
      chars = list(s)
      return [chars,
              ''.join([chars[2], chars[1], chars[0], chars[3]]),
              ''.join([chars[0], chars[3], chars[2], chars[1]]),
              ''.join([chars[2], chars[3], chars[0], chars[1]])]

    return any(a == b
               for a in swappedStrings(s1)
               for b in swappedStrings(s2))"
"284","class PeekingIterator:
  def __init__(self, iterator: Iterator):
    self.iterator = iterator
    self.buffer = self.iterator.next() if self.iterator.hasNext() else None

  def peek(self) -> int:
    """"""
    Returns the next element in the iteration without advancing the iterator.
    """"""
    return self.buffer

  def next(self) -> int:
    next = self.buffer
    self.buffer = self.iterator.next() if self.iterator.hasNext() else None
    return next

  def hasNext(self) -> bool:
    return self.buffer is not None"
"2840","class Solution:
  def checkStrings(self, s1: str, s2: str) -> bool:
    count = [collections.Counter() for _ in range(2)]

    for i, (a, b) in enumerate(zip(s1, s2)):
      count[i % 2][a] += 1
      count[i % 2][b] -= 1

    return (all(freq == 0 for freq in count[0].values()) and
            all(freq == 0 for freq in count[1].values()))"
"2841","class Solution:
  def maxSum(self, nums: list[int], m: int, k: int) -> int:
    ans = 0
    summ = 0
    count = collections.Counter()

    for i, num in enumerate(nums):
      summ += num
      count[num] += 1
      if i >= k:
        numToRemove = nums[i - k]
        summ -= numToRemove
        count[numToRemove] -= 1
        if count[numToRemove] == 0:
          del count[numToRemove]
      if len(count) >= m:
        ans = max(ans, summ)

    return ans"
"2842","class Solution:
  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
    kMod = 1_000_000_007
    count = collections.Counter(s)
    if len(count) < k:
      return 0

    ans = 1
    # freqCount := (f(c), # of chars with f(c))
    freqCount = collections.Counter(count.values())

    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):
      if numOfChars >= k:
        ans *= math.comb(numOfChars, k) * pow(fc, k, kMod)
        return ans % kMod
      ans *= pow(fc, numOfChars, kMod)
      ans %= kMod
      k -= numOfChars"
"2843","class Solution:
  def countSymmetricIntegers(self, low: int, high: int) -> int:
    def isSymmetricInteger(num: int) -> bool:
      if num >= 10 and num <= 99:
        return num // 10 == num % 10
      if num >= 1000 and num <= 9999:
        left = num // 100
        right = num % 100
        return left // 10 + left % 10 == right // 10 + right % 10
      return False

    return sum(isSymmetricInteger(num) for num in range(low, high + 1))"
"2844","class Solution:
  def minimumOperations(self, num: str) -> int:
    n = len(num)
    seenFive = False
    seenZero = False

    for i in range(n - 1, -1, -1):
      if seenZero and num[i] == '0':  # '00'
        return n - i - 2
      if seenZero and num[i] == '5':  # '50'
        return n - i - 2
      if seenFive and num[i] == '2':  # '25'
        return n - i - 2
      if seenFive and num[i] == '7':  # '75'
        return n - i - 2
      seenZero = seenZero or num[i] == '0'
      seenFive = seenFive or num[i] == '5'

    return n - 1 if seenZero else n"
"2845","class Solution:
  def countInterestingSubarrays(
      self,
      nums: list[int],
      modulo: int,
      k: int,
  ) -> int:
    ans = 0
    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo
    prefixCount = collections.Counter({0: 1})

    for num in nums:
      if num % modulo == k:
        prefix = (prefix + 1) % modulo
      ans += prefixCount[(prefix - k + modulo) % modulo]
      prefixCount[prefix] += 1

    return ans"
"2846","class Solution:
  def minOperationsQueries(
      self,
      n: int,
      edges: list[list[int]],
      queries: list[list[int]],
  ) -> list[int]:
    kMax = 26
    m = int(math.log2(n)) + 1
    ans = []
    graph = [[] for _ in range(n)]
    # jump[i][j] := the node you reach after jumping 2^j from i
    jump = [[0] * m for _ in range(n)]
    # count[i][j] := the count of j from root to i, where 1 <= j <= 26
    count = [[] for _ in range(n)]
    # depth[i] := the depth of i
    depth = [0] * n

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    def dfs(u: int, prev: int, d: int):
      if prev != -1:
        jump[u][0] = prev
      depth[u] = d
      for v, w in graph[u]:
        if v == prev:
          continue
        # Inherit the count from the parent.
        count[v] = count[u][:]
        # Add one to this edge.
        count[v][w] += 1
        dfs(v, u, d + 1)

    count[0] = [0] * (kMax + 1)
    dfs(0, -1, 0)

    # Calculate binary lifting.
    for j in range(1, m):
      for i in range(n):
        jump[i][j] = jump[jump[i][j - 1]][j - 1]

    def getLCA(u: int, v: int) -> int:
      """"""Returns the lca(u, v) via Calculate binary lifting.""""""
      # v is always deeper than u.
      if depth[u] > depth[v]:
        return getLCA(v, u)
      # Jump v to the same height of u.
      for j in range(m):
        if depth[v] - depth[u] >> j & 1:
          v = jump[v][j]
      if u == v:
        return u
      # Jump u and v to the node right below the lca.
      for j in range(m - 1, -1, -1):
        if jump[u][j] != jump[v][j]:
          u = jump[u][j]
          v = jump[v][j]
      return jump[v][0]

    for u, v in queries:
      lca = getLCA(u, v)
      # the number of edges between (u, v).
      numEdges = depth[u] + depth[v] - 2 * depth[lca]
      # the maximum frequency of edges between (u, v)
      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]
                    for j in range(1, kMax + 1))
      ans.append(numEdges - maxFreq)

    return ans"
"2847","class Solution:
  def smallestNumber(self, n: int) -> str:
    if n <= 9:
      return str(n)

    ans = []

    for divisor in range(9, 1, -1):
      while n % divisor == 0:
        ans.append(str(divisor))
        n //= divisor

    return '-1' if n > 1 else ''.join(reversed(ans))"
"2848","class Solution:
  def numberOfPoints(self, nums: list[list[int]]) -> int:
    kMax = 100
    ans = 0
    runningSum = 0
    count = [0] * (kMax + 2)

    for start, end in nums:
      count[start] += 1
      count[end + 1] -= 1

    for i in range(1, kMax + 1):
      runningSum += count[i]
      if runningSum > 0:
        ans += 1

    return ans"
"2849","class Solution:
  def isReachableAtTime(
      self,
      sx: int,
      sy: int,
      fx: int,
      fy: int,
      t: int,
  ) -> bool:
    minStep = max(abs(sx - fx), abs(sy - fy))
    return t != 1 if minStep == 0 else minStep <= t"
"285","class Solution:
  def inorderSuccessor(
      self,
      root: TreeNode | None,
      p: TreeNode | None,
  ) -> TreeNode | None:
    if not root:
      return None
    if root.val <= p.val:
      return self.inorderSuccessor(root.right, p)
    return self.inorderSuccessor(root.left, p) or root"
"2850","class Solution:
  def minimumMoves(self, grid: list[list[int]]) -> int:
    if sum(row.count(0) for row in grid) == 0:
      return 0

    ans = math.inf

    for i in range(3):
      for j in range(3):
        if grid[i][j] == 0:
          for x in range(3):
            for y in range(3):
              if grid[x][y] > 1:
                grid[x][y] -= 1
                grid[i][j] += 1
                ans = min(ans, abs(x - i) + abs(y - j) +
                          self.minimumMoves(grid))
                grid[x][y] += 1
                grid[i][j] -= 1

    return ans"
"2851","class Solution:
  # This dynamic programming table dp[k][i] represents the number of ways to
  # rearrange the String s after k steps such that it starts with s[i].
  # A String can be rotated from 1 to n - 1 times. The transition rule is
  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and
  # k = 3, the table looks like this:
  #
  # -----------------------------------------------------------
  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |
  # -----------------------------------------------------------
  # | k = 0 |   1   |   0   |   0   |   0   |        1        |
  # | k = 1 |   0   |   1   |   1   |   1   |        3        |
  # | k = 2 |   3   |   2   |   2   |   2   |        9        |
  # | k = 3 |   6   |   7   |   7   |   7   |       27        |
  # -----------------------------------------------------------
  #
  # By observation, we have
  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n
  #   * dp[k][0] = dp[k][!0] + (-1)^k
  def numberOfWays(self, s: str, t: str, k: int) -> int:
    kMod = 1_000_000_007
    n = len(s)
    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k
    z = self._zFunction(s + t + t)
    # indices in `s` s.t. for each `i` in the returned indices,
    # `s[i..n) + s[0..i) = t`.
    indices = [i - n for i in range(n, n + n) if z[i] >= n]
    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]
    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)
    dp[0] = dp[1] + negOnePowK
    return sum(dp[0] if index == 0 else dp[1] for index in indices) % kMod

  def _zFunction(self, s: str) -> list[int]:
    """"""
    Returns the z array, where z[i] is the length of the longest prefix of
    s[i..n) which is also a prefix of s.

    https://cp-algorithms.com/string/z-function.html#implementation
    """"""
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z"
"2852","class Solution:
  def sumRemoteness(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    n = len(grid)
    summ = sum(max(0, cell) for row in grid for cell in row)
    ans = 0

    def dfs(i: int, j: int) -> tuple[int, int]:
      """"""
      Returns the (count, componentSum) of the connected component that contains
      (x, y).
      """"""
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return (0, 0)
      if grid[i][j] == -1:
        return (0, 0)

      count = 1
      componentSum = grid[i][j]
      grid[i][j] = -1  # Mark as visited.

      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        nextCount, nextComponentSum = dfs(x, y)
        count += nextCount
        componentSum += nextComponentSum

      return (count, componentSum)

    for i in range(n):
      for j in range(n):
        if grid[i][j] > 0:
          count, componentSum = dfs(i, j)
          ans += (summ - componentSum) * count

    return ans"
"2853","SELECT ABS(
    (
      SELECT MAX(salary) AS salary
      FROM Salaries
      WHERE department = 'Engineering'
    ) - (
      SELECT MAX(salary) AS salary
      FROM Salaries
      WHERE department = 'Marketing'
    )
  ) AS salary_difference;"
"2854","WITH
  StepsWithRollingAverage AS (
    SELECT
      user_id,
      steps_date,
      ROUND(
        AVG(steps_count) OVER(
          PARTITION by user_id
          ORDER BY steps_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ),
        2
      ) AS rolling_average,
      LAG(steps_date, 2) OVER(
        PARTITION by user_id
        ORDER BY steps_date
      ) AS two_dates_before
    FROM Steps
  )
SELECT
  user_id,
  steps_date,
  rolling_average
FROM StepsWithRollingAverage
WHERE DATEDIFF(steps_date, two_dates_before) = 2
ORDER BY 1, 2;"
"2855","class Solution:
  def minimumRightShifts(self, nums: list[int]) -> int:
    count = 0

    for i, (a, b) in enumerate(itertools.pairwise(nums)):
      if a > b:
        count += 1
        pivot = i

    if count == 0:
      return 0
    if count > 1 or nums[-1] > nums[0]:
      return -1
    return len(nums) - pivot - 1"
"2856","class Solution:
  def minLengthAfterRemovals(self, nums: list[int]) -> int:
    n = len(nums)
    count = collections.Counter(nums)
    maxFreq = max(count.values())

    # The number with the maximum frequency cancel all the other numbers.
    if maxFreq <= n / 2:
      return n % 2
    # The number with the maximum frequency cancel all the remaining numbers.
    return maxFreq - (n - maxFreq)"
"2857","class Solution:
  def countPairs(self, coordinates: list[list[int]], k: int) -> int:
    ans = 0

    for x in range(k + 1):
      y = k - x
      count = collections.Counter()
      for xi, yi in coordinates:
        ans += count[(xi ^ x, yi ^ y)]
        count[(xi, yi)] += 1

    return ans"
"2858","class Solution:
  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((v, True))  # 1 means (u -> v)
      graph[v].append((u, False))  # 0 means (v <- u)

    seen = {0}

    @functools.lru_cache(None)
    def dp(u: int) -> int:
      """"""
      Returns the minimum number of edge reversals so node u can reach every
      node in its subtree.
      """"""
      res = 0
      for v, isForward in graph[u]:
        if v in seen:
          continue
        seen.add(v)
        res += dp(v) + (0 if isForward else 1)
      return res

    ans = [0] * n
    ans[0] = dp(0)

    def dfs(u: int) -> None:
      for v, isForward in graph[u]:
        if v in seen:
          continue
        seen.add(v)
        ans[v] = ans[u] + (1 if isForward else -1)
        dfs(v)

    seen = {0}
    dfs(0)
    return ans"
"2859","class Solution:
  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:
    return sum(num for i, num in enumerate(nums)
               if i.bit_count() == k)"
"286","class Solution:
  def wallsAndGates(self, rooms: list[list[int]]) -> None:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kInf = 2**31 - 1
    m = len(rooms)
    n = len(rooms[0])
    q = collections.deque((i, j)
                          for i in range(m)
                          for j in range(n)
                          if rooms[i][j] == 0)

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if rooms[x][y] != kInf:
          continue
        rooms[x][y] = rooms[i][j] + 1
        q.append((x, y))"
"2860","class Solution:
  def countWays(self, nums: list[int]) -> int:
    return sum(a < i < b
               for i, (a, b) in  # i := the number of the selected numbers
               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))"
"2861","class Solution:
  def maxNumberOfAlloys(self, n: int, k: int, budget: int,
                        composition: list[list[int]], stock: list[int],
                        costs: list[int]) -> int:
    l = 1
    r = 1_000_000_000

    def isPossible(m: int) -> bool:
      """"""Returns True if it's possible to create `m` alloys by using any machine.""""""
      # Try all the possible machines.
      for machine in composition:
        requiredMoney = 0
        for j in range(n):
          requiredUnits = max(0, machine[j] * m - stock[j])
          requiredMoney += requiredUnits * costs[j]
        if requiredMoney <= budget:
          return True
      return False

    while l < r:
      m = (l + r) // 2
      if isPossible(m):
        l = m + 1
      else:
        r = m

    return l - 1"
"2862","class Solution:
  def maximumSum(self, nums: list[int]) -> int:
    ans = 0

    for oddPower in range(1, len(nums) + 1):
      summ = 0
      for num in range(1, len(nums) + 1):
        if num * num * oddPower > len(nums):
          break
        summ += nums[oddPower * num * num - 1]
      ans = max(ans, summ)

    return ans"
"2863","class Solution:
  def maxSubarrayLength(self, nums: list[int]) -> int:
    ans = 0
    stack = []

    for i in range(len(nums) - 1, -1, -1):
      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.
      # So, no need to append it.
      if not stack or nums[stack[-1]] > nums[i]:
        stack.append(i)

    for i, num in enumerate(nums):
      while stack and num > nums[stack[-1]]:
        ans = max(ans, stack.pop() - i + 1)

    return ans"
"2864","class Solution:
  def maximumOddBinaryNumber(self, s: str) -> str:
    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'"
"2865","class Solution:
  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:
    n = len(maxHeights)
    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i

    def process(stack: list[int], i: int, summ: int) -> int:
      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:
        j = stack.pop()
        # The last abs(j - stack[-1]) heights are maxHeights[j].
        summ -= abs(j - stack[-1]) * maxHeights[j]
      # Put abs(i - stack[-1]) `maxHeight` in heights.
      summ += abs(i - stack[-1]) * maxHeights[i]
      stack.append(i)
      return summ

    stack = [-1]
    summ = 0
    for i in range(len(maxHeights)):
      summ = process(stack, i, summ)
      maxSum[i] = summ

    stack = [n]
    summ = 0
    for i in range(n - 1, -1, -1):
      summ = process(stack, i, summ)
      maxSum[i] += summ - maxHeights[i]

    return max(maxSum)"
"2866","class Solution:
  # Same as 2865. Beautiful Towers I
  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:
    n = len(maxHeights)
    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i

    def process(stack: list[int], i: int, summ: int) -> int:
      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:
        j = stack.pop()
        # The last abs(j - stack[-1]) heights are maxHeights[j].
        summ -= abs(j - stack[-1]) * maxHeights[j]
      # Put abs(i - stack[-1]) `maxHeight` in heights.
      summ += abs(i - stack[-1]) * maxHeights[i]
      stack.append(i)
      return summ

    stack = [-1]
    summ = 0
    for i in range(len(maxHeights)):
      summ = process(stack, i, summ)
      maxSum[i] = summ

    stack = [n]
    summ = 0
    for i in range(n - 1, -1, -1):
      summ = process(stack, i, summ)
      maxSum[i] += summ - maxHeights[i]

    return max(maxSum)"
"2867","class Solution:
  def countPaths(self, n: int, edges: list[list[int]]) -> int:
    ans = 0
    isPrime = self._sieveEratosthenes(n + 1)
    graph = [[] for _ in range(n + 1)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    def dfs(u: int, prev: int) -> tuple[int, int]:
      nonlocal ans
      countZeroPrimePath = int(not isPrime[u])
      countOnePrimePath = int(isPrime[u])

      for v in graph[u]:
        if v == prev:
          continue
        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)
        ans += (countZeroPrimePath * countOnePrimeChildPath +
                countOnePrimePath * countZeroPrimeChildPath)
        if isPrime[u]:
          countOnePrimePath += countZeroPrimeChildPath
        else:
          countZeroPrimePath += countZeroPrimeChildPath
          countOnePrimePath += countOnePrimeChildPath

      return countZeroPrimePath, countOnePrimePath

    dfs(1, -1)
    return ans

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"2868","class Solution:
  def canAliceWin(self, a: list[str], b: list[str]) -> bool:
    # words[0][i] := the biggest word starting with ('a' + i) for Alice
    # words[1][i] := the biggest word starting with ('a' + i) for Bob
    words = [[''] * 26 for _ in range(2)]

    # For each letter, only the biggest word is useful.
    for word in a:
      words[0][ord(word[0]) - ord('a')] = word

    for word in b:
      words[1][ord(word[0]) - ord('a')] = word

    # Find Alice's smallest word.
    i = 0
    while not words[0][i]:
      i += 1

    # 0 := Alice, 1 := Bob
    # Start with Alice, so it's Bob's turn now.
    turn = 1

    # Iterate through each letter until we find a winner.
    while True:
      # If the current player has a word that having the letter that is greater
      # than the opponent's word, choose it.
      if words[turn][i] and words[turn][i] > words[1 - turn][i]:
        # Choose the current words[turn][i].
        pass
      elif words[turn][i + 1]:
        # Choose the next words[turn][i + 1].
        i += 1
      else:
        # Game over. If it's Bob's turn, Alice wins, and vice versa.
        return turn == 1
      turn = 1 - turn"
"2869","class Solution:
  def minOperations(self, nums: list[int], k: int) -> int:
    seen = set()

    for i, num in enumerate(reversed(nums)):
      if num > k:
        continue
      seen.add(num)
      if len(seen) == k:
        return i + 1"
"287","class Solution:
  def findDuplicate(self, nums: list[int]) -> int:
    slow = nums[nums[0]]
    fast = nums[nums[nums[0]]]

    while slow != fast:
      slow = nums[slow]
      fast = nums[nums[fast]]

    slow = nums[0]

    while slow != fast:
      slow = nums[slow]
      fast = nums[fast]

    return slow"
"2870","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    count = collections.Counter(nums)
    if 1 in count.values():
      return -1
    return sum((freq + 2) // 3 for freq in count.values())"
"2871","class Solution:
  def maxSubarrays(self, nums: list[int]) -> int:
    ans = 0
    score = 0

    for num in nums:
      score = num if score == 0 else score & num
      if score == 0:
        ans += 1

    return max(1, ans)"
"2872","class Solution:
  def maxKDivisibleComponents(
      self,
      n: int,
      edges: list[list[int]],
      values: list[int],
      k: int,
  ) -> int:
    ans = 0
    graph = [[] for _ in range(n)]

    def dfs(u: int, prev: int) -> int:
      nonlocal ans
      treeSum = values[u]

      for v in graph[u]:
        if v != prev:
          treeSum += dfs(v, u)

      if treeSum % k == 0:
        ans += 1
      return treeSum

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    dfs(0, -1)
    return ans"
"2873","class Solution:
  def maximumTripletValue(self, nums: list[int]) -> int:
    ans = 0
    maxDiff = 0  # max(nums[i] - nums[j])
    maxNum = 0   # max(nums[i])

    for num in nums:
      ans = max(ans, maxDiff * num)         # num := nums[k]
      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]
      maxNum = max(maxNum, num)             # num := nums[i]

    return ans"
"2874","class Solution:
  # Same as 2873. Maximum Value of an Ordered Triplet I
  def maximumTripletValue(self, nums: list[int]) -> int:
    ans = 0
    maxDiff = 0  # max(nums[i] - nums[j])
    maxNum = 0   # max(nums[i])

    for num in nums:
      ans = max(ans, maxDiff * num)         # num := nums[k]
      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]
      maxNum = max(maxNum, num)             # num := nums[i]

    return ans"
"2875","class Solution:
  def minSizeSubarray(self, nums: list[int], target: int) -> int:
    summ = sum(nums)
    n = len(nums)
    remainingTarget = target % summ
    repeatLength = (target // summ) * n
    if remainingTarget == 0:
      return repeatLength

    suffixPlusPrefixLength = n
    prefix = 0
    prefixToIndex = {0: -1}

    for i in range(2 * n):
      prefix += nums[i % n]
      if prefix - remainingTarget in prefixToIndex:
        suffixPlusPrefixLength = min(
            suffixPlusPrefixLength,
            i - prefixToIndex[prefix - remainingTarget])
      prefixToIndex[prefix] = i

    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength"
"2876","class Solution:
  def countVisitedNodes(self, edges: list[int]) -> list[int]:
    n = len(edges)
    ans = [0] * n
    inDegrees = [0] * n
    seen = [False] * n
    stack = []

    for v in edges:
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    # Push non-cyclic nodes to stack.
    while q:
      u = q.popleft()
      inDegrees[edges[u]] -= 1
      if inDegrees[edges[u]] == 0:
        q.append(edges[u])
      stack.append(u)
      seen[u] = True

    # Fill the length of cyclic nodes.
    for i in range(n):
      if not seen[i]:
        self._fillCycle(edges, i, seen, ans)

    # Fill the length of non-cyclic nodes.
    while stack:
      u = stack.pop()
      ans[u] = ans[edges[u]] + 1

    return ans

  def _fillCycle(
      self,
      edges: list[int],
      start: int,
      seen: list[bool],
      ans: list[int],
  ) -> None:
    cycleLength = 0
    u = start
    while not seen[u]:
      cycleLength += 1
      seen[u] = True
      u = edges[u]
    ans[start] = cycleLength
    u = edges[start]
    while u != start:
      ans[u] = cycleLength
      u = edges[u]"
"2877","import pandas as pd


def createDataframe(student_data: list[list[int]]) -> pd.DataFrame:
  return pd.DataFrame(student_data, columns=['student_id', 'age'])"
"2878","import pandas as pd


def getDataframeSize(players: pd.DataFrame) -> list[int]:
  return [*players.shape]"
"2879","import pandas as pd


def selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:
  return employees.head(3)"
"288","class ValidWordAbbr:
  def __init__(self, dictionary: list[str]):
    self.dict = set(dictionary)
    # T := unique, F := not unique
    self.abbrUnique = {}

    for word in self.dict:
      abbr = self._getAbbr(word)
      self.abbrUnique[abbr] = abbr not in self.abbrUnique

  def isUnique(self, word: str) -> bool:
    abbr = self._getAbbr(word)
    return abbr not in self.abbrUnique or self.abbrUnique[abbr] and word in self.dict

  def _getAbbr(self, s: str) -> str:
    n = len(s)
    if n <= 2:
      return s
    return s[0] + str(n - 2) + s[-1]"
"2880","import pandas as pd


def selectData(students: pd.DataFrame) -> pd.DataFrame:
  return students.loc[students['student_id'] == 101, ['name', 'age']]"
"2881","import pandas as pd


def createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['bonus'] = employees['salary'] * 2
  return employees"
"2882","import pandas as pd


def dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:
  customers.drop_duplicates(subset='email', keep='first', inplace=True)
  return customers"
"2883","import pandas as pd


def dropMissingData(students: pd.DataFrame) -> pd.DataFrame:
  students.dropna(subset=['name'], inplace=True)
  return students"
"2884","import pandas as pd


def modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['salary'] = employees['salary'] * 2
  return employees"
"2885","import pandas as pd


def renameColumns(students: pd.DataFrame) -> pd.DataFrame:
  return students.rename(
      columns={
          ""id"": ""student_id"",
          ""first"": ""first_name"",
          ""last"": ""last_name"",
          ""age"": ""age_in_years"",
      }
  )"
"2886","import pandas as pd


def changeDatatype(students: pd.DataFrame) -> pd.DataFrame:
  return students.astype({'grade': int})"
"2887","import pandas as pd


def fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:
  products['quantity'].fillna(0, inplace=True)
  return products"
"2888","import pandas as pd


def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:
  return pd.concat([df1, df2], axis=0)"
"2889","import pandas as pd


def pivotTable(weather: pd.DataFrame) -> pd.DataFrame:
  return weather.pivot_table(
      index='month',
      columns='city',
      values='temperature',
      aggfunc='max',
  )"
"289","class Solution:
  def gameOfLife(self, board: list[list[int]]) -> None:
    m = len(board)
    n = len(board[0])

    for i in range(m):
      for j in range(n):
        ones = 0
        for x in range(max(0, i - 1), min(m, i + 2)):
          for y in range(max(0, j - 1), min(n, j + 2)):
            ones += board[x][y] & 1
        # Any live cell with two or three live neighbors lives on to the next
        # generation.
        if board[i][j] == 1 and (ones == 3 or ones == 4):
          board[i][j] |= 0b10
        # Any dead cell with exactly three live neighbors becomes a live cell,
        # as if by reproduction.
        if board[i][j] == 0 and ones == 3:
          board[i][j] |= 0b10

    for i in range(m):
      for j in range(n):
        board[i][j] >>= 1"
"2890","import pandas as pd


def meltTable(report: pd.DataFrame) -> pd.DataFrame:
  return pd.melt(
      report,
      id_vars=['product'],
      var_name='quarter',
      value_name='sales',
  )"
"2891","import pandas as pd


def findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:
  return animals[animals['weight'] > 100].sort_values(
      by='weight',
      ascending=False
  )[['name']]"
"2892","class Solution:
  def minArrayLength(self, nums: list[int], k: int) -> int:
    count = 0
    prod = -1

    for num in nums:
      if num == 0:
        return 1
      if prod != -1 and prod * num <= k:
        prod *= num
      else:
        prod = num
        count += 1

    return count"
"2893","SELECT
  CEIL(minute / 6) AS interval_no,
  SUM(order_count) AS total_orders
FROM Orders
GROUP BY 1
ORDER BY 1;"
"2894","class Solution:
  def differenceOfSums(self, n: int, m: int) -> int:
    summ = (1 + n) * n // 2
    num2 = self._getDivisibleSum(n, m)
    num1 = summ - num2
    return num1 - num2

  def _getDivisibleSum(self, n: int, m: int) -> int:
    """"""Returns the sum of all the integers in [1, n] that are divisible by m.""""""
    last = n // m * m
    if last == 0:
      return 0
    first = m
    count = (last - first) // m + 1
    return (first + last) * count // 2"
"2895","class Solution:
  def minProcessingTime(
      self,
      processorTime: list[int],
      tasks: list[int],
  ) -> int:
    return max(time + task
               for (time, task) in zip(
                   sorted(processorTime),
                   sorted(tasks)[:: -4]))"
"2896","class Solution:
  def minOperations(self, s1: str, s2: str, x: int) -> int:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    if not diffIndices:
      return 0
    # It's impossible to make two strings equal if there are odd number of
    # differences.
    if len(diffIndices) & 1:
      return -1

    @functools.lru_cache(None)
    def dp(i: int) -> int:
      """"""Returns the minimum cost to correct diffIndices[i..n).""""""
      if i == len(diffIndices):
        return 0
      if i == len(diffIndices) - 1:
        return x / 2
      return min(dp(i + 1) + x / 2,
                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])

    return int(dp(0))"
"2897","class Solution:
  def maxSum(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    kMaxBit = 30
    ans = 0
    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit
    # should be moved to
    minIndices = [0] * kMaxBit
    optimalNums = [0] * len(nums)

    for num in nums:
      for i in range(kMaxBit):
        if num >> i & 1:
          optimalNums[minIndices[i]] |= 1 << i
          minIndices[i] += 1

    for i in range(k):
      ans += optimalNums[i]**2
      ans %= kMod

    return ans"
"2898","class Solution:
  def maxScore(self, prices: list[int]) -> int:
    groupIdToSum = collections.defaultdict(int)

    for i, price in enumerate(prices):
      groupIdToSum[price - i] += price

    return max(groupIdToSum.values())"
"2899","class Solution:
  def lastVisitedIntegers(self, words: list[str]) -> list[int]:
    ans = []
    nums = []
    k = 0

    for word in words:
      if word == 'prev':
        k += 1
        ans.append(-1 if k > len(nums) else nums[-k])
      else:
        k = 0
        nums.append(int(word))

    return ans"
"29","class Solution:
  def divide(self, dividend: int, divisor: int) -> int:
    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.
    if dividend == -2**31 and divisor == -1:
      return 2**31 - 1

    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1
    ans = 0
    dvd = abs(dividend)
    dvs = abs(divisor)

    while dvd >= dvs:
      k = 1
      while k * 2 * dvs <= dvd:
        k <<= 1
      dvd -= k * dvs
      ans += k

    return sign * ans"
"290","class Solution:
  def wordPattern(self, pattern: str, str: str) -> bool:
    t = str.split()
    return [*map(pattern.index, pattern)] == [*map(t.index, t)]"
"2900","class Solution:
  def getWordsInLongestSubsequence(
      self,
      n: int,
      words: list[str],
      groups: list[int],
  ) -> list[str]:
    ans = []
    groupId = -1

    for word, group in zip(words, groups):
      if group != groupId:
        groupId = group
        ans.append(word)

    return ans"
"2901","class Solution:
  def getWordsInLongestSubsequence(
      self,
      n: int,
      words: list[str],
      groups: list[int],
  ) -> list[str]:
    ans = []
    # dp[i] := the length of the longest subsequence ending in `words[i]`
    dp = [1] * n
    # prev[i] := the best index of words[i]
    prev = [-1] * n

    for i in range(1, n):
      for j in range(i):
        if groups[i] == groups[j]:
          continue
        if len(words[i]) != len(words[j]):
          continue
        if sum(a != b for a, b in zip(words[i], words[j])) != 1:
          continue
        if dp[i] < dp[j] + 1:
          dp[i] = dp[j] + 1
          prev[i] = j

    # Find the last index of the subsequence.
    index = dp.index(max(dp))
    while index != -1:
      ans.append(words[index])
      index = prev[index]

    return ans[::-1]"
"2902","class Solution:
  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of submultisets of `nums` with sum i
    dp = [1] + [0] * r
    count = collections.Counter(nums)
    zeros = count.pop(0, 0)

    for num, freq in count.items():
      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...
      stride = dp.copy()
      for i in range(num, r + 1):
        stride[i] += stride[i - num]
      for i in range(r, 0, -1):
        if i >= num * (freq + 1):
          # dp[i] + dp[i - num] + dp[i - freq * num]
          dp[i] = stride[i] - stride[i - num * (freq + 1)]
        else:
          dp[i] = stride[i]

    return (zeros + 1) * sum(dp[l:r + 1]) % kMod"
"2903","class Solution:
  def findIndices(
      self,
      nums: list[int],
      indexDifference: int,
      valueDifference: int,
  ) -> list[int]:
    # nums[minIndex] := the minimum number with enough index different from the
    # current number
    minIndex = 0
    # nums[maxIndex] := the maximum number with enough index different from the
    # current number
    maxIndex = 0

    for i in range(indexDifference, len(nums)):
      if nums[i - indexDifference] < nums[minIndex]:
        minIndex = i - indexDifference
      if nums[i - indexDifference] > nums[maxIndex]:
        maxIndex = i - indexDifference
      if nums[i] - nums[minIndex] >= valueDifference:
        return [i, minIndex]
      if nums[maxIndex] - nums[i] >= valueDifference:
        return [i, maxIndex]

    return [-1, -1]"
"2904","class Solution:
  # Same as 76. Minimum Window Substring
  def shortestBeautifulSubstring(self, s: str, k: int) -> str:
    bestLeft = -1
    minLength = len(s) + 1
    ones = 0

    l = 0
    for r, c in enumerate(s):
      if c == '1':
        ones += 1
      while ones == k:
        if r - l + 1 < minLength:
          bestLeft = l
          minLength = r - l + 1
        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:
          bestLeft = l
        if s[l] == '1':
          ones -= 1
        l += 1

    return """" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]"
"2905","class Solution:
  def findIndices(
      self,
      nums: list[int],
      indexDifference: int,
      valueDifference: int,
  ) -> list[int]:
    # nums[minIndex] := the minimum number with enough index different from the current number
    minIndex = 0
    # nums[maxIndex] := the maximum number with enough index different from the current number
    maxIndex = 0

    for i in range(indexDifference, len(nums)):
      if nums[i - indexDifference] < nums[minIndex]:
        minIndex = i - indexDifference
      if nums[i - indexDifference] > nums[maxIndex]:
        maxIndex = i - indexDifference
      if nums[i] - nums[minIndex] >= valueDifference:
        return [i, minIndex]
      if nums[maxIndex] - nums[i] >= valueDifference:
        return [i, maxIndex]

    return [-1, -1]"
"2906","class Solution:
  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:
    kMod = 12345
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    prefix = [1]
    suffix = 1

    for row in grid:
      for num in row:
        prefix.append(prefix[-1] * num % kMod)

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        ans[i][j] = prefix[i * n + j] * suffix % kMod
        suffix = suffix * grid[i][j] % kMod

    return ans"
"2907","class FenwickTree:
  def __init__(self, n: int):
    self.vals = [0] * (n + 1)

  def maximize(self, i: int, val: int) -> None:
    while i < len(self.vals):
      self.vals[i] = max(self.vals[i], val)
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    res = 0
    while i > 0:
      res = max(res, self.vals[i])
      i -= FenwickTree.lowbit(i)
    return res

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def maxProfit(self, prices: list[int], profits: list[int]) -> int:
    ans = -1
    maxPrice = max(prices)
    maxProfitTree1 = FenwickTree(maxPrice)
    maxProfitTree2 = FenwickTree(maxPrice)

    for price, profit in zip(prices, profits):
      # max(proftis[i])
      maxProfit1 = maxProfitTree1.get(price - 1)
      # max(proftis[i]) + max(profits[j])
      maxProfit2 = maxProfitTree2.get(price - 1)
      maxProfitTree1.maximize(price, profit)
      if maxProfit1 > 0:
        maxProfitTree2.maximize(price, profit + maxProfit1)
      if maxProfit2 > 0:
        ans = max(ans, profit + maxProfit2)

    return ans"
"2908","class Solution:
  # Same as 2908. Minimum Sum of Mountain Triplets I
  def minimumSum(self, nums: list[int]) -> int:
    ans = math.inf
    minPrefix = list(itertools.accumulate(nums, min))
    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]

    for i, num in enumerate(nums):
      if num > minPrefix[i] and num > minSuffix[i]:
        ans = min(ans, num + minPrefix[i] + minSuffix[i])

    return -1 if ans == math.inf else ans"
"2909","class Solution:
  # Same as 2908. Minimum Sum of Mountain Triplets I
  def minimumSum(self, nums: list[int]) -> int:
    ans = math.inf
    minPrefix = list(itertools.accumulate(nums, min))
    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]

    for i, num in enumerate(nums):
      if num > minPrefix[i] and num > minSuffix[i]:
        ans = min(ans, num + minPrefix[i] + minSuffix[i])

    return -1 if ans == math.inf else ans"
"291","class Solution:
  def wordPatternMatch(self, pattern: str, s: str) -> bool:
    def isMatch(
            i: int, j: int, charToString: dict[str, str],
            seen: set[str]) -> bool:
      if i == len(pattern) and j == len(s):
        return True
      if i == len(pattern) or j == len(s):
        return False

      c = pattern[i]

      if c in charToString:
        t = charToString[c]
        # See if we can match t with s[j..n).
        if t not in s[j:]:
          return False

        # If there's a match, continue to match the rest.
        return isMatch(i + 1, j + len(t), charToString, seen)

      for k in range(j, len(s)):
        t = s[j:k + 1]

        # This string is mapped by another character.
        if t in seen:
          continue

        charToString[c] = t
        seen.add(t)

        if isMatch(i + 1, k + 1, charToString, seen):
          return True

        # Backtrack.
        del charToString[c]
        seen.remove(t)

      return False

    return isMatch(0, 0, {}, set())"
"2910","class Solution:
  def minGroupsForValidAssignment(self, nums: list[int]) -> int:
    count = collections.Counter(nums)
    minFreq = min(count.values())

    for groupSize in range(minFreq, 0, -1):
      numGroups = self.getNumGroups(count, groupSize)
      if numGroups > 0:
        return numGroups

    raise ValueError(""Invalid argument"")

  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:
    """"""Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.""""""
    numGroups = 0
    for freq in count.values():
      a = freq // (groupSize + 1)
      b = freq % (groupSize + 1)
      if b == 0:
        # Assign 1 number from `groupSize - b` out of `a` groups to this group,
        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`
        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have
        # `a + 1` groups.
        numGroups += a
      elif groupSize - b <= a:
        numGroups += a + 1
      else:
        return 0
    return numGroups"
"2911","class Solution:
  def minimumChanges(self, s: str, k: int) -> int:
    n = len(s)
    # factors[i] := factors of i
    factors = self._getFactors(n)
    # cost[i][j] := changes to make s[i..j] a semi-palindrome
    cost = self._getCost(s, n, factors)
    # dp[i][j] := the minimum changes to split s[i:] into j valid parts
    dp = [[n] * (k + 1) for _ in range(n + 1)]

    dp[n][0] = 0

    for i in range(n - 1, -1, -1):
      for j in range(1, k + 1):
        for l in range(i + 1, n):
          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])

    return dp[0][k]

  def _getFactors(self, n: int) -> list[list[int]]:
    factors = [[1] for _ in range(n + 1)]
    for d in range(2, n):
      for i in range(d * 2, n + 1, d):
        factors[i].append(d)
    return factors

  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:
    cost = [[0] * n for _ in range(n)]
    for i in range(n):
      for j in range(i + 1, n):
        length = j - i + 1
        minCost = length
        for d in factors[length]:
          minCost = min(minCost, self._getCostD(s, i, j, d))
        cost[i][j] = minCost
    return cost

  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:
    """"""Returns the cost to make s[i..j] a semi-palindrome of `d`.""""""
    cost = 0
    for offset in range(d):
      l = i + offset
      r = j - d + 1 + offset
      while l < r:
        if s[l] != s[r]:
          cost += 1
        l += d
        r -= d
    return cost"
"2912","class Solution:
  def numberOfWays(
      self,
      n: int,
      m: int,
      k: int,
      source: list[int],
      dest: list[int],
  ) -> int:
    kMod = 1_000_000_007
    # the number of ways of `source` to `dest` using steps so far
    ans = int(source == dest)
    # the number of ways of `source` to dest's row using steps so far
    row = int(source[0] == dest[0] and source[1] != dest[1])
    # the number of ways of `source` to dest's col using steps so far
    col = int(source[0] != dest[0] and source[1] == dest[1])
    # the number of ways of `source` to others using steps so far
    others = int(source[0] != dest[0] and source[1] != dest[1])

    for _ in range(k):
      nextAns = (row + col) % kMod
      nextRow = (ans * (m - 1) +  # -self
                 row * (m - 2) +  # -self, -center
                 others) % kMod
      nextCol = (ans * (n - 1) +  # -self
                 col * (n - 2) +  # -self, -center
                 others) % kMod
      nextOthers = (row * (n - 1) +  # -self
                    col * (m - 1) +  # -self
                    others * (m + n - 1 - 3)) % kMod  # -self, -row, -col
      ans = nextAns
      row = nextRow
      col = nextCol
      others = nextOthers

    return ans"
"2913","class SegmentTree {
 public:
  SegmentTree(int n, int kMod)
      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}

  void updateRange(int l, int r) {
    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);
  }

  void propagate(int i, int l, int r) {
    const int gap = r - l + 1;
    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]
    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3
    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;
    squaredSums[i] %= kMod;
    sums[i] += lazy[i] * gap;
    sums[i] %= kMod;
    if (l < r) {
      lazy[i * 2 + 1] += lazy[i];
      lazy[i * 2 + 2] += lazy[i];
    }
    lazy[i] = 0;
  }

  int getTreeSquaredSums() {
    return squaredSums[0];
  }

 private:
  const int kMod;
  const int n;
  vector<long> lazy;
  vector<long> sums;
  vector<long> squaredSums;

  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i] > 0)
      propagate(i, start, end);
    if (end < l || start > r)
      return;
    if (start >= l && end <= r) {
      lazy[i] = 1;
      propagate(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;
    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;
  }
};

class Solution {
 public:
  int sumCounts(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    unordered_map<int, int> lastSeen;
    SegmentTree tree(n, kMod);

    for (int r = 0; r < n; ++r) {
      const int l = lastSeen.contains(nums[r]) ? lastSeen[nums[r]] + 1 : 0;
      tree.updateRange(l, r);
      lastSeen[nums[r]] = r;
      ans = (ans + tree.getTreeSquaredSums()) % kMod;
    }

    return ans;
  }
};"
"2914","class Solution:
  def minChanges(self, s: str) -> int:
    return sum(a != b for a, b in zip(s[::2], s[1::2]))"
"2915","class Solution:
  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:
    # dp[i] := the maximum length of any subsequence of numbers so far that
    # sum to j
    dp = [0] * (target + 1)

    for num in nums:
      for i in range(target, num - 1, -1):
        if i == num or dp[i - num] > 0:
          dp[i] = max(dp[i], 1 + dp[i - num])

    return dp[target] if dp[target] > 0 else -1"
"2916","class SegmentTree {
 public:
  SegmentTree(int n, int kMod)
      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}

  void updateRange(int l, int r) {
    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);
  }

  void propagate(int i, int l, int r) {
    const int gap = r - l + 1;
    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]
    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3
    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;
    squaredSums[i] %= kMod;
    sums[i] += lazy[i] * gap;
    sums[i] %= kMod;
    if (l < r) {
      lazy[i * 2 + 1] += lazy[i];
      lazy[i * 2 + 2] += lazy[i];
    }
    lazy[i] = 0;
  }

  int getTreeSquaredSums() {
    return squaredSums[0];
  }

 private:
  const int kMod;
  const int n;
  vector<long> lazy;
  vector<long> sums;
  vector<long> squaredSums;

  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i] > 0)
      propagate(i, start, end);
    if (end < l || start > r)
      return;
    if (start >= l && end <= r) {
      lazy[i] = 1;
      propagate(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;
    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;
  }
};

class Solution {
 public:
  int sumCounts(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    unordered_map<int, int> lastSeen;
    SegmentTree tree(n, kMod);

    for (int r = 0; r < n; ++r) {
      const int l = lastSeen.contains(nums[r]) ? lastSeen[nums[r]] + 1 : 0;
      tree.updateRange(l, r);
      lastSeen[nums[r]] = r;
      ans = (ans + tree.getTreeSquaredSums()) % kMod;
    }

    return ans;
  }
};"
"2917","class Solution:
  def findKOr(self, nums: list[int], k: int) -> int:
    kMaxBit = 30
    return sum(2**i
               for i in range(kMaxBit + 1)
               if sum(num >> i & 1 for num in nums) >= k)"
"2918","class Solution:
  def minSum(self, nums1: list[int], nums2: list[int]) -> int:
    sum1 = sum(nums1)
    sum2 = sum(nums2)
    zero1 = nums1.count(0)
    zero2 = nums2.count(0)
    if zero1 == 0 and sum1 < sum2 + zero2:
      return -1
    if zero2 == 0 and sum2 < sum1 + zero1:
      return -1
    return max(sum1 + zero1, sum2 + zero2)"
"2919","class Solution:
  def minIncrementOperations(self, nums: list[int], k: int) -> int:
    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)
    prev3 = 0
    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)
    prev2 = 0
    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)
    prev1 = 0

    for num in nums:
      dp = min(prev1, prev2, prev3) + max(0, k - num)
      prev3 = prev2
      prev2 = prev1
      prev1 = dp

    return min(prev1, prev2, prev3)"
"292","class Solution:
  def canWinNim(self, n: int) -> bool:
    return n % 4 != 0"
"2920","class Solution:
  def maximumPoints(
      self,
      edges: list[list[int]],
      coins: list[int],
      k: int,
  ) -> int:
    kMaxCoin = 10000
    kMaxHalved = int(kMaxCoin).bit_length()
    n = len(coins)
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    @functools.lru_cache(None)
    def dfs(u: int, prev: int, halved: int) -> int:
      # All the children will be 0, so no need to explore.
      if halved > kMaxHalved:
        return 0

      val = coins[u] // (1 << halved)
      takeAll = val - k
      takeHalf = math.floor(val / 2)

      for v in graph[u]:
        if v == prev:
          continue
        takeAll += dfs(v, u, halved)
        takeHalf += dfs(v, u, halved + 1)

      return max(takeAll, takeHalf)

    return dfs(0, -1, 0)"
"2921","class FenwickTree:
  def __init__(self, n: int):
    self.vals = [0] * (n + 1)

  def maximize(self, i: int, val: int) -> None:
    while i < len(self.vals):
      self.vals[i] = max(self.vals[i], val)
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    res = 0
    while i > 0:
      res = max(res, self.vals[i])
      i -= FenwickTree.lowbit(i)
    return res

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I
  def maxProfit(self, prices: list[int], profits: list[int]) -> int:
    ans = -1
    maxPrice = max(prices)
    maxProfitTree1 = FenwickTree(maxPrice)
    maxProfitTree2 = FenwickTree(maxPrice)

    for price, profit in zip(prices, profits):
      # max(proftis[i])
      maxProfit1 = maxProfitTree1.get(price - 1)
      # max(proftis[i]) + max(profits[j])
      maxProfit2 = maxProfitTree2.get(price - 1)
      maxProfitTree1.maximize(price, profit)
      if maxProfit1 > 0:
        maxProfitTree2.maximize(price, profit + maxProfit1)
      if maxProfit2 > 0:
        ans = max(ans, profit + maxProfit2)

    return ans"
"2922","WITH
  Sellers AS(
    SELECT
      Users.seller_id,
      COUNT(DISTINCT Orders.item_id) AS num_items
    FROM Users
    INNER JOIN Orders
      USING (seller_id)
    INNER JOIN Items
      USING (item_id)
    WHERE Items.item_brand != Users.favorite_brand
    GROUP BY 1
  ),
  RankedSellers AS (
    SELECT
      seller_id,
      num_items,
      RANK() OVER(ORDER BY num_items DESC) AS `rank`
    FROM Sellers
  )
SELECT seller_id, num_items
FROM RankedSellers
WHERE `rank` = 1;"
"2923","class Solution:
  def findChampion(self, grid: list[list[int]]) -> int:
    return max(range(len(grid)), key=lambda x: sum(grid[x]))"
"2924","class Solution:
  def findChampion(self, n: int, edges: list[list[int]]) -> int:
    inDegrees = [0] * n

    for _, v in edges:
      inDegrees[v] += 1

    return (-1 if inDegrees.count(0) > 1
            else inDegrees.index(0))"
"2925","class Solution:
  def maximumScoreAfterOperations(
      self,
      edges: list[list[int]],
      values: list[int],
  ) -> int:
    tree = [[] for _ in values]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> None:
      if u > 0 and len(tree[u]) == 1:
        return values[u]
      childrenSum = sum(dfs(v, u)
                        for v in tree[u]
                        if v != prev)
      return min(childrenSum, values[u])

    return sum(values) - dfs(0, -1)"
"2926","class FenwickTree:
  def __init__(self, n: int):
    self.vals = [0] * (n + 1)

  def maximize(self, i: int, val: int) -> None:
    """"""Updates the maximum sum of subsequence ending in (i - 1) with `val`.""""""
    while i < len(self.vals):
      self.vals[i] = max(self.vals[i], val)
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    """"""Returns the maximum sum of subsequence ending in (i - 1).""""""
    res = 0
    while i > 0:
      res = max(res, self.vals[i])
      i -= FenwickTree.lowbit(i)
    return res

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:
    # Let's define maxSum[i] := subsequence with the maximum sum ending in i
    # By observation:
    #    nums[i] - nums[j] >= i - j
    # => nums[i] - i >= nums[j] - j
    # So, if nums[i] - i >= nums[j] - j, where i > j,
    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])
    ans = -math.inf
    tree = FenwickTree(len(nums))

    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):
      subseqSum = tree.get(i) + nums[i]
      tree.maximize(i + 1, subseqSum)
      ans = max(ans, subseqSum)

    return ans"
"2927","class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """"""Returns the number of ways to distribute n candies to 3 children.""""""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return (ways(n)
            - 3 * oneChildExceedsLimit
            + 3 * twoChildrenExceedLimit
            - threeChildrenExceedLimit)"
"2928","class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """"""Returns the number of ways to distribute n candies to 3 children.""""""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return (ways(n)
            - 3 * oneChildExceedsLimit
            + 3 * twoChildrenExceedLimit
            - threeChildrenExceedLimit)"
"2929","class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """"""Returns the number of ways to distribute n candies to 3 children.""""""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return (ways(n)
            - 3 * oneChildExceedsLimit
            + 3 * twoChildrenExceedLimit
            - threeChildrenExceedLimit)"
"293","class Solution:
  def generatePossibleNextMoves(self, currentState: str) -> list[str]:
    return [currentState[:i] + '--' + currentState[i + 2:]
            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))
            if a == '+' and b == '+']"
"2930","class Solution:
  def stringCount(self, n: int) -> int:
    # There're three invalid conditions:
    #   a. count('l') == 0
    #   b. count('e') < 2
    #   c. count('t') == 0
    #
    # By Principle of Inclusion-Exclusion (PIE):
    #   ans = allCount - a - b - c + ab + ac + bc - abc
    kMod = 1_000_000_007
    allCount = pow(26, n, kMod)
    a = pow(25, n, kMod)
    b = pow(25, n, kMod)
    c = pow(25, n, kMod) + n * pow(25, n - 1, kMod)
    ab = pow(24, n, kMod) + n * pow(24, n - 1, kMod)
    ac = pow(24, n, kMod)
    bc = pow(24, n, kMod) + n * pow(24, n - 1, kMod)
    abc = pow(23, n, kMod) + n * pow(23, n - 1, kMod)
    return (allCount - a - b - c + ab + ac + bc - abc) % kMod"
"2931","class Solution:
  def maxSpending(self, values: list[list[int]]) -> int:
    items = sorted(item for shop in values for item in shop)
    return sum(item * d for d, item in enumerate(items, 1))"
"2932","class TrieNode:
  def __init__(self):
    self.children: list[TrieNode | None] = [None] * 2
    self.mn = math.inf
    self.mx = -math.inf


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]
      node.mn = min(node.mn, num)
      node.mx = max(node.mx, num)

  def getMaxXor(self, x: int) -> int:
    """"""Returns max(x ^ y) where |x - y| <= min(x, y).

    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.
    So, y <= 2 * x.
    """"""
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = x >> i & 1
      toggleBit = bit ^ 1
      # If `node.children[toggleBit].mx > x`, it means there's a number in the
      # node that satisfies the condition to ensure that x <= y among x and y.
      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in
      # the node that satisfies the condition for a valid y.
      if (node.children[toggleBit] and
          node.children[toggleBit].mx > x and
              node.children[toggleBit].mn <= 2 * x):
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:  # There's nothing in the Bit Trie.
        return 0
    return maxXor


class Solution:
  # Similar to 421. Maximum XOR of Two Numbers in an Array
  def maximumStrongPairXor(self, nums: list[int]) -> int:
    maxNum = max(nums)
    maxBit = int(math.log2(maxNum))
    bitTrie = BitTrie(maxBit)

    for num in nums:
      bitTrie.insert(num)

    return max(bitTrie.getMaxXor(num) for num in nums)"
"2933","class Solution:
  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:
    ans = set()

    access_times.sort()

    for i in range(len(access_times) - 2):
      name = access_times[i][0]
      if name in ans:
        continue
      if name != access_times[i + 2][0]:
        continue
      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:
        ans.add(name)

    return list(ans)"
"2934","class Solution:
  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:
    n = len(nums1)
    mn = min(nums1[-1], nums2[-1])
    mx = max(nums1[-1], nums2[-1])
    # the number of the minimum operations, where nums1[n - 1] is not swapped
    # with nums2[n - 1]
    dp1 = 0
    # the number of the minimum operations, where nums1[n - 1] is swapped with
    # nums2[n - 1]
    dp2 = 0

    for a, b in zip(nums1, nums2):
      if min(a, b) > mn:
        return -1
      if max(a, b) > mx:
        return -1
      if a > nums1[-1] or b > nums2[-1]:
        dp1 += 1
      if a > nums2[-1] or b > nums1[-1]:
        dp2 += 1

    return min(dp1, dp2)"
"2935","class TrieNode:
  def __init__(self):
    self.children: list[TrieNode | None] = [None] * 2
    self.mn = math.inf
    self.mx = -math.inf


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]
      node.mn = min(node.mn, num)
      node.mx = max(node.mx, num)

  def getMaxXor(self, x: int) -> int:
    """"""Returns max(x ^ y) where |x - y| <= min(x, y).

    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.
    So, y <= 2 * x.
    """"""
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = x >> i & 1
      toggleBit = bit ^ 1
      # If `node.children[toggleBit].mx > x`, it means there's a number in the
      # node that satisfies the condition to ensure that x <= y among x and y.
      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in
      # the node that satisfies the condition for a valid y.
      if (node.children[toggleBit] and
          node.children[toggleBit].mx > x and
              node.children[toggleBit].mn <= 2 * x):
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:  # There's nothing in the Bit Trie.
        return 0
    return maxXor


class Solution:
  # Same as 2932. Maximum Strong Pair XOR I
  def maximumStrongPairXor(self, nums: list[int]) -> int:
    maxNum = max(nums)
    maxBit = int(math.log2(maxNum))
    bitTrie = BitTrie(maxBit)

    for num in nums:
      bitTrie.insert(num)

    return max(bitTrie.getMaxXor(num) for num in nums)"
"2936","# Definition for BigArray.
# class BigArray:
#   def at(self, index: long) -> int:
#     pass
#   def size(self) -> long:
#     pass

class Solution(object):
  def countBlocks(self, nums: Optional['BigArray']) -> int:
    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:
      """"""Returns the number of maximal blocks in nums[l..r].""""""
      if leftValue == rightValue:
        return 1
      if l + 1 == r:
        return 2
      m = (l + r) // 2
      midValue = nums.at(m)
      return (countBlocks(l, m, leftValue, midValue) +
              countBlocks(m, r, midValue, rightValue) - 1)
    # Substract nums[m], which will be counted twice.
    return countBlocks(0, nums.size() - 1,
                       nums.at(0), nums.at(nums.size() - 1))"
"2937","class Solution:
  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:
    minLength = min(map(len, [s1, s2, s3]))
    i = 0
    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:
      i += 1
    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3"
"2938","class Solution:
  def minimumSteps(self, s: str) -> int:
    ans = 0
    ones = 0

    for c in s:
      if c == '1':
        ones += 1
      else:  # Move 1s to the front of the current '0'.
        ans += ones

    return ans"
"2939","class Solution:
  def maximumXorProduct(self, a: int, b: int, n: int) -> int:
    kMod = 1_000_000_007
    for bit in (2**i for i in range(n)):
      # Pick a bit if it makes min(a, b) larger.
      if a * b < (a ^ bit) * (b ^ bit):
        a ^= bit
        b ^= bit
    return a * b % kMod"
"294","class Solution:
  @functools.lru_cache(None)
  def canWin(self, currentState: str) -> bool:
    # If any of currentState[i:i + 2] == ""++"" and your friend can't win after
    # changing currentState[i:i + 2] to ""--"" (or ""-""), then you can win.
    return any(True
               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))
               if a == '+' and b == '+' and
               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))"
"2940","from dataclasses import dataclass


@dataclass
class IndexedQuery:
  queryIndex: int
  a: int  # Alice's index
  b: int  # Bob's index

  def __iter__(self):
    yield self.queryIndex
    yield self.a
    yield self.b


class Solution:
  # Similar to 2736. Maximum Sum Queries
  def leftmostBuildingQueries(
      self,
      heights: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    ans = [-1] * len(queries)
    # Store indices (heightsIndex) of heights with heights[heightsIndex] in
    # descending order.
    stack = []

    # Iterate through queries and heights simultaneously.
    heightsIndex = len(heights) - 1
    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))
                                    for i, (a, b) in enumerate(queries)],
                                   key=lambda x: -x.b):
      if a == b or heights[a] < heights[b]:
        # 1. Alice and Bob are already in the same index (a == b) or
        # 2. Alice can jump from a -> b (heights[a] < heights[b]).
        ans[queryIndex] = b
      else:
        # Now, a < b and heights[a] >= heights[b].
        # Gradually add heights with an index > b to the monotonic stack.
        while heightsIndex > b:
          # heights[heightsIndex] is a better candidate, given that
          # heightsIndex is smaller than the indices in the stack and
          # heights[heightsIndex] is larger or equal to the heights mapped in
          # the stack.
          while stack and heights[stack[-1]] <= heights[heightsIndex]:
            stack.pop()
          stack.append(heightsIndex)
          heightsIndex -= 1
        # Binary search to find the smallest index j such that j > b and
        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].
        j = self._lastGreater(stack, a, heights)
        if j != -1:
          ans[queryIndex] = stack[j]

    return ans

  def _lastGreater(self, A: list[int], target: int, heights: list[int]):
    """"""
    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].
    """"""
    l = -1
    r = len(A) - 1
    while l < r:
      m = (l + r + 1) // 2
      if heights[A[m]] > heights[target]:
        l = m
      else:
        r = m - 1
    return l"
"2941","class Solution:
  def maxGcdSum(self, nums: list[int], k: int) -> int:
    ans = 0
    # [(startIndex, gcd of subarray starting at startIndex)]
    startIndexAndGcds = []
    prefix = list(itertools.accumulate(nums, initial=0))

    for i, num in enumerate(nums):
      nextStartIndexAndGcds = []
      for startIndex, gcd in startIndexAndGcds:
        nextGcd = math.gcd(gcd, nums[i])
        if (not nextStartIndexAndGcds or
                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.
          nextStartIndexAndGcds.append((startIndex, nextGcd))
      startIndexAndGcds = nextStartIndexAndGcds
      startIndexAndGcds.append((i, nums[i]))
      for startIndex, gcd in startIndexAndGcds:
        if i - startIndex + 1 >= k:
          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)

    return ans"
"2942","class Solution {
 public:
  vector<int> findWordsContaining(vector<string>& words, char x) {
    vector<int> ans;

    for (int i = 0; i < words.size(); ++i)
      if (words[i].find(x) != string::npos)
        ans.push_back(i);

    return ans;
  }
};"
"2943","class Solution {
 public:
  int maximizeSquareHoleArea(int n, int m, vector<int>& hBars,
                             vector<int>& vBars) {
    const int gap = min(maxContinousGap(hBars), maxContinousGap(vBars));
    return gap * gap;
  }

 private:
  int maxContinousGap(vector<int>& bars) {
    int res = 2;
    int runningGap = 2;
    ranges::sort(bars);
    for (int i = 1; i < bars.size(); ++i) {
      runningGap = bars[i] == bars[i - 1] + 1 ? runningGap + 1 : 2;
      res = max(res, runningGap);
    }
    return res;
  }
};"
"2944","class Solution:
  def minimumCoins(self, prices: list[int]) -> int:
    n = len(prices)
    # Convert to 0-indexed for easy computation.
    # dp[i] := the minimum number of coins to acquire fruits[i:]
    dp = [math.inf] * n + [0]

    for i in range(n - 1, -1, -1):
      # Convert back to 1-indexed.
      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):
        dp[i] = min(dp[i], prices[i] + dp[j])

    return dp[0]"
"2945","class Solution:
  def findMaximumLength(self, nums: list[int]) -> int:
    n = len(nums)
    # prefix[i] := the sum of the first i nums
    prefix = list(itertools.accumulate(nums, initial=0))
    # dp[i] := the maximum number of elements in the increasing
    # sequence after processing the first i nums
    dp = [0] * (n + 1)
    # bestLeft[i] := the index l s.t. merging nums[l..i) is the
    # optimal strategy among processing the first i nums
    bestLeft = [0] * (n + 2)

    for i in range(1, n + 1):
      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])
      # When merging nums[l, i), consider the next segment as [i, r).
      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).
      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].
      #            => prefix[r] >= prefix[i] * 2 - prefix[l]
      # Therefore, we can binary search `prefix` to find the minimum `r`.
      l = bestLeft[i]
      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])
      dp[i] = dp[l] + 1
      bestLeft[r] = i

    return dp[n]"
"2946","class Solution:
  def areSimilar(self, mat: list[list[int]], k: int) -> bool:
    n = len(mat[0])
    for row in mat:
      for j in range(n):
        if row[j] != row[(j + k) % n]:
          return False
    return True"
"2947","class Solution:
  def beautifulSubstrings(self, s: str, k: int) -> int:
    kVowels = 'aeiou'
    root = self._getRoot(k)
    ans = 0
    vowels = 0
    vowelsMinusConsonants = 0
    # {(vowels, vowelsMinusConsonants): count}
    prefixCount = collections.Counter({(0, 0): 1})

    for c in s:
      if c in kVowels:
        vowelsMinusConsonants += 1
        vowels = (vowels + 1) % root
      else:
        vowelsMinusConsonants -= 1
      ans += prefixCount[(vowels, vowelsMinusConsonants)]
      prefixCount[(vowels, vowelsMinusConsonants)] += 1

    return ans

  def _getRoot(self, k: int) -> int:
    for i in range(1, k + 1):
      if i * i % k == 0:
        return i"
"2948","class Solution:
  def lexicographicallySmallestArray(
      self,
      nums: list[int],
      limit: int,
  ) -> list[int]:
    ans = [0] * len(nums)
    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])
    # [[(num, index)]], where the difference between in each pair in each
    # `[(num, index)]` group <= `limit`
    numAndIndexesGroups: list[list[tuple[int, int]]] = []

    for numAndIndex in numAndIndexes:
      if (not numAndIndexesGroups or
              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):
        # Start a new group.
        numAndIndexesGroups.append([numAndIndex])
      else:
        # Append to the existing group.
        numAndIndexesGroups[-1].append(numAndIndex)

    for numAndIndexesGroup in numAndIndexesGroups:
      sortedNums = [num for num, _ in numAndIndexesGroup]
      sortedIndices = sorted([index for _, index in numAndIndexesGroup])
      for num, index in zip(sortedNums, sortedIndices):
        ans[index] = num

    return ans"
"2949","class Solution:
  # Same as 2947. Count Beautiful Substrings I
  def beautifulSubstrings(self, s: str, k: int) -> int:
    kVowels = 'aeiou'
    root = self._getRoot(k)
    ans = 0
    vowels = 0
    vowelsMinusConsonants = 0
    # {(vowels, vowelsMinusConsonants): count}
    prefixCount = collections.Counter({(0, 0): 1})

    for c in s:
      if c in kVowels:
        vowelsMinusConsonants += 1
        vowels = (vowels + 1) % root
      else:
        vowelsMinusConsonants -= 1
      ans += prefixCount[(vowels, vowelsMinusConsonants)]
      prefixCount[(vowels, vowelsMinusConsonants)] += 1

    return ans

  def _getRoot(self, k: int) -> int:
    for i in range(1, k + 1):
      if i * i % k == 0:
        return i"
"295","class MedianFinder:
  def __init__(self):
    self.maxHeap = []
    self.minHeap = []

  def addNum(self, num: int) -> None:
    if not self.maxHeap or num <= -self.maxHeap[0]:
      heapq.heappush(self.maxHeap, -num)
    else:
      heapq.heappush(self.minHeap, num)

    # Balance the two heaps s.t.
    # |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1.
    if len(self.maxHeap) < len(self.minHeap):
      heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))
    elif len(self.maxHeap) - len(self.minHeap) > 1:
      heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))

  def findMedian(self) -> float:
    if len(self.maxHeap) == len(self.minHeap):
      return (-self.maxHeap[0] + self.minHeap[0]) / 2.0
    return -self.maxHeap[0]"
"2950","class Solution:
  def countDivisibleSubstrings(self, word: str) -> int:
    # Let f(c) = d, where d = 1, 2, ..., 9.
    # Rephrase the question to return the number of substrings that satisfy
    #    f(c1) + f(c2) + ... + f(ck) // k = avg
    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].
    ans = 0

    def f(c: str) -> int:
      return 9 - (ord('z') - ord(c)) // 3

    for avg in range(1, 10):
      prefix = 0
      prefixCount = collections.Counter({0: 1})
      for c in word:
        prefix += f(c) - avg
        ans += prefixCount[prefix]
        prefixCount[prefix] += 1

    return ans"
"2951","class Solution:
  def findPeaks(self, mountain: list[int]) -> list[int]:
    return [i for i in range(1, len(mountain) - 1)
            if mountain[i - 1] < mountain[i] > mountain[i + 1]]"
"2952","class Solution:
  # Same as 330. Patching Array
  def minimumAddedCoins(self, coins: list[int], target: int) -> int:
    ans = 0
    i = 0  # coins' index
    miss = 1  # the minimum sum in [1, n] we might miss

    coins.sort()

    while miss <= target:
      if i < len(coins) and coins[i] <= miss:
        miss += coins[i]
        i += 1
      else:
        # Greedily add `miss` itself to increase the range from
        # [1, miss) to [1, 2 * miss).
        miss += miss
        ans += 1

    return ans"
"2953","class Solution:
  def countCompleteSubstrings(self, word: str, k: int) -> int:
    uniqueLetters = len(set(word))
    return sum(self._countCompleteStrings(word, k, windowSize)
               for windowSize in range(k, k * uniqueLetters + 1, k))

  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:
    """"""
    Returns the number of complete substrings of `windowSize` of `word`.
    """"""
    res = 0
    countLetters = 0  # the number of letters in the running substring
    count = collections.Counter()

    for i, c in enumerate(word):
      count[c] += 1
      countLetters += 1
      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:
        count = collections.Counter()
        # Start a new substring starting at word[i].
        count[c] += 1
        countLetters = 1
      if countLetters == windowSize + 1:
        count[word[i - windowSize]] -= 1
        countLetters -= 1
      if countLetters == windowSize:
        res += all(freq == 0 or freq == k for freq in count.values())

    return res"
"2954","class Solution:
  def numberOfSequence(self, n: int, sick: list[int]) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    ans = fact(n - len(sick))  # the number of infected children
    prevSick = -1

    for i, s in enumerate(sick):
      # The segment [prevSick + 1, sick - 1] are the current non-infected
      # children.
      nonInfected = sick[i] - prevSick - 1
      prevSick = sick[i]
      if nonInfected == 0:
        continue
      ans *= inv(fact(nonInfected))
      ans %= kMod
      if i > 0:
        # There're two choices per second since the children at the two
        # endpoints can both be the infect candidates. So, there are
        # 2^[nonInfected - 1] ways to infect all children in the current
        # segment.
        ans *= pow(2, nonInfected - 1, kMod)

    nonInfected = n - sick[-1] - 1
    return ans * inv(fact(nonInfected)) % kMod"
"2955","class Solution:
  def sameEndSubstringCount(
      self,
      s: str,
      queries: list[list[int]],
  ) -> list[int]:
    count = collections.Counter()
    # counts[i] := the count of s[0..i)
    counts = [count.copy()]

    for c in s:
      count[c] += 1
      counts.append(count.copy())

    ans = []

    for l, r in queries:
      sameEndCount = 0
      for c in string.ascii_lowercase:
        #   the count of s[0..r] - the count of s[0..l - 1]
        # = the count of s[l..r]
        freq = counts[r + 1][c] - counts[l][c]
        #   C(freq, 2) + freq
        # = freq * (freq - 1) / 2 + freq
        # = freq * (freq + 1) / 2
        sameEndCount += freq * (freq + 1) // 2
      ans.append(sameEndCount)

    return ans"
"2956","class Solution:
  def findIntersectionValues(
      self,
      nums1: list[int],
      nums2: list[int],
  ) -> list[int]:
    nums1Set = set(nums1)
    nums2Set = set(nums2)
    return [sum(num in nums2Set for num in nums1),
            sum(num in nums1Set for num in nums2)]"
"2957","class Solution:
  def removeAlmostEqualCharacters(self, word: str) -> int:
    ans = 0
    i = 1
    while i < len(word):
      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:
        ans += 1
        i += 2
      else:
        i += 1
    return ans"
"2958","class Solution:
  def maxSubarrayLength(self, nums: list[int], k: int) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      count[num] += 1
      while count[num] == k + 1:
        count[nums[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"2959","class Solution:
  def numberOfSets(
      self,
      n: int,
      maxDistance: int,
      roads: list[list[int]],
  ) -> int:
    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance
               for mask in range(1 << n))

  def _floydWarshall(
      self,
      n: int,
      maxDistanceThreshold: int,
      roads: list[list[int]],
      mask: int,
  ) -> list[list[int]]:
    """"""
    Returns the maximum distance between any two branches, where the mask
    represents the selected branches.
    """"""
    maxDistance = 0
    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]

    for i in range(n):
      if mask >> i & 1:
        dist[i][i] = 0

    for u, v, w in roads:
      if mask >> u & 1 and mask >> v & 1:
        dist[u][v] = min(dist[u][v], w)
        dist[v][u] = min(dist[v][u], w)

    for k in range(n):
      if mask >> k & 1:
        for i in range(n):
          if mask >> i & 1:
            for j in range(n):
              if mask >> j & 1:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    for i in range(n):
      if mask >> i & 1:
        for j in range(i + 1, n):
          if mask >> j & 1:
            maxDistance = max(maxDistance, dist[i][j])

    return maxDistance"
"296","class Solution:
  def minTotalDistance(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # i indices s.t. grid[i][j] == 1
    I = [i for i in range(m) for j in range(n) if grid[i][j]]
    # j indices s.t. grid[i][j] == 1
    J = [j for j in range(n) for i in range(m) if grid[i][j]]

    def minTotalDistance(grid: list[int]) -> int:
      summ = 0
      i = 0
      j = len(grid) - 1
      while i < j:
        summ += grid[j] - grid[i]
        i += 1
        j -= 1
      return summ

    # sum(i - median(I)) + sum(j - median(J))
    return minTotalDistance(I) + minTotalDistance(J)"
"2960","class Solution:
  def countTestedDevices(self, batteryPercentages: list[int]) -> int:
    ans = 0

    for batteryPercentage in batteryPercentages:
      if batteryPercentage - ans > 0:
        ans += 1

    return ans"
"2961","class Solution:
  def getGoodIndices(
      self,
      variables: list[list[int]],
      target: int,
  ) -> list[int]:
    return [i for i, (a, b, c, m) in enumerate(variables)
            if pow(pow(a, b, 10), c, m) == target]"
"2962","class Solution:
  def countSubarrays(self, nums: list[int], k: int) -> int:
    maxNum = max(nums)
    ans = 0
    count = 0

    l = 0
    for r, num in enumerate(nums):
      if num == maxNum:
        count += 1
      # Keep the window to include k - 1 times of the maxNummum number.
      while count == k:
        if nums[l] == maxNum:
          count -= 1
        l += 1
      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any
      # subarray nums[i:r+1], where i < l, it will have at least k times of the
      # maxNummum number, since nums[l - 1] equals the maxNummum number.
      ans += l

    return ans"
"2963","class Solution:
  def numberOfGoodPartitions(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    ans = 1
    # lastSeen[num] := the index of the last time `num` appeared
    lastSeen = {}

    for i, num in enumerate(nums):
      lastSeen[num] = i

    # Track the maximum right index of each running partition by ensuring that
    # the first and last occurrences of a number fall within the same partition.
    maxRight = 0
    for i, num in enumerate(nums):
      if i > maxRight:
        # Start a new partition that starts from nums[i].
        # Each partition doubles the total number of good partitions.
        ans = ans * 2 % kMod
      maxRight = max(maxRight, lastSeen[num])

    return ans"
"2964","class Solution:
  # Similar to 1995. Count Special Quadruplets
  def divisibleTripletCount(self, nums: list[int], d: int) -> int:
    ans = 0
    count = collections.Counter()

    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.
      for i in range(j - 1, -1, -1):
        ans += count[-(nums[i] + nums[j]) % d]
      count[nums[j] % d] += 1  # j := k

    return ans"
"2965","class Solution:
  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:
    count = [1] + [0] * len(grid)**2  # padding for 1-indexed

    for row in grid:
      for num in row:
        count[num] += 1

    return [count.index(2), count.index(0)]"
"2966","class Solution:
  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:
    ans = []

    nums.sort()

    for i in range(2, len(nums), 3):
      if nums[i] - nums[i - 2] > k:
        return []
      ans.append([nums[i - 2], nums[i - 1], nums[i]])

    return ans"
"2967","class Solution:
  def minimumCost(self, nums: list[int]) -> int:
    nums.sort()
    median = nums[len(nums) // 2]
    nextPalindrome = self._getPalindrome(median, delta=1)
    prevPalindrome = self._getPalindrome(median, delta=-1)
    return min(self._cost(nums, nextPalindrome),
               self._cost(nums, prevPalindrome))

  def _cost(self, nums: list[int], palindrome: int) -> int:
    """"""Returns the cost to change all the numbers to `palindrome`.""""""
    return sum(abs(palindrome - num) for num in nums)

  def _getPalindrome(self, num: int, delta: int) -> int:
    """"""Returns the palindrome `p`, where p = num + a * delta and a > 0.""""""
    while not self._isPalindrome(num):
      num += delta
    return num

  def _isPalindrome(self, num: int) -> int:
    original = str(num)
    return original == original[::-1]"
"2968","class Solution:
  def maxFrequencyScore(self, nums: list[int], k: int) -> int:
    nums.sort()
    ans = 0
    cost = 0

    l = 0
    for r, num in enumerate(nums):
      cost += num - nums[(l + r) // 2]
      while cost > k:
        cost -= nums[(l + r + 1) // 2] - nums[l]
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"2969","class Solution:
  # Same as 2944. Minimum Number of Coins for Fruits
  def minimumCoins(self, prices: list[int]) -> int:
    n = len(prices)
    ans = math.inf
    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire
    # fruits[i:] (0-indexed) in ascending order.
    minQ = collections.deque([(0, n)])

    for i in range(n - 1, -1, -1):
      while minQ and minQ[0][1] > (i + 1) * 2:
        minQ.popleft()
      ans = prices[i] + minQ[0][0]
      while minQ and minQ[-1][0] >= ans:
        minQ.pop()
      minQ.append((ans, i))

    return ans"
"297","class Codec:
  def serialize(self, root: 'TreeNode') -> str:
    """"""Encodes a tree to a single string.""""""
    if not root:
      return ''

    s = ''
    q = collections.deque([root])

    while q:
      node = q.popleft()
      if node:
        s += str(node.val) + ' '
        q.append(node.left)
        q.append(node.right)
      else:
        s += 'n '

    return s

  def deserialize(self, data: str) -> 'TreeNode':
    """"""Decodes your encoded data to tree.""""""
    if not data:
      return None

    vals = data.split()
    root = TreeNode(vals[0])
    q = collections.deque([root])

    for i in range(1, len(vals), 2):
      node = q.popleft()
      if vals[i] != 'n':
        node.left = TreeNode(vals[i])
        q.append(node.left)
      if vals[i + 1] != 'n':
        node.right = TreeNode(vals[i + 1])
        q.append(node.right)

    return root"
"2970","class Solution:
  def incremovableSubarrayCount(self, nums: list[int]) -> int:
    n = len(nums)
    startIndex = self._getStartIndexOfSuffix(nums)
    # If the complete array is strictly increasing, the total number of ways we
    # can remove elements equals the total number of possible subarrays.
    if startIndex == 0:
      return n * (n + 1) // 2

    # The valid removals starting from nums[0] include nums[0..startIndex - 1],
    # nums[0..startIndex], ..., nums[0..n).
    ans = n - startIndex + 1

    # Enumerate each prefix subarray that is strictly increasing.
    for i in range(startIndex):
      if i > 0 and nums[i] <= nums[i - 1]:
        break
      # Since nums[0..i] is strictly increasing, find the first index j in
      # nums[startIndex..n) such that nums[j] > nums[i]. The valid removals
      # will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).
      ans += n - bisect.bisect_right(nums, nums[i], startIndex) + 1

    return ans

  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:
    for i in range(len(nums) - 2, -1, -1):
      if nums[i] >= nums[i + 1]:
        return i + 1
    return 0"
"2971","class Solution:
  def largestPerimeter(self, nums: list[int]) -> int:
    prefix = sum(nums)

    for num in sorted(nums, reverse=True):
      prefix -= num
      # Let `num` be the longest side. Check if the sum of all the edges with
      # length no longer than `num` > `num``.
      if prefix > num:
        return prefix + num

    return -1"
"2972","class Solution:
  # Same as 2970. Count the Number of Incremovable Subarrays I
  def incremovableSubarrayCount(self, nums: list[int]) -> int:
    n = len(nums)
    startIndex = self._getStartIndexOfSuffix(nums)
    # If the complete array is strictly increasing, the total number of ways we
    # can remove elements equals the total number of possible subarrays.
    if startIndex == 0:
      return n * (n + 1) // 2

    # The valid removals starting from nums[0] include nums[0..startIndex - 1],
    # nums[0..startIndex], ..., nums[0..n).
    ans = n - startIndex + 1

    # Enumerate each prefix subarray that is strictly increasing.
    j = startIndex
    for i in range(startIndex):
      if i > 0 and nums[i] <= nums[i - 1]:
        break
      # Since nums[0..i] is strictly increasing, move j to the place such that
      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],
      # nums[i + 1..j], ..., nums[i + 1..n).
      while j < n and nums[i] >= nums[j]:
        j += 1
      ans += n - j + 1

    return ans

  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:
    for i in range(len(nums) - 2, -1, -1):
      if nums[i] >= nums[i + 1]:
        return i + 1
    return 0"
"2973","class ChildCost:
  def __init__(self, cost: int):
    self.numNodes = 1
    self.maxPosCosts = [cost] if cost > 0 else []
    self.minNegCosts = [cost] if cost < 0 else []

  def update(self, childCost: 'ChildCost') -> None:
    self.numNodes += childCost.numNodes
    self.maxPosCosts.extend(childCost.maxPosCosts)
    self.minNegCosts.extend(childCost.minNegCosts)
    self.maxPosCosts.sort(reverse=True)
    self.minNegCosts.sort()
    self.maxPosCosts = self.maxPosCosts[:3]
    self.minNegCosts = self.minNegCosts[:2]

  def maxProduct(self) -> int:
    if self.numNodes < 3:
      return 1
    if not self.maxPosCosts:
      return 0
    res = 0
    if len(self.maxPosCosts) == 3:
      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]
    if len(self.minNegCosts) == 2:
      res = max(res,
                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])
    return res


class Solution:
  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:
    n = len(cost)
    ans = [0] * n
    tree = [[] for _ in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> None:
      res = ChildCost(cost[u])
      for v in tree[u]:
        if v != prev:
          res.update(dfs(v, u))
      ans[u] = res.maxProduct()
      return res

    dfs(0, -1)
    return ans"
"2974","class Solution:
  def numberGame(self, nums: list[int]) -> list[int]:
    nums.sort()
    return [nums[i + 1] if i % 2 == 0
            else nums[i - 1]
            for i in range(len(nums))]"
"2975","class Solution:
  def maximizeSquareArea(
      self,
      m: int,
      n: int,
      hFences: list[int],
      vFences: list[int],
  ) -> int:
    hFences = sorted(hFences + [1, m])
    vFences = sorted(vFences + [1, n])
    hGaps = {hFences[i] - hFences[j]
             for i in range(len(hFences))
             for j in range(i)}
    vGaps = {vFences[i] - vFences[j]
             for i in range(len(vFences))
             for j in range(i)}
    maxGap = next((hGap
                  for hGap in sorted(hGaps, reverse=True)
                  if hGap in vGaps), -1)
    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)"
"2976","class Solution:
  def minimumCost(
      self,
      source: str,
      target: str,
      original: list[str],
      changed: list[str],
      cost: list[int],
  ) -> int:
    ans = 0
    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)
    dist = [[math.inf] * 26 for _ in range(26)]

    for a, b, c in zip(original, changed, cost):
      u = string.ascii_lowercase.index(a)
      v = string.ascii_lowercase.index(b)
      dist[u][v] = min(dist[u][v], c)

    for k in range(26):
      for i in range(26):
        if dist[i][k] < math.inf:
          for j in range(26):
            if dist[k][j] < math.inf:
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    for s, t in zip(source, target):
      if s == t:
        continue
      u = string.ascii_lowercase.index(s)
      v = string.ascii_lowercase.index(t)
      if dist[u][v] == math.inf:
        return -1
      ans += dist[u][v]

    return ans"
"2977","class Solution:
  def minimumCost(
      self,
      source: str,
      target: str,
      original: list[str],
      changed: list[str],
      cost: list[int],
  ) -> int:
    subLengths = set(len(s) for s in original)
    subToId = self._getSubToId(original, changed)
    subCount = len(subToId)
    # dist[u][v] := the minimum distance to change the substring with id u to
    # the substring with id v
    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]
    # dp[i] := the minimum cost to change the first i letters of `source` into
    # `target`, leaving the suffix untouched
    dp = [math.inf for _ in range(len(source) + 1)]

    for a, b, c in zip(original, changed, cost):
      u = subToId[a]
      v = subToId[b]
      dist[u][v] = min(dist[u][v], c)

    for k in range(subCount):
      for i in range(subCount):
        if dist[i][k] < math.inf:
          for j in range(subCount):
            if dist[k][j] < math.inf:
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    dp[0] = 0

    for i, (s, t) in enumerate(zip(source, target)):
      if dp[i] == math.inf:
        continue
      if s == t:
        dp[i + 1] = min(dp[i + 1], dp[i])
      for subLength in subLengths:
        if i + subLength > len(source):
          continue
        subSource = source[i:i + subLength]
        subTarget = target[i:i + subLength]
        if subSource not in subToId or subTarget not in subToId:
          continue
        u = subToId[subSource]
        v = subToId[subTarget]
        if dist[u][v] != math.inf:
          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])

    return -1 if dp[len(source)] == math.inf else dp[len(source)]

  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:
    subToId = {}
    for s in original + changed:
      if s not in subToId:
        subToId[s] = len(subToId)
    return subToId"
"2978","WITH
  SymmetricCoordinates AS (
    SELECT DISTINCT C1.x, C1.y
    FROM Coordinates AS C1
    INNER JOIN Coordinates AS C2
      ON (C1.x, C1.y) = (C2.y, C2.x)
    WHERE C1.x < C1.y
    UNION ALL
    SELECT x, y
    FROM Coordinates
    WHERE x = y
    GROUP BY 1
    HAVING COUNT(*) > 1
  )
SELECT x, y
FROM SymmetricCoordinates
ORDER BY 1, 2;"
"2979","class Solution:
  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:
    # https://en.wikipedia.org/wiki/Coin_problem
    return primeOne * primeTwo - primeOne - primeTwo"
"298","class Solution:
  def longestConsecutive(self, root: TreeNode | None) -> int:
    if not root:
      return 0

    def dfs(root: TreeNode | None, target: int, length: int, maxLength: int) -> int:
      if not root:
        return maxLength
      if root.val == target:
        length += 1
        maxLength = max(maxLength, length)
      else:
        length = 1
      return max(dfs(root.left, root.val + 1, length, maxLength),
                 dfs(root.right, root.val + 1, length, maxLength))

    return dfs(root, root.val, 0, 0)"
"2980","class Solution:
  def hasTrailingZeros(self, nums: list[int]) -> bool:
    return sum(num % 2 == 0 for num in nums) >= 2"
"2981","class Solution:
  def maximumLength(self, s: str) -> int:
    n = len(s)
    runningLen = 0
    prevLetter = '@'
    # counts[i][j] := the frequency of ('a' + i) repeating j times
    counts = [[0] * (n + 1) for _ in range(26)]

    for c in s:
      if c == prevLetter:
        runningLen += 1
        counts[string.ascii_lowercase.index(c)][runningLen] += 1
      else:
        runningLen = 1
        counts[string.ascii_lowercase.index(c)][runningLen] += 1
        prevLetter = c

    def getMaxFreq(count: list[int]) -> int:
      """"""Returns the maximum frequency that occurs more than three times.""""""
      times = 0
      for freq in range(n, 0, -1):
        times += count[freq]
        if times >= 3:
          return freq
      return -1

    return max(getMaxFreq(count) for count in counts)"
"2982","class Solution:
  def maximumLength(self, s: str) -> int:
    n = len(s)
    runningLen = 0
    prevLetter = '@'
    # counts[i][j] := the frequency of ('a' + i) repeating j times
    counts = [[0] * (n + 1) for _ in range(26)]

    for c in s:
      if c == prevLetter:
        runningLen += 1
        counts[string.ascii_lowercase.index(c)][runningLen] += 1
      else:
        runningLen = 1
        counts[string.ascii_lowercase.index(c)][runningLen] += 1
        prevLetter = c

    def getMaxFreq(count: list[int]) -> int:
      """"""Returns the maximum frequency that occurs more than three times.""""""
      times = 0
      for freq in range(n, 0, -1):
        times += count[freq]
        if times >= 3:
          return freq
      return -1

    return max(getMaxFreq(count) for count in counts)"
"2983","class Solution:
  def canMakePalindromeQueries(
      self,
      s: str,
      queries: list[list[int]],
  ) -> list[bool]:
    n = len(s)
    # mirroredDiffs[i] := the number of different letters between the first i
    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]
    mirroredDiffs = self._getMirroredDiffs(s)
    # counts[i] := the count of s[0..i)
    counts = self._getCounts(s)
    ans = []

    def subtractArrays(a: list[int], b: list[int]):
      return [x - y for x, y in zip(a, b)]

    for a, b, c, d in queries:
      # Use left-closed, right-open intervals to facilitate the calculation.
      #   ...... [a, b) ...|... [rb, ra) ......
      #   .... [rd, rc) .....|..... [c, d) ....
      b += 1
      d += 1
      ra = n - a  # the reflected index of a in s[n / 2..n)
      rb = n - b  # the reflected index of b in s[n / 2..n)
      rc = n - c  # the reflected index of c in s[n / 2..n)
      rd = n - d  # the reflected index of d in s[n / 2..n)
      # No difference is allowed outside the query ranges.
      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or
         (n // 2 > max(b, rc) and
          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or
         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or
         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):
        ans.append(False)
      else:
        # The `count` map of the intersection of [a, b) and [rd, rc) in
        # s[0..n / 2) must equate to the `count` map of the intersection of
        # [c, d) and [rb, ra) in s[n / 2..n).
        leftRangeCount = subtractArrays(counts[b], counts[a])
        rightRangeCount = subtractArrays(counts[d], counts[c])
        if a > rd:
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))
        if rc > b:
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))
        if c > rb:
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))
        if ra > d:
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))
        ans.append(min(leftRangeCount) >= 0
                   and min(rightRangeCount) >= 0
                   and leftRangeCount == rightRangeCount)

    return ans

  def _getMirroredDiffs(self, s: str) -> list[int]:
    diffs = [0]
    for i, j in zip(range(len(s)), reversed(range(len(s)))):
      if i >= j:
        break
      diffs.append(diffs[-1] + (s[i] != s[j]))
    return diffs

  def _getCounts(self, s: str) -> list[list[int]]:
    count = [0] * 26
    counts = [count.copy()]
    for c in s:
      count[string.ascii_lowercase.index(c)] += 1
      counts.append(count.copy())
    return counts"
"2984","WITH
  CityHourCount AS (
    SELECT
      city,
      HOUR(call_time) AS call_hour,
      COUNT(*) AS number_of_calls
    FROM Calls
    GROUP BY 1, 2
  ),
  RankedCityHourCount AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY city
        ORDER BY number_of_calls DESC
      ) AS `rank`
    FROM CityHourCount
  )
SELECT
  city,
  call_hour AS peak_calling_hour,
  number_of_calls
FROM RankedCityHourCount
WHERE `rank` = 1
ORDER BY 2 DESC, 1 DESC;"
"2985","SELECT
  ROUND(
    SUM(item_count * order_occurrences) / SUM(order_occurrences),
    2
  ) AS average_items_per_order
FROM Orders;"
"2986","WITH
  TransactionNeighbors AS (
    SELECT
      user_id,
      spend,
      transaction_date,
      RANK() OVER(PARTITION BY user_id ORDER BY transaction_date) AS date_rank,
      FIRST_VALUE(spend) OVER(
        PARTITION BY user_id
        ORDER BY transaction_date
      ) AS first_spend,
      LAG(spend) OVER(
        PARTITION BY user_id
        ORDER BY transaction_date
      ) AS second_spend
    FROM Transactions
  )
SELECT
  user_id,
  spend AS third_transaction_spend,
  transaction_date AS third_transaction_date
FROM TransactionNeighbors
WHERE
  date_rank = 3
  AND spend > first_spend
  AND spend > second_spend
ORDER BY 1;"
"2987","SELECT city
FROM Listings
GROUP BY 1
HAVING AVG(price) > (SELECT AVG(price) FROM Listings)
ORDER BY 1;"
"2988","WITH
  RankedDepartments AS (
    SELECT
      dep_id,
      DENSE_RANK() OVER(
        ORDER BY COUNT(*) DESC
      ) AS `rank`
    FROM Employees
    GROUP BY 1
  )
SELECT
  Employees.emp_name AS manager_name,
  Employees.dep_id
FROM Employees
INNER JOIN RankedDepartments
  USING (dep_id)
WHERE
  Employees.position = 'Manager'
  AND RankedDepartments.`rank` = 1
ORDER BY dep_id;"
"2989","WITH
  TotalScores AS (
    SELECT assignment1 + assignment2 + assignment3 AS score
    FROM Scores
  )
SELECT MAX(score) - MIN(score) AS difference_in_score
FROM TotalScores;"
"299","class Solution:
  def getHint(self, secret: str, guess: str) -> str:
    bulls = sum(map(operator.eq, secret, guess))
    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))
    return '%dA%dB' % (bulls, bovine - bulls)"
"2990","SELECT user_id
FROM Loans
WHERE loan_type IN ('Refinance', 'Mortgage')
GROUP BY 1
HAVING COUNT(DISTINCT loan_type) = 2
ORDER BY 1;"
"2991","WITH
  WineryToTotalPoints AS (
    SELECT
      country,
      winery,
      SUM(points) AS total_points
    FROM Wineries
    GROUP BY 1, 2
  ),
  RankedWineries AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY country
        ORDER BY total_points DESC, winery
      ) AS `rank`
    FROM WineryToTotalPoints
  )
SELECT
  country,
  MAX(
    CASE WHEN `rank` = 1 THEN CONCAT(winery, ' (', total_points, ')') END
  ) AS top_winery,
  IFNULL(
    MAX(CASE WHEN `rank` = 2 THEN CONCAT(winery, ' (', total_points, ')') END),
    'No second winery'
  ) AS second_winery,
  IFNULL(
    MAX(CASE WHEN `rank` = 3 THEN CONCAT(winery, ' (', total_points, ')') END),
    'No third winery'
  ) AS third_winery
FROM RankedWineries
WHERE `rank` <= 3
GROUP BY 1
ORDER BY 1;"
"2992","class Solution:
  def selfDivisiblePermutationCount(self, n: int) -> int:
    def dfs(num: int, used: int) -> int:
      if num > n:
        return 1

      count = 0
      for i in range(1, n + 1):
        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):
          count += dfs(num + 1, used | 1 << i)

      return count

    return dfs(1, 0)"
"2993","SELECT
  WEEK(purchase_date, 1) - WEEK('2023-11-01', 1) + 1 AS week_of_month,
  purchase_date,
  SUM(amount_spend) AS total_amount
FROM Purchases
WHERE
  DAYOFWEEK(purchase_date) = 6
  AND MONTH(purchase_date) = 11
  AND YEAR(purchase_date) = 2023
GROUP BY purchase_date
ORDER BY week_of_month;"
"2994","WITH
  Recursive Fridays AS (
     -- the first Friday of November 2023
    SELECT '2023-11-03' AS friday
    UNION ALL
    SELECT DATE_ADD(friday, INTERVAL 7 DAY)
    FROM Fridays
    -- the last day of November 2023 - 7 days
    WHERE friday < '2023-11-23'
  )
SELECT
  WEEK(Fridays.friday, 1) - WEEK('2023-11-01', 1) + 1 AS week_of_month,
  Fridays.friday AS purchase_date,
  IFNULL(SUM(Purchases.amount_spend), 0) AS total_amount
FROM Fridays
LEFT JOIN Purchases
  ON (Fridays.friday = Purchases.purchase_date)
GROUP BY Fridays.friday
ORDER BY week_of_month;"
"2995","WITH
  FirstSessions AS (
    SELECT
      user_id,
      session_type,
      RANK() OVER(PARTITION BY user_id ORDER BY session_start) AS session_rank
    FROM Sessions
  ),
  ViewerFirst AS (
    SELECT user_id
    FROM FirstSessions
    WHERE session_rank = 1 AND session_type = 'Viewer'
  )
SELECT
  Sessions.user_id,
  COUNT(*) AS sessions_count
FROM Sessions
INNER JOIN ViewerFirst
  USING (user_id)
WHERE Sessions.session_type = 'Streamer'
GROUP BY 1
ORDER BY sessions_count DESC, Sessions.user_id DESC;"
"2996","class Solution:
  def missingInteger(self, nums: list[int]) -> int:
    numsSet = set(nums)
    ans = nums[0]

    for i in range(1, len(nums)):
      if nums[i] != nums[i - 1] + 1:
        break
      ans += nums[i]

    while ans in numsSet:
      ans += 1

    return ans"
"2997","class Solution:
  def minOperations(self, nums: list[int], k: int) -> int:
    return functools.reduce(operator.xor, nums, k).bit_count()"
"2998","class Solution:
  def minimumOperationsToMakeEqual(self, x, y):
    if x <= y:
      return y - x

    queue = collections.deque([x])
    seen = set()

    ans = 0
    while queue:
      for _ in range(len(queue)):
        num = queue.popleft()
        if num == y:
          return ans
        if num in seen:
          continue
        seen.add(num)
        if num % 11 == 0:
          queue.append(num // 11)
        if num % 5 == 0:
          queue.append(num // 5)
        queue.append(num - 1)
        queue.append(num + 1)
      ans += 1"
"2999","class Solution {
 public:
  long long numberOfPowerfulInt(long long start, long long finish, int limit,
                                string s) {
    const string a = to_string(start);
    const string b = to_string(finish);
    const string aWithLeadingZeros = string(b.length() - a.length(), '0') + a;
    vector<vector<vector<long>>> mem(
        b.length(), vector<vector<long>>(2, vector<long>(2, -1)));
    const string sWithLeadingZeros = string(b.length() - s.length(), '0') + s;
    return count(aWithLeadingZeros, b, 0, limit, s, true, true, mem);
  }

 private:
  // Returns the number of powerful integers, considering the i-th digit, where
  // `isTight1` indicates if the current digit is tightly bound for `a` and
  // `isTight2` indicates if the current digit is tightly bound for `b`.
  long count(const string& a, const string& b, int i, int limit,
             const string& s, bool isTight1, bool isTight2,
             vector<vector<vector<long>>>& mem) {
    if (i + s.length() == b.length()) {
      const string aMinSuffix = isTight1
                                    ? std::string(a.end() - s.length(), a.end())
                                    : string(s.length(), '0');
      const string bMaxSuffix = isTight2
                                    ? std::string(b.end() - s.length(), b.end())
                                    : string(s.length(), '9');
      const long suffix = stoll(s);
      return stoll(aMinSuffix) <= suffix && suffix <= stoll(bMaxSuffix);
    }

    if (mem[i][isTight1][isTight2] != -1)
      return mem[i][isTight1][isTight2];

    long res = 0;
    const int minDigit = isTight1 ? a[i] - '0' : 0;
    const int maxDigit = isTight2 ? b[i] - '0' : 9;

    for (int d = minDigit; d <= maxDigit; ++d) {
      if (d > limit)
        continue;
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(a, b, i + 1, limit, s, nextIsTight1, nextIsTight2, mem);
    }

    return mem[i][isTight1][isTight2] = res;
  }
};"
"3","class Solution:
  def lengthOfLongestSubstring(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] > 1:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"30","class Solution:
  def findSubstring(self, s: str, words: list[str]) -> list[int]:
    if len(s) == 0 or words == []:
      return []

    k = len(words)
    n = len(words[0])
    ans = []
    count = collections.Counter(words)

    for i in range(len(s) - k * n + 1):
      seen = collections.defaultdict(int)
      j = 0
      while j < k:
        word = s[i + j * n: i + j * n + n]
        seen[word] += 1
        if seen[word] > count[word]:
          break
        j += 1
      if j == k:
        ans.append(i)

    return ans"
"300","class Solution:
  def lengthOfLIS(self, nums: list[int]) -> int:
    # tails[i] := the minimum tails of all the increasing subsequences having
    # length i + 1
    tails = []

    for num in nums:
      if not tails or num > tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_left(tails, num)] = num

    return len(tails)"
"3000","class Solution:
  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:
    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))
    return a * b"
"3001","class Solution:
  def minMovesToCaptureTheQueen(
      self, a: int, b: int, c: int, d: int, e: int, f: int,
  ) -> int:
    # The rook is in the same row as the queen.
    if a == e:
      # The bishop blocks the rook or not.
      return 2 if c == a and (b < d < f or b > d > f) else 1
    # The rook is in the same column as the queen.
    if b == f:
      # The bishop blocks the rook or not.
      return 2 if d == f and (a < c < e or a > c > e) else 1
    # The bishop is in the same up-diagonal as the queen.
    if c + d == e + f:
      # The rook blocks the bishop or not.
      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1
    # The bishop is in the same down-diagonal as the queen.
    if c - d == e - f:
      # The rook blocks the bishop or not.
      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1
    # The rook can always get the green in two steps.
    return 2"
"3002","class Solution:
  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:
    set1 = set(nums1)
    set2 = set(nums2)
    common = set1.intersection(set2)

    n = len(nums1)
    n1 = len(set1)
    n2 = len(set2)
    nc = len(common)
    maxUniqueNums1 = min(n1 - nc, n // 2)
    maxUniqueNums2 = min(n2 - nc, n // 2)
    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)"
"3003","class Solution:
  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, canChange: bool, mask: int) -> int:
      """"""
      Returns the maximum number of partitions of s[i..n), where `canChange` is
      True if we can still change a letter, and `mask` is the bitmask of the
      letters we've seen.
      """"""
      if i == len(s):
        return 0

      def getRes(newBit: int, nextCanChange: bool) -> int:
        nextMask = mask | newBit
        if nextMask.bit_count() > k:
          return 1 + dp(i + 1, nextCanChange, newBit)
        return dp(i + 1, nextCanChange, nextMask)

      # Initialize the result based on the current letter.
      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)

      # If allowed, explore the option to change the current letter.
      if canChange:
        for j in range(26):
          res = max(res, getRes(1 << j, False))
      return res

    return dp(0, True, 0) + 1"
"3004","class Solution:
  def maximumSubtreeSize(
      self,
      edges: list[list[int]],
      colors: list[int],
  ) -> int:
    ans = 1
    tree = [[] for _ in range(len(colors))]

    for u, v in edges:
      tree[u].append(v)

    def dfs(u: int) -> int:
      """"""
      Returns the size of subtree of u if every node in the subtree has the same
      color. Otherwise, returns -1.
      """"""
      nonlocal ans
      res = 1
      for v in tree[u]:
        if colors[v] != colors[u]:
          res = -1
        # If any node in the subtree of v has a different color, the result of
        # the subtree of u will be -1 as well.
        subtreeSize = dfs(v)
        if subtreeSize == -1:
          res = -1
        elif res != -1:
          res += subtreeSize
      ans = max(ans, res)
      return res

    dfs(0)
    return ans"
"3005","class Solution:
  def maxFrequencyElements(self, nums: list[int]) -> int:
    count = collections.Counter(nums)
    maxFreq = max(count.values())
    return sum(freq == maxFreq for freq in count.values()) * maxFreq"
"3006","class Solution:
  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:
    ans = []
    indicesA = self._kmp(s, a)
    indicesB = self._kmp(s, b)
    indicesBIndex = 0  # indicesB' index

    for i in indicesA:
      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move
      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].
      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:
        indicesBIndex += 1
      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:
        ans.append(i)

    return ans

  def _kmp(self, s: str, pattern: str) -> list[int]:
    """"""Returns the starting indices of all occurrences of the pattern in `s`.""""""

    def getLPS(pattern: str) -> list[int]:
      """"""
      Returns the lps array, where lps[i] is the length of the longest prefix of
      pattern[0..i] which is also a suffix of this substring.
      """"""
      lps = [0] * len(pattern)
      j = 0
      for i in range(1, len(pattern)):
        while j > 0 and pattern[j] != pattern[i]:
          j = lps[j - 1]
        if pattern[i] == pattern[j]:
          lps[i] = j + 1
          j += 1
      return lps

    res = []
    lps = getLPS(pattern)
    i = 0  # s' index
    j = 0  # pattern's index
    while i < len(s):
      if s[i] == pattern[j]:
        i += 1
        j += 1
        if j == len(pattern):
          res.append(i - j)
          j = lps[j - 1]
      # Mismatch after j matches.
      elif j != 0:
          # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
    return res"
"3007","class Solution:
  def findMaximumNumber(self, k: int, x: int) -> int:
    def getSumPrices(num: int) -> int:
      """"""Returns the sum of prices of all numbers from 1 to `num`.""""""
      sumPrices = 0
      # Increment `num` to account the 0-th row in the count of groups.
      num += 1
      for i in range(num.bit_length(), 0, -1):
        if i % x == 0:
          groupSize = 1 << i
          halfGroupSize = 1 << i - 1
          sumPrices += num // groupSize * halfGroupSize
          sumPrices += max(0, (num % groupSize) - halfGroupSize)
      return sumPrices

    return bisect.bisect_right(range(1, 10**15), k,
                               key=lambda m: getSumPrices(m))"
"3008","class Solution:
  # Same as 3006. Find Beautiful Indices in the Given Array I
  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:
    ans = []
    indicesA = self._kmp(s, a)
    indicesB = self._kmp(s, b)
    indicesBIndex = 0  # indicesB' index

    for i in indicesA:
      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move
      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].
      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:
        indicesBIndex += 1
      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:
        ans.append(i)

    return ans

  def _kmp(self, s: str, pattern: str) -> list[int]:
    """"""Returns the starting indices of all occurrences of the pattern in `s`.""""""

    def getLPS(pattern: str) -> list[int]:
      """"""
      Returns the lps array, where lps[i] is the length of the longest prefix of
      pattern[0..i] which is also a suffix of this substring.
      """"""
      lps = [0] * len(pattern)
      j = 0
      for i in range(1, len(pattern)):
        while j > 0 and pattern[j] != pattern[i]:
          j = lps[j - 1]
        if pattern[i] == pattern[j]:
          lps[i] = j + 1
          j += 1
      return lps

    lps = getLPS(pattern)
    res = []
    i = 0  # s' index
    j = 0  # pattern's index
    while i < len(s):
      if s[i] == pattern[j]:
        i += 1
        j += 1
        if j == len(pattern):
          res.append(i - j)
          j = lps[j - 1]
      # Mismatch after j matches.
      elif j != 0:
          # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
    return res"
"3009","class Solution:
  def maxIntersectionCount(self, y: list[int]) -> int:
    ans = 0
    intersectionCount = 0
    line = collections.Counter()

    for i, (a, b) in enumerate(itertools.pairwise(y)):
      start = 2 * a
      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)
      line[min(start, end)] += 1
      line[max(start, end) + 1] -= 1

    for count in sorted(line):
      intersectionCount += line[count]
      ans = max(ans, intersectionCount)

    return ans"
"301","class Solution:
  def removeInvalidParentheses(self, s: str) -> list[str]:
    # Similar to 921. Minimum Add to Make Parentheses Valid
    def getLeftAndRightCounts(s: str) -> tuple[int, int]:
      """"""Returns how many '(' and ')' need to be deleted.""""""
      l = 0
      r = 0

      for c in s:
        if c == '(':
          l += 1
        elif c == ')':
          if l == 0:
            r += 1
          else:
            l -= 1

      return l, r

    def isValid(s: str):
      opened = 0  # the number of '(' - # of ')'
      for c in s:
        if c == '(':
          opened += 1
        elif c == ')':
          opened -= 1
        if opened < 0:
          return False
      return True  # opened == 0

    ans = []

    def dfs(s: str, start: int, l: int, r: int) -> None:
      if l == 0 and r == 0 and isValid(s):
        ans.append(s)
        return

      for i in range(start, len(s)):
        if i > start and s[i] == s[i - 1]:
          continue
        if r > 0 and s[i] == ')':  # Delete s[i]
          dfs(s[:i] + s[i + 1:], i, l, r - 1)
        elif l > 0 and s[i] == '(':  # Delete s[i]
          dfs(s[:i] + s[i + 1:], i, l - 1, r)

    l, r = getLeftAndRightCounts(s)
    dfs(s, 0, l, r)
    return ans"
"3010","class Solution:
  def minimumCost(self, nums: list[int]) -> int:
    kMax = 50
    min1 = kMax
    min2 = kMax

    for i in range(1, len(nums)):
      if nums[i] < min1:
        min2 = min1
        min1 = nums[i]
      elif nums[i] < min2:
        min2 = nums[i]

    return nums[0] + min1 + min2"
"3011","class Solution:
  def canSortArray(self, nums: list[int]) -> int:
    # Divide the array into distinct segments where each segment is comprised
    # of consecutive elements sharing an equal number of set bits. Ensure that
    # for each segment, when moving from left to right, the maximum of a
    # preceding segment is less than the minimum of the following segment.
    prevSetBits = 0
    prevMax = -math.inf  # the maximum of the previous segment
    currMax = -math.inf  # the maximum of the current segment
    currMin = math.inf   # the minimum of the current segment

    for num in nums:
      setBits = num.bit_count()
      if setBits != prevSetBits:  # Start a new segment.
        if prevMax > currMin:
          return False
        prevSetBits = setBits
        prevMax = currMax
        currMax = num
        currMin = num
      else:  # Continue with the current segment.
        currMax = max(currMax, num)
        currMin = min(currMin, num)

    return prevMax <= currMin"
"3012","class Solution:
  def minimumArrayLength(self, nums: list[int]) -> int:
    # Let the minimum number in the array `nums` be x.
    # * If there exists any element nums[i] where nums[i] % x > 0, a new
    #   minimum can be generated and all other numbers can be removed.
    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is
    #   generated which cannot be removed. Therefore, the result will be
    #   (frequency of x + 1) / 2.
    minNum = min(nums)
    if any(num % minNum > 0 for num in nums):
      return 1
    return (nums.count(minNum) + 1) // 2"
"3013","from sortedcontainers import SortedList


class Solution:
  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:
    # Equivalently, the problem is to find nums[0] + the minimum sum of the top
    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.
    windowSum = sum(nums[i] for i in range(1, dist + 2))
    selected = SortedList(nums[i] for i in range(1, dist + 2))
    candidates = SortedList()

    def balance() -> int:
      """"""
      Returns the updated `windowSum` by balancing the multiset `selected` to
      keep the top k - 1 numbers.
      """"""
      nonlocal windowSum
      while len(selected) < k - 1:
        minCandidate = candidates[0]
        windowSum += minCandidate
        selected.add(minCandidate)
        candidates.remove(minCandidate)
      while len(selected) > k - 1:
        maxSelected = selected[-1]
        windowSum -= maxSelected
        selected.remove(maxSelected)
        candidates.add(maxSelected)
      return windowSum

    windowSum = balance()
    minWindowSum = windowSum

    for i in range(dist + 2, len(nums)):
      outOfScope = nums[i - dist - 1]
      if outOfScope in selected:
        windowSum -= outOfScope
        selected.remove(outOfScope)
      else:
        candidates.remove(outOfScope)
      if nums[i] < selected[-1]:  # nums[i] is a better number.
        windowSum += nums[i]
        selected.add(nums[i])
      else:
        candidates.add(nums[i])
      windowSum = balance()
      minWindowSum = min(minWindowSum, windowSum)

    return nums[0] + minWindowSum"
"3014","class Solution:
  def minimumPushes(self, word: str) -> int:
    freqs = sorted(collections.Counter(word).values(), reverse=True)
    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))"
"3015","class Solution:
  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:
    if x > y:
      x, y = y, x

    def bothInRing(ringLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where two houses are located
      in the ring.
      """"""
      res = [0] * n
      for k in range(1, (ringLen - 1) // 2 + 1):
        res[k - 1] += ringLen
      if ringLen % 2 == 0:
        res[ringLen // 2 - 1] += ringLen // 2
      return res

    def bothInTheSameLine(lineLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where two houses are either
      located in the left line [1, x) or the right line (y, n].
      """"""
      res = [0] * n
      for k in range(1, lineLen + 1):
        res[k - 1] += lineLen - k
      return res

    def lineToRing(lineLen: int, ringLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where one house is either
      located in the left line [1, x) or the right line (y, n] and the
      other house is located in the cycle.
      """"""
      res = [0] * n
      for k in range(1, lineLen + ringLen):
        # min(
        #   at most k - 1 since we need to give 1 to the line,
        #   at most ringLen / 2 since for length > ringLen / 2, it can always be
        #     calculated as ringLen - ringLen / 2
        # )
        maxInRingLen = min(k - 1, ringLen // 2)
        # max(at least 0, at lest k - lineLen)
        minInRingLen = max(0, k - lineLen)
        if minInRingLen <= maxInRingLen:
          # Each ring length contributes 2 to the count due to the split of
          # paths when entering the ring: One path traverses the upper half of
          # the ring, and the other traverses the lower half.
          # This is illustrated as follows:
          #   Path 1: ... -- x -- (upper half of the ring)
          #   Path 2: ... -- x -- (lower half of the ring)
          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2
          if minInRingLen == 0:
            # Subtract 1 since there's no split.
            res[k - 1] -= 1
          if maxInRingLen * 2 == ringLen:
            # Subtract 1 since the following case only contribute one:
            #   ... -- x -- (upper half of the ring) -- middle point
            #   ... -- x -- (upper half of the ring) -- middle point
            res[k - 1] -= 1
      return res

    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where one house is in the left
      line [1, x) and the other house is in the right line (y, n].
      """"""
      res = [0] * n
      for k in range(leftLineLen + rightLineLen + 2):
        # min(
        #   at most leftLineLen,
        #   at most k - 1 - (x < y) since we need to give 1 to the right line
        #     and if x < y we need to give another 1 to ""x - y"".
        # )
        maxInLeft = min(leftLineLen, k - 1 - (x < y))
        # max(at least 1, at least k - rightLineLen - (x < y))
        minInLeft = max(1, k - rightLineLen - (x < y))
        if minInLeft <= maxInLeft:
          res[k - 1] += maxInLeft - minInLeft + 1
      return res

    ringLen = y - x + 1
    leftLineLen = x - 1
    rightLineLen = (n - y)

    ans = [0] * n
    ans = list(map(operator.add, ans, bothInRing(ringLen)))
    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))
    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))
    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))
    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))
    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))
    return [freq * 2 for freq in ans]"
"3016","class Solution:
  # Same as 3014. Minimum Number of Pushes to Type Word I
  def minimumPushes(self, word: str) -> int:
    freqs = sorted(collections.Counter(word).values(), reverse=True)
    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))"
"3017","class Solution:
  # Same as 3015. Count the Number of Houses at a Certain Distance I
  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:
    if x > y:
      x, y = y, x

    def bothInRing(ringLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where two houses are located
      in the ring.
      """"""
      res = [0] * n
      for k in range(1, (ringLen - 1) // 2 + 1):
        res[k - 1] += ringLen
      if ringLen % 2 == 0:
        res[ringLen // 2 - 1] += ringLen // 2
      return res

    def bothInTheSameLine(lineLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where two houses are either
      located in the left line [1, x) or the right line (y, n].
      """"""
      res = [0] * n
      for k in range(1, lineLen + 1):
        res[k - 1] += lineLen - k
      return res

    def lineToRing(lineLen: int, ringLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where one house is either
      located in the left line [1, x) or the right line (y, n] and the
      other house is located in the cycle.
      """"""
      res = [0] * n
      for k in range(1, lineLen + ringLen):
        # min(
        #   at most k - 1 since we need to give 1 to the line,
        #   at most ringLen / 2 since for length > ringLen / 2, it can always be
        #     calculated as ringLen - ringLen / 2
        # )
        maxInRingLen = min(k - 1, ringLen // 2)
        # max(at least 0, at lest k - lineLen)
        minInRingLen = max(0, k - lineLen)
        if minInRingLen <= maxInRingLen:
          # Each ring length contributes 2 to the count due to the split of
          # paths when entering the ring: One path traverses the upper half of
          # the ring, and the other traverses the lower half.
          # This is illustrated as follows:
          #   Path 1: ... -- x -- (upper half of the ring)
          #   Path 2: ... -- x -- (lower half of the ring)
          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2
          if minInRingLen == 0:
            # Subtract 1 since there's no split.
            res[k - 1] -= 1
          if maxInRingLen * 2 == ringLen:
            # Subtract 1 since the following case only contribute one:
            #   ... -- x -- (upper half of the ring) -- middle point
            #   ... -- x -- (upper half of the ring) -- middle point
            res[k - 1] -= 1
      return res

    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:
      """"""
      Returns the contribution from the scenario where one house is in the left
      line [1, x) and the other house is in the right line (y, n].
      """"""
      res = [0] * n
      for k in range(leftLineLen + rightLineLen + 2):
        # min(
        #   at most leftLineLen,
        #   at most k - 1 - (x < y) since we need to give 1 to the right line
        #     and if x < y we need to give another 1 to ""x - y"".
        # )
        maxInLeft = min(leftLineLen, k - 1 - (x < y))
        # max(at least 1, at least k - rightLineLen - (x < y))
        minInLeft = max(1, k - rightLineLen - (x < y))
        if minInLeft <= maxInLeft:
          res[k - 1] += maxInLeft - minInLeft + 1
      return res

    ringLen = y - x + 1
    leftLineLen = x - 1
    rightLineLen = (n - y)

    ans = [0] * n
    ans = list(map(operator.add, ans, bothInRing(ringLen)))
    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))
    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))
    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))
    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))
    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))
    return [freq * 2 for freq in ans]"
"3018","class Solution:
  def maximumProcessableQueries(
      self,
      nums: list[int],
      queries: list[int],
  ) -> int:
    n = len(nums)
    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not
    # removed after processing dp[i][j] queries
    dp = [[0] * n for _ in range(n)]

    for d in range(n - 1, -1, -1):
      for i in range(n):
        j = i + d
        if j >= n:
          continue
        if i > 0:
          # Remove nums[i - 1] from nums[i - 1..j] if possible.
          dp[i][j] = max(dp[i][j], dp[i - 1][j] +
                         (nums[i - 1] >= queries[dp[i - 1][j]]))
        if j + 1 < n:
          # Remove nums[j + 1] from nums[i..j + 1] if possible.
          dp[i][j] = max(dp[i][j], dp[i][j + 1] +
                         (nums[j + 1] >= queries[dp[i][j + 1]]))
        if dp[i][j] == len(queries):
          return len(queries)

    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])
               for i in range(n))"
"3019","class Solution:
  def countKeyChanges(self, s: str) -> int:
    return sum(a.lower() != b.lower()
               for a, b in itertools.pairwise(s))"
"302","class Solution:
  def minArea(self, image: list[list[str]], x: int, y: int) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(image)
    n = len(image[0])
    topLeft = [x, y]
    bottomRight = [x, y]
    q = collections.deque([(x, y)])
    image[x][y] = '2'  # Mark as visited.

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        r = i + dx
        c = j + dy
        if r < 0 or r == m or c < 0 or c == n:
          continue
        if image[r][c] != '1':
          continue
        topLeft[0] = min(topLeft[0], r)
        topLeft[1] = min(topLeft[1], c)
        bottomRight[0] = max(bottomRight[0], r)
        bottomRight[1] = max(bottomRight[1], c)
        q.append((r, c))
        image[r][c] = '2'

    width = bottomRight[1] - topLeft[1] + 1
    height = bottomRight[0] - topLeft[0] + 1
    return width * height"
"3020","class Solution:
  def maximumLength(self, nums: list[int]) -> int:
    maxNum = max(nums)
    count = collections.Counter(nums)
    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1

    for num in nums:
      if num == 1:
        continue
      length = 0
      x = num
      while x <= maxNum and x in count and count[x] >= 2:
        length += 2
        x *= x
      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].
      # The goal is to determine if we can insert x^k in the middle of the
      # pattern to increase the length by 1. If not, we make x^(k/2) the middle
      # and decrease the length by 1.
      ans = max(ans, length + (1 if x in count else -1))

    return ans"
"3021","class Solution:
  def flowerGame(self, n: int, m: int) -> int:
    # Alice wins if x + y is odd, occurring when:
    #   1. x is even and y is odd, or
    #   2. y is even and x is odd.
    xEven = n // 2
    yEven = m // 2
    xOdd = (n + 1) // 2
    yOdd = (m + 1) // 2
    return xEven * yOdd + yEven * xOdd"
"3022","class Solution:
  def minOrAfterOperations(self, nums: list[int], k: int) -> int:
    kMaxBit = 30
    ans = 0
    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111

    for i in range(kMaxBit, -1, -1):
      # Add the i-th bit to `prefixMask` and attempt to ""turn off"" the
      # currently added bit within k operations. If it's impossible, then we
      # add the i-th bit to the answer.
      prefixMask |= 1 << i
      if self._getMergeOps(nums, prefixMask, ans) > k:
        ans |= 1 << i

    return ans

  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:
    """"""
    Returns the number of merge operations to turn `prefixMask` to the target
    by ANDing `nums`.
    """"""
    mergeOps = 0
    ands = prefixMask
    for num in nums:
      ands &= num
      if (ands | target) == target:
        ands = prefixMask
      else:
        mergeOps += 1  # Keep merging the next num
    return mergeOps"
"3023","# Definition for an infinite stream.
# class InfiniteStream:
#   def next(self) -> int:
#     pass

class Solution:
  def findPattern(
      self,
      stream: Optional['InfiniteStream'],
      pattern: list[int],
  ) -> int:
    lps = self._getLPS(pattern)
    i = 0  # stream's index
    j = 0  # pattern's index
    bit = 0  # the bit in the stream
    readNext = False
    while True:
      if not readNext:
        bit = stream.next()
        readNext = True
      if bit == pattern[j]:
        i += 1
        readNext = False
        j += 1
        if j == len(pattern):
          return i - j
      # Mismatch after j matches.
      elif j > 0:
        # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
        readNext = False

  def _getLPS(self, pattern: list[int]) -> list[int]:
    """"""
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """"""
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        j += 1
        lps[i] = j
    return lps"
"3024","class Solution:
  def triangleType(self, nums: list[int]) -> str:
    nums.sort()
    if nums[0] + nums[1] <= nums[2]:
      return 'none'
    if nums[0] == nums[1] and nums[1] == nums[2]:
      return 'equilateral'
    if nums[0] == nums[1] or nums[1] == nums[2]:
      return 'isosceles'
    return 'scalene'"
"3025","class Solution:
  def numberOfPairs(self, points: list[list[int]]) -> int:
    ans = 0

    points.sort(key=lambda x: (x[0], -x[1]))

    for i, (_, yi) in enumerate(points):
      maxY = -math.inf
      for j in range(i + 1, len(points)):
        _, yj = points[j]
        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the
        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that
        # nobody other than Chisato and Takina is inside or on the fence.
        if yi >= yj > maxY:
          ans += 1
          maxY = yj

    return ans"
"3026","class Solution:
  def maximumSubarraySum(self, nums: list[int], k: int) -> int:
    ans = -math.inf
    prefix = 0
    numToMinPrefix = {}

    for num in nums:
      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:
        numToMinPrefix[num] = prefix
      prefix += num
      if num + k in numToMinPrefix:
        ans = max(ans, prefix - numToMinPrefix[num + k])
      if num - k in numToMinPrefix:
        ans = max(ans, prefix - numToMinPrefix[num - k])

    return 0 if ans == -math.inf else ans"
"3027","class Solution:
  # Same as 3025. Find the Number of Ways to Place People I
  def numberOfPairs(self, points: list[list[int]]) -> int:
    ans = 0

    points.sort(key=lambda x: (x[0], -x[1]))

    for i, (_, yi) in enumerate(points):
      maxY = -math.inf
      for j in range(i + 1, len(points)):
        _, yj = points[j]
        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the
        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that
        # nobody other than Chisato and Takina is inside or on the fence.
        if yi >= yj > maxY:
          ans += 1
          maxY = yj

    return ans"
"3028","class Solution:
  def returnToBoundaryCount(self, nums: list[int]) -> int:
    return sum(prefix == 0 for prefix in itertools.accumulate(nums))"
"3029","class Solution:
  # Same as 3029. Minimum Time to Revert Word to Initial State I
  def minimumTimeToInitialState(self, word: str, k: int) -> int:
    n = len(word)
    maxOps = (n - 1) // k + 1
    z = self._zFunction(word)

    for ans in range(1, maxOps):
      if z[ans * k] >= n - ans * k:
        return ans

    return maxOps

  def _zFunction(self, s: str) -> list[int]:
    """"""
    Returns the z array, where z[i] is the length of the longest prefix of
    s[i..n) which is also a prefix of s.

    https://cp-algorithms.com/string/z-function.html#implementation
    """"""
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z"
"303","class NumArray:
  def __init__(self, nums: list[int]):
    self.prefix = list(itertools.accumulate(nums, initial=0))

  def sumRange(self, left: int, right: int) -> int:
    return self.prefix[right + 1] - self.prefix[left]"
"3030","class Solution:
  def resultGrid(
      self,
      image: list[list[int]],
      threshold: int,
  ) -> list[list[int]]:
    m = len(image)
    n = len(image[0])
    sums = [[0] * n for _ in range(m)]
    counts = [[0] * n for _ in range(m)]

    for i in range(m - 2):
      for j in range(n - 2):
        if self._isRegion(image, i, j, threshold):
          subgridSum = sum(image[x][y]
                           for x in range(i, i + 3)
                           for y in range(j, j + 3))
          for x in range(i, i + 3):
            for y in range(j, j + 3):
              sums[x][y] += subgridSum // 9
              counts[x][y] += 1

    for i in range(m):
      for j in range(n):
        if counts[i][j] > 0:
          image[i][j] = sums[i][j] // counts[i][j]

    return image

  def _isRegion(
      self,
      image: list[list[int]],
      i: int,
      j: int,
      threshold: int,
  ) -> bool:
    """"""Returns True if image[i..i + 2][j..j + 2] is a region.""""""
    for x in range(i, i + 3):
      for y in range(j, j + 3):
        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:
          return False
        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:
          return False
    return True"
"3031","class Solution:
  # Same as 3029. Minimum Time to Revert Word to Initial State I
  def minimumTimeToInitialState(self, word: str, k: int) -> int:
    n = len(word)
    maxOps = (n - 1) // k + 1
    z = self._zFunction(word)

    for ans in range(1, maxOps):
      if z[ans * k] >= n - ans * k:
        return ans

    return maxOps

  def _zFunction(self, s: str) -> list[int]:
    """"""
    Returns the z array, where z[i] is the length of the longest prefix of
    s[i..n) which is also a prefix of s.

    https://cp-algorithms.com/string/z-function.html#implementation
    """"""
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z"
"3032","class Solution:
  def numberCount(self, a: int, b: int) -> int:
    return sum(len(set(str(num))) == len(str(num))
               for num in range(a, b + 1))"
"3033","class Solution:
  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:
    m = len(matrix)
    n = len(matrix[0])
    ans = matrix.copy()

    for j in range(n):
      mx = max(matrix[i][j] for i in range(m))
      for i in range(m):
        if matrix[i][j] == -1:
          ans[i][j] = mx

    return ans"
"3034","class Solution:
  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:
    def getNum(a: int, b: int) -> int:
      if a < b:
        return 1
      if a > b:
        return -1
      return 0

    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]
    return self._kmp(numsPattern, pattern)

  def _kmp(self, nums: list[int], pattern: list[int]) -> int:
    """"""Returns the number of occurrences of the pattern in `nums`.""""""

    def getLPS(nums: list[int]) -> list[int]:
      """"""
      Returns the lps array, where lps[i] is the length of the longest prefix of
      nums[0..i] which is also a suffix of this substring.
      """"""
      lps = [0] * len(nums)
      j = 0
      for i in range(1, len(nums)):
        while j > 0 and nums[j] != nums[i]:
          j = lps[j - 1]
        if nums[i] == nums[j]:
          lps[i] = j + 1
          j += 1
      return lps

    lps = getLPS(pattern)
    res = 0
    i = 0  # s' index
    j = 0  # pattern's index
    while i < len(nums):
      if nums[i] == pattern[j]:
        i += 1
        j += 1
        if j == len(pattern):
          res += 1
          j = lps[j - 1]
      # Mismatch after j matches.
      elif j != 0:
          # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
    return res"
"3035","class Solution:
  def maxPalindromesAfterOperations(self, words: list[str]) -> int:
    ans = 0
    count = collections.Counter(''.join(words))
    pairs = sum(value // 2 for value in count.values())

    for length in sorted(len(word) for word in words):
      needPairs = length // 2
      if pairs < needPairs:
        return ans
      ans += 1
      pairs -= needPairs

    return ans"
"3036","class Solution:
  # Same as 3034. Number of Subarrays That Match a Pattern I
  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:
    def getNum(a: int, b: int) -> int:
      if a < b:
        return 1
      if a > b:
        return -1
      return 0

    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]
    return self._kmp(numsPattern, pattern)

  def _kmp(self, nums: list[int], pattern: list[int]) -> int:
    """"""Returns the number of occurrences of the pattern in `nums`.""""""

    def getLPS(nums: list[int]) -> list[int]:
      """"""
      Returns the lps array, where lps[i] is the length of the longest prefix of
      nums[0..i] which is also a suffix of this substring.
      """"""
      lps = [0] * len(nums)
      j = 0
      for i in range(1, len(nums)):
        while j > 0 and nums[j] != nums[i]:
          j = lps[j - 1]
        if nums[i] == nums[j]:
          lps[i] = j + 1
          j += 1
      return lps

    lps = getLPS(pattern)
    res = 0
    i = 0  # s' index
    j = 0  # pattern's index
    while i < len(nums):
      if nums[i] == pattern[j]:
        i += 1
        j += 1
        if j == len(pattern):
          res += 1
          j = lps[j - 1]
      # Mismatch after j matches.
      elif j != 0:
          # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
    return res"
"3037","# Definition for an infinite stream.
# class InfiniteStream:
#   def next(self) -> int:
#     pass

class Solution:
  # Same as 3023. Find Pattern in Infinite Stream I
  def findPattern(
      self,
      stream: Optional['InfiniteStream'],
      pattern: list[int]
  ) -> int:
    lps = self._getLPS(pattern)
    i = 0  # stream's index
    j = 0  # pattern's index
    bit = 0  # the bit in the stream
    readNext = False
    while True:
      if not readNext:
        bit = stream.next()
        readNext = True
      if bit == pattern[j]:
        i += 1
        readNext = False
        j += 1
        if j == len(pattern):
          return i - j
      # Mismatch after j matches.
      elif j > 0:
        # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
        readNext = False

  def _getLPS(self, pattern: list[int]) -> list[int]:
    """"""
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """"""
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        j += 1
        lps[i] = j
    return lps"
"3038","class Solution:
  def maxOperations(self, nums: list[int]) -> int:
    ans = 1
    summ = nums[0] + nums[1]

    for i in range(2, len(nums) - 1, 2):
      if nums[i] + nums[i + 1] == summ:
        ans += 1
      else:
        break

    return ans"
"3039","class Solution:
  def lastNonEmptyString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    maxFreq = max(count.values())

    for c in reversed(s):
      if count[c] == maxFreq:
        ans.append(c)
        count[c] -= 1

    return ''.join(reversed(ans))"
"304","class NumMatrix:
  def __init__(self, matrix: list[list[int]]):
    if not matrix:
      return

    m = len(matrix)
    n = len(matrix[0])
    # prefix[i][j] := the sum of matrix[0..i)[0..j)
    self.prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        self.prefix[i + 1][j + 1] = (matrix[i][j] + self.prefix[i][j + 1] +
                                     self.prefix[i + 1][j] - self.prefix[i][j])

  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
    return (self.prefix[row2 + 1][col2 + 1] - self.prefix[row1][col2 + 1] -
            self.prefix[row2 + 1][col1] + self.prefix[row1][col1])"
"3040","class Solution:
  def maxOperations(self, nums: list[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, score: int) -> int:
      """"""
      Returns the maximum number of operations that can be performed for
      nums[i..j], s.t. all operations have the same `score`.
      """"""
      if i >= j:
        return 0
      deleteFirstTwo = (1 + dp(i + 2, j, score)
                        if nums[i] + nums[i + 1] == score else 0)
      deleteLastTwo = (1 + dp(i, j - 2, score)
                       if nums[j] + nums[j - 1] == score else 0)
      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)
                            if nums[i] + nums[j] == score else 0)
      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)

    n = len(nums)
    return max(dp(0, n - 1, nums[0] + nums[1]),
               dp(0, n - 1, nums[-1] + nums[-2]),
               dp(0, n - 1, nums[0] + nums[-1]))"
"3041","class Solution:
  def maxSelectedElements(self, nums: list[int]) -> int:
    ans = 1
    prev = -math.inf
    # the length of the longest consecutive elements (seq0) ending in the
    # previous number
    dp0 = 1
    # the length of the longest consecutive elements (seq1) ending in the
    # previous number + 1
    dp1 = 1

    for num in sorted(nums):
      if num == prev:
        dp1 = dp0 + 1  # Append `num + 1` to seq0.
      elif num == prev + 1:
        dp0 += 1  # Append `num` to seq0.
        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.
      elif num == prev + 2:
        dp0 = dp1 + 1  # Append `num` to seq1.
        dp1 = 1        # Start a new sequence [`num + 1`].
      else:
        dp0 = 1  # Start a new sequence [`num`].
        dp1 = 1  # Start a new sequence [`num + 1`].
      ans = max(ans, dp0, dp1)
      prev = num

    return ans"
"3042","class TrieNode:
  def __init__(self):
    self.children: dict[tuple[str, str], TrieNode] = {}
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> int:
    node = self.root
    count = 0
    for i, prefix in enumerate(word):
      suffix = word[-i - 1]
      node = node.children.setdefault((prefix, suffix), TrieNode())
      count += node.count
    node.count += 1
    return count


class Solution:
  def countPrefixSuffixPairs(self, words: list[str]) -> int:
    trie = Trie()
    return sum(trie.insert(word) for word in words)"
"3043","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str) -> int:
    prefixLength = 0
    node = self.root
    for c in word:
      if c not in node.children:
        break
      node = node.children[c]
      prefixLength += 1
    return prefixLength


class Solution:
  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:
    trie = Trie()

    for num in arr1:
      trie.insert(str(num))

    return max(trie.search(str(num)) for num in arr2)"
"3044","class Solution:
  def mostFrequentPrime(self, mat: list[list[int]]) -> int:
    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),
            (-1, 0), (-1, 1), (0, 1), (1, 1))
    m = len(mat)
    n = len(mat[0])
    count = collections.Counter()

    def isPrime(num: int) -> bool:
      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))

    for i in range(m):
      for j in range(n):
        for dx, dy in dirs:
          num = 0
          x = i
          y = j
          while 0 <= x < m and 0 <= y < n:
            num = num * 10 + mat[x][y]
            if num > 10 and isPrime(num):
              count[num] += 1
            x += dx
            y += dy

    if not count.items():
      return -1
    return max(count.items(), key=lambda x: (x[1], x[0]))[0]"
"3045","class TrieNode:
  def __init__(self):
    self.children: dict[tuple[str, str], TrieNode] = {}
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> int:
    node = self.root
    count = 0
    for i, prefix in enumerate(word):
      suffix = word[-i - 1]
      node = node.children.setdefault((prefix, suffix), TrieNode())
      count += node.count
    node.count += 1
    return count


class Solution:
  # Same as 3045. Count Prefix and Suffix Pairs II
  def countPrefixSuffixPairs(self, words: list[str]) -> int:
    trie = Trie()
    return sum(trie.insert(word) for word in words)"
"3046","class Solution:
  def isPossibleToSplit(self, nums: list[int]) -> bool:
    return all(freq <= 2 for freq in collections.Counter(nums).values())"
"3047","class Solution:
  def largestSquareArea(
      self,
      bottomLeft: list[list[int]],
      topRight: list[list[int]],
  ) -> int:
    minSide = 0

    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (
            itertools.combinations(zip(bottomLeft, topRight), 2)):
      overlapX = min(ax2, bx2) - max(ax1, bx1)
      overlapY = min(ay2, by2) - max(ay1, by1)
      minSide = max(minSide, min(overlapX, overlapY))

    return minSide**2"
"3048","class Solution:
  def earliestSecondToMarkIndices(
      self,
      nums: list[int],
      changeIndices: list[int],
  ) -> int:
    def canMark(second: int) -> bool:
      """"""
      Returns True if all indices of `nums` can be marked within `second`.
      """"""
      numMarked = 0
      decrement = 0
      indexToLastSecond = {}

      for i in range(second):
        indexToLastSecond[changeIndices[i] - 1] = i

      for i in range(second):
        index = changeIndices[i] - 1  # Convert to 0-indexed
        if i == indexToLastSecond[index]:
          # Reach the last occurrence of the number.
          # So, the current second will be used to mark the index.
          if nums[index] > decrement:
            # The decrement is less than the number to be marked.
            return False
          decrement -= nums[index]
          numMarked += 1
        else:
          decrement += 1

      return numMarked == len(nums)

    l = bisect.bisect_left(range(1, len(changeIndices) + 1), True,
                           key=lambda m: canMark(m)) + 1
    return l if l <= len(changeIndices) else -1"
"3049","class Solution:
  def earliestSecondToMarkIndices(
      self,
      nums: list[int],
      changeIndices: list[int],
  ) -> int:
    # {the second: the index of nums can be zeroed at the current second}
    secondToIndex = self._getSecondToIndex(nums, changeIndices)
    numsSum = sum(nums)

    def canMark(maxSecond: int) -> bool:
      """"""
      Returns True if all indices of `nums` can be marked within `maxSecond`.
      """"""
      # Use a min-heap to greedily pop out the minimum number, which yields the
      # least saving.
      minHeap = []
      marks = 0

      for second in range(maxSecond - 1, -1, -1):
        if second in secondToIndex:
          # The number mapped by the index is a candidate to be zeroed out.
          index = secondToIndex[second]
          heapq.heappush(minHeap, nums[index])
          if marks == 0:
            # Running out of marks, so need to pop out the minimum number.
            # So, the current second will be used to mark an index.
            heapq.heappop(minHeap)
            marks += 1
          else:
            # There're enough marks.
            # So, the current second will be used to zero out a number.
            marks -= 1
        else:
          # There's no candidate to be zeroed out.
          # So, the current second will be used to mark an index.
          marks += 1

      decrementAndMarkCost = ((numsSum - sum(minHeap)) +
                              (len(nums) - len(minHeap)))
      zeroAndMarkCost = len(minHeap) + len(minHeap)
      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond

    l = bisect.bisect_left(range(1, len(changeIndices) + 1), True,
                           key=lambda m: canMark(m)) + 1
    return l if l <= len(changeIndices) else -1

  def _getSecondToIndex(
      self,
      nums: list[int],
      changeIndices: list[int],
  ) -> dict[int, int]:
    # {the `index` of nums: the earliest second to zero out nums[index]}
    indexToFirstSecond = {}
    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):
      index = oneIndexedIndex - 1  # Convert to 0-indexed.
      if nums[index] > 0 and index not in indexToFirstSecond:
        indexToFirstSecond[index] = zeroIndexedSecond
    return {second: index for index, second in indexToFirstSecond.items()}"
"305","class UnionFind:
  def __init__(self, n: int):
    self.id = [-1] * n
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def numIslands2(
      self,
      m: int,
      n: int,
      positions: list[list[int]],
  ) -> list[int]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = []
    seen = [[False] * n for _ in range(m)]
    uf = UnionFind(m * n)
    count = 0

    def getId(i: int, j: int, n: int) -> int:
      return i * n + j

    for i, j in positions:
      if seen[i][j]:
        ans.append(count)
        continue
      seen[i][j] = True
      id = getId(i, j, n)
      uf.id[id] = id
      count += 1
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        neighborId = getId(x, y, n)
        if uf.id[neighborId] == -1:  # water
          continue
        currentParent = uf.find(id)
        neighborParent = uf.find(neighborId)
        if currentParent != neighborParent:
          uf.unionByRank(currentParent, neighborParent)
          count -= 1
      ans.append(count)

    return ans"
"3050","SELECT
  CONCAT(T1.topping_name, ',', T2.topping_name, ',', T3.topping_name) AS pizza,
  ROUND(T1.cost + T2.cost + T3.cost, 2) AS total_cost
FROM Toppings AS T1
INNER JOIN Toppings AS T2
  ON (T1.topping_name < T2.topping_name)
INNER JOIN Toppings AS T3
  ON (T2.topping_name < T3.topping_name)
ORDER BY total_cost DESC, pizza;"
"3051","SELECT candidate_id
FROM Candidates
WHERE skill IN ('Python', 'Tableau', 'PostgreSQL')
GROUP BY 1
HAVING COUNT(skill) = 3
ORDER BY 1;"
"3052","WITH
  Prime AS (
    SELECT SUM(square_footage) AS sum_square_footage
    FROM Inventory
    WHERE item_type = 'prime_eligible'
  )
SELECT
  'prime_eligible' AS item_type,
  COUNT(*) * FLOOR(500000 / Prime.sum_square_footage) AS item_count
FROM Inventory, Prime
WHERE item_type = 'prime_eligible'
UNION ALL
SELECT
  'not_prime',
  COUNT(*) * FLOOR(500000 % Prime.sum_square_footage / SUM(square_footage))
FROM Inventory, Prime
WHERE item_type = 'not_prime';"
"3053","SELECT
  (
    CASE
      WHEN A = B AND B = C THEN 'Equilateral'
      WHEN
        A = B AND A + B > C OR
        A = C AND A + C > B OR
        B = C AND B + C > A THEN 'Isosceles'
      WHEN A + B > C AND A + C > B AND B + C > A THEN 'Scalene'
      ELSE 'Not A Triangle'
    END
  ) AS triangle_type
FROM Triangles;"
"3054","# Similar to 608. Tree Node
SELECT DISTINCT Parent.N,
  (
    CASE
      WHEN Parent.P IS NULL THEN 'Root'
      WHEN Parent.P IS NOT NULL AND Child.P IS NOT NULL THEN 'Inner'
      WHEN Parent.P IS NOT NULL AND Child.P IS NULL THEN 'Leaf'
    END
  ) AS type
FROM Tree AS Parent
LEFT JOIN Tree AS Child
  ON (Parent.N = Child.P)
ORDER BY 1;"
"3055","WITH
  FraudPercentile AS (
    SELECT
      policy_id,
      state,
      fraud_score,
      PERCENT_RANK() OVER(
        PARTITION BY state
        ORDER BY fraud_score DESC
      ) AS `percent_rank`
    FROM Fraud
  )
SELECT policy_id, state, fraud_score
FROM FraudPercentile
WHERE `percent_rank` < 0.05
ORDER BY state, fraud_score DESC, policy_id;"
"3056","SELECT
  Age.age_bucket,
  ROUND(
    SUM(IF(Activities.activity_type = 'send', Activities.time_spent, 0)) /
    SUM(Activities.time_spent) * 100,
    2
  ) AS send_perc,
  ROUND(
    SUM(IF(Activities.activity_type = 'open', Activities.time_spent, 0)) /
    SUM(Activities.time_spent) * 100,
    2
  ) AS open_perc
FROM Activities
INNER JOIN Age
  USING (user_id)
GROUP BY 1;"
"3057","WITH
  EmployeesWithAvgWorkload AS (
    SELECT
      Employees.employee_id,
      Employees.name AS employee_name,
      Project.project_id,
      Project.workload AS project_workload,
      AVG(workload) OVER(PARTITION BY team) AS avg_team_workload
    FROM Project
    INNER JOIN Employees
      USING (employee_id)
)
SELECT
  employee_id,
  project_id,
  employee_name,
  project_workload
FROM EmployeesWithAvgWorkload
WHERE project_workload > avg_team_workload
ORDER BY 1, 2;"
"3058","WITH
  TwoWayFriends AS (
    SELECT user_id1 AS user_id, user_id2 AS friend_id FROM Friends
    UNION ALL
    SELECT user_id2, user_id1 FROM Friends
  ),
  UserToMutualFriend AS (
    SELECT
      User1.user_id,
      User2.user_id AS friend_id
    FROM TwoWayFriends AS User1
    INNER JOIN TwoWayFriends AS User2
      USING (friend_id)
    WHERE User1.user_id != User2.user_id
  )
SELECT Friends.* FROM Friends
LEFT JOIN UserToMutualFriend
  ON (
    Friends.user_id1 = UserToMutualFriend.user_id
    AND Friends.user_id2 = UserToMutualFriend.friend_id)
WHERE UserToMutualFriend.friend_id IS NULL
ORDER BY 1, 2;"
"3059","SELECT
  SUBSTRING_INDEX(email, '@', -1) AS email_domain,
  COUNT(*) AS count
FROM Emails
WHERE email LIKE '%.com'
GROUP BY 1
ORDER BY 1;"
"306","class Solution:
  def isAdditiveNumber(self, num: str) -> bool:
    n = len(num)

    def dfs(firstNum: int, secondNum: int, s: int) -> bool:
      if s == len(num):
        return True

      thirdNum = firstNum + secondNum
      thirdNumStr = str(thirdNum)

      return (num.find(thirdNumStr, s) == s and
              dfs(secondNum, thirdNum, s + len(thirdNumStr)))

    # num[0..i] = firstNum
    for i in range(n // 2):
      if i > 0 and num[0] == '0':
        return False
      firstNum = int(num[:i + 1])
      # num[i + 1..j] = secondNum
      # |thirdNum| >= max(|firstNum|, |secondNum|)
      j = i + 1
      while max(i, j - i) < n - j:
        if j > i + 1 and num[i + 1] == '0':
          break
        secondNum = int(num[i + 1:j + 1])
        if dfs(firstNum, secondNum, j + 1):
          return True
        j += 1

    return False"
"3060","WITH
  SessionDifferences AS (
    SELECT
      user_id,
      session_start,
      LAG(session_end) OVER(
        PARTITION BY user_id, session_type
        ORDER BY session_end
      ) AS prev_session_end
    FROM Sessions
  )
SELECT DISTINCT user_id
FROM SessionDifferences
WHERE TIMESTAMPDIFF(HOUR, prev_session_end, session_start) <= 12
ORDER BY 1;"
"3061","WITH
  HeightsWithMinMax AS (
    SELECT
      height,
      MAX(height) OVER(ORDER BY id ASC) AS prev_max_height,
      MAX(height) OVER(ORDER BY id DESC) AS next_max_height
    FROM Heights
  )
SELECT
  SUM(LEAST(prev_max_height, next_max_height) - height) AS total_trapped_water
FROM HeightsWithMinMax;"
"3062","class Solution:
  def gameResult(self, head: ListNode | None) -> str:
    even = 0
    odd = 0

    while head:
      if head.val > head.next.val:
        even += 1
      elif head.val < head.next.val:
        odd += 1
      head = head.next.next

    if even > odd:
      return 'Even'
    if even < odd:
      return 'Odd'
    return 'Tie'"
"3063","class Solution:
  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:
    count = collections.Counter()
    curr = head

    while curr:
      count[curr.val] += 1
      curr = curr.next

    dummy = ListNode(0)
    tail = dummy

    for freq in count.values():
      tail.next = ListNode(freq)
      tail = tail.next

    return dummy.next"
"3064","# Definition of commonSetBits API.
# def commonSetBits(num: int) -> int:

class Solution:
  def findNumber(self) -> int:
    return sum(1 << i for i in range(31)
               if commonSetBits(1 << i) == 1)"
"3065","class Solution:
  def minOperations(self, nums: list[int], k: int) -> int:
    return sum(num < k for num in nums)"
"3066","class Solution:
  def minOperations(self, nums: list[int], k: int) -> int:
    ans = 0
    minHeap = nums.copy()
    heapq.heapify(minHeap)

    while len(minHeap) > 1 and minHeap[0] < k:
      x = heapq.heappop(minHeap)
      y = heapq.heappop(minHeap)
      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))
      ans += 1

    return ans"
"3067","class Solution:
  def countPairsOfConnectableServers(
      self,
      edges: list[list[int]],
      signalSpeed: int,
  ) -> list[int]:
    n = len(edges) + 1
    tree = [[] for _ in range(n)]

    for u, v, w in edges:
      tree[u].append((v, w))
      tree[v].append((u, w))

    def connectablePairsRootedAt(u: int) -> int:
      pairs = 0
      count = 0
      for v, w in tree[u]:
        childCount = dfs(v, u, w)
        pairs += count * childCount
        count += childCount
      return pairs

    def dfs(u: int, prev: int, dist: int) -> int:
      return (int(dist % signalSpeed == 0) +
              sum(dfs(v, u, dist + w)
              for v, w in tree[u]
              if v != prev))

    return [connectablePairsRootedAt(i) for i in range(n)]"
"3068","class Solution:
  def maximumValueSum(
      self,
      nums: list[int],
      k: int,
      edges: list[list[int]],
  ) -> int:
    maxSum = sum(max(num, num ^ k) for num in nums)
    changedCount = sum((num ^ k) > num for num in nums)
    if changedCount % 2 == 0:
      return maxSum
    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)
    return maxSum - minChangeDiff"
"3069","class Solution:
  def resultArray(self, nums: list[int]) -> list[int]:
    arr1 = [nums[0]]
    arr2 = [nums[1]]

    for i in range(2, len(nums)):
      if arr1[-1] > arr2[-1]:
        arr1.append(nums[i])
      else:
        arr2.append(nums[i])

    return arr1 + arr2"
"307","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class NumArray:
  def __init__(self, nums: list[int]):
    self.nums = nums
    self.tree = FenwickTree(len(nums))
    for i, num in enumerate(nums):
      self.tree.add(i + 1, num)

  def update(self, index: int, val: int) -> None:
    self.tree.add(index + 1, val - self.nums[index])
    self.nums[index] = val

  def sumRange(self, left: int, right: int) -> int:
    return self.tree.get(right + 1) - self.tree.get(left)"
"3070","class Solution:
  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    # prefix[i][j] := the sum of matrix[0..i)[0..j)
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +
                                prefix[i + 1][j] - prefix[i][j])
        if prefix[i + 1][j + 1] <= k:
          ans += 1

    return ans"
"3071","class Solution:
  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:
    n = len(grid)
    mid = n // 2

    def getOperations(a: int, b: int) -> int:
      """"""Returns the number of operations to turn Y into a and non-Y into b.""""""
      operations = 0
      for i, row in enumerate(grid):
        for j, num in enumerate(row):
          # For the 'Y' pattern, before the midpoint, check the diagonal and
          # anti-diagonal. After the midpoint, check the middle column.
          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:
            if num != a:
              operations += 1
          elif num != b:
            operations += 1
      return operations

    return min(getOperations(0, 1), getOperations(0, 2),
               getOperations(1, 0), getOperations(1, 2),
               getOperations(2, 0), getOperations(2, 1))"
"3072","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def resultArray(self, nums: list[int]) -> list[int]:
    arr1 = []
    arr2 = []
    ranks = self._getRanks(nums)
    tree1 = FenwickTree(len(ranks))
    tree2 = FenwickTree(len(ranks))

    def add(num: int, arr: list[int], tree: FenwickTree) -> None:
      arr.append(num)
      tree.add(ranks[num], 1)

    add(nums[0], arr1, tree1)
    add(nums[1], arr2, tree2)

    for i in range(2, len(nums)):
      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])
      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])
      if greaterCount1 > greaterCount2:
        add(nums[i], arr1, tree1)
      elif greaterCount1 < greaterCount2:
        add(nums[i], arr2, tree2)
      elif len(arr1) > len(arr2):
        add(nums[i], arr2, tree2)
      else:
        add(nums[i], arr1, tree1)

    return arr1 + arr2

  def _getRanks(self, nums: list[int]) -> dict[int, int]:
    ranks = collections.Counter()
    rank = 0
    for num in sorted(set(nums)):
      rank += 1
      ranks[num] = rank
    return ranks"
"3073","from sortedcontainers import SortedSet


class Solution:
  def maximumTripletValue(self, nums: list[int]) -> int:
    ans = 0
    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))
    leftSortedSet = SortedSet([nums[0]])

    for i in range(len(nums) - 2, -1, -1):
      rightMax[i] = max(nums[i + 1], rightMax[i + 1])

    for j in range(1, len(nums) - 1):
      i = bisect.bisect_left(leftSortedSet, nums[j])
      if i > 0 and rightMax[j] > nums[j]:
        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])
      leftSortedSet.add(nums[j])

    return ans"
"3074","class Solution:
  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:
    appleSum = sum(apple)
    capacitySum = 0

    for i, c in enumerate(sorted(capacity, reverse=True)):
      capacitySum += c
      if capacitySum >= appleSum:
        return i + 1

    return len(capacity)"
"3075","class Solution:
  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:
    ans = 0
    decremented = 0

    happiness.sort(reverse=True)

    for i in range(k):
      ans += max(0, happiness[i] - decremented)
      decremented += 1

    return ans"
"3076","class Solution:
  def shortestSubstrings(self, arr: list[str]) -> list[str]:
    ans = []
    count = collections.Counter()

    def getSubstrings(s: str) -> Iterator[str]:
      for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
          yield s[i:j]

    def add(s: str) -> None:
      """"""Adds all substrings of s to `count`.""""""
      for sub in getSubstrings(s):
        count[sub] += 1

    def remove(s: str) -> None:
      """"""Removes all substrings of s from `count`.""""""
      for sub in getSubstrings(s):
        count[sub] -= 1

    def getMinSub(s: str) -> str:
      minSub = ''
      for sub in getSubstrings(s):
        if count[sub] > 0:
          continue
        if minSub == ('' or
                      len(sub) < len(minSub) or
                      len(sub) == len(minSub) and sub < minSub):
          minSub = sub
      return minSub

    for s in arr:
      add(s)

    for s in arr:
      remove(s)
      ans.append(getMinSub(s))
      add(s)

    return ans"
"3077","class Solution:
  def maximumStrength(self, nums: list[int], k: int) -> int:

    @functools.lru_cache(None)
    def dp(i: int, k: int, fresh: bool) -> int:
      """"""
      Returns the maximum strength of nums[i..n) with k operations left, where
      `fresh` means we're starting a new subarray.
      """"""
      if len(nums) - i < k:
        return -math.inf
      if k == 0:
        return 0
      if i == len(nums):
        return 0 if k == 0 else -math.inf
      # If it's not fresh, we can't skip the current number and consider it as a
      # fresh start, since the case where it's fresh is already covered by
      # `includeAndFreshStart`.
      skip = dp(i + 1, k, True) if fresh else -math.inf
      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k
      includeAndContinue = dp(i + 1, k, False) + gain
      includeAndFreshStart = dp(i + 1, k - 1, True) + gain
      return max(skip, includeAndContinue, includeAndFreshStart)

    return dp(0, k, True)"
"3078","class Solution:
  def findPattern(
      self,
      board: list[list[int]],
      pattern: list[str],
  ) -> list[int]:
    def isMatch(x: int, y: int) -> bool:
      digitToLetter = {}
      letterToDigit = {}
      for i, row in enumerate(pattern):
        for j, c in enumerate(row):
          digit = board[i + x][j + y]
          if c.isdigit():
            if int(c) != digit:
              return False
          else:
            if digitToLetter.get(digit, c) != c:
              return False
            if letterToDigit.get(c, digit) != digit:
              return False
            digitToLetter[digit] = c
            letterToDigit[c] = digit
      return True

    for x in range(len(board) - len(pattern) + 1):
      for y in range(len(board[0]) - len(pattern[0]) + 1):
        if isMatch(x, y):
          return [x, y]

    return [-1, -1]"
"3079","class Solution:
  def sumOfEncryptedInt(self, nums: list[int]) -> int:
    def getEncrypted(num: int) -> int:
      maxDigit = 0
      base = 0
      while num > 0:
        maxDigit = max(maxDigit, num % 10)
        base = base * 10 + 1
        num //= 10
      return base * maxDigit

    return sum(getEncrypted(num) for num in nums)"
"308","class FenwickTree:
  def __init__(self, m: int, n: int):
    self.sums = [[0] * (n + 1) for _ in range(m + 1)]

  def add(self, row: int, col: int, delta: int) -> None:
    i = row
    while i < len(self.sums):
      j = col
      while j < len(self.sums[0]):
        self.sums[i][j] += delta
        j += FenwickTree.lowbit(j)
      i += FenwickTree.lowbit(i)

  def get(self, row: int, col: int) -> int:
    summ = 0
    i = row
    while i > 0:
      j = col
      while j > 0:
        summ += self.sums[i][j]
        j -= FenwickTree.lowbit(j)
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class NumMatrix:
  def __init__(self, matrix: list[list[int]]):
    self.matrix = matrix
    self.tree = FenwickTree(len(matrix), len(matrix[0]))

    for i in range(len(matrix)):
      for j, val in enumerate(matrix[i]):
        self.tree.add(i + 1, j + 1, val)

  def update(self, row: int, col: int, val: int) -> None:
    self.tree.add(row + 1, col + 1, val - self.matrix[row][col])
    self.matrix[row][col] = val

  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
    return (self.tree.get(row2 + 1, col2 + 1) - self.tree.get(row1, col2 + 1) -
            self.tree.get(row2 + 1, col1) + self.tree.get(row1, col1))"
"3080","class Solution:
  def unmarkedSumArray(
      self,
      nums: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    ans = []
    marked = set()
    summ = sum(nums)
    minHeap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(minHeap)

    for index, k in queries:
      if index not in marked:
        marked.add(index)
        summ -= nums[index]
      popped = 0
      while popped < k and minHeap:
        num, i = heapq.heappop(minHeap)
        if i not in marked:
          marked.add(i)
          summ -= num
          popped += 1
      ans.append(summ)

    return ans"
"3081","class Solution:
  def minimizeStringValue(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    letters = []

    del count['?']

    def getMinFreqLetter(count: dict[str, int]) -> str:
      minFreqLetter = 'a'
      for c in string.ascii_lowercase:
        if count[c] < count[minFreqLetter]:
          minFreqLetter = c
      return minFreqLetter

    for c in s:
      if c == '?':
        minFreqLetter = getMinFreqLetter(count)
        letters.append(minFreqLetter)
        count[minFreqLetter] += 1

    letters.sort()
    i = 0  # letters' index

    for c in s:
      if c == '?':
        ans.append(letters[i])
        i += 1
      else:
        ans.append(c)

    return ''.join(ans)"
"3082","class Solution:
  def sumOfPower(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of subsequences in nums so far that sums to k
    dp = [1] + [0] * k

    for num in nums:
      for i in range(k, -1, -1):
        if i < num:
          dp[i] = (dp[i] * 2) % kMod
        else:
          dp[i] = (dp[i] * 2 + dp[i - num]) % kMod

    return dp[k]"
"3083","class Solution:
  def isSubstringPresent(self, s: str) -> bool:
    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))"
"3084","class Solution:
  def countSubstrings(self, s: str, c: str) -> int:
    freq = s.count(c)
    return freq * (freq + 1) // 2"
"3085","class Solution:
  def minimumDeletions(self, word: str, k: int) -> int:
    ans = math.inf
    count = collections.Counter(word)

    for minFreq in count.values():
      deletions = 0
      for freq in count.values():
        if freq < minFreq:
          deletions += freq
        else:
          deletions += max(0, freq - (minFreq + k))
      ans = min(ans, deletions)

    return ans"
"3086","class Solution:
  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:
    # Dylan has two actions for collecting '1's in a sequence:
    # Action 1: Put a '1' next to him and pick it up.
    #           The cost is 2.
    # Action 2: Swap a '1' towards him and collect it.
    #           The cost equals the distance to the '1'.
    #
    # To minimize the swapping cost, Dylan can use a sliding window strategy,
    # selecting the optimal position (middle '1' in the window) for efficient
    # collection. The window's size is crucial:

    # The minimum window size: min(0, k - maxChanges), ensuring the window
    # isn't too small.
    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),
    # preventing overly ambitious swaps.
    #
    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's
    # cheaper to use Action 1.

    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have
    # a distance <= 1 from dylanIndex, implying that we'll be taking at most
    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and
    # should be replaced with Action 1.
    kNumOfIndicesWithinOneDistance = 3
    ans = math.inf
    oneIndices = [i for i, num in enumerate(nums) if num == 1]
    prefix = list(itertools.accumulate(oneIndices, initial=0))

    minOnesByTwo = max(0, k - maxChanges)
    maxOnesByTwo = min(
        k, minOnesByTwo + kNumOfIndicesWithinOneDistance, len(oneIndices))

    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):
      for l in range(len(prefix) - onesByTwo):
        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].
        cost1 = (k - onesByTwo) * 2
        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -
                 (prefix[(l + r + 1) // 2] - prefix[l]))
        ans = min(ans, cost1 + cost2)

    return ans"
"3087","SELECT
  CONCAT(
    '#',
    SUBSTRING_INDEX(SUBSTRING_INDEX(tweet, '#', -1), ' ', 1)
  ) AS hashtag,
  COUNT(*) AS hashtag_count
FROM Tweets
WHERE MONTH(tweet_date) = 2
GROUP BY hashtag
ORDER BY hashtag_count DESC, hashtag DESC
LIMIT 3;"
"3088","class Solution:
  def makeAntiPalindrome(self, s: str) -> str:
    n = len(s)
    i = n // 2
    chars = sorted(list(s))
    if chars[i] != chars[n - i - 1]:
      return ''.join(chars)

    j = self._getFirstDiffIndexInSecondHalf(chars)
    while chars[i] == chars[n - i - 1]:
      if j == n:
        return '-1'
      chars[i], chars[j] = chars[j], chars[i]
      i += 1
      j += 1

    return ''.join(chars)

  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:
    """"""
    Returns the first index in chars[n / 2..n) that is different from the first
    letter of the second half, chars[n / 2].
    """"""
    n = len(chars)
    firstLetter = chars[n // 2]
    firstDiffIndex = n // 2
    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:
      firstDiffIndex += 1
    return firstDiffIndex"
"3089","WITH
  FilteredPosts AS (
    SELECT *
    FROM Posts
    WHERE post_date BETWEEN '2024-02-01' AND '2024-02-28'
  ),
  AvgWeeklyPosts AS (
    SELECT user_id, COUNT(*) / 4.0 AS avg_weekly_posts
    FROM FilteredPosts
    GROUP BY 1
  ),
  UserTo7dayPosts AS (
    SELECT
      FirstPost.user_id,
      COUNT(*) AS sevenday_posts
    FROM Posts AS FirstPost
    INNER JOIN Posts AS FollowingPost
      ON (
        FirstPost.user_id = FollowingPost.user_id
        AND FollowingPost.post_date BETWEEN FirstPost.post_date
        AND DATE_ADD(FirstPost.post_date, INTERVAL 6 DAY))
    GROUP BY FirstPost.user_id, FirstPost.post_date
  ),
  UserToMax7dayPosts AS (
    SELECT user_id, MAX(sevenday_posts) AS max_7day_posts
    FROM UserTo7dayPosts
    GROUP BY 1
  )
SELECT *
FROM UserToMax7dayPosts
INNER JOIN AvgWeeklyPosts
  USING (user_id)
WHERE UserToMax7dayPosts.max_7day_posts >= 2 * AvgWeeklyPosts.avg_weekly_posts
ORDER BY user_id;"
"309","class Solution:
  def maxProfit(self, prices: list[int]) -> int:
    sell = 0
    hold = -math.inf
    prev = 0

    for price in prices:
      cache = sell
      sell = max(sell, hold + price)
      hold = max(hold, prev - price)
      prev = cache

    return sell"
"3090","class Solution:
  def maximumLengthSubstring(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] > 2:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"3091","class Solution:
  def minOperations(self, k: int) -> int:
    # The required operations are
    #   1. Increase `1` to `x`
    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.
    # The number of operations used would be (x - 1) + y. Equivalently, the
    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.
    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and
    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.
    x = math.ceil(math.sqrt(k))
    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1
    return x - 1 + y"
"3092","from sortedcontainers import SortedDict


class Solution:
  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:
    ans = []
    numCount = collections.Counter()  # {num: freq}
    freqCount = SortedDict()  # {num's freq: freq}

    for num, f in zip(nums, freq):
      if numCount[num] > 0:
        numFreq = numCount[num]
        freqCount[numFreq] -= 1
        if freqCount[numFreq] == 0:
          del freqCount[numFreq]
      newFreq = numCount[num] + f
      if newFreq == 0:
        del numCount[num]
      else:
        numCount[num] = newFreq
        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1
      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)

    return ans"
"3093","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.isWord = False
    self.length = math.inf
    self.index = -1


class Solution:
  def stringIndices(
      self,
      wordsContainer: list[str],
      wordsQuery: list[str],
  ) -> list[int]:
    ans = []
    root = TrieNode()
    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]

    def insert(word: str, index: int) -> None:
      node = root
      for c in reversed(word):
        node = node.children.setdefault(c, TrieNode())
        if node.length > len(word):
          node.length = len(word)
          node.index = index

    def search(word: str) -> int:
      node = root
      for c in reversed(word):
        if c not in node.children:
          return node.index
        node = node.children[c]
      return node.index

    for i, word in enumerate(wordsContainer):
      insert(word, i)

    for query in wordsQuery:
      index = search(query)
      ans.append(minIndex if index == -1 else index)

    return ans"
"3094","# Definition of commonBits API.
# def commonBits(num: int) -> int:

class Solution:
  def findNumber(self) -> int:
    return functools.reduce(lambda x, i: x | (1 << i)
                            if commonBits(1 << i) > commonBits(1 << i)
                            else x, range(31), 0)"
"3095","class Solution:
  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:
    ans = len(nums) + 1
    ors = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      ors = self._orNum(ors, num, count)
      while ors >= k and l <= r:
        ans = min(ans, r - l + 1)
        ors = self._undoOrNum(ors, nums[l], count)
        l += 1

    return -1 if ans == len(nums) + 1 else ans

  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] += 1
        if count[i] == 1:
          ors += 1 << i
    return ors

  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] -= 1
        if count[i] == 0:
          ors -= 1 << i
    return ors"
"3096","class Solution:
  def minimumLevels(self, possible: list[int]) -> int:
    n = len(possible)
    nums = [num if num == 1 else -1 for num in possible]
    prefix = list(itertools.accumulate(nums, initial=0))

    for i in range(1, n):
      if prefix[i] > prefix[n] - prefix[i]:
        return i

    return -1"
"3097","class Solution:
  # Same as 3095. Shortest Subarray With OR at Least K I
  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:
    ans = len(nums) + 1
    ors = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      ors = self._orNum(ors, num, count)
      while ors >= k and l <= r:
        ans = min(ans, r - l + 1)
        ors = self._undoOrNum(ors, nums[l], count)
        l += 1

    return -1 if ans == len(nums) + 1 else ans

  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] += 1
        if count[i] == 1:
          ors += 1 << i
    return ors

  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] -= 1
        if count[i] == 0:
          ors -= 1 << i
    return ors"
"3098","class Solution:
  def sumOfPowers(self, nums: list[int], k: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)

    nums.sort()

    @functools.lru_cache(None)
    def dp(i: int, k: int, lastPickIndex: int, minDiff: int) -> int:
      if k == 0:
        return minDiff
      if i == n:
        return 0
      newMinDiff = (minDiff if lastPickIndex == - 1
                    else min(minDiff, nums[i] - nums[lastPickIndex]))
      pick = dp(i + 1, k - 1, i, newMinDiff)
      skip = dp(i + 1, k, lastPickIndex, minDiff)
      return (pick + skip) % kMod

    return dp(0, k, -1, math.inf)"
"3099","class Solution:
  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
    digitSum = self._getDigitSum(x)
    return digitSum if x % digitSum == 0 else -1

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))"
"31","class Solution:
  def nextPermutation(self, nums: list[int]) -> None:
    n = len(nums)

    # From back to front, find the first number < nums[i + 1].
    i = n - 2
    while i >= 0:
      if nums[i] < nums[i + 1]:
        break
      i -= 1

    # From back to front, find the first number > nums[i], swap it with nums[i].
    if i >= 0:
      for j in range(n - 1, i, -1):
        if nums[j] > nums[i]:
          nums[i], nums[j] = nums[j], nums[i]
          break

    def reverse(nums: list[int], l: int, r: int) -> None:
      while l < r:
        nums[l], nums[r] = nums[r], nums[l]
        l += 1
        r -= 1

    # Reverse nums[i + 1..n - 1].
    reverse(nums, i + 1, len(nums) - 1)"
"310","class Solution:
  def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:
    if n == 1 or not edges:
      return [0]

    ans = []
    graph = collections.defaultdict(set)

    for u, v in edges:
      graph[u].add(v)
      graph[v].add(u)

    for label, children in graph.items():
      if len(children) == 1:
        ans.append(label)

    while n > 2:
      n -= len(ans)
      nextLeaves = []
      for leaf in ans:
        u = next(iter(graph[leaf]))
        graph[u].remove(leaf)
        if len(graph[u]) == 1:
          nextLeaves.append(u)
      ans = nextLeaves

    return ans"
"3100","class Solution:
  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
    ans = numBottles

    while numBottles >= numExchange:
      numBottles = numBottles - numExchange + 1
      numExchange += 1
      ans += 1

    return ans"
"3101","class Solution:
  def countAlternatingSubarrays(self, nums: list[int]) -> int:
    # dp[i] := the number of alternating subarrays ending in index i
    dp = [1] * len(nums)

    for i in range(1, len(nums)):
      if nums[i] != nums[i - 1]:
        dp[i] += dp[i - 1]

    return sum(dp)"
"3102","class Solution:
  def minimumDistance(self, points: list[list[int]]) -> int:
    i, j = self._maxManhattanDistance(points, -1)
    xi, yi = self._maxManhattanDistance(points, i)
    xj, yj = self._maxManhattanDistance(points, j)
    return min(self._manhattan(points, xi, yi),
               self._manhattan(points, xj, yj))

  def _maxManhattanDistance(
      self,
      points: list[list[int]],
      excludedIndex: int,
  ) -> int:
    minSum = math.inf
    maxSum = -math.inf
    minDiff = math.inf
    maxDiff = -math.inf
    minSumIndex = -1
    maxSumIndex = -1
    minDiffIndex = -1
    maxDiffIndex = -1

    for i, (x, y) in enumerate(points):
      if i == excludedIndex:
        continue
      summ = x + y
      diff = x - y
      if summ < minSum:
        minSum = summ
        minSumIndex = i
      if summ > maxSum:
        maxSum = summ
        maxSumIndex = i
      if diff < minDiff:
        minDiff = diff
        minDiffIndex = i
      if diff > maxDiff:
        maxDiff = diff
        maxDiffIndex = i

    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff
            else [minDiffIndex, maxDiffIndex])

  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:
    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])"
"3103","WITH
  RECURSIVE FebruaryTweets AS (
    SELECT * FROM Tweets
    WHERE YEAR(tweet_date) = 2024 AND MONTH(tweet_date) = 2
  ),
  HashtagToTweet AS (
    SELECT
      REGEXP_SUBSTR(tweet, '#[^\\s]+') AS hashtag,
      REGEXP_REPLACE(tweet, '#[^\\s]+', '', 1, 1) AS tweet
    FROM FebruaryTweets
    UNION ALL
    SELECT
      REGEXP_SUBSTR(tweet, '#[^\\s]+') AS hashtag,
      REGEXP_REPLACE(tweet, '#[^\\s]+', '', 1, 1) AS tweet
    FROM HashtagToTweet
    WHERE POSITION('#' IN tweet) > 0
  )
SELECT
  hashtag,
  COUNT(*) AS count
FROM HashtagToTweet
GROUP BY hashtag
ORDER BY count DESC, hashtag DESC
LIMIT 3;"
"3104","class Solution:
  def maxSubstringLength(self, s: str) -> int:
    allCount = collections.Counter(s)

    # Similar to 395. Longest Substring with At Least K Repeating Characters
    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:
      res = -1
      # the number of unique letters
      uniqueLetters = 0
      # the number of letters that have all their frequency in the substring
      lettersHavingAllFreq = 0
      count = collections.Counter()

      l = 0
      for r, c in enumerate(s):
        count[c] += 1
        if count[c] == 1:
          uniqueLetters += 1
        if count[c] == allCount[c]:
          lettersHavingAllFreq += 1
        while uniqueLetters > n:
          if count[s[l]] == allCount[s[l]]:
            lettersHavingAllFreq -= 1
          count[s[l]] -= 1
          if count[s[l]] == 0:
            uniqueLetters -= 1
          l += 1
        # Since both the number of unique letters and the number of letters
        # having all their frequency are equal to n, this is a valid window.
        # Implcit: uniqueLetters == n
        if lettersHavingAllFreq == n and r - l + 1 < len(s):
          res = max(res, r - l + 1)

      return res

    return max(maxSubstringLengthWithNUniqueLetters(n)
               for n in range(1, 27))"
"3105","class Solution:
  # Similar to 978. Longest Turbulent Subarray
  def longestMonotonicSubarray(self, nums: list[int]) -> int:
    ans = 1
    increasing = 1
    decreasing = 1

    for i in range(1, len(nums)):
      if nums[i] > nums[i - 1]:
        increasing += 1
        decreasing = 1
      elif nums[i] < nums[i - 1]:
        decreasing += 1
        increasing = 1
      else:
        increasing = 1
        decreasing = 1
      ans = max(ans, increasing, decreasing)

    return ans"
"3106","class Solution:
  def getSmallestString(self, s: str, k: int) -> str:
    ans = list(s)

    for i, c in enumerate(s):
      if k == 0:
        break
      distToA = min(string.ascii_lowercase.index(c), ord('z') - ord(c) + 1)
      if k >= distToA:
        k -= distToA
        ans[i] = 'a'
      else:
        # k is not enough to change the current letter to 'a', so move as closer
        # to 'a' as possible.
        ans[i] = chr(ord(c) - k)
        k = 0

    return ''.join(ans)"
"3107","class Solution:
  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:
    n = len(nums)
    ans = 0

    nums.sort()

    for i in range(n // 2 + 1):
      ans += max(0, nums[i] - k)

    for i in range(n // 2, n):
      ans += max(0, k - nums[i])

    return ans"
"3108","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n
    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.
    self.weight = [(1 << 17) - 1] * n

  def unionByRank(self, u: int, v: int, w: int) -> None:
    i = self._find(u)
    j = self._find(v)
    newWeight = self.weight[i] & self.weight[j] & w
    self.weight[i] = newWeight
    self.weight[j] = newWeight
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def getMinCost(self, u: int, v: int) -> int:
    if u == v:
      return 0
    i = self._find(u)
    j = self._find(v)
    return self.weight[i] if i == j else -1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def minimumCost(
      self,
      n: int,
      edges: list[list[int]],
      query: list[list[int]],
  ) -> list[int]:
    uf = UnionFind(n)

    for u, v, w in edges:
      uf.unionByRank(u, v, w)

    return [uf.getMinCost(u, v) for u, v in query]"
"3109","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def getPermutationIndex(self, perm: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(perm)
    ans = 0
    tree = FenwickTree(n)
    fact = [1] * (n + 1)  # fact[i] := i!

    for i in range(2, n + 1):
      fact[i] = (fact[i - 1] * i) % kMod

    for i, num in enumerate(perm):
      # the number of unused numbers less than `num`
      unusedNums = num - 1 - tree.get(num - 1)
      suffixLength = fact[n - 1 - i]
      ans += unusedNums * suffixLength
      ans %= kMod
      tree.add(num, 1)

    return ans"
"311","class Solution:
  def multiply(self, mat1: list[list[int]],
               mat2: list[list[int]]) -> list[list[int]]:
    m = len(mat1)
    n = len(mat2)
    l = len(mat2[0])
    ans = [[0] * l for _ in range(m)]

    for i in range(m):
      for j in range(l):
        for k in range(n):
          ans[i][j] += mat1[i][k] * mat2[k][j]

    return ans"
"3110","class Solution:
  def scoreOfString(self, s: str) -> int:
    return sum(abs(ord(a) - ord(b))
               for a, b in itertools.pairwise(s))"
"3111","class Solution:
  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:
    ans = 0
    prevX = -w - 1
    xs = sorted([x for x, _ in points])

    for x in xs:
      if x > prevX + w:
        ans += 1
        prevX = x

    return ans"
"3112","class Solution:
  def minimumTime(
      self,
      n: int,
      edges: list[list[int]],
      disappear: list[int],
  ) -> list[int]:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, disappear)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      disappear: list[int],
  ) -> list[int]:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < disappear[v] and d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return [d if d != math.inf else -1
            for d in dist]"
"3113","class Solution:
  def numberOfSubarrays(self, nums: list[int]) -> int:
    ans = 0
    stack = []

    for num in nums:
      while stack and stack[-1][0] < num:
        stack.pop()
      if not stack or stack[-1][0] != num:
        stack.append([num, 0])
      stack[-1][1] += 1
      ans += stack[-1][1]

    return ans"
"3114","class Solution:
  # Similar to 1736. Latest Time by Replacing Hidden Digits
  def findLatestTime(self, s: str) -> str:
    ans = list(s)
    if s[0] == '?':
      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'
    if s[1] == '?':
      ans[1] = '1' if ans[0] == '1' else '9'
    if s[3] == '?':
      ans[3] = '5'
    if s[4] == '?':
      ans[4] = '9'
    return ''.join(ans)"
"3115","class Solution:
  def maximumPrimeDifference(self, nums: list[int]) -> int:
    kMax = 100
    isPrime = self._sieveEratosthenes(kMax + 1)
    minPrimeIndex = -1
    maxPrimeIndex = -1

    for i, num in enumerate(nums):
      if isPrime[num]:
        if minPrimeIndex == -1:
          minPrimeIndex = i
        maxPrimeIndex = i

    return maxPrimeIndex - minPrimeIndex

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"3116","class Solution:
  def findKthSmallest(self, coins: list[int], k: int) -> int:
    sizeToLcms = self._getSizeToLcms(coins)

    def count(m: int) -> int:
      """"""Returns the number of denominations <= m.""""""
      res = 0
      for sz, lcms in enumerate(sizeToLcms):
        for lcm in lcms:
          # Principle of Inclusion-Exclusion (PIE)
          res += m // lcm * pow(-1, sz + 1)
      return res

    return bisect.bisect_left(range(k * min(coins)), k,
                              key=lambda m: count(m))

  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:
    # Returns the LCMs for each number of combination of coins.
    sizeToLcms = [[] for _ in range(len(coins) + 1)]
    for sz in range(1, len(coins) + 1):
      for combination in itertools.combinations(coins, sz):
        sizeToLcms[sz].append(math.lcm(*combination))
    return sizeToLcms"
"3117","class Solution:
  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:
    n = len(nums)
    m = len(andValues)

    @functools.lru_cache(None)
    def dp(i: int, j: int, mask: int) -> int:
      """"""
      Returns the minimum value sum of nums[i..n) and andValues[j..m), where
      `mask` is the running value of the current subarray.
      """"""
      if i == n and j == m:
        return 0
      if i == n or j == m:
        return math.inf
      mask &= nums[i]
      if mask < andValues[j]:
        return math.inf
      if mask == andValues[j]:
        # 1. Keep going.
        # 2. End the subarray here and pick nums[i], then fresh start.
        return min(dp(i + 1, j, mask),
                   nums[i] + dp(i + 1, j + 1, -1))
      return dp(i + 1, j, mask)  # Keep going.

    ans = dp(0, 0, -1)
    return ans if ans < math.inf else -1"
"3118","WITH
  RECURSIVE Fridays AS (
    SELECT 1 AS week_of_month, '2023-11-03' AS purchase_date
    UNION ALL
    SELECT week_of_month + 1, DATE_ADD(purchase_date, INTERVAL 7 DAY)
    FROM Fridays
    WHERE week_of_month < 4
  ),
  Memberships AS (
    SELECT 'Premium' AS membership
    UNION ALL
    SELECT 'VIP'
  )
SELECT
  Fridays.week_of_month,
  Memberships.membership,
  IFNULL(SUM(Purchases.amount_spend), 0) AS total_amount
FROM Fridays
CROSS JOIN Memberships
LEFT JOIN Users
  ON (Memberships.membership = Users.membership)
LEFT JOIN Purchases
  ON (
    Fridays.purchase_date = Purchases.purchase_date
    AND Users.user_id = Purchases.user_id)
GROUP BY 1, 2
ORDER BY 1, 2;"
"3119","class Solution:
  def maxPotholes(self, road: str, budget: int) -> int:
    ans = 0

    for length in sorted(map(len, road.split('.')), reverse=True):
      canRepair = max(0, budget - 1)
      if length > canRepair:
        return ans + canRepair
      ans += length
      budget -= length + 1

    return ans"
"312","class Solution:
  def maxCoins(self, nums: list[int]) -> int:
    n = len(nums)
    # dp[i][j] := maxCoins(nums[i..j])
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    nums = [1] + nums + [1]

    for d in range(n):
      for i in range(1, n - d + 1):
        j = i + d
        for k in range(i, j + 1):
          dp[i][j] = max(
              dp[i][j],
              dp[i][k - 1] +
              dp[k + 1][j] +
              nums[i - 1] * nums[k] * nums[j + 1])

    return dp[1][n]"
"3120","class Solution:
  def numberOfSpecialChars(self, word: str) -> int:
    lower = collections.defaultdict(bool)
    upper = collections.defaultdict(bool)

    for c in word:
      if c.islower():
        lower[c] = True
      else:
        upper[c] = True

    return sum(lower[a] and upper[b]
               for a, b in zip(string.ascii_lowercase,
                               string.ascii_uppercase))"
"3121","class Solution:
  def numberOfSpecialChars(self, word: str) -> int:
    lower = collections.defaultdict(bool)
    upper = collections.defaultdict(bool)

    for c in word:
      if c.islower():
        lower[c] = not upper[c.upper()]
      else:
        upper[c] = True

    return sum(lower[a] and upper[b]
               for a, b in zip(string.ascii_lowercase,
                               string.ascii_uppercase))"
"3122","class Solution:
  def minimumOperations(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    count = [[0] * 10 for _ in range(n)]

    for row in grid:
      for j, num in enumerate(row):
        count[j][num] += 1

    @functools.lru_cache(None)
    def dp(i: int, prev: int) -> int:
      """"""
      Returns the number of minimum operations needed to make grid[:][j..n)
      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.
      """"""
      if i == n:
        return 0

      res = math.inf

      for num in range(10):
        if i == 0 or num != prev:
          res = min(res, m - count[i][num] + dp(i + 1, num))

      return res

    return dp(0, 0)"
"3123","class Solution:
  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths
  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    from0 = self._dijkstra(graph, 0)
    from1 = self._dijkstra(graph, n - 1)
    return [from0[u] + w + from1[v] == from0[-1] or
            from0[v] + w + from1[u] == from0[-1]
            for u, v, w in edges]

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
  ) -> list[int]:
    dist = [10**9] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist"
"3124","WITH
  RankedCalls AS (
    SELECT
      Contacts.first_name,
      Calls.type,
      Calls.duration,
      RANK() OVER(
        PARTITION BY type
        ORDER BY duration DESC
      ) AS `rank`
    FROM Calls
    INNER JOIN Contacts
      ON (Calls.contact_id = Contacts.id)
  )
SELECT
  first_name,
  type,
  CONCAT(
    LPAD(FLOOR(duration / 3600), 2, '0'), ':',
    LPAD(FLOOR((duration % 3600) / 60), 2, '0'), ':',
    LPAD(FLOOR(duration % 60), 2, '0')
  ) AS duration_formatted
FROM RankedCalls
WHERE `rank` <= 3
ORDER BY type, duration DESC, first_name DESC;"
"3125","class Solution:
  def maxNumber(self, n: int) -> int:
    # assume n = 0b00...11???
    #        x = 0b00...01111
    #  since y = 0b00...10000 is in [x, n]
    #    and x & y = 0
    return (1 << n.bit_length() - 1) - 1"
"3126","WITH
  ServerNeighbors AS (
    SELECT
      status_time,
      session_status,
      LEAD(status_time) OVER(
        PARTITION BY server_id
        ORDER BY status_time
      ) AS next_status_time
    FROM Servers
  )
SELECT
  FLOOR(
    SUM(
      TIMESTAMPDIFF(SECOND, status_time, next_status_time)
    ) / 86400
  ) AS total_uptime_days
FROM ServerNeighbors
WHERE ServerNeighbors.session_status = 'start';"
"3127","class Solution:
  def canMakeSquare(self, grid: list[list[str]]) -> bool:
    for i in range(2):
      for j in range(2):
        black = 0
        white = 0
        for x in range(2):
          for y in range(2):
            if grid[i + x][j + y] == 'B':
              black += 1
            else:
              white += 1
        if black >= 3 or white >= 3:
          return True
    return False"
"3128","class Solution:
  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:
    rows = [0] * len(grid)
    cols = [0] * len(grid[0])

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num == 1:
          rows[i] += 1
          cols[j] += 1

    return sum((rows[i] - 1) * (cols[j] - 1)
               for i, row in enumerate(grid)
               for j, num in enumerate(row)
               if num == 1)"
"3129","class Solution:
  # Same as 3129. Find All Possible Stable Binary Arrays I
  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of stable arrays, where the number of
    # occurrences of 0 is i and the number of occurrences of 1 is j and the last
    # number is k (0/1)
    dp = [[[0] * 2
           for _ in range(one + 1)]
          for _ in range(zero + 1)]

    for i in range(min(zero, limit) + 1):
      dp[i][0][0] = 1

    for j in range(min(one, limit) + 1):
      dp[0][j][1] = 1

    for i in range(1, zero + 1):
      for j in range(1, one + 1):
        dp[i][j][0] = (
            dp[i - 1][j][0] + dp[i - 1][j][1] -
            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + kMod) % kMod
        dp[i][j][1] = (
            dp[i][j - 1][0] + dp[i][j - 1][1] -
            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + kMod) % kMod

    return (dp[zero][one][0] + dp[zero][one][1]) % kMod"
"313","class Solution:
  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:
    k = len(primes)
    nums = [1]
    indices = [0] * k

    while len(nums) < n:
      nexts = [0] * k
      for i in range(k):
        nexts[i] = nums[indices[i]] * primes[i]
      next = min(nexts)
      for i in range(k):
        if next == nexts[i]:
          indices[i] += 1
      nums.append(next)

    return nums[-1]"
"3130","class Solution:
  # Same as 3129. Find All Possible Stable Binary Arrays I
  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of stable arrays, where the number of
    # occurrences of 0 is i and the number of occurrences of 1 is j and the last
    # number is k (0/1)
    dp = [[[0] * 2
          for _ in range(one + 1)]
          for _ in range(zero + 1)]

    for i in range(min(zero, limit) + 1):
      dp[i][0][0] = 1

    for j in range(min(one, limit) + 1):
      dp[0][j][1] = 1

    for i in range(1, zero + 1):
      for j in range(1, one + 1):
        dp[i][j][0] = (
            dp[i - 1][j][0] + dp[i - 1][j][1] -
            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + kMod) % kMod
        dp[i][j][1] = (
            dp[i][j - 1][0] + dp[i][j - 1][1] -
            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + kMod) % kMod

    return (dp[zero][one][0] + dp[zero][one][1]) % kMod"
"3131","class Solution:
  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:
    return min(nums2) - min(nums1)"
"3132","class Solution:
  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:
    # After removing two elements from nums1, either nums1[0], nums1[1], or
    # nums1[2] will persist. Therefore, the difference between nums1 (with two
    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where
    # 0 <= i <= 2.
    ans = math.inf

    nums1.sort()
    nums2.sort()

    for i in range(3):
      inc = nums2[0] - nums1[i]
      if self._isValidDiff(nums1, nums2, inc):
        ans = min(ans, inc)

    return ans

  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:
    """"""
    Returns True if it's possible to increase nums1 (with two elements removed)
    by `inc` to nums2.
    """"""
    removed = 0
    i = 0  # nums2's index

    for num in nums1:
      if num + inc == nums2[i]:
        i += 1
        if i == len(nums2):
          break
      else:
        removed += 1

    return removed <= 2"
"3133","class Solution:
  def minEnd(self, n: int, x: int) -> int:
    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This
    # operation increase x for (n - 1) iterations while preserving x's 1s.
    kMaxBit = n.bit_length() + x.bit_length()
    k = n - 1
    kBinaryIndex = 0

    for i in range(kMaxBit):
      if x >> i & 1 == 0:
        # Set x's 0 with k's bit if the running bit of k is 1.
        if k >> kBinaryIndex & 1:
          x |= 1 << i
        kBinaryIndex += 1

    return x"
"3134","class Solution:
  def medianOfUniquenessArray(self, nums: list[int]):
    n = len(nums)
    subarrayCount = n * (n + 1) // 2
    medianCount = (subarrayCount + 1) // 2

    # Similar to 992. Subarrays with K Different Integers
    def subarraysWithAtMostKDistinct(k: int) -> int:
      res = 0
      count = collections.Counter()

      l = 0
      for r, num in enumerate(nums):
        count[num] += 1
        if count[num] == 1:
          k -= 1
        while k < 0:
          count[nums[l]] -= 1
          if count[nums[l]] == 0:
            k += 1
          l += 1
        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]

      return res

    return bisect.bisect_left(range(1, n), medianCount,
                              key=lambda m: subarraysWithAtMostKDistinct(m)) + 1"
"3135","class Solution:
  def minOperations(self, initial: str, target: str) -> int:
    m = len(initial)
    n = len(target)
    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if initial[i - 1] == target[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]

    return m + n - 2 * max(map(max, dp))"
"3136","class Solution:
  def isValid(self, word: str) -> bool:
    kVowels = 'aeiouAEIOU'

    def isConsonant(c: str) -> bool:
      return c.isalpha() and c not in kVowels

    return (len(word) >= 3 and
            all(c.isalnum() for c in word) and
            any(c in kVowels for c in word) and
            any(isConsonant(c) for c in word))"
"3137","class Solution:
  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:
    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))
    return len(word) // k - max(count.values())"
"3138","class Solution:
  def minAnagramLength(self, s: str) -> int:
    n = len(s)
    for k in range(1, n + 1):
      if n % k == 0 and self._canFormAnagram(s, k):
        return k
    return n

  def _canFormAnagram(self, s: str, k: int) -> bool:
    """"""Returns True if we can concatenate an anagram of length k to s.""""""
    anagramCount = collections.Counter(s[:k])
    return all(collections.Counter(s[i:i + k]) == anagramCount
               for i in range(k, len(s), k))"
"3139","class Solution:
  def minCostToEqualizeArray(
      self,
      nums: list[int],
      cost1: int,
      cost2: int,
  ) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    minNum = min(nums)
    maxNum = max(nums)
    summ = sum(nums)

    if cost1 * 2 <= cost2 or n < 3:
      totalGap = maxNum * n - summ
      return (cost1 * totalGap) % kMod

    def getMinCost(target: int) -> int:
      """"""Returns the minimum cost to make all numbers equal to `target`.""""""
      maxGap = target - minNum
      totalGap = target * n - summ
      # Pair one shallowest number with one non-shallowest number, so the worst
      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.
      pairs = min(totalGap // 2, totalGap - maxGap)
      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs

    return min(getMinCost(target)
               for target in range(maxNum, 2 * maxNum)) % kMod"
"314","class Solution:
  def verticalOrder(self, root: TreeNode | None) -> list[list[int]]:
    if not root:
      return []

    range_ = [0] * 2

    def getRange(root: TreeNode | None, x: int) -> None:
      if not root:
        return

      range_[0] = min(range_[0], x)
      range_[1] = max(range_[1], x)

      getRange(root.left, x - 1)
      getRange(root.right, x + 1)

    getRange(root, 0)  # Get the leftmost and the rightmost x index.

    ans = [[] for _ in range(range_[1] - range_[0] + 1)]
    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)

    while q:
      node, x = q.popleft()
      ans[x].append(node.val)
      if node.left:
        q.append((node.left, x - 1))
      if node.right:
        q.append((node.right, x + 1))

    return ans"
"3140","WITH
  FreeSeats AS (
    SELECT
      *,
      seat_id - ROW_NUMBER() OVER(ORDER BY seat_id) AS group_id
    FROM Cinema
    WHERE free = 1
  ),
  RankedFreeSeats AS (
    SELECT
      MIN(seat_id) AS first_seat_id,
      MAX(seat_id) AS last_seat_id,
      COUNT(*) AS consecutive_seats_len,
      RANK() OVER(ORDER BY COUNT(*) DESC) AS `rank`
    FROM FreeSeats
    GROUP BY group_id
  )
SELECT first_seat_id, last_seat_id, consecutive_seats_len
FROM RankedFreeSeats
WHERE `rank` = 1
ORDER BY 1;"
"3141","class Solution:
  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:
    kMaxMask = 1 << m
    # dp[i] := the maximum hamming distance from i to any number in `nums`
    dp = [-math.inf] * kMaxMask

    for num in nums:
      dp[num] = 0

    for bit in range(m):
      newDp = [0] * kMaxMask
      for mask in range(kMaxMask):
        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)
      dp = newDp

    return [dp[num] for num in nums]"
"3142","class Solution:
  def satisfiesConditions(self, grid: list[list[int]]) -> bool:
    m = len(grid)
    n = len(grid[0])
    return (all(grid[i][j] == grid[i + 1][j]
                for i in range(m - 1)
                for j in range(n)) and
            all(grid[i][j] != grid[i][j + 1]
                for i in range(m)
                for j in range(n - 1)))"
"3143","class Solution:
  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:
    secondMinSize = math.inf
    minSizes = {}

    for (x, y), c in zip(points, s):
      sz = max(abs(x), abs(y))
      if c not in minSizes:
        minSizes[c] = sz
      elif sz < minSizes[c]:
        # This is because minSizes[j] is about to be replaced by a smaller
        # value, so it becomes a candidate for the second minimum size.
        secondMinSize = min(secondMinSize, minSizes[c])
        minSizes[c] = sz
      else:
        # `sz` is not smaller than the current minimum size, but it could be
        # smaller than the current second minimum size.
        secondMinSize = min(secondMinSize, sz)

    return sum(sz < secondMinSize for sz in minSizes.values())"
"3144","class Solution:
  def minimumSubstringsInPartition(self, s: str) -> int:
    n = len(s)
    # dp[i] := the minimum number of substrings in s[0..i]
    dp = [n] * n

    for i in range(n):
      count = collections.Counter()
      for j in range(i, -1, -1):
        count[s[j]] += 1
        # word[j..i] is balanced.
        if min(count.values()) == max(count.values()):
          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)

    return dp[-1]"
"3145","class Solution:
  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:
    def sumBitsTill(x: int) -> int:
      """"""Returns sum(i.bit_count()), where 1 <= i <= x.""""""
      sumBits = 0
      powerOfTwo = 1
      while powerOfTwo <= x:
        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo
        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)
        powerOfTwo *= 2
      return sumBits

    def sumPowersTill(x: int) -> int:
      """"""Returns sum(all powers of i), where 1 <= i <= x.""""""
      sumPowers = 0
      powerOfTwo = 1
      for power in range(x.bit_length()):
        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power
        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power
        powerOfTwo *= 2
      return sumPowers

    def sumPowersFirstKBigNums(k: int) -> int:
      """"""Returns the sum of powers of the first k numbers in `big_nums`.""""""
      # Find the first number in [1, k] that has sumBitsTill(num) >= k.
      num = bisect.bisect_left(range(k), k, key=sumBitsTill)
      sumPowers = sumPowersTill(num - 1)
      remainingCount = k - sumBitsTill(num - 1)
      for power in range(num.bit_length()):
        if num >> power & 1:
          sumPowers += power
          remainingCount -= 1
          if remainingCount == 0:
            break
      return sumPowers

    return [pow(2,
                sumPowersFirstKBigNums(b + 1) -
                sumPowersFirstKBigNums(a), mod)
            for a, b, mod in queries]"
"3146","class Solution:
  def findPermutationDifference(self, s: str, t: str) -> int:
    indices = {c: i for i, c in enumerate(s)}
    return sum([abs(indices[c] - i) for i, c in enumerate(t)])"
"3147","class Solution:
  def maximumEnergy(self, energy: list[int], k: int) -> int:
    # dp[i] := the sum of energy starting at i
    dp = energy.copy()
    for i in range(len(energy) - 1 - k, -1, -1):
      dp[i] += dp[i + k]
    return max(dp)"
"3148","class Solution:
  def maxScore(self, grid: list[list[int]]) -> int:
    kMax = 200000
    ans = -kMax

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        prevMin = min(grid[i - 1][j] if i > 0 else kMax,
                      grid[i][j - 1] if j > 0 else kMax)
        ans = max(ans, num - prevMin)
        grid[i][j] = min(num, prevMin)

    return ans"
"3149","class Solution:
  def findPermutation(self, nums: list[int]) -> list[int]:
    n = len(nums)
    bestPick = [[0] * (1 << n) for _ in range(n)]

    @functools.lru_cache(None)
    def getScore(last: int, mask: int) -> int:
      if mask.bit_count() == len(nums):
        return abs(last - nums[0])

      minScore = math.inf
      for i in range(1, len(nums)):
        if mask >> i & 1:
          continue
        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))
        if nextMinScore < minScore:
          minScore = nextMinScore
          bestPick[last][mask] = i

      return minScore

    getScore(0, 1)
    return self._construct(bestPick)

  def _construct(self, bestPick: list[list[int]]) -> list[int]:
    ans = []
    last = 0
    mask = 1
    for _ in range(len(bestPick)):
      ans.append(last)
      last = bestPick[last][mask]
      mask |= 1 << last
    return ans"
"315","from dataclasses import dataclass


@dataclass
class Item:
  num: int = 0
  index: int = 0


class Solution:
  def countSmaller(self, nums: list[int]) -> list[int]:
    n = len(nums)
    ans = [0] * n
    items = [Item(num, i) for i, num in enumerate(nums)]

    self._mergeSort(items, 0, n - 1, ans)
    return ans

  def _mergeSort(
      self,
      items: list[Item],
      l: int,
      r: int,
      ans: list[int],
  ) -> None:
    if l >= r:
      return

    m = (l + r) // 2
    self._mergeSort(items, l, m, ans)
    self._mergeSort(items, m + 1, r, ans)
    self._merge(items, l, m, r, ans)

  def _merge(
      self,
      items: list[Item],
      l: int,
      m: int,
      r: int,
      ans: list[int],
  ) -> None:
    sorted = [Item()] * (r - l + 1)
    k = 0  # sorted's index
    i = l  # left's index
    j = m + 1  # right's index
    rightCount = 0  # the number of numbers < items[i].num

    while i <= m and j <= r:
      if items[i].num > items[j].num:
        rightCount += 1
        sorted[k] = items[j]
        k += 1
        j += 1
      else:
        ans[items[i].index] += rightCount
        sorted[k] = items[i]
        k += 1
        i += 1

    # Put the possible remaining left part into the sorted array.
    while i <= m:
      ans[items[i].index] += rightCount
      sorted[k] = items[i]
      k += 1
      i += 1

    # Put the possible remaining right part into the sorted array.
    while j <= r:
      sorted[k] = items[j]
      k += 1
      j += 1

    items[l:l + len(sorted)] = sorted"
"3150","SELECT tweet_id
FROM Tweets
WHERE
  LENGTH(content) > 140
  OR LENGTH(content) - LENGTH(REPLACE(content, '@', '')) > 3
  OR LENGTH(content) - LENGTH(REPLACE(content, '#', '')) > 3
ORDER BY 1;"
"3151","class Solution:
  def isArraySpecial(self, nums: list[int]) -> bool:
    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))"
"3152","class Solution:
  def isArraySpecial(
      self,
      nums: list[int],
      queries: list[list[int]],
  ) -> list[bool]:
    ans = []
    id = 0
    # parityIds[i] := the id of the parity group that nums[i] belongs to
    parityIds = [id]

    for a, b in itertools.pairwise(nums):
      if a % 2 == b % 2:
        id += 1
      parityIds.append(id)

    for _from, to in queries:
      ans.append(parityIds[_from] == parityIds[to])

    return ans"
"3153","class Solution:
  def sumDigitDifferences(self, nums: list[int]) -> int:
    n = len(nums)
    digitSize = len(str(nums[0]))
    ans = 0

    denominator = 1
    for _ in range(digitSize):
      count = [0] * 10
      for num in nums:
        count[num // denominator % 10] += 1
      ans += sum(freq * (n - freq) for freq in count)
      denominator *= 10

    return ans // 2"
"3154","class Solution:
  def waysToReachStair(self, k: int) -> int:
    # Let's say we have `down` operation 1 and `jump` operation 2.
    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.
    # => 1 + (2^jump - 1) - down = k.
    # => down = 2^jump - k.
    # Since `down` operations cannot be used consecutively, there're jump + 1
    # positions (before and after each `jump`) for  `down`. The maximum jump is
    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k
    # being the maximum value of 10^9.
    kMaxJump = 29
    ans = 0

    for jump in range(kMaxJump + 1):
      down = (1 << jump) - k
      if down < 0 or down > jump + 1:
        continue
      ans += math.comb(jump + 1, down)

    return ans"
"3155","class Solution:
  def maxUpgrades(
      self,
      count: list[int],
      upgrade: list[int],
      sell: list[int],
      money: list[int],
  ) -> list[int]:
    # If there's enough money, upgrade all servers; otherwise, optimize by
    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.
    # Therefore, x = (money + count * sell) / (sell + upgrade).
    return [min(c, (m + c * s) // (s + u))
            for c, u, s, m in zip(count, upgrade, sell, money)]"
"3156","WITH
  EmployeeTimes AS (
    SELECT DISTINCT employee_id, start_time AS `time`
    FROM Tasks
    UNION DISTINCT
    SELECT DISTINCT employee_id, end_time AS `time`
    FROM Tasks
  ),
  Segments AS (
    SELECT
      employee_id,
      `time` AS start_time,
      LEAD(`time`) OVER(PARTITION BY employee_id ORDER BY `time`) AS end_time
    FROM EmployeeTimes
  ),
  SegmentsCount AS (
    SELECT
      Segments.*,
      COUNT(*) AS concurrent_count
    FROM Segments
    INNER JOIN Tasks
      USING (employee_id)
    WHERE
      Segments.start_time >= Tasks.start_time
      AND Segments.end_time <= Tasks.end_time
    GROUP BY 1, 2, 3
  )
SELECT
  employee_id,
  FLOOR(
    SUM(
      TIME_TO_SEC(TIMEDIFF(end_time, start_time)) / 3600
    )
  ) AS total_task_hours,
  MAX(concurrent_count) AS max_concurrent_tasks
FROM SegmentsCount
GROUP BY 1
ORDER BY 1;"
"3157","class Solution:
  # Similar to 1161. Maximum Level Sum of a Binary Tree
  def minimumLevel(self, root: TreeNode | None) -> int:
    ans = 0
    minLevelSum = math.inf
    q = collections.deque([root])

    level = 1
    while q:
      levelSum = 0
      for _ in range(len(q)):
        node = q.popleft()
        levelSum += node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      if levelSum < minLevelSum:
        minLevelSum = levelSum
        ans = level
      level += 1

    return ans"
"3158","class Solution:
  def duplicateNumbersXOR(self, nums):
    count = collections.Counter(nums)
    return functools.reduce(
        operator.xor, [num for num, freq in count.items() if freq == 2],
        0)"
"3159","class Solution:
  def occurrencesOfElement(
      self,
      nums: list[int],
      queries: list[int],
      x: int,
  ) -> list[int]:
    indices = [i for i, num in enumerate(nums) if num == x]
    return [indices[query - 1] if query <= len(indices) else -1
            for query in queries]"
"316","class Solution:
  def removeDuplicateLetters(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    used = [False] * 26

    for c in s:
      count[c] -= 1
      if used[string.ascii_lowercase.index(c)]:
        continue
      while ans and ans[-1] > c and count[ans[-1]] > 0:
        used[ord(ans[-1]) - ord('a')] = False
        ans.pop()
      ans.append(c)
      used[ord(ans[-1]) - ord('a')] = True

    return ''.join(ans)"
"3160","class Solution:
  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:
    ans = []
    ballToColor = {}
    colorCount = collections.Counter()

    for ball, color in queries:
      if ball in ballToColor:
        prevColor = ballToColor[ball]
        colorCount[prevColor] -= 1
        if colorCount[prevColor] == 0:
          del colorCount[prevColor]
      ballToColor[ball] = color
      colorCount[color] += 1
      ans.append(len(colorCount))

    return ans"
"3161","from sortedcontainers import SortedList


class FenwickTree:
  def __init__(self, n: int):
    self.vals = [0] * (n + 1)

  def maximize(self, i: int, val: int) -> None:
    while i < len(self.vals):
      self.vals[i] = max(self.vals[i], val)
      i += FenwickTree.lowtree(i)

  def get(self, i: int) -> int:
    res = 0
    while i > 0:
      res = max(res, self.vals[i])
      i -= FenwickTree.lowtree(i)
    return res

  @staticmethod
  def lowtree(i: int) -> int:
    return i & -i


class Solution:
  def getResults(self, queries: list[list[int]]) -> list[bool]:
    n = min(50000, len(queries) * 3)
    ans = []
    tree = FenwickTree(n + 1)
    obstacles = SortedList([0, n])  # sentinel values

    for query in queries:
      type = query[0]
      if type == 1:
        x = query[1]
        obstacles.add(x)

    for x1, x2 in itertools.pairwise(obstacles):
      tree.maximize(x2, x2 - x1)

    for query in reversed(queries):
      type = query[0]
      x = query[1]
      if type == 1:
        i = obstacles.index(x)
        next = obstacles[i + 1]
        prev = obstacles[i - 1]
        obstacles.remove(x)
        tree.maximize(next, next - prev)
      else:
        sz = query[2]
        i = obstacles.bisect_right(x)
        prev = obstacles[i - 1]
        ans.append(tree.get(prev) >= sz or x - prev >= sz)

    return ans[::-1]"
"3162","class Solution:
  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:
    return sum(num1 % (num2 * k) == 0
               for num1 in nums1
               for num2 in nums2)"
"3163","class Solution:
  def compressedString(self, word: str) -> str:
    n = len(word)
    ans = []
    i = 0
    j = 0

    while i < n:
      count = 0
      while j < n and word[j] == word[i] and count < 9:
        j += 1
        count += 1
      ans.append(str(count) + word[i])
      i = j

    return ''.join(ans)"
"3164","class Solution:
  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:
    count = collections.Counter(num * k for num in nums2)
    ans = 0

    for num in nums1:
      for divisor in range(1, int(num ** 0.5) + 1):
        if num % divisor == 0:
          ans += count[divisor]
          if num // divisor != divisor:
            ans += count[num // divisor]

    return ans"
"3165","using NodeType = array<array<int, 2>, 2>;

class SegmentTree {
 public:
  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(4 * n) {
    build(nums, 0, 0, n - 1);
  }

  // Updates nums[i] to val.
  void update(int i, int val) {
    update(0, 0, n - 1, i, val);
  }

  // Returns the four values of the range query from nums[i..j].
  //
  // The four values are:
  //   1. nums[i] is not selected, nums[j] is not selected
  //   2. nums[i] is not selected, nums[j] is selected
  //   3. nums[i] is selected, nums[j] is not selected
  //   4. nums[i] is selected, nums[j] is selected
  NodeType query(int i, int j) const {
    return query(0, 0, n - 1, i, j);
  }

 private:
  static constexpr int kInf = 1'000'000'000;
  static constexpr NodeType kDefaultNode = {{{-kInf, -kInf}, {-kInf, -kInf}}};
  const int n;  // the size of the input array
  // tree[i][l][r] := the value of the i-th node, where `l` and `r` represent if
  // the leftmost or rightmost element is selected, respectively
  vector<NodeType> tree;

  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {
    if (lo == hi) {
      tree[treeIndex] = {{{0, -kInf}, {-kInf, nums[lo]}}};
      return;
    }
    const int mid = (lo + hi) / 2;
    build(nums, 2 * treeIndex + 1, lo, mid);
    build(nums, 2 * treeIndex + 2, mid + 1, hi);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      tree[treeIndex] = {{{0, -kInf}, {-kInf, val}}};
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, val);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  NodeType query(int treeIndex, int lo, int hi, int i, int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return kDefaultNode;
    const int mid = (lo + hi) / 2;
    return merge(query(2 * treeIndex + 1, lo, mid, i, j),
                 query(2 * treeIndex + 2, mid + 1, hi, i, j));
  }

  // Merges the result of the left node and the right node.
  NodeType merge(const NodeType& a, const NodeType& b) const {
    NodeType node = {{{0, 0}, {0, 0}}};
    for (int l = 0; l < 2; ++l)
      for (int r = 0; r < 2; ++r)
        node[l][r] =
            max({a[l][0] + b[0][r], a[l][0] + b[1][r], a[l][1] + b[0][r]});
    return node;
  }
};

class Solution {
 public:
  int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    SegmentTree tree(nums);

    for (const vector<int>& query : queries) {
      const int pos = query[0];
      const int x = query[1];
      tree.update(pos, x);
      NodeType res = tree.query(0, n - 1);
      ans = (ans + static_cast<long>(
                       max({res[0][0], res[0][1], res[1][0], res[1][1]}))) %
            kMod;
    }

    return ans;
  }
};"
"3166","WITH
  Cars AS (
    SELECT
      car_id,
      SUM(fee_paid) AS total_fee_paid,
      SUM(TIMESTAMPDIFF(MINUTE, entry_time, exit_time)) AS total_duration
    FROM ParkingTransactions
    GROUP BY 1
  ),
  CarToDurationPerLot AS (
    SELECT
      car_id,
      lot_id,
      SUM(TIMESTAMPDIFF(MINUTE, entry_time, exit_time)) AS duration_per_lot
    FROM ParkingTransactions
    GROUP BY 1, 2
  ),
  CarToMaxDurationPerLot AS (
    SELECT
      car_id,
      MAX(duration_per_lot) AS max_duration_per_lot
    FROM CarToDurationPerLot
    GROUP BY 1
  )
SELECT
  Cars.car_id,
  Cars.total_fee_paid,
  ROUND(Cars.total_fee_paid * 60 / Cars.total_duration, 2) AS avg_hourly_fee,
  CarToDurationPerLot.lot_id AS most_time_lot
FROM Cars
INNER JOIN CarToDurationPerLot
  USING (car_id)
INNER JOIN CarToMaxDurationPerLot
  USING (car_id)
WHERE
  CarToDurationPerLot.duration_per_lot = CarToMaxDurationPerLot.max_duration_per_lot
ORDER BY 1;"
"3167","class Solution:
  def betterCompression(self, compressed: str) -> str:
    count = collections.Counter()
    i = 0

    while i < len(compressed):
      c = compressed[i]
      i += 1
      freq = 0
      while i < len(compressed) and compressed[i].isdigit():
        freq = freq * 10 + int(compressed[i])
        i += 1
      count[c] += freq

    return ''.join([c + str(count[c])
                    for c in sorted(count.keys())])"
"3168","class Solution:
  def minimumChairs(self, s: str) -> int:
    ans = 0
    chairs = 0

    for c in s:
      chairs += 1 if c == 'E' else -1
      ans = max(ans, chairs)

    return ans"
"3169","class Solution:
  def countDays(self, days: int, meetings: list[list[int]]) -> int:
    freeDays = 0
    prevEnd = 0

    for start, end in sorted(meetings):
      if start > prevEnd:
        freeDays += start - prevEnd - 1
      prevEnd = max(prevEnd, end)

    return freeDays + max(0, days - prevEnd)"
"317","class Solution:
  def shortestDistance(self, grid: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    nBuildings = sum(a == 1 for row in grid for a in row)
    ans = math.inf
    # dist[i][j] := the total distance of grid[i][j] (0) to reach all the
    # buildings (1)
    dist = [[0] * n for _ in range(m)]
    # reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach
    reachCount = [[0] * n for _ in range(m)]

    def bfs(row: int, col: int) -> bool:
      q = collections.deque([(row, col)])
      seen = {(row, col)}
      seenBuildings = 1

      step = 1
      while q:
        for _ in range(len(q)):
          i, j = q.popleft()
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if x < 0 or x == m or y < 0 or y == n:
              continue
            if (x, y) in seen:
              continue
            seen.add((x, y))
            if not grid[x][y]:
              dist[x][y] += step
              reachCount[x][y] += 1
              q.append((x, y))
            elif grid[x][y] == 1:
              seenBuildings += 1
        step += 1

      # True if all the buildings (1) are connected
      return seenBuildings == nBuildings

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:  # BFS from this building.
          if not bfs(i, j):
            return -1

    for i in range(m):
      for j in range(n):
        if reachCount[i][j] == nBuildings:
          ans = min(ans, dist[i][j])

    return -1 if ans == math.inf else ans"
"3170","class Solution:
  def clearStars(self, s: str) -> str:
    ans = list(s)
    buckets = [[] for _ in range(26)]

    for i, c in enumerate(s):
      if c == '*':
        ans[i] = ''
        j = next(j for j, bucket in enumerate(buckets) if bucket)
        ans[buckets[j].pop()] = ''
      else:
        buckets[string.ascii_lowercase.index(c)].append(i)

    return ''.join(ans)"
"3171","class Solution:
  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target
  def minimumDifference(self, nums: list[int], k: int) -> int:
    ans = math.inf
    dp = set()  # all the values of subarrays that end in the current number

    for num in nums:
      # Extend each subarray that ends in the dpious number. Due to
      # monotonicity of the OR operation, the size of `next_set` will be at most
      # bin(num).count('1') + 1.
      dp = {num} | {val | num for val in dp}
      ans = min(ans, min(abs(k - val) for val in dp))

    return ans"
"3172","SELECT Emails.user_id
FROM Emails
INNER JOIN Texts
  USING (email_id)
WHERE
  Texts.signup_action = 'Verified'
  AND DATEDIFF(Texts.action_date, Emails.signup_date) = 1
ORDER BY 1;"
"3173","class Solution:
  def orArray(self, nums: list[int]) -> list[int]:
    return [a | b for a, b in itertools.pairwise(nums)]"
"3174","class Solution:
  def clearDigits(self, s: str) -> str:
    ans = []

    for c in s:
      if c.isdigit():
        # Since `ans` only contains non-digit characters, removing the last
        # character is equivalent to deleting the closest non-digit character.
        ans.pop()
      else:
        ans.append(c)

    return ''.join(ans)"
"3175","class Solution:
  # Similar to 1535. Find the Winner of an Array Game
  def findWinningPlayer(self, skills: list[int], k: int) -> int:
    ans = 0
    wins = 0

    i = 1
    while i < len(skills) and wins < k:
      if skills[i] > skills[ans]:
        ans = i
        wins = 1
      else:
        wins += 1
      i += 1

    return ans"
"3176","class Solution:
  def maximumLength(self, nums: list[int], k: int) -> int:
    # dp[count][num] := the maximum length of a good subsequence with at most
    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.
    dp = [collections.Counter() for _ in range(k + 1)]
    # maxLen[count] := the maximum length of a good subsequence with `count`
    # indices where seq[i] != seq[i + 1]
    maxLen = [0] * (k + 1)

    for num in nums:
      for count in range(k, -1, -1):
        # Append `num` to the subsequence.
        dp[count][num] += 1
        if count > 0:
          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)
        maxLen[count] = max(maxLen[count], dp[count][num])

    return maxLen[k]"
"3177","class Solution:
  # Same as 3176. Find the Maximum Length of a Good Subsequence I
  def maximumLength(self, nums: list[int], k: int) -> int:
    # dp[count][num] := the maximum length of a good subsequence with at most
    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.
    dp = [collections.Counter() for _ in range(k + 1)]
    # maxLen[count] := the maximum length of a good subsequence with `count`
    # indices where seq[i] != seq[i + 1]
    maxLen = [0] * (k + 1)

    for num in nums:
      for count in range(k, -1, -1):
        # Append `num` to the subsequence.
        dp[count][num] += 1
        if count > 0:
          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)
        maxLen[count] = max(maxLen[count], dp[count][num])

    return maxLen[k]"
"3178","class Solution:
  def numberOfChild(self, n: int, k: int) -> int:
    # the time for the ball to return to 0
    roundTime = 2 * (n - 1)
    pos = k % roundTime
    return pos if pos < n else roundTime - pos"
"3179","class Solution:
  def valueAfterKSeconds(self, n: int, k: int) -> int:
    return math.comb(n + k - 1, n - 1) % 1_000_000_007"
"318","class Solution:
  def maxProduct(self, words: list[str]) -> int:
    ans = 0

    def getMask(word: str) -> int:
      mask = 0
      for c in word:
        mask |= 1 << string.ascii_lowercase.index(c)
      return mask

    masks = [getMask(word) for word in words]

    for i in range(len(words)):
      for j in range(i):
        if not (masks[i] & masks[j]):
          ans = max(ans, len(words[i]) * len(words[j]))

    return ans"
"3180","# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total
# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each
# `rewardValue` is achievable in O(1).
#
# Let's use `rewardValues = [1, 3, 4]` as an example.
#
# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.
# Therefore, we can set the size of the bitset to 8 to represent possible
# total rewards from 0 to 7.
#
# Let's define a bitset `dp` to record whether each total reward is
# achievable. dp[num] = true if reward `num` is achievable.
#
# Initially, dp = 0b00000001 := reward 0 is achievable.
#
# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.
#   => dp = 0b00000011 := rewards 0 and 1 are achievable.
#
# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.
#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.
#
# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.
#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.
#
# Therefore, the maximum total reward is 7.

class Solution:
  def maxTotalReward(self, rewardValues: list[int]) -> int:
    dp = 1  # the possible rewards (initially, 0 is achievable)

    for num in sorted(rewardValues):
      # Remove the numbers >= the current number.
      smallerNums = dp & ((1 << num) - 1)
      dp |= smallerNums << num

    return dp.bit_length() - 1"
"3181","class Solution:
  # Same as 3180. Maximum Total Reward Using Operations I
  def maxTotalReward(self, rewardValues: list[int]) -> int:
    dp = 1  # the possible rewards (initially, 0 is achievable)

    for num in sorted(rewardValues):
      # Remove the numbers >= the current number.
      smallerNums = dp & ((1 << num) - 1)
      dp |= smallerNums << num

    return dp.bit_length() - 1"
"3182","WITH
  Majors AS (
    SELECT major, COUNT(course_id) AS course_count
    FROM Courses
    GROUP BY 1
  ),
  StudentMetadata AS (
    SELECT
      Students.student_id,
      Students.major,
      SUM(
        Students.major = Courses.major
        AND Enrollments.grade = 'A'
      ) AS major_grade_a_count
    FROM Students
    INNER JOIN Courses
      USING (major)
    INNER JOIN Enrollments
      USING (student_id, course_id)
    GROUP BY 1
  )
SELECT StudentMetadata.student_id
FROM StudentMetadata
INNER JOIN Majors
  ON (
    StudentMetadata.major = Majors.major
    AND StudentMetadata.major_grade_a_count = Majors.course_count)
ORDER BY 1;"
"3183","class Solution:
  def numberOfWays(self, n: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6
    dp = [1] + [0] * n

    for coin in (1, 2, 6):
      for i in range(coin, n + 1):
        dp[i] = (dp[i] + dp[i - coin]) % kMod

    ans = dp[n]
    if n - 4 >= 0:
      ans = (ans + dp[n - 4]) % kMod
    if n - 8 >= 0:
      ans = (ans + dp[n - 8]) % kMod
    return ans"
"3184","class Solution:
  def countCompleteDayPairs(self, hours: list[int]) -> int:
    ans = 0
    count = [0] * 24

    for hour in hours:
      ans += count[(24 - hour % 24) % 24]
      count[hour % 24] += 1

    return ans"
"3185","class Solution:
  # Same as 3184. Count Pairs That Form a Complete Day I
  def countCompleteDayPairs(self, hours: list[int]) -> int:
    ans = 0
    count = [0] * 24

    for hour in hours:
      ans += count[(24 - hour % 24) % 24]
      count[hour % 24] += 1

    return ans"
"3186","class Solution:
  def maximumTotalDamage(self, power: list[int]) -> int:
    count = collections.Counter(power)
    uniqueDamages = sorted(count.keys())
    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k
    # indicates if the i-th damage is used
    dp = [[0] * 2 for _ in range(len(uniqueDamages))]

    for i, damage in enumerate(uniqueDamages):
      if i == 0:
        dp[0] = [0, damage * count[damage]]
        continue
      dp[i][0] = max(dp[i - 1])
      dp[i][1] = damage * count[damage]
      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):
        dp[i][1] += max(dp[i - 1])
      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:
        dp[i][1] += max(dp[i - 2])
      elif i >= 3:
        dp[i][1] += max(dp[i - 3])

    return max(dp[-1])"
"3187","class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def countOfPeaks(
      self,
      nums: list[int],
      queries:
      list[list[int]],
  ) -> list[int]:
    ans = []
    peak = [0] + [int(a < b > c)
                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]
    tree = FenwickTree(len(peak))

    for i, p in enumerate(peak):
      tree.add(i + 1, p)

    def update(i: int) -> None:
      """"""
      Update the peak array and Fenwick tree if the peak status of nums[i]
      changes.
      """"""
      newPeak = self._isPeak(nums, i)
      if newPeak != peak[i]:
        tree.add(i + 1, newPeak - peak[i])
        peak[i] = newPeak

    for query in queries:
      if query[0] == 1:
        l = query[1]
        r = query[2]
        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))
      elif query[0] == 2:
        index = query[1]
        val = query[2]
        nums[index] = val
        update(index)
        if index > 0:
          update(index - 1)
        if index + 1 < len(nums):
          update(index + 1)

    return ans

  def _isPeak(self, nums: list[int], i: int) -> bool:
    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]"
"3188","WITH
  MandatoryMajors AS (
    SELECT major, COUNT(course_id) AS course_count
    FROM Courses
    WHERE mandatory = 'Yes'
    GROUP BY 1
  ),
  StudentsMetadata AS (
    SELECT
      Students.student_id,
      Students.major,
      SUM(
        Students.major = Courses.major
        AND Courses.mandatory = 'YES'
        AND Enrollments.grade = 'A'
      ) AS mandatory_grade_a_count,
      SUM(
        Students.major = Courses.major
        AND Courses.mandatory = 'No'
      ) AS elective_count,
      ROUND(
        SUM(Enrollments.GPA * Courses.credits) / SUM(Courses.credits),
        1
      ) AS avg_gpa
    FROM Students
    INNER JOIN Enrollments
      USING (student_id)
    INNER JOIN Courses
      USING (course_id)
    GROUP BY 1
  )
SELECT StudentsMetadata.student_id
FROM StudentsMetadata
INNER JOIN MandatoryMajors
  ON (
    StudentsMetadata.major = MandatoryMajors.major
    AND StudentsMetadata.mandatory_grade_a_count = MandatoryMajors.course_count)
WHERE StudentsMetadata.avg_gpa >= 2.5 AND StudentsMetadata.elective_count >= 2
ORDER BY 1;"
"3189","class Solution:
  def minMoves(self, rooks: list[list[int]]) -> int:
    n = len(rooks)
    sortedByRow = sorted(rooks, key=lambda x: x[0])
    sortedByCol = sorted(rooks, key=lambda x: x[1])
    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +
            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))"
"319","class Solution:
  def bulbSwitch(self, n: int) -> int:
    # The k-th bulb can only be switched when k % i == 0.
    # So, we can rephrase the problem:
    # To find number of numbers <= n that have odd factors.
    # Obviously, only square numbers have odd factor(s).
    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10
    return math.isqrt(n)"
"3190","class Solution:
  def minimumOperations(self, nums: list[int]) -> int:
    return sum(num % 3 != 0 for num in nums)"
"3191","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    ans = 0

    for i in range(len(nums) - 2):
      if nums[i] == 0:
        nums[i + 1] ^= 1
        nums[i + 2] ^= 1
        ans += 1

    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans"
"3192","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    ans = 0
    target = 1

    for num in nums:
      if num != target:
        ans += 1
        target ^= 1

    return ans"
"3193","class Solution:
  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:
    kMod = 1_000_000_007
    kMaxInversions = 400
    # dp[i][j] := the number of ways to arrange the first i numbers of the
    # permutation s.t. there are j inversions
    dp = [[0] * (kMaxInversions + 1) for _ in range(n + 1)]
    endToCnt = {end + 1: cnt for end, cnt in requirements}

    # There's only one way to arrange a single number with zero inversions.
    dp[1][0] = 1

    for i in range(2, n + 1):
      for newInversions in range(i):
        for j in range(kMaxInversions - newInversions + 1):
          inversionsAfterInsertion = j + newInversions
          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:
            continue
          dp[i][inversionsAfterInsertion] += dp[i - 1][j]
          dp[i][inversionsAfterInsertion] %= kMod

    return dp[n][endToCnt[n]]"
"3194","class Solution:
  def minimumAverage(self, nums: list[int]) -> float:
    nums.sort()
    return min((nums[i] + nums[~i]) / 2
               for i in range(len(nums) // 2 + 1))"
"3195","class Solution:
  def minimumArea(self, grid: list[list[int]]) -> int:
    x1 = math.inf
    y1 = math.inf
    x2 = 0
    y2 = 0

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num == 1:
          x1 = min(x1, i)
          y1 = min(y1, j)
          x2 = max(x2, i)
          y2 = max(y2, j)

    return (x2 - x1 + 1) * (y2 - y1 + 1)"
"3196","class Solution:
  def maximumTotalCost(self, nums: list[int]) -> int:
    # A small trick so that we don't need to handle the edge case and can use
    # ranged-based for loop.
    keep = -math.inf  # the maximum cost if the last number is kept
    flip = 0  # the maximum cost if the last number is flipped

    for num in nums:
      keep, flip = max(keep, flip) + num, keep - num

    return max(keep, flip)"
"3197","
class Solution:
  def minimumSum(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = m * n

    for i in range(m):
      top = self._minimumArea(grid, 0, i, 0, n - 1)
      for j in range(n):
        ans = min(ans, top +
                  self._minimumArea(grid, i + 1, m - 1, 0, j) +
                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))

    for i in range(m):
      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)
      for j in range(n):
        ans = min(ans, bottom +
                  self._minimumArea(grid, 0, i - 1, 0, j) +
                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))

    for j in range(n):
      left = self._minimumArea(grid, 0, m - 1, 0, j)
      for i in range(m):
        ans = min(ans, left +
                  self._minimumArea(grid, 0, i, j + 1, n - 1) +
                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))

    for j in range(n):
      right = self._minimumArea(grid, 0, m - 1, j, n - 1)
      for i in range(m):
        ans = min(ans, right +
                  self._minimumArea(grid, 0, i, 0, j - 1) +
                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))

    for i1 in range(m):
      for i2 in range(i1 + 1, m):
        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +
                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +
                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))

    for j1 in range(n):
      for j2 in range(j1 + 1, n):
        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +
                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +
                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))

    return ans

  def _minimumArea(
      self,
      grid: list[list[int]],
      si: int,
      ei: int,
      sj: int,
      ej: int,
  ) -> int:
    x1 = math.inf
    y1 = math.inf
    x2 = 0
    y2 = 0
    for i in range(si, ei + 1):
      for j in range(sj, ej + 1):
        if grid[i][j] == 1:
          x1 = min(x1, i)
          y1 = min(y1, j)
          x2 = max(x2, i)
          y2 = max(y2, j)
    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)"
"3198","SELECT
  state,
  GROUP_CONCAT(city ORDER BY city SEPARATOR ', ') AS cities
FROM Cities
GROUP BY 1
ORDER BY 1;"
"3199","class Solution:
  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:
    evenA, oddA = self._getEvenOddBitCount(a)
    evenB, oddB = self._getEvenOddBitCount(b)
    evenC, oddC = self._getEvenOddBitCount(c)
    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC

  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:
    """"""
    Returns the count of numbers in the `nums` arrays that have even number of
    ones and odd number of ones in their binary representation.
    """"""
    even = sum(num.bit_count() % 2 == 0 for num in nums)
    return (even, len(nums) - even)"
"32","class Solution:
  def longestValidParentheses(self, s: str) -> int:
    s2 = ')' + s
    # dp[i] := the length of the longest valid parentheses in the substring
    # s2[1..i]
    dp = [0] * len(s2)

    for i in range(1, len(s2)):
      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2

    return max(dp)"
"320","class Solution:
  def generateAbbreviations(self, word: str) -> list[str]:
    ans = []

    def getCountString(count: int) -> str:
      return str(count) if count > 0 else ''

    def dfs(i: int, count: int, path: list[str]) -> None:
      if i == len(word):
        ans.append(''.join(path) + getCountString(count))
        return

      # Abbreviate the word[i].
      dfs(i + 1, count + 1, path)
      # Keep the word[i], so consume the count as a string.
      path.append(getCountString(count) + word[i])
      # Reset the count to 0.
      dfs(i + 1, 0, path)
      path.pop()

    dfs(0, 0, [])
    return ans"
"3200","class Solution:
  def maxHeightOfTriangle(self, red: int, blue: int) -> int:
    return max(self._maxHeight(red, blue),
               self._maxHeight(blue, red))

  def _maxHeight(self, n1: int, n2: int) -> int:
    """"""
    Returns the maximum height of a triangle with the odd levels having `n1`
    balls and the even levels having `n2` balls.
    """"""
    #             1 + 3 + ... + h <= n1
    # ((1 + h) * (n + 1) / 2) / 2 <= n1
    #                           h <= sqrt(4 * n1) - 1
    oddHeight = math.isqrt(4 * n1) - 1
    #       2 + 4 + ... + h <= n2
    # ((2 + h) * h / 2) / 2 <= n2
    #                     h <= sqrt(4 * n2 + 1) - 1
    evenHeight = math.isqrt(4 * n2 + 1) - 1
    # If the difference between the odd and even heights is >= 1, we can add an
    # extra level to the minimum height.
    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1
                                         else 0)"
"3201","class Solution:
  def maximumLength(self, nums: list[int]) -> int:
    # dp[i][j] := the maximum length of a valid subsequence, where the last
    # number mod k equal to i and the next desired number mod k equal to j
    dp = [[0] * 2 for _ in range(2)]

    # Extend the pattern xyxyxy...xy.
    for x in nums:
      for y in range(2):
        dp[x % 2][y] = dp[y][x % 2] + 1

    return max(map(max, dp))"
"3202","class Solution:
  # Similar to 3201. Find the Maximum Length of Valid Subsequence I
  def maximumLength(self, nums: list[int], k: int) -> int:
    # dp[i][j] := the maximum length of a valid subsequence, where the last
    # number mod k equal to i and the next desired number mod k equal to j
    dp = [[0] * k for _ in range(k)]

    # Extend the pattern xyxyxy...xy.
    for x in nums:
      for y in range(k):
        dp[x % k][y] = dp[y][x % k] + 1

    return max(map(max, dp))"
"3203","class Solution:
  def minimumDiameterAfterMerge(
      self,
      edges1: list[list[int]],
      edges2: list[list[int]],
  ) -> int:
    diameter1 = self._getDiameter(edges1)
    diameter2 = self._getDiameter(edges2)
    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1
    return max(diameter1, diameter2, combinedDiameter)

  def _getDiameter(self, edges: list[list[int]]) -> int:
    n = len(edges) + 1
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    maxDiameter = [0]
    self._maxDepth(graph, 0, -1, maxDiameter)
    return maxDiameter[0]

  # Similar to 1522. Diameter of N-Ary Tree
  def _maxDepth(
      self,
      graph: list[list[int]],
      u: int,
      prev: int,
      maxDiameter: list[int],
  ) -> int:
    """"""Returns the maximum depth of the subtree rooted at u.""""""
    maxSubDepth1 = 0
    maxSubDepth2 = 0
    for v in graph[u]:
      if v == prev:
        continue
      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)
      if maxSubDepth > maxSubDepth1:
        maxSubDepth2 = maxSubDepth1
        maxSubDepth1 = maxSubDepth
      elif maxSubDepth > maxSubDepth2:
        maxSubDepth2 = maxSubDepth
    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)
    return 1 + maxSubDepth1"
"3204","SELECT
  BIT_AND(permissions) AS common_perms,
  BIT_OR(permissions) AS any_perms
FROM user_permissions;"
"3205","class Solution:
  def maxScore(self, nums: list[int]) -> int:
    n = len(nums)
    # dp[i] := the maximum score to jump from index i to n - 1
    dp = [0] * n

    for i in reversed(range(n)):
      for j in range(i + 1, n):
        # Jump from i to j, and then jump from j to n - 1.
        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])

    return dp[0]"
"3206","class Solution:
  def numberOfAlternatingGroups(self, colors: list[int]) -> int:
    n = len(colors)
    return sum(colors[i] != colors[i - 1] and
               colors[i] != colors[(i + 1) % n]
               for i in range(n))"
"3207","class Solution:
  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:
    minEnergy = min(enemyEnergies)
    return (0 if currentEnergy < minEnergy
            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)"
"3208","class Solution:
  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:
    n = len(colors)
    ans = 0
    alternating = 1

    for i in range(n + k - 2):
      alternating = (1 if colors[i % n] == colors[(i - 1) % n]
                     else alternating + 1)
      if alternating >= k:
        ans += 1

    return ans"
"3209","class Solution:
  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target
  def countSubarrays(self, nums: list[int], k: int) -> int:
    ans = 0
    # the counter of all the values of subarrays that end in the previous
    # number
    prev = collections.Counter()

    for num in nums:
      # Extend each subarray that ends in the previous number. Due to
      # monotonicity of the AND operation, the size of `curr` will be at most
      # num.bit_count() + 1.
      curr = collections.Counter({num: 1})
      for val, freq in prev.items():
        curr[val & num] += freq
      ans += curr[k]
      prev = curr

    return ans"
"321","class Solution:
  def maxNumber(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:
    def maxArray(nums: list[int], k: int) -> list[int]:
      res = []
      toTop = len(nums) - k
      for num in nums:
        while res and res[-1] < num and toTop > 0:
          res.pop()
          toTop -= 1
        res.append(num)
      return res[:k]

    def merge(nums1: list[int], nums2: list[int]) -> list[int]:
      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]

    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))
               for i in range(k + 1)
               if i <= len(nums1) and k - i <= len(nums2))"
"3210","class Solution:
  def getEncryptedString(self, s: str, k: int) -> str:
    k %= len(s)
    return s[k:] + s[0:k]"
"3211","class Solution:
  def validStrings(self, n: int) -> list[str]:
    ans = []

    def dfs(n: int, s: list[str]) -> None:
      if n == 0:
        ans.append(''.join(s))
        return
      if not s or s[-1] == '1':
        s.append('0')
        dfs(n - 1, s)
        s.pop()
      s.append('1')
      dfs(n - 1, s)
      s.pop()

    dfs(n, [])
    return ans"
"3212","class Solution:
  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    # x[i][j] := the number of 'X' in grid[0..i)[0..j)
    x = [[0] * (n + 1) for _ in range(m + 1)]
    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)
    y = [[0] * (n + 1) for _ in range(m + 1)]

    for i, row in enumerate(grid):
      for j, cell in enumerate(row):
        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]
        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]
        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:
          ans += 1

    return ans"
"3213","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.cost = math.inf


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str, cost: int) -> None:
    """"""Inserts a word with a cost.""""""
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.cost = min(node.cost, cost)

  @functools.lru_cache(None)
  def search(self, word: str, i: int) -> int:
    """"""Returns the minimum cost to construct s[i:].""""""
    if i == len(word):
      return 0
    cost = math.inf
    node = self.root
    for i in range(i, len(word)):
      if word[i] not in node.children:
        break
      node = node.children[word[i]]
      if node.cost != math.inf:
        childCost = self.search(word, i + 1)
        if childCost != math.inf:
          cost = min(cost, node.cost + childCost)
    return cost


class Solution:
  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:
    trie = Trie()

    for word, cost in zip(words, costs):
      trie.insert(word, cost)

    ans = trie.search(target, 0)
    return -1 if ans == math.inf else ans"
"3214","WITH
  YearlySpends AS (
    SELECT
      product_id,
      YEAR(transaction_date) AS year,
      SUM(spend) AS spend
    FROM user_transactions
    GROUP BY 1, 2
  )
SELECT
  CurrYear.year,
  CurrYear.product_id,
  CurrYear.spend AS curr_year_spend,
  PrevYear.spend AS prev_year_spend,
  ROUND(100 * (CurrYear.spend - PrevYear.spend) / PrevYear.spend, 2) AS yoy_rate
FROM YearlySpends AS CurrYear
LEFT JOIN YearlySpends AS PrevYear
  ON (
    CurrYear.product_id = PrevYear.product_id
    AND CurrYear.year - 1 = PrevYear.year)
ORDER BY product_id, year;"
"3215","class Solution:
  # Same as 3199. Count Triplets with Even XOR Set Bits I
  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:
    evenA, oddA = self._getEvenOddBitCount(a)
    evenB, oddB = self._getEvenOddBitCount(b)
    evenC, oddC = self._getEvenOddBitCount(c)
    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC

  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:
    """"""
    Returns the count of numbers in the `nums` arrays that have even number of
    ones and odd number of ones in their binary representation.
    """"""
    even = sum(num.bit_count() % 2 == 0 for num in nums)
    return (even, len(nums) - even)"
"3216","class Solution:
  def getSmallestString(self, s: str) -> str:
    chars = list(s)
    for i, (a, b) in enumerate(itertools.pairwise(chars)):
      if ord(a) % 2 == ord(b) % 2 and a > b:
        chars[i], chars[i + 1] = chars[i + 1], chars[i]
        return ''.join(chars)
    return s"
"3217","class Solution:
  def modifiedList(
      self,
      nums: list[int],
      head: ListNode | None,
  ) -> ListNode | None:
    dummy = ListNode(0, head)
    numsSet = set(nums)

    curr = dummy
    while curr.next:
      if curr.next.val in numsSet:
        curr.next = curr.next.next
      else:
        curr = curr.next

    return dummy.next"
"3218","class Solution:
  def minimumCost(
      self,
      m: int,
      n: int,
      horizontalCut: list[int],
      verticalCut: list[int],
  ) -> int:
    ans = 0
    sumH = sum(horizontalCut)
    sumV = sum(verticalCut)

    horizontalCut.sort()
    verticalCut.sort()

    while horizontalCut and verticalCut:
      if horizontalCut[-1] > verticalCut[-1]:
        ans += horizontalCut[-1] + sumV
        sumH -= horizontalCut.pop()
      else:
        ans += verticalCut[-1] + sumH
        sumV -= verticalCut.pop()

    return ans + sumH + sumV"
"3219","class Solution:
  # Same as 3218. Minimum Cost for Cutting Cake I
  def minimumCost(
      self,
      m: int,
      n: int,
      horizontalCut: list[int],
      verticalCut: list[int],
  ) -> int:
    ans = 0
    sumH = sum(horizontalCut)
    sumV = sum(verticalCut)

    horizontalCut.sort()
    verticalCut.sort()

    while horizontalCut and verticalCut:
      if horizontalCut[-1] > verticalCut[-1]:
        ans += horizontalCut[-1] + sumV
        sumH -= horizontalCut.pop()
      else:
        ans += verticalCut[-1] + sumH
        sumV -= verticalCut.pop()

    return ans + sumH + sumV"
"322","class Solution:
  def coinChange(self, coins: list[int], amount: int) -> int:
    # dp[i] := the minimum number Of coins to make up i
    dp = [0] + [amount + 1] * amount

    for coin in coins:
      for i in range(coin, amount + 1):
        dp[i] = min(dp[i], dp[i - coin] + 1)

    return -1 if dp[amount] == amount + 1 else dp[amount]"
"3220","SELECT
  transaction_date,
  SUM(IF(amount % 2 = 1, amount, 0)) AS odd_sum,
  SUM(IF(amount % 2 = 0, amount, 0)) AS even_sum
FROM Transactions
GROUP BY 1
ORDER BY 1;"
"3221","class Solution:
  # Same as 3205. Maximum Array Hopping Score I
  def maxScore(self, nums: list[int]) -> int:
    # The optimal jump is the maximum number in the remaining suffix.
    return sum(itertools.accumulate(nums[:0:-1], max))"
"3222","class Solution:
  def losingPlayer(self, x: int, y: int) -> str:
    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'"
"3223","class Solution:
  def minimumLength(self, s: str) -> int:
    count = collections.Counter(s)
    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())"
"3224","class Solution:
  def minChanges(self, nums: list[int], k: int) -> int:
    pairSize = len(nums) // 2
    diffCount = collections.Counter()  # {nums[-i - 1] - nums[i]: freq}
    # oneChangeCount[i] := the number of pairs that need only one change to
    # to achieve a difference of `i`
    oneChangeCount = [0] * (k + 1)

    for i in range(pairSize):
      a = nums[i]
      b = nums[-i - 1]
      diffCount[abs(a - b)] += 1
      oneChangeCount[max(a, b, k - a, k - b)] += 1

    # prefixOneChangeCount[i] := the number of pairs that need only one change
    # to achieve a difference >= `i`
    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])
    prefixOneChangeCount = list(
        itertools.accumulate(reversed(oneChangeCount)))[::-1]

    return min(prefixOneChangeCount[diff] - freq +  # one change
               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes
               for diff, freq in diffCount.items())"
"3225","class Solution:
  def maximumScore(self, grid: list[list[int]]) -> int:
    n = len(grid)
    # prefix[j][i] := the sum of the first i elements in the j-th column
    prefix = [[0] * (n + 1) for _ in range(n)]
    # prevPick[i] := the maximum score up to the previous column, where the
    # bottommost selected element in the previous column is in row (i - 1)
    prevPick = [0] * (n + 1)
    # prevSkip[i] := the maximum score up to the previous column, where the
    # bottommost selected element in the column before the previous one is in
    # row (i - 1)
    prevSkip = [0] * (n + 1)

    for j in range(n):
      for i in range(n):
        prefix[j][i + 1] = prefix[j][i] + grid[i][j]

    for j in range(1, n):
      currPick = [0] * (n + 1)
      currSkip = [0] * (n + 1)
      # Consider all possible combinations of the number of current and
      # previous selected elements.
      for curr in range(n + 1):  # the number of current selected elements
        for prev in range(n + 1):  # the number of previous selected elements
          if curr > prev:
            # 1. The current bottom is deeper than the previous bottom.
            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.
            score = prefix[j - 1][curr] - prefix[j - 1][prev]
            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)
            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)
          else:
            # 2. The previous bottom is deeper than the current bottom.
            # Get the score of grid[curr..prev)[j] for pick only.
            score = prefix[j][prev] - prefix[j][curr]
            currPick[curr] = max(currPick[curr], prevPick[prev] + score)
            currSkip[curr] = max(currSkip[curr], prevPick[prev])
      prevPick = currPick
      prevSkip = currSkip

    return max(prevPick)"
"3226","class Solution:
  def minChanges(self, n: int, k: int) -> int:
    # n needs to be a superset of k.
    return (n ^ k).bit_count() if (n & k) == k else -1"
"3227","class Solution:
  def doesAliceWin(self, s: str) -> bool:
    # Let k be the number of vowels in s.
    # 1. If k == 0, Bob wins since Alice has no vowels to pick.
    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.
    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,
    # then Bob will either pick a substring containing 0 vowels, resulting in
    # Alice picking the remaining entire string, or Bob couldn't pick at all
    # (the last vowel).
    kVowels = 'aeiou'
    return any(c in kVowels for c in s)"
"3228","class Solution:
  def maxOperations(self, s: str) -> int:
    ans = 0
    ones = 0

    for i, c in enumerate(s):
      if c == '1':
        ones += 1
      elif i + 1 == len(s) or s[i + 1] == '1':
        ans += ones

    return ans"
"3229","class Solution:
  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array
  def minimumOperations(self, nums: list[int], target: list[int]) -> int:
    ans = abs(nums[0] - target[0])

    for (prevNum, prevTarget), (currNum, currTarget) in (
        itertools.pairwise(zip(nums, target))
    ):
      currDiff = currTarget - currNum
      prevDiff = prevTarget - prevNum
      if currDiff >= 0 and prevDiff >= 0:
        ans += max(0, currDiff - prevDiff)
      elif currDiff <= 0 and prevDiff <= 0:
        ans += max(0, abs(currDiff) - abs(prevDiff))
      else:
        ans += abs(currDiff)

    return ans"
"323","class Solution:
  def countComponents(self, n: int, edges: list[list[int]]) -> int:
    ans = 0
    graph = [[] for _ in range(n)]
    seen = set()

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    def bfs(node: int, seen: set[int]) -> None:
      q = collections.deque([node])
      seen.add(node)

      while q:
        u = q.pop()
        for v in graph[u]:
          if v not in seen:
            q.append(v)
            seen.add(v)

    for i in range(n):
      if i not in seen:
        bfs(i, seen)
        ans += 1

    return ans"
"3230","WITH
  RankedCategoriesPerCustomer AS (
    SELECT
      Transactions.customer_id,
      Products.category,
      RANK() OVER(
        PARTITION BY Transactions.customer_id
        ORDER BY COUNT(Products.category) DESC,
          MAX(Transactions.transaction_date) DESC
      ) AS `rank`
    FROM Transactions
    INNER JOIN Products
      USING (product_id)
    GROUP BY 1, 2
  ),
  TransactionsMetadata AS (
    SELECT
      Transactions.customer_id,
      ROUND(SUM(Transactions.amount), 2) AS total_amount,
      COUNT(Transactions.transaction_id) AS transaction_count,
      COUNT(DISTINCT Products.category) AS unique_categories,
      ROUND(AVG(Transactions.amount), 2) AS avg_transaction_amount,
      RankedCategoriesPerCustomer.category AS top_category
    FROM Transactions
    INNER JOIN Products
      USING (product_id)
    INNER JOIN RankedCategoriesPerCustomer
      USING (customer_id)
    WHERE RankedCategoriesPerCustomer.`rank` = 1
    GROUP BY 1
  )
SELECT
  *,
  ROUND(transaction_count * 10 + total_amount / 100, 2) AS loyalty_score
FROM TransactionsMetadata
ORDER BY loyalty_score DESC, customer_id;"
"3231","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    return self._lengthOfLIS(nums[::-1])

  def _lengthOfLIS(self, nums: list[int]) -> int:
    # tails[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tails = []
    for num in nums:
      if not tails or num >= tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_right(tails, num)] = num
    return len(tails)"
"3232","class Solution:
  def canAliceWin(self, nums: list[int]) -> bool:
    return sum(num if num < 10 else -num for num in nums) != 0"
"3233","class Solution:
  def nonSpecialCount(self, l: int, r: int) -> int:
    maxRoot = math.isqrt(r)
    isPrime = self._sieveEratosthenes(maxRoot + 1)
    specialCount = 0

    for num in range(2, math.isqrt(r) + 1):
      if isPrime[num] and l <= num**2 <= r:
        specialCount += 1

    return r - l + 1 - specialCount

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"3234","class Solution:
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    #    z^2 + z = n.
    # => z^2 + z - n = 0.
    # => z = (-1 + sqrt(1 + 4n)) / 2.
    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2

    # Iterate through all possible number of 0s.
    for zero in range(int(maxZero) + 1):
      lastInvalidPos = -1
      count = [0, 0]
      l = 0
      for r, c in enumerate(s):
        count[int(c)] += 1
        # Try to shrink the window to maintain the ""minimum"" length of the
        # valid substring.
        while l < r:
          if s[l] == '0' and count[0] > zero:
            count[0] -= 1  # Remove an extra '0'.
            lastInvalidPos = l
            l += 1
          elif s[l] == '1' and count[1] - 1 >= zero * zero:
            count[1] -= 1  # Remove an extra '1'.
            l += 1
          else:
            break  # Cannot remove more characters.
        if count[0] == zero and count[1] >= zero * zero:
          # Add valid substrings ending in s[r] to the answer. They are
          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].
          ans += l - lastInvalidPos

    return ans"
"3235","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def canReachCorner(self, X: int, Y: int, circles: list[list[int]]) -> bool:
    n = len(circles)
    # Add two virtual nodes, where node n represents (0, 0) and node n + 1
    # represents (X, Y).
    uf = UnionFind(n + 2)

    # Iterate through each circle.
    for i, (x, y, r) in enumerate(circles):
      # Union the current circle with the node (0, 0) if the circle overlaps
      # with the left or top edges.
      if x - r <= 0 or y + r >= Y:
        uf.unionByRank(i, n)
      # Union the current circle with the node (X, Y) if the circle overlaps
      # with the right or bottom edges.
      if x + r >= X or y - r <= 0:
        uf.unionByRank(i, n + 1)
      # Union the current circle with previous circles if they overlap.
      for j in range(i):
        x2, y2, r2 = circles[j]
        if (x - x2)**2 + (y - y2)**2 <= (r + r2)**2:
          uf.unionByRank(i, j)

    # If nodes (0, 0) and (X, Y) are in the same union set, that means there's
    # a path of overlapping circles that connects the left or top edges to the
    # right or bottom edges, implying that (0, 0) cannot reach (X, Y).
    return uf.find(n) != uf.find(n + 1)"
"3236","WITH
  RECURSIVE EmployeeHierarchy AS (
    -- Base case: direct reports to CEO
    SELECT
      employee_id,
      employee_name,
      salary,
      1 AS hierarchy_level
    FROM Employees
    WHERE manager_id = (
        SELECT employee_id
        FROM Employees
        WHERE manager_id IS NULL
      )
    UNION ALL
    -- Recursive case: reports of reports
    SELECT
      Employees.employee_id,
      Employees.employee_name,
      Employees.salary,
      EmployeeHierarchy.hierarchy_level + 1
    FROM Employees
    INNER JOIN EmployeeHierarchy
      ON (Employees.manager_id = EmployeeHierarchy.employee_id)
  ),
  Ceo AS (
    SELECT salary
    FROM Employees
    WHERE manager_id IS NULL
  )
SELECT
  EmployeeHierarchy.employee_id AS subordinate_id,
  EmployeeHierarchy.employee_name AS subordinate_name,
  EmployeeHierarchy.hierarchy_level,
  EmployeeHierarchy.salary - Ceo.salary AS salary_difference
FROM EmployeeHierarchy
CROSS JOIN Ceo
ORDER BY hierarchy_level, employee_id;"
"3237","class Solution:
  def simulationResult(
      self,
      windows: list[int],
      queries: list[int],
  ) -> list[int]:
    ans = []
    seen = set()

    for query in reversed(queries):
      if query not in seen:
        ans.append(query)
        seen.add(query)

    for window in windows:
      if window not in seen:
        ans.append(window)
        seen.add(window)

    return ans"
"3238","class Solution:
  def winningPlayerCount(self, n: int, pick: list[list[int]]) -> int:
    counts = [collections.Counter() for _ in range(n)]
    for player, color in pick:
      counts[player][color] += 1
    return sum(max(count.values(), default=0) > i
               for i, count in enumerate(counts))"
"3239","class Solution:
  def minFlips(self, grid: list[list[int]]) -> int:
    rowFlips = sum(row[i] != row[-1 - i]
                   for row in grid for i in range(len(row) // 2))
    colFlips = sum(col[i] != col[-1 - i] for col in zip(*grid)
                   for i in range(len(col) // 2))
    return min(rowFlips, colFlips)"
"324","class Solution:
  def wiggleSort(self, nums: list[int]) -> None:
    n = len(nums)
    median = self._findKthLargest(nums, (n + 1) // 2)

    def A(i: int):
      return (1 + 2 * i) % (n | 1)

    i = 0
    j = 0
    k = n - 1

    while i <= k:
      if nums[A(i)] > median:
        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]
        i, j = i + 1, j + 1
      elif nums[A(i)] < median:
        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]
        k -= 1
      else:
        i += 1

  # Same as 215. Kth Largest Element in an Array
  def _findKthLargest(self, nums: list[int], k: int) -> int:
    def quickSelect(l: int, r: int, k: int) -> int:
      randIndex = random.randint(0, r - l) + l
      nums[randIndex], nums[r] = nums[r], nums[randIndex]
      pivot = nums[r]

      nextSwapped = l
      for i in range(l, r):
        if nums[i] >= pivot:
          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]
          nextSwapped += 1
      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]

      count = nextSwapped - l + 1  # Number of nums >= pivot
      if count == k:
        return nums[nextSwapped]
      if count > k:
        return quickSelect(l, nextSwapped - 1, k)
      return quickSelect(nextSwapped + 1, r, k - count)

    return quickSelect(0, len(nums) - 1, k)"
"3240","class Solution:
  def minFlips(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    middleOnes = 0
    mismatchedPairs = 0

    # Handle top-left, top-right, bottom-left, bottom-right cells.
    for i in range(m // 2):
      for j in range(n // 2):
        ones = (grid[i][j] + grid[i][n - 1 - j] +
                grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j])
        ans += min(ones, 4 - ones)

    # Handle the middle row if the number of m is odd.
    if m % 2 == 1:
      for j in range(n // 2):
        leftCell = grid[m // 2][j]
        rightCell = grid[m // 2][n - 1 - j]
        mismatchedPairs += leftCell ^ rightCell
        middleOnes += leftCell + rightCell

    # Handle the middle column if the number of columns is odd.
    if n % 2 == 1:
      for i in range(m // 2):
        topCell = grid[i][n // 2]
        bottomCell = grid[m - 1 - i][n // 2]
        mismatchedPairs += topCell ^ bottomCell
        middleOnes += topCell + bottomCell

    if mismatchedPairs == 0:
      # Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.
      if middleOnes % 4 == 2:
        ans += 2  # Flip two 1s to 0s.
    else:
      # Flip every mismatched pair 01 to 00 or 11. It doesn't matter.
      ans += mismatchedPairs

    # Handle the center cell if both dimensions are odd.
    if m % 2 == 1 and n % 2 == 1:
      ans += grid[m // 2][n // 2]

    return ans"
"3241","from dataclasses import dataclass


@dataclass
class Node:
  node: int = 0  # the node number
  time: int = 0  # the time taken to mark the entire subtree rooted at the node


class Top2:
  def __init__(self, top1: Node = Node(), top2: Node = Node()):
    # the direct child node, where the time taken to mark the entire subtree
    # rooted at the node is the maximum
    self.top1 = top1
    # the direct child node, where the time taken to mark the entire subtree
    # rooted at the node is the second maximum
    self.top2 = top2


class Solution:
  def timeTaken(self, edges: list[list[int]]) -> list[int]:
    n = len(edges) + 1
    ans = [0] * n
    tree = [[] for _ in range(n)]
    # dp[i] := the top two direct child nodes for subtree rooted at node i,
    # where each node contains the time taken to mark the entire subtree rooted
    # at the node itself
    dp = [Top2()] * n

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    self._dfs(tree, 0, -1, dp)
    self._reroot(tree, 0, -1, 0, dp, ans)
    return ans

  def _getTime(self, u: int) -> int:
    """"""Returns the time taken to mark node u.""""""
    return 2 if u % 2 == 0 else 1

  def _dfs(
      self,
      tree: list[list[int]],
      u: int,
      prev: int,
      dp: list[Top2]
  ) -> int:
    """"""
    Performs a DFS traversal of the subtree rooted at node `u`, computes the
    time taken to mark all nodes in the subtree, records the top two direct
    child nodes, where the time taken to mark the subtree rooted at each of the
    child nodes is maximized, and returns the top child node.

    These values are used later in the rerooting process.
    """"""
    top1 = Node()
    top2 = Node()
    for v in tree[u]:
      if v == prev:
        continue
      time = self._dfs(tree, v, u, dp) + self._getTime(v)
      if time >= top1.time:
        top2 = top1
        top1 = Node(v, time)
      elif time > top2.time:
        top2 = Node(v, time)
    dp[u] = Top2(top1, top2)
    return top1.time

  def _reroot(
      self,
      tree: list[list[int]],
      u: int,
      prev: int,
      maxTime: int,
      dp: list[Top2],
      ans: list[int]
  ) -> None:
    """"""
    Reroots the tree at node `u` and updates the answer array, where `maxTime`
    is the longest path that doesn't go through `u`'s subtree.
    """"""
    ans[u] = max(maxTime, dp[u].top1.time)

    for v in tree[u]:
      if v == prev:
        continue
      newMaxTime = self._getTime(u) + max(
          maxTime,
          dp[u].top2.time if dp[u].top1.node == v else dp[u].top1.time
      )
      self._reroot(tree, v, u, newMaxTime, dp, ans)"
"3242","class neighborSum:
  def __init__(self, grid: list[list[int]]):
    self.grid = grid
    self.n = len(grid)
    self.numToPos = {num: (i, j)
                     for i, row in enumerate(grid)
                     for j, num in enumerate(row)}

  def adjacentSum(self, value: int) -> int:
    i, j = self.numToPos[value]
    return sum(self.grid[x][y]
               for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1))
               if 0 <= x < self.n and 0 <= y < self.n)

  def diagonalSum(self, value: int) -> int:
    i, j = self.numToPos[value]
    return sum(self.grid[x][y]
               for x, y in ((i - 1, j - 1), (i - 1, j + 1),
                            (i + 1, j - 1), (i + 1, j + 1))
               if 0 <= x < self.n and 0 <= y < self.n)"
"3243","class Solution:
  def shortestDistanceAfterQueries(
      self,
      n: int,
      queries: list[list[int]],
  ) -> list[int]:
    ans = []
    dist = list(range(n))
    graph = [[] for _ in range(n)]

    for i in range(n - 1):
      graph[i].append(i + 1)

    for u, v in queries:
      graph[u].append(v)
      if dist[u] + 1 < dist[v]:
        dist[v] = dist[u] + 1
        self._bfs(graph, v, dist)
      ans.append(dist[n - 1])

    return ans

  def _bfs(self, graph: list[list[int]], start: int, dist: list[int]) -> None:
    """"""
    Performs a BFS to update the shortest distances from the given `start` node
    to all other reachable nodes in the graph. It updates the `dist` vector
    with the new shortest distances.
    """"""
    q = collections.deque([start])
    while q:
      u = q.popleft()
      for v in graph[u]:
        if dist[u] + 1 < dist[v]:
          dist[v] = dist[u] + 1
          q.append(v)"
"3244","class Solution:
  def shortestDistanceAfterQueries(
      self,
      n: int,
      queries: list[list[int]],
  ) -> list[int]:
    ans = []
    nodeToFarthestNode = {i: i + 1 for i in range(n - 1)}

    for u, v in queries:
      # If `u` exists in the map and `v` is farther than the current farthest
      # node for `u`, we need to update the map and remove intermediate nodes.
      if u in nodeToFarthestNode and nodeToFarthestNode[u] < v:
        node = nodeToFarthestNode[u]
        while node < v:
          node = nodeToFarthestNode.pop(node)
        nodeToFarthestNode[u] = v
      ans.append(len(nodeToFarthestNode))

    return ans"
"3245","struct SegmentTree {
 public:
  explicit SegmentTree(int n)
      : n(n), treeIntervalCounts(4 * n), treeIntervalLengths(4 * n) {}

  // Adds val to intervalCounts[i] and updates intervalLengths[i] accordingly.
  void add(int i, int val) {
    add(0, 0, n - 1, i, val);
  }

  // Returns sum(intervalCounts[i..n - 1]).
  int queryIntervalCounts(int i) const {
    return query(treeIntervalCounts, 0, 0, n - 1, i, n - 1);
  }

  // Returns sum(intervalLengths[i..n - 1]).
  int queryIntervalLengths(int i) const {
    return query(treeIntervalLengths, 0, 0, n - 1, i, n - 1);
  }

 private:
  const int n;
  vector<int> treeIntervalCounts;
  vector<int> treeIntervalLengths;

  void add(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      treeIntervalCounts[treeIndex] += val;
      treeIntervalLengths[treeIndex] = treeIntervalCounts[treeIndex] * i;
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      add(2 * treeIndex + 1, lo, mid, i, val);
    else
      add(2 * treeIndex + 2, mid + 1, hi, i, val);
    treeIntervalCounts[treeIndex] =
        merge(treeIntervalCounts[2 * treeIndex + 1],
              treeIntervalCounts[2 * treeIndex + 2]);
    treeIntervalLengths[treeIndex] =
        merge(treeIntervalLengths[2 * treeIndex + 1],
              treeIntervalLengths[2 * treeIndex + 2]);
  }

  int query(const vector<int>& tree, int treeIndex, int lo, int hi, int i,
            int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return 0;
    const int mid = (lo + hi) / 2;
    return merge(query(tree, treeIndex * 2 + 1, lo, mid, i, j),
                 query(tree, treeIndex * 2 + 2, mid + 1, hi, i, j));
  }

  int merge(int left, int right) const {
    return left + right;
  }
};

class Solution {
 public:
  vector<int> numberOfAlternatingGroups(vector<int>& colors,
                                        vector<vector<int>>& queries) {
    const int n = colors.size();
    vector<int> ans;
    vector<int> arr{colors};
    SegmentTree tree(2 * n - 1);
    set<pair<int, int>> intervals;

    arr.insert(arr.end(), colors.begin(), colors.end());

    // Insert all intervals, each of them is an alternating sequence.
    int start = 0;
    for (int i = 1; i < 2 * n - 1; ++i)
      if (arr[i] == arr[i - 1]) {
        insert(intervals, {start, i - 1}, tree, n);
        start = i;
      }
    insert(intervals, {start, 2 * n - 2}, tree, n);

    for (const vector<int>& query : queries)
      if (query[0] == 1) {
        const int sz = query[1];
        const pair<int, int>& intervalWithN = findInterval(intervals, n);
        const int numAlternatingGroups =
            getNumAlternatingGroups(sz, intervalWithN, tree, n);
        ans.push_back(numAlternatingGroups);
      } else {
        const int index = query[1];
        const int color = query[2];
        if (arr[index] == color)
          continue;
        update(intervals, index, color, arr, tree, n);
        if (index < n - 1)
          update(intervals, index + n, color, arr, tree, n);
      }

    return ans;
  }

 private:
  // Returns the number of alternating groups of size `sz`.
  int getNumAlternatingGroups(int sz, const pair<int, int>& intervalWithN,
                              const SegmentTree& tree, int n) {
    const int numIntervals = tree.queryIntervalCounts(sz);
    const int sumIntervals = tree.queryIntervalLengths(sz);
    // The number of alternating groups for an interval is |interval| - sz + 1.
    // Therefore, the number of alternating groups for all intervals is
    //   sum(|intervals[i]| - sz + 1)
    // = sum(|intervals[i]) - numIntervals * sz + numIntervals
    const int numAlternatingGroups =
        sumIntervals - numIntervals * sz + numIntervals;
    // We need to check if the interval (l, r) contains n, and if it does, we
    // need to adjust the number of alternating groups to avoid duplicates.
    const auto& [l, r] = intervalWithN;
    // 1. For an interval with l >= n, it wasn't being considered in `insert`
    // and `remove`.
    // 2. For an interval with r - l + 1 < sz, it's impossible to form a group
    // of size `sz`.
    if (l >= n || r - l + 1 < sz)
      return numAlternatingGroups;
    // 3. For an interval with r >= n, it's possible to duplicately count the
    // groups starting from n.
    if (r >= n) {  // l < n && r - 1 + 1 >= sz
      // Groups starting from [l..n) are non-duplicately counted.
      const int nonDuplicateGroups = n - l;
      // The number of groups of size `sz` in the interval [l..r].
      const int numGroups = (r - l + 1) - sz + 1;
      return numAlternatingGroups - max(0, numGroups - nonDuplicateGroups);
    }
    return numAlternatingGroups;
  }

  // Inserts an interval into `intervals` and updates `tree`.
  void insert(set<pair<int, int>>& intervals, const pair<int, int>& interval,
              SegmentTree& tree, int n) {
    intervals.insert(interval);
    if (interval.first < n)
      tree.add(interval.second - interval.first + 1, 1);
  }

  // Removes an interval from `intervals` and updates `tree`.
  void remove(set<pair<int, int>>& intervals, const pair<int, int>& interval,
              SegmentTree& tree, int n) {
    intervals.erase(interval);
    if (interval.first < n)
      tree.add(interval.second - interval.first + 1, -1);
  }

  // Returns the interval containing the target.
  pair<int, int> findInterval(const set<pair<int, int>>& intervals,
                              int target) {
    auto it = intervals.upper_bound({target, INT_MAX});
    return (*--it);
  }

  // Updates the color of the index-th element in `arr` and updates `intervals`
  // and `tree`.
  void update(set<pair<int, int>>& intervals, int index, int color,
              vector<int>& arr, SegmentTree& tree, int n) {
    arr[index] = color;

    const pair<int, int> intervalWithIndex = findInterval(intervals, index);
    remove(intervals, intervalWithIndex, tree, n);
    auto [start, end] = intervalWithIndex;

    // interval [s..i - 1|i|i + 1..e]
    //    index           ^
    if (start < index && index < end) {
      insert(intervals, {start, index - 1}, tree, n);
      insert(intervals, {index, index}, tree, n);
      insert(intervals, {index + 1, end}, tree, n);
      return;
    }

    // interval [s|s + 1..e]
    //    index  ^
    if (start == index && index < end)
      insert(intervals, {start + 1, end}, tree, n);

    // interval [s..e - 1|e]
    //    index           ^
    if (start < index && index == end)
      insert(intervals, {start, end - 1}, tree, n);

    start = index;
    end = index;
    vector<pair<int, int>> intervalsToRemove;

    auto it = intervals.upper_bound({index, INT_MAX});

    for (auto lit = it; lit != intervals.begin();) {
      --lit;
      if (arr[lit->second] == arr[start])  // [..lit->second|start..]
        break;
      intervalsToRemove.push_back(*lit);
      start = lit->first;
    }

    for (auto rit = it; rit != intervals.end(); ++rit) {
      if (arr[rit->first] == arr[end])  // [..end|rit->first..]
        break;
      intervalsToRemove.push_back(*rit);
      end = rit->second;
    }

    for (const pair<int, int>& interval : intervalsToRemove)
      remove(intervals, interval, tree, n);

    insert(intervals, {start, end}, tree, n);
  }
};"
"3246","WITH
  TeamPoints AS (
    SELECT team_id, team_name, wins * 3 + draws AS points
    FROM TeamStats
  ),
  RankedTeams AS (
    SELECT *, RANK() OVER(ORDER BY points DESC) AS position
    FROM TeamPoints
  )
SELECT team_id, team_name, points, position
FROM RankedTeams
ORDER BY points DESC, team_name;"
"3247","class Solution:
  def subsequenceCount(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    even = 0  # the number of subsequences with even sum
    odd = 0  # the number of subsequences with odd sum

    for num in nums:
      if num % 2 == 0:
        # Appending an even number to a subsequence doesn't change the parity.
        # The even number itself is also a valid subsequence.
        even, odd = even + even + 1, odd + odd
      else:
        # Appending an odd number to a subsequence changes the parity.
        # The odd number itself is also a valid subsequence.
        even, odd = even + odd, odd + even + 1

    return odd % kMod"
"3248","class Solution:
  def finalPositionOfSnake(self, n: int, commands: list[str]) -> int:
    directions = {
        ""UP"": (-1, 0),
        ""RIGHT"": (0, 1),
        ""DOWN"": (1, 0),
        ""LEFT"": (0, -1),
    }
    i = 0
    j = 0

    for command in commands:
      dx, dy = directions[command]
      i += dx
      j += dy

    return i * n + j"
"3249","class Solution:
  def countGoodNodes(self, edges: list[list[int]]) -> int:
    n = len(edges) + 1
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    ans = 0

    def dfs(u: int, prev: int) -> int:
      """"""Returns the size of the subtree rooted at u.""""""
      nonlocal ans
      size = 1
      childrenSizes = []
      for v in graph[u]:
        if v == prev:
          continue
        child_size = dfs(v, u)
        size += child_size
        childrenSizes.append(child_size)

      if not childrenSizes or all(s == childrenSizes[0]
                                  for s in childrenSizes):
        ans += 1

      return size

    dfs(0, -1)
    return ans"
"325","class Solution:
  def maxSubArrayLen(self, nums: list[int], k: int) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      target = prefix - k
      if target in prefixToIndex:
        ans = max(ans, i - prefixToIndex[target])
      if prefix not in prefixToIndex:
        prefixToIndex[prefix] = i

    return ans"
"3250","class Solution:
  def countOfPairs(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    kMax = 1000
    n = len(nums)
    # dp[i][num] := the number of valid ways to fill the arrays up to index i
    # with arr1[i] = num
    dp = [[0] * (kMax + 1) for _ in range(n)]

    for num in range(nums[0] + 1):
      dp[0][num] = 1

    for i in range(1, n):
      ways = 0
      prevNum = 0
      # To satisfy arr1, prevNum <= num.
      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.
      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).
      # As we move from `num` to `num + 1`, the range of valid `prevNum` values
      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).
      # Since the range of `prevNum` can only increase by at most 1, there's
      # no need to iterate through all possible values of `prevNum`. We can
      # simply increment `prevNum` by 1 if it meets the condition.
      for num in range(nums[i] + 1):
        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):
          ways = (ways + dp[i - 1][prevNum]) % kMod
          prevNum += 1
        dp[i][num] = ways

    return sum(dp[n - 1]) % kMod"
"3251","class Solution:
  # Same as 3250. Find the Count of Monotonic Pairs I
  def countOfPairs(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    kMax = 1000
    n = len(nums)
    # dp[i][num] := the number of valid ways to fill the arrays up to index i
    # with arr1[i] = num
    dp = [[0] * (kMax + 1) for _ in range(n)]

    for num in range(nums[0] + 1):
      dp[0][num] = 1

    for i in range(1, n):
      ways = 0
      prevNum = 0
      # To satisfy arr1, prevNum <= num.
      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.
      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).
      # As we move from `num` to `num + 1`, the range of valid `prevNum` values
      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).
      # Since the range of `prevNum` can only increase by at most 1, there's
      # no need to iterate through all possible values of `prevNum`. We can
      # simply increment `prevNum` by 1 if it meets the condition.
      for num in range(nums[i] + 1):
        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):
          ways = (ways + dp[i - 1][prevNum]) % kMod
          prevNum += 1
        dp[i][num] = ways

    return sum(dp[n - 1]) % kMod"
"3252","WITH
  TeamPoints AS (
    SELECT team_id, team_name, wins * 3 + draws AS points
    FROM TeamStats
  ),
  RankedTeams AS (
    SELECT *, RANK() OVER(ORDER BY points DESC) AS position
    FROM TeamPoints
  ),
  Tiers AS (
    SELECT
      CEIL(COUNT(*) * 0.33) AS tier1_bound,
      CEIL(COUNT(*) * 0.67) AS tier2_bound
    FROM RankedTeams
  )
SELECT
  RankedTeams.team_name,
  RankedTeams.points,
  RankedTeams.position,
  CASE
    WHEN RankedTeams.position <= Tiers.tier1_bound THEN 'Tier 1'
    WHEN RankedTeams.position <= Tiers.tier2_bound THEN 'Tier 2'
    ELSE 'Tier 3'
  END AS tier
FROM RankedTeams
CROSS JOIN Tiers
ORDER BY points DESC, team_name;"
"3253","class Solution:
  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:
    n = len(target)
    # dp[i] := the minimum cost to construct target[0:i]
    dp = [0] + [math.inf] * n

    for i in range(1, n + 1):
      for j, (word, cost) in enumerate(zip(words, costs)):
        if (i >= len(word) and
            target[i - len(word):i] == word and
                dp[i - len(word)] != math.inf):
          dp[i] = min(dp[i], dp[i - len(word)] + cost)

    return dp[n] if dp[n] != math.inf else -1"
"3254","class Solution:
  def resultsArray(self, nums: list[int], k: int) -> list[int]:
    ans = []
    start = 0

    for i, num in enumerate(nums):
      if i > 0 and num != nums[i - 1] + 1:
        start = i
      if i >= k - 1:
        ans.append(num if i - start + 1 >= k else -1)

    return ans"
"3255","class Solution:
  # Same as 3254. Find the Power of K-Size Subarrays I
  def resultsArray(self, nums: list[int], k: int) -> list[int]:
    ans = []
    start = 0

    for i, num in enumerate(nums):
      if i > 0 and num != nums[i - 1] + 1:
        start = i
      if i >= k - 1:
        ans.append(num if i - start + 1 >= k else -1)

    return ans"
"3256","class Solution:
  def maximumValueSum(self, board: list[list[int]]) -> int:
    rows = [heapq.nlargest(3, [(val, i, j)
            for j, val in enumerate(row)])
            for i, row in enumerate(board)]
    cols = [heapq.nlargest(3, [(val, i, j)
            for i, val in enumerate(col)])
            for j, col in enumerate(zip(*board))]
    topNine = heapq.nlargest(9,
                             set(itertools.chain(*rows)) &
                             set(itertools.chain(*cols)))
    return max(
        (val1 + val2 + val3 for
         (val1, i1, j1),
         (val2, i2, j2),
         (val3, i3, j3) in (itertools.combinations(topNine, 3))
         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))"
"3257","class Solution:
  # Same as 3256. Maximum Value Sum by Placing Three Rooks I
  def maximumValueSum(self, board: list[list[int]]) -> int:
    rows = [heapq.nlargest(3, [(val, i, j)
            for j, val in enumerate(row)])
            for i, row in enumerate(board)]
    cols = [heapq.nlargest(3, [(val, i, j)
            for i, val in enumerate(col)])
            for j, col in enumerate(zip(*board))]
    topNine = heapq.nlargest(9,
                             set(itertools.chain(*rows)) &
                             set(itertools.chain(*cols)))
    return max(
        (val1 + val2 + val3 for
         (val1, i1, j1),
         (val2, i2, j2),
         (val3, i3, j3) in (itertools.combinations(topNine, 3))
         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))"
"3258","class Solution:
  def countKConstraintSubstrings(self, s: str, k: int) -> int:
    ans = 0
    count = [0, 0]

    l = 0
    for r, c in enumerate(s):
      count[int(c)] += 1
      while min(count) > k:
        count[int(s[l])] -= 1
        l += 1
      ans += r - l + 1

    return ans"
"3259","class Solution:
  def maxEnergyBoost(
      self,
      energyDrinkA: list[int],
      energyDrinkB: list[int]
  ) -> int:
    dpA = 0  # the maximum energy boost if the last drink is A
    dpB = 0  # the maximum energy boost if the last drink is B

    for a, b in zip(energyDrinkA, energyDrinkB):
      dpA, dpB = max(dpB, dpA + a), max(dpA, dpB + b)

    return max(dpA, dpB)"
"326","class Solution:
  def isPowerOfThree(self, n: int) -> bool:
    return n > 0 and 3**19 % n == 0"
"3260","class Solution:
  def largestPalindrome(self, n: int, k: int) -> str:
    match k:
      case 1:
        return '9' * n
      case 2:
        return '8' * n if n <= 2 else '8' + '9' * (n - 2) + '8'
      case 3 | 9:
        return '9' * n
      case 4:
        return '8' * n if n <= 4 else '88' + '9' * (n - 4) + '88'
      case 5:
        return '5' * n if n <= 2 else '5' + '9' * (n - 2) + '5'
      case 6:
        if n <= 2:
          return '6' * n
        elif n % 2 == 1:
          l = n // 2 - 1
          return '8' + '9' * l + '8' + '9' * l + '8'
        else:
          l = n // 2 - 2
          return '8' + '9' * l + '77' + '9' * l + '8'
      case 8:
        return '8' * n if n <= 6 else '888' + '9' * (n - 6) + '888'
      case _:
        middle = {
            0: '', 1: '7', 2: '77', 3: '959', 4: '9779', 5: '99799',
            6: '999999', 7: '9994999', 8: '99944999', 9: '999969999',
            10: '9999449999', 11: '99999499999'
        }
        q, r = divmod(n, 12)
        return '999999' * q + middle[r] + '999999' * q"
"3261","class Solution:
  def countKConstraintSubstrings(
      self,
      s: str,
      k: int,
      queries: list[list[int]]
  ) -> list[int]:
    n = len(s)
    ans = []
    count = [0, 0]
    # leftToRight[l] := the maximum right index r s.t. s[l..r] is valid
    leftToRight = [0] * n
    # rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid
    rightToLeft = [0] * n

    l = 0
    for r in range(n):
      count[int(s[r])] += 1
      while min(count) > k:
        count[int(s[l])] -= 1
        l += 1
      rightToLeft[r] = l

    count = [0, 0]
    r = n - 1
    for l in reversed(range(n)):
      count[int(s[l])] += 1
      while min(count) > k:
        count[int(s[r])] -= 1
        r -= 1
      leftToRight[l] = r

    # prefix[i] := the number of valid substrings ending in [0..i - 1].
    prefix = list(itertools.accumulate((r - l + 1
                                       for r, l in enumerate(rightToLeft)),
                                       initial=0))

    for l, r in queries:
      if r > leftToRight[l]:
        # If r is beyond leftToRight[l], compute the number of valid substrings
        # from l to leftToRight[l] and add the number of valid substrings
        # ending in [leftToRight[l] + 1..r].
        #
        # prefix[r + 1] := the number of valid substrings ending in [0..r].
        # prefix[leftToRight[l] + 1] := the number of valid substrings ending
        # in [0..leftToRight].
        # => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid
        # substrings ending in [leftToRight[l] + 1..r].
        sz = leftToRight[l] - l + 1
        numValidSubstrings = sz * (sz + 1) // 2 + (
            prefix[r + 1] - prefix[leftToRight[l] + 1])
      else:
        # If r is within the range of leftToRight[l], compute the number of
        # valid substrings directly from l to r.
        sz = r - l + 1
        numValidSubstrings = sz * (sz + 1) // 2
      ans.append(numValidSubstrings)

    return ans"
"3262","SELECT
  Shift1.employee_id,
  COUNT(*) AS overlapping_shifts
FROM EmployeeShifts AS Shift1
INNER JOIN EmployeeShifts AS Shift2
  USING (employee_id)
WHERE
  Shift1.start_time < Shift2.start_time
  AND Shift2.start_time < Shift1.end_time
GROUP BY 1
ORDER BY 1;"
"3263","class Solution:
  def toArray(self, head: 'Optional[Node]') -> list[int]:
    ans = []
    curr = head

    while curr:
      ans.append(curr.val)
      curr = curr.next

    return ans"
"3264","class Solution:
  def getFinalState(
      self,
      nums: list[int],
      k: int,
      multiplier: int
  ) -> list[int]:
    ans = [0] * len(nums)
    minHeap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(minHeap)

    for _ in range(k):
      num, i = heapq.heappop(minHeap)
      heapq.heappush(minHeap, (num * multiplier, i))

    for num, i in minHeap:
      ans[i] = num

    return ans"
"3265","class Solution:
  def countPairs(self, nums: list[int]) -> int:
    ans = 0
    count = collections.Counter()
    maxLen = len(str(max(nums)))

    for num in nums:
      digits = list(str(num).zfill(maxLen))
      for swap in self._getSwaps(digits):
        ans += count[swap]
      count[num] += 1

    return ans

  def _getSwaps(self, digits: str) -> set[int]:
    """"""Returns all possible numbers after 1 swap.""""""
    n = len(digits)
    swaps = set([int(''.join(digits))])

    for i, j in itertools.combinations(range(n), 2):
      newDigits = digits[:]
      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]
      swaps.add(int(''.join(newDigits)))

    return swaps"
"3266","class Solution:
  def getFinalState(
      self,
      nums: list[int],
      k: int,
      multiplier: int
  ) -> list[int]:
    if multiplier == 1:
      return nums

    kMod = 1_000_000_007
    n = len(nums)
    maxNum = max(nums)
    ans = [0] * n
    minHeap = [(num, i) for i, num in enumerate(nums)]

    heapq.heapify(minHeap)

    # Keep multiplying the minimum number as close as possible to the maximum
    # number in the array. After that, stop multiplying the minimum number
    # because it will be greater than the maximum number in the array and break
    # the circularity.
    while k > 0 and minHeap[0][0] * multiplier <= maxNum:
      num, i = heapq.heappop(minHeap)
      heapq.heappush(minHeap, (num * multiplier, i))
      k -= 1

    sortedIndexedNums = sorted(minHeap)
    multipliesPerNum, remainingK = divmod(k, n)

    # Evenly distribute the remaining multiplications to each number by using
    # fast exponentiation.
    for index, (num, i) in enumerate(sortedIndexedNums):
      sortedIndexedNums[index] = (
          sortedIndexedNums[index][0] *
          pow(multiplier, multipliesPerNum, kMod) % kMod, i)

    # Distribute the remaining multiplications to the minimum `remainingK`
    # numbers.
    for index in range(remainingK):
      sortedIndexedNums[index] = (
          sortedIndexedNums[index][0] * multiplier % kMod,
          sortedIndexedNums[index][1])

    for num, i in sortedIndexedNums:
      ans[i] = num

    return ans"
"3267","class Solution:
  # Similar to 3265. Count Almost Equal Pairs I
  def countPairs(self, nums: list[int]) -> int:
    ans = 0
    count = collections.Counter()
    maxLen = len(str(max(nums)))

    for num in nums:
      digits = list(str(num).zfill(maxLen))
      for swap in self._getSwaps(digits):
        ans += count[swap]
      count[num] += 1

    return ans

  def _getSwaps(self, digits: str) -> set[int]:
    """"""Returns all possible numbers after 1 or 2 swaps.""""""
    n = len(digits)
    swaps = set([int(''.join(digits))])

    # Add all numbers after 1 swap.
    for i, j in itertools.combinations(range(n), 2):
      newDigits = digits[:]
      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]
      swaps.add(int(''.join(newDigits)))

    # Add all numbers after 2 swaps.
    for (i1, j1), (i2, j2) in itertools.combinations(
            itertools.combinations(range(n), 2), 2):
      newDigits = digits[:]
      newDigits[i1], newDigits[j1] = newDigits[j1], newDigits[i1]
      newDigits[i2], newDigits[j2] = newDigits[j2], newDigits[i2]
      swaps.add(int(''.join(newDigits)))

    return swaps"
"3268","WITH
  EmployeeTimes AS (
    SELECT DISTINCT employee_id, start_time AS `time`
    FROM EmployeeShifts
    UNION DISTINCT
    SELECT DISTINCT employee_id, end_time AS `time`
    FROM EmployeeShifts
  ),
  Segments AS (
    SELECT
      employee_id,
      `time` AS start_time,
      LEAD(`time`) OVER(PARTITION BY employee_id ORDER BY `time`) AS end_time
    FROM EmployeeTimes
  ),
  SegmentsCount AS (
    SELECT
      Segments.*,
      COUNT(*) AS concurrent_count
    FROM Segments
    INNER JOIN EmployeeShifts
      USING (employee_id)
    WHERE
      Segments.start_time >= EmployeeShifts.start_time
      AND Segments.end_time <= EmployeeShifts.end_time
    GROUP BY 1, 2, 3
  )
SELECT
  employee_id,
  MAX(concurrent_count) AS max_overlapping_shifts,
  SUM(
    concurrent_count * (concurrent_count - 1) / 2 * TIMESTAMPDIFF(
      MINUTE,
      start_time,
      end_time
    )
  ) AS total_overlap_duration -- C(concurrent_count, 2)
FROM SegmentsCount
GROUP BY 1
ORDER BY 1;"
"3269","class Solution:
  def minLargest(self, nums1: list[int], nums2: list[int]) -> int:
    m = len(nums1)
    n = len(nums2)
    # dp[i][j] := the minimum largest number for the first i nums1 and the
    # first j nums2
    dp = [[math.inf] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = 0

    def f(prev: int, num: int) -> int:
      """"""
      Returns the next number to fill in the array based on the previous number
      and the current number.
      """"""
      return prev + (2 if prev % 2 == num else 1)

    for i in range(m + 1):
      for j in range(n + 1):
        if i > 0:
          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]))
        if j > 0:
          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]))

    return dp[m][n]"
"327","class Solution:
  def countRangeSum(self, nums: list[int], lower: int, upper: int) -> int:
    n = len(nums)
    self.ans = 0
    prefix = list(itertools.accumulate(nums, initial=0))

    self._mergeSort(prefix, 0, n, lower, upper)
    return self.ans

  def _mergeSort(
      self,
      prefix: list[int],
      l: int,
      r: int,
      lower: int,
      upper: int,
  ) -> None:
    if l >= r:
      return

    m = (l + r) // 2
    self._mergeSort(prefix, l, m, lower, upper)
    self._mergeSort(prefix, m + 1, r, lower, upper)
    self._merge(prefix, l, m, r, lower, upper)

  def _merge(
      self,
      prefix: list[int],
      l: int,
      m: int,
      r: int,
      lower: int,
      upper: int,
  ) -> None:
    lo = m + 1  # the first index s.t. prefix[lo] - prefix[i] >= lower
    hi = m + 1  # the first index s.t. prefix[hi] - prefix[i] > upper

    # For each index i in range [l, m], add hi - lo to `ans`.
    for i in range(l, m + 1):
      while lo <= r and prefix[lo] - prefix[i] < lower:
        lo += 1
      while hi <= r and prefix[hi] - prefix[i] <= upper:
        hi += 1
      self.ans += hi - lo

    sorted = [0] * (r - l + 1)
    k = 0  # sorted's index
    i = l  # left's index
    j = m + 1  # right's index

    while i <= m and j <= r:
      if prefix[i] < prefix[j]:
        sorted[k] = prefix[i]
        k += 1
        i += 1
      else:
        sorted[k] = prefix[j]
        k += 1
        j += 1

    # Put the possible remaining left part into the sorted array.
    while i <= m:
      sorted[k] = prefix[i]
      k += 1
      i += 1

    # Put the possible remaining right part into the sorted array.
    while j <= r:
      sorted[k] = prefix[j]
      k += 1
      j += 1

    prefix[l:l + len(sorted)] = sorted"
"3270","class Solution:
  def generateKey(self, num1: int, num2: int, num3: int) -> int:
    return int(''.join(min(a, b, c)
                       for a, b, c in zip(str(num1).zfill(4),
                                          str(num2).zfill(4),
                                          str(num3).zfill(4))))"
"3271","class Solution:
  def stringHash(self, s: str, k: int) -> str:
    ans = []

    for i in range(0, len(s), k):
      sumHash = sum(string.ascii_lowercase.index(s[j])
                    for j in range(i, i + k))
      ans.append(string.ascii_lowercase[sumHash % 26])

    return ''.join(ans)"
"3272","class Solution:
  def countGoodIntegers(self, n: int, k: int) -> int:
    halfLength = (n + 1) // 2
    minHalf = 10**(halfLength - 1)
    maxHalf = 10**halfLength
    ans = 0
    seen = set()

    for num in range(minHalf, maxHalf):
      palindrome = str(num) + str(num)[::-1][n % 2:]
      sortedDigits = ''.join(sorted(palindrome))
      if int(palindrome) % k != 0 or sortedDigits in seen:
        continue
      seen.add(sortedDigits)
      digitCount = collections.Counter(palindrome)
      # Leading zeros are not allowed, so the first digit is special.
      firstDigitChoices = n - digitCount['0']
      permutations = firstDigitChoices * math.factorial(n - 1)
      # For each repeated digit, divide by the factorial of the frequency since
      # permutations that swap identical digits don't create a new number.
      for freq in digitCount.values():
        permutations //= math.factorial(freq)
      ans += permutations

    return ans"
"3273","from dataclasses import dataclass


@dataclass(frozen=True)
class Enemy:
  damage: int
  timeTakenDown: int


class Solution:
  def minDamage(self, power: int, damage: list[int], health: list[int]) -> int:
    ans = 0
    sumDamage = sum(damage)
    enemies = [Enemy(d, (h + power - 1) // power)
               for d, h in zip(damage, health)]

    # It's better to take down the enemy i first if the damage dealt of taking
    # down i first is less than the damage dealt of taking down j first. So,
    #    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <
    #    damage[j] * t[j] + (t[i] + t[j]) * damage[i]
    # => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <
    #    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]
    # => damage[j] * t[i] < damage[i] * t[j]
    # => damage[j] / t[j] < damage[i] / t[i]
    enemies.sort(key=lambda x: -x.damage / x.timeTakenDown)

    for enemy in enemies:
      ans += sumDamage * enemy.timeTakenDown
      sumDamage -= enemy.damage

    return ans"
"3274","class Solution:
  def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
    # Same as 1812. Determine Color of a Chessboard Square
    def squareIsWhite(coordinate: str) -> bool:
      letter, digit = coordinate
      return ord(letter) % 2 != int(digit) % 2

    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2)"
"3275","class Solution:
  def resultsArray(self, queries: list[list[int]], k: int) -> list[int]:
    ans = []
    maxHeap = []

    for x, y in queries:
      heapq.heappush(maxHeap, -(abs(x) + abs(y)))
      if len(maxHeap) > k:
        heapq.heappop(maxHeap)
      ans.append(-maxHeap[0] if len(maxHeap) == k else -1)

    return ans"
"3276","class Solution:
  def maxScore(self, grid: list[list[int]]) -> int:
    numToIndices = collections.defaultdict(set)
    for index, row in enumerate(grid):
      for num in row:
        numToIndices[num].add(index)
    numToIndices = list(numToIndices.items())

    @functools.lru_cache(None)
    def dp(i: int, mask: int) -> int:
      """"""
      Returns the maximum score by selecting numbers from numToIndices[i..],
      where `mask` is the bitmask of the used row indices.
      """"""
      if i == len(numToIndices):
        return 0
      # Skip numToIndices[i][0].
      res = dp(i + 1, mask)
      for index in numToIndices[i][1]:
        if (mask >> index & 1) == 0:
          # Take numToIndices[i][0].
          res = max(res, numToIndices[i][0] + dp(i + 1, mask | 1 << index))
      return res

    return dp(0, 0)"
"3277","class Solution:
  def maximumSubarrayXor(
      self,
      nums: list[int],
      queries: list[list[int]]
  ) -> list[int]:
    n = len(nums)
    # xors[i][j] := the XOR score of nums[i..j]
    xors = [[0] * n for _ in range(n)]
    # dp[i][j] := the maximum XOR score of nums[i..j]
    dp = [[0] * n for _ in range(n)]

    for i, num in enumerate(nums):
      xors[i][i] = num
      dp[i][i] = num

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j]
        dp[i][j] = max(xors[i][j], dp[i][j - 1], dp[i + 1][j])

    return [dp[l][r] for l, r in queries]"
"3278","WITH
  ProjectSkills AS (
    SELECT project_id, COUNT(skill) AS required_skills
    FROM Projects
    GROUP BY 1
  ),
  CandidateScores AS (
    SELECT
      Projects.project_id,
      Candidates.candidate_id,
      100 + SUM(
        CASE
          WHEN Candidates.proficiency > Projects.importance THEN 10
          WHEN Candidates.proficiency < Projects.importance THEN -5
          ELSE 0
        END
      ) AS score,
      COUNT(Projects.skill) AS matched_skills
    FROM Projects
    INNER JOIN Candidates
      USING (skill)
    GROUP BY 1, 2
  ),
  RankedCandidates AS (
    SELECT
      CandidateScores.project_id,
      CandidateScores.candidate_id,
      CandidateScores.score,
      RANK() OVER(
        PARTITION BY CandidateScores.project_id
        ORDER BY CandidateScores.score DESC, CandidateScores.candidate_id
      ) AS `rank`
    FROM CandidateScores
    INNER JOIN ProjectSkills
      USING (project_id)
    WHERE CandidateScores.matched_skills = ProjectSkills.required_skills
  )
SELECT project_id, candidate_id, score
FROM RankedCandidates
WHERE `rank` = 1
ORDER BY 1;"
"3279","from sortedcontainers import SortedDict


class Solution:
  def maxArea(self, height: int, positions: list[int], directions: str) -> int:
    area = sum(positions)
    ans = area
    diffPerSecond = 0
    timeToIndices: SortedDict[int, list[int]] = SortedDict()

    for i, (position, direction) in enumerate(zip(positions, directions)):
      if direction == 'U':
        timeToIndices.setdefault(height - position, []).append(i)
        timeToIndices.setdefault(height - position + height, []).append(i)
        diffPerSecond += 1
      else:
        timeToIndices.setdefault(position, []).append(i)
        timeToIndices.setdefault(position + height, []).append(i)
        diffPerSecond -= 1

    prevTime = 0
    directionsList = list(directions)

    for time, indices in timeToIndices.items():
      area += (time - prevTime) * diffPerSecond
      ans = max(ans, area)
      prevTime = time
      for i in indices:
        if directionsList[i] == 'U':
          directionsList[i] = 'D'
          diffPerSecond -= 2
        else:
          directionsList[i] = 'U'
          diffPerSecond += 2

    return ans"
"328","class Solution:
  def oddEvenList(self, head: ListNode) -> ListNode:
    oddHead = ListNode(0)
    evenHead = ListNode(0)
    odd = oddHead
    even = evenHead
    isOdd = True

    while head:
      if isOdd:
        odd.next = head
        odd = head
      else:
        even.next = head
        even = head
      head = head.next
      isOdd = not isOdd

    even.next = None
    odd.next = evenHead.next
    return oddHead.next"
"3280","class Solution:
  def convertDateToBinary(self, date: str) -> str:
    year, month, day = map(int, date.split('-'))

    def toBinary(value: int) -> str:
      """"""Converts an integer to binary without leading zeros.""""""
      return bin(value)[2:]

    return '-'.join([toBinary(year), toBinary(month), toBinary(day)])"
"3281","class Solution:
  def maxPossibleScore(self, start: list[int], d: int) -> int:
    def isPossible(m: int) -> bool:
      lastPick = start[0]
      for i in range(1, len(start)):
        if lastPick + m > start[i] + d:
          return False
        lastPick = max(lastPick + m, start[i])
      return True

    start.sort()

    maxScore = (start[-1] + d) - start[0] + 1
    l = bisect.bisect_left(range(maxScore), True,
                           key=lambda m: not isPossible(m))
    return l - 1"
"3282","class Solution:
  # Similar to 3205. Maximum Array Hopping Score I
  def findMaximumScore(self, nums: list[int]) -> int:
    return sum(itertools.accumulate(nums[:-1], max))"
"3283","class Solution:
  def __init__(self):
    self.kSize = 50
    self.kMax = 1_000_000
    self.dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
                 (-1, -2), (-2, -1), (-2, 1), (-1, 2))

  def maxMoves(self, kx: int, ky: int, positions: list[list[int]]) -> int:
    n = len(positions)
    positions.append([kx, ky])
    hashedPositionToIndex = {}
    # dist[i][j] := the minimum distance from positions[i] to positions[j]
    dist = [[0] * (n + 1) for _ in range(n + 1)]

    for i, (x, y) in enumerate(positions):
      hashedPositionToIndex[self._hash(x, y)] = i

    for sourceIndex in range(n + 1):
      self._bfs(positions, sourceIndex, hashedPositionToIndex, dist)

    kMaxMask = 1 << (n + 1)
    # dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to
    # kill all pawns, where i is the current pawn, mask is the set of pawns
    # that have been killed, and turn is the current player's turn (0 for Alice
    # and 1 for Bob)
    dp = [[[0, 0]
          for _ in range(1 << (n + 1))]
          for _ in range(n + 1)]

    for i in range(n + 1):
      for mask in range(kMaxMask - 1):
        dp[i][mask] = [-self.kMax, self.kMax]

    for mask in range(kMaxMask - 2, -1, -1):
      for i in range(n + 1):
        for turn in range(2):
          for j in range(n):
            if mask >> j & 1:
              continue
            moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn]
            dp[i][mask][turn] = (max(dp[i][mask][turn], moves) if turn == 0 else
                                 min(dp[i][mask][turn], moves))

    # Returns the maximum cost to kill all pawns, i.e., the original positions
    # array without the knight (kx, ky).
    return dp[n][1 << n][0]

  def _hash(self, x: int, y: int) -> int:
    return x * self.kSize + y

  def _bfs(
      self,
      positions: list[list[int]],
      sourceIndex: int,
      hashedPositionToIndex: dict[int, int],
      dist: list[list[int]]
  ) -> None:
    """"""
    Computes the distance between positions[sourceIndex] and other positions.
    """"""
    sx, sy = positions[sourceIndex]
    q = collections.deque([(sx, sy)])
    seen = {(sx, sy)}
    seenPositions = 0

    step = 0
    while q and seenPositions < len(positions):
      for _ in range(len(q)):
        i, j = q.popleft()
        hashedPosition = self._hash(i, j)
        if hashedPosition in hashedPositionToIndex:
          dist[sourceIndex][hashedPositionToIndex[hashedPosition]] = step
          seenPositions += 1
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x >= self.kSize or y < 0 or y >= self.kSize:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))
      step += 1"
"3284","class Solution:
  def getSum(self, nums: list[int]) -> int:
    def getSum(diff: int) -> int:
      """"""Returns the sum of all subarrays with a difference of `diff`.""""""
      res = nums[0]
      summ = nums[0]
      count = 1
      for prev, num in itertools.pairwise(nums):
        if num == prev + diff:
          count += 1
          summ += count * num
        else:
          count = 1
          summ = num
        res += summ
      return res

    return (getSum(1) + getSum(-1) - sum(nums)) % 1_000_000_007"
"3285","class Solution:
  def stableMountains(self, height: list[int], threshold: int) -> list[int]:
    return [i for i in range(1, len(height))
            if height[i - 1] > threshold]"
"3286","class Solution:
  def findSafeWalk(self, grid: list[list[int]], health: int) -> bool:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    initialHealth = health - grid[0][0]
    q = collections.deque([(0, 0, initialHealth)])
    seen = {(0, 0, initialHealth)}

    while q:
      for _ in range(len(q)):
        i, j, h = q.popleft()
        if i == m - 1 and j == n - 1 and h > 0:
          return True
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          nextHealth = h - grid[x][y]
          if nextHealth <= 0 or (x, y, nextHealth) in seen:
            continue
          q.append((x, y, nextHealth))
          seen.add((x, y, nextHealth))

    return False"
"3287","class Solution:
  def maxValue(self, nums: list[int], k: int) -> int:
    left = self._getPossibleORs(nums, k)
    right = self._getPossibleORs(nums[::-1], k)[::-1]
    return max(a ^ b
               for i in range(k - 1, len(nums) - k)
               for a in range(128 + 1)
               for b in range(128 + 1)
               if left[i][k][a] and right[i + 1][k][b])

  def _getPossibleORs(self, nums: list[int], k: int) -> list[list[list[bool]]]:
    dp = [[[False] * (128 + 1)
          for _ in range(k + 1)]
          for _ in range(len(nums))]

    dp[0][1][nums[0]] = True

    for i in range(len(nums)):
      dp[i][0][0] = True

    for i in range(1, len(nums)):
      for j in range(1, k + 1):
        for x in range(128 + 1):
          if dp[i - 1][j][x]:
            dp[i][j][x] = True
          if dp[i - 1][j - 1][x]:
            dp[i][j][nums[i] | x] = True

    return dp"
"3288","class Solution:
  def maxPathLength(self, coordinates: list[list[int]], k: int) -> int:
    xk, yk = coordinates[k]
    leftCoordinates = [(x, y) for x, y in coordinates if x < xk and y < yk]
    rightCoordinates = [(x, y) for x, y in coordinates if x > xk and y > yk]
    return (1 +
            self._lengthOfLIS(leftCoordinates) +
            self._lengthOfLIS(rightCoordinates))

  # Similar to 300. Longest Increasing Subsequence
  def _lengthOfLIS(self, coordinates: list[tuple[int, int]]) -> int:
    coordinates.sort(key=lambda x: (x[0], -x[1]))
    # tail[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tail = []
    for _, y in coordinates:
      if not tail or y > tail[-1]:
        tail.append(y)
      else:
        tail[bisect.bisect_left(tail, y)] = y
    return len(tail)"
"3289","class Solution:
  def getSneakyNumbers(self, nums: list[int]) -> list[int]:
    return [num for num, freq in collections.Counter(nums).items()
            if freq == 2]"
"329","class Solution:
  def longestIncreasingPath(self, matrix: list[list[int]]) -> int:
    m = len(matrix)
    n = len(matrix[0])

    @functools.lru_cache(None)
    def dfs(i: int, j: int, prev: int) -> int:
      if i < 0 or i == m or j < 0 or j == n:
        return 0
      if matrix[i][j] <= prev:
        return 0

      curr = matrix[i][j]
      return 1 + max(dfs(i + 1, j, curr),
                     dfs(i - 1, j, curr),
                     dfs(i, j + 1, curr),
                     dfs(i, j - 1, curr))

    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))"
"3290","class Solution:
  def maxScore(self, a: list[int], b: list[int]) -> int:
    n = len(b)
    # dp[i][j] := the maximum score by selecting 4 - i numbers from b[j..n - 1]
    # using the corresponding numbers from a[i..3]
    dp = [[0] * (n + 1) for _ in range(5)]

    # Run out of numbers in b but still need to select numbers from a.
    for i in range(4):
      dp[i][n] = -math.inf

    for i in reversed(range(4)):
      for j in reversed(range(n)):
        # Skip b[j] or pair a[i] with b[j].
        dp[i][j] = max(dp[i][j + 1], a[i] * b[j] + dp[i + 1][j + 1])

    return -1 if dp[0][0] == -math.inf else dp[0][0]"
"3291","class Solution:
  def minValidStrings(self, words: list[str], target: str) -> int:
    ans = 0
    unmatchedPrefix = len(target)
    lpsList = [self._getLPS(word + '#' + target) for word in words]

    while unmatchedPrefix > 0:
      # Greedily choose the word that has the longest suffix match with the
      # remaining unmatched prefix.
      maxMatchSuffix = 0
      for lps, word in zip(lpsList, words):
        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])
      if maxMatchSuffix == 0:
        return -1
      ans += 1
      unmatchedPrefix -= maxMatchSuffix

    return ans

  def _getLPS(self, pattern: str) -> list[int]:
    """"""
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """"""
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        lps[i] = j + 1
        j += 1
    return lps"
"3292","class Solution:
  # 3291. Minimum Number of Valid Strings to Form Target I
  def minValidStrings(self, words: list[str], target: str) -> int:
    ans = 0
    unmatchedPrefix = len(target)
    lpsList = [self._getLPS(word + '#' + target) for word in words]

    while unmatchedPrefix > 0:
      # Greedily choose the word that has the longest suffix match with the
      # remaining unmatched prefix.
      maxMatchSuffix = 0
      for lps, word in zip(lpsList, words):
        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])
      if maxMatchSuffix == 0:
        return -1
      ans += 1
      unmatchedPrefix -= maxMatchSuffix

    return ans

  def _getLPS(self, pattern: str) -> list[int]:
    """"""
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """"""
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        lps[i] = j + 1
        j += 1
    return lps"
"3293","SELECT
  Products.product_id,
  Products.price - (
    Products.price * IFNULL(Discounts.discount, 0) / 100
  ) AS final_price,
  Products.category
FROM Products
LEFT JOIN Discounts
  USING (category);"
"3294","class Solution:
  def toArray(self, node: 'Optional[Node]') -> list[int]:
    ans = []
    curr = node

    while curr.prev:
      curr = curr.prev

    while curr:
      ans.append(curr.val)
      curr = curr.next

    return ans"
"3295","class Solution:
  def reportSpam(self, message: list[str], bannedWords: list[str]) -> bool:
    bannedWordsSet = set(bannedWords)
    return sum(word in bannedWordsSet for word in message) > 1"
"3296","class Solution:
  def minNumberOfSeconds(
      self,
      mountainHeight: int,
      workerTimes: list[int]
  ) -> int:
    def getReducedHeight(m: int) -> int:
      """"""Returns the total height reduced by all workers in `m` seconds.""""""
      # The height `x` that a worker with working time `w` reduces in `m`
      # seconds.
      # w * (1 + 2 + ... + x) <= m
      #       (1 + x) * x / 2 <= m / w
      #   x^2 + x - 2 * m / w <= 0
      #                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2
      return sum((-1 + math.sqrt(1 + 8 * m // workerTime)) // 2
                 for workerTime in workerTimes)

    r = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
    return bisect.bisect_left(range(1, r), mountainHeight,
                              key=lambda m: getReducedHeight(m)) + 1"
"3297","class Solution:
  def validSubstringCount(self, word1: str, word2: str) -> int:
    ans = 0
    count = collections.Counter(word2)
    required = len(word2)

    l = 0
    for r, c in enumerate(word1):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      while required == 0:
        # Add valid substrings containing word1[l..r] to the answer. They are
        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].
        ans += len(word1) - r
        count[word1[l]] += 1
        if count[word1[l]] > 0:
          required += 1
        l += 1

    return ans"
"3298","class Solution:
  # Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I
  def validSubstringCount(self, word1: str, word2: str) -> int:
    ans = 0
    count = collections.Counter(word2)
    required = len(word2)

    l = 0
    for r, c in enumerate(word1):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      while required == 0:
        # Add valid substrings containing word1[l..r] to the answer. They are
        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].
        ans += len(word1) - r
        count[word1[l]] += 1
        if count[word1[l]] > 0:
          required += 1
        l += 1

    return ans"
"3299","class Solution:
  def getSum(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)

    def getSequenceSum(nums: list[int], direction: int) -> int:
      """"""
      Returns the sum of all sequences in the array that are in consecutive
      increasing order if `direction` is 1, or in consecutive decreasing order
      if `direction` is -1.""""""
      sequenceSum = 0
      # {num: the number of subsequences ending in `num` so far}
      prefixCount = collections.Counter()
      # {num: the number of subsequences starting from `num` so far}
      suffixCount = collections.Counter()
      # prefixSubseqs[i] := the number of subsequences ending in nums[i]
      prefixSubseqs = [0] * n
      # suffixSubseqs[i] := the number of subsequences starting from nums[i]
      suffixSubseqs = [0] * n

      for i, num in enumerate(nums):
        prevNum = num - direction
        freq = prefixCount[prevNum] + 1
        prefixSubseqs[i] = freq
        prefixCount[num] += freq
        prefixCount[num] %= kMod

      for i, num in reversed(list(enumerate(nums))):
        nextNum = num + direction
        freq = suffixCount[nextNum] + 1
        suffixSubseqs[i] = freq
        suffixCount[num] += freq
        suffixCount[num] %= kMod

      for num, prefixSubseq, suffixSubseq in zip(
              nums, prefixSubseqs, suffixSubseqs):
        sequenceSum += num * prefixSubseq * suffixSubseq
        sequenceSum %= kMod

      return sequenceSum

    increasingSequenceSum = getSequenceSum(nums, 1)
    decreasingSequenceSum = getSequenceSum(nums, -1)
    return (increasingSequenceSum + decreasingSequenceSum - sum(nums) + kMod) % kMod"
"33","class Solution:
  def search(self, nums: list[int], target: int) -> int:
    l = 0
    r = len(nums) - 1

    while l <= r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[l] <= nums[m]:  # nums[l..m] are sorted.
        if nums[l] <= target < nums[m]:
          r = m - 1
        else:
          l = m + 1
      else:  # nums[m..n - 1] are sorted.
        if nums[m] < target <= nums[r]:
          l = m + 1
        else:
          r = m - 1

    return -1"
"330","class Solution:
  def minPatches(self, nums: list[int], n: int) -> int:
    ans = 0
    i = 0  # nums' index
    miss = 1  # the minimum sum in [1, n] we might miss

    while miss <= n:
      if i < len(nums) and nums[i] <= miss:
        miss += nums[i]
        i += 1
      else:
        # Greedily add `miss` itself to increase the range from
        # [1, miss) to [1, 2 * miss).
        miss += miss
        ans += 1

    return ans"
"3300","class Solution:
  def minElement(self, nums: list[int]) -> int:
    return min(sum(map(int, str(num))) for num in nums)"
"3301","class Solution:
  def maximumTotalSum(self, maximumHeight: list[int]) -> int:
    ans = 0
    mn = math.inf

    for height in sorted(maximumHeight, reverse=True):
      assigned = min(height, mn - 1)
      if assigned == 0:
        return -1
      ans += assigned
      mn = assigned

    return ans"
"3302","class Solution:
  def validSequence(self, word1: str, word2: str) -> list[int]:
    ans = []
    # last[j] := the index i of the last occurrence in word1, where
    # word1[i] == word2[j]
    last = [-1] * len(word2)

    i = len(word1) - 1
    j = len(word2) - 1
    while i >= 0 and j >= 0:
      if word1[i] == word2[j]:
        last[j] = i
        j -= 1
      i -= 1

    canSkip = True
    j = 0
    for i, c in enumerate(word1):
      if j == len(word2):
        break
      if c == word2[j]:
        ans.append(i)
        j += 1
      elif canSkip and (j == len(word2) - 1 or i < last[j + 1]):
        canSkip = False
        ans.append(i)
        j += 1

    return ans if j == len(word2) else []"
"3303","class Solution:
  def minStartingIndex(self, s: str, pattern: str) -> int:
    z1 = self._zFunction(pattern + s)
    z2 = self._zFunction(pattern[::-1] + s[::-1])

    # Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and
    # the suffix.
    for i in range(len(s) - len(pattern) + 1):
      if z1[len(pattern) + i] + z2[len(s) - i] >= len(pattern) - 1:
        return i

    return -1

  def _zFunction(self, s: str) -> list[int]:
    """"""
    Returns the z array, where z[i] is the length of the longest prefix of
    s[i..n) which is also a prefix of s.

    https://cp-algorithms.com/string/z-function.html#implementation
    """"""
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z"
"3304","class Solution:
  def kthCharacter(self, k: int) -> str:
    return string.ascii_lowercase[(k - 1).bit_count()]"
"3305","class Solution:
  def countOfSubstrings(self, word: str, k: int) -> int:
    kVowels = 'aeiou'

    def substringsWithAtMost(k: int) -> int:
      """"""
      Return the number of substrings containing every vowel with at most k
      consonants.
      """"""
      if k == -1:
        return 0

      res = 0
      vowels = 0
      uniqueVowels = 0
      vowelLastSeen = {}

      l = 0
      for r, c in enumerate(word):
        if c in kVowels:
          vowels += 1
          if c not in vowelLastSeen or vowelLastSeen[c] < l:
            uniqueVowels += 1
          vowelLastSeen[c] = r
        while r - l + 1 - vowels > k:
          if word[l] in kVowels:
            vowels -= 1
            if vowelLastSeen[word[l]] == l:
              uniqueVowels -= 1
          l += 1
        if uniqueVowels == 5:
          # Add substrings containing every vowel with at most k consonants to
          # the answer. They are
          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]
          res += min(vowelLastSeen[vowel] for vowel in kVowels) - l + 1

      return res

    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)"
"3306","class Solution:
  # Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I
  def countOfSubstrings(self, word: str, k: int) -> int:
    kVowels = 'aeiou'

    def substringsWithAtMost(k: int) -> int:
      """"""
      Return the number of substrings containing every vowel with at most k
      consonants.
      """"""
      if k < 0:
        return 0

      res = 0
      vowels = 0
      uniqueVowels = 0
      vowelLastSeen = {}

      l = 0
      for r, c in enumerate(word):
        if c in kVowels:
          vowels += 1
          if c not in vowelLastSeen or vowelLastSeen[c] < l:
            uniqueVowels += 1
          vowelLastSeen[c] = r
        while r - l + 1 - vowels > k:
          if word[l] in kVowels:
            vowels -= 1
            if vowelLastSeen[word[l]] == l:
              uniqueVowels -= 1
          l += 1
        if uniqueVowels == 5:
          # Add substrings containing every vowel with at most k consonants to
          # the answer. They are
          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]
          res += min(vowelLastSeen[vowel] for vowel in kVowels) - l + 1

      return res

    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)"
"3307","class Solution:
  def kthCharacter(self, k: int, operations: list[int]) -> str:
    operationsCount = math.ceil(math.log2(k))
    increases = 0

    for i in range(operationsCount - 1, -1, -1):
      halfSize = 2**i
      if k > halfSize:
        k -= halfSize  # Move k from the right half to the left half.
        increases += operations[i]

    return string.ascii_lowercase[increases % 26]"
"3308","WITH
  DriverPerformance AS (
    SELECT
      Vehicles.fuel_type,
      Vehicles.driver_id,
      Drivers.accidents,
      ROUND(AVG(Trips.rating), 2) AS rating,
      SUM(Trips.distance) AS distance
    FROM Vehicles
    INNER JOIN Trips
      USING (vehicle_id)
    INNER JOIN Drivers
      USING (driver_id)
    GROUP BY 1, 2
  ),
  RankedDrivers AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY fuel_type
        ORDER BY rating DESC, distance DESC, accidents
      ) AS `rank`
    FROM DriverPerformance
  )
SELECT fuel_type, driver_id, rating, distance
FROM RankedDrivers
WHERE `rank` = 1
ORDER BY 1;"
"3309","class Solution:
  def maxGoodNumber(self, nums: list[int]) -> int:
    ans = 0

    def concat(a: int, b: int) -> int:
      """"""Returns the concatenation of the binary representations of a and b.""""""
      return (a << b.bit_length()) + b

    nums.sort(key=functools.cmp_to_key(
        lambda a, b: concat(b, a) - concat(a, b)))

    for num in nums:
      ans = concat(ans, num)

    return ans"
"331","class Solution:
  def isValidSerialization(self, preorder: str) -> bool:
    degree = 1  # out-degree (children) - in-degree (parent)

    for node in preorder.split(','):
      degree -= 1
      if degree < 0:
        return False
      if node != '#':
        degree += 2

    return degree == 0"
"3310","class Solution:
  def remainingMethods(
      self,
      n: int,
      k: int,
      invocations: list[list[int]]
  ) -> list[int]:
    ans = []
    graph = [[] for _ in range(n)]

    for u, v in invocations:
      graph[u].append(v)

    q = collections.deque([k])
    seen = {k}

    while q:
      for _ in range(len(q)):
        for v in graph[q.popleft()]:
          if v not in seen:
            q.append(v)
            seen.add(v)

    for u in range(n):
      if u in seen:
        continue
      for v in graph[u]:
        if v in seen:
          return list(range(n))
      ans.append(u)

    return ans"
"3311","class Solution:
  def constructGridLayout(self, n: int, edges: list[list[int]]) -> list[list[int]]:
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    # Randomly choose a node with the minimum degree as the corner.
    corner = min(range(len(graph)), key=lambda x: len(graph[x]))

    seen = {corner}
    firstRow = self._getFirstRow(graph, corner, seen)
    cols = len(firstRow)
    rows = n // cols

    ans = [[0] * cols for _ in range(rows)]
    ans[0] = firstRow

    for i in range(1, rows):
      for j in range(cols):
        for v in graph[ans[i - 1][j]]:
          if v not in seen:
            ans[i][j] = v
            seen.add(v)
            break

    return ans

  def _getFirstRow(
      self,
      graph: list[list[int]],
      corner: int,
      seen: set[int]
  ) -> list[int]:
    cornerDegree = len(graph[corner])
    row = [corner]
    # Continue appending neighbors until we hit another corner.
    while len(row) == 1 or len(graph[row[-1]]) == cornerDegree + 1:
      # Sort neighbors by degree to prioritize smaller ones (shortest row built first).
      graph[row[-1]].sort(key=lambda x: len(graph[x]))
      for v in graph[row[-1]]:
        if v not in seen and len(graph[v]) in (cornerDegree, cornerDegree + 1):
          row.append(v)
          seen.add(v)
          break
    return row"
"3312","class Solution:
  def gcdValues(self, nums: list[int], queries: list[int]) -> list[int]:
    maxNum = max(nums)
    # countDivisor[d] := the number of `nums` having `num % d == 0`
    countDivisor = [0] * (maxNum + 1)
    # countGcdPair[g] := the number of pairs having gcd == g
    countGcdPair = [0] * (maxNum + 1)

    for num in nums:
      for i in range(1, math.isqrt(num) + 1):
        if num % i == 0:
          countDivisor[i] += 1
          if i != num // i:
            countDivisor[num // i] += 1

    for gcd in range(maxNum, 0, -1):
      # There are C(countDivisor[gcd], 2) pairs that have a common divisor
      # that's a multiple of `gcd` (including the one that equals to `gcd`).
      # So, substract the multiples of `gcd` to have the number of pairs with a
      # gcd that's exactly `gcd`.
      countGcdPair[gcd] = countDivisor[gcd] * (countDivisor[gcd] - 1) // 2
      for largerGcd in range(2 * gcd, maxNum + 1, gcd):
        countGcdPair[gcd] -= countGcdPair[largerGcd]

    # prefixCountGcdPair[g] := the number of pairs having gcd <= g
    prefixCountGcdPair = list(itertools.accumulate(countGcdPair))
    return [bisect.bisect_left(prefixCountGcdPair, query + 1)
            for query in queries]"
"3313","from dataclasses import dataclass


@dataclass
class Node:
  node: int = 0  # the node number
  time: int = 0  # the time it got marked


class Last2:
  def __init__(self, last1: Node = Node(), last2: Node = Node()):
    self.last1 = last1  # the last marked node
    self.last2 = last2  # the second last marked node


class Solution:
  # Similar to 3241. Time Taken to Mark All Nodes
  def lastMarkedNodes(self, edges: list[list[int]]) -> list[int]:
    n = len(edges) + 1
    ans = [0] * n
    tree = [[] for _ in range(n)]
    # dp[i] := the last marked two nodes for subtree rooted at node i, where
    # each node contains the time it got marked
    dp = [Last2()] * n

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    self._dfs(tree, 0, -1, dp)
    self._reroot(tree, 0, -1, Node(), dp, ans)
    return ans

  def _dfs(
      self,
      tree: list[list[int]],
      u: int,
      prev: int,
      dp: list[Last2]
  ) -> Node:
    """"""
    Performs a DFS traversal of the subtree rooted at node `u`, computes the
    time taken to mark all nodes in the subtree, records the last two marked
    nodes, and returns the last marked node.

    These values are used later in the rerooting process.
    """"""
    last1 = Node(u, 0)
    last2 = Node()
    for v in tree[u]:
      if v == prev:
        continue
      child = self._dfs(tree, v, u, dp)
      time = child.time + 1
      if time > last1.time:
        last2 = last1
        last1 = Node(child.node, time)
      elif time > last2.time:
        last2 = Node(child.node, time)
    dp[u] = Last2(last1, last2)
    return last1

  def _reroot(
      self,
      tree: list[list[int]],
      u: int,
      prev: int,
      last: Node,
      dp: list[list[int]],
      ans: list[int]
  ) -> None:
    """"""
    Reroots the tree at node `u` and updates the answer array, where `last`
    is the last marked node that doesn't go through `u`'s subtree.
    """"""
    ans[u] = last.node if last.time > dp[u].last1.time else dp[u].last1.node
    for v in tree[u]:
      if v == prev:
        continue
      newLast = Node(last.node, last.time + 1)
      if dp[u].last1.node == dp[v].last1.node:
        alternativeTime = 1 + dp[u].last2.time
        if alternativeTime > newLast.time:
          newLast = Node(dp[u].last2.node, alternativeTime)
      else:
        alternativeTime = 1 + dp[u].last1.time
        if alternativeTime > newLast.time:
          newLast = Node(dp[u].last1.node, alternativeTime)
      self._reroot(tree, v, u, newLast, dp, ans)"
"3314","class Solution:
  def minBitwiseArray(self, nums: list[int]) -> list[int]:
    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)
            for num in nums]

  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:
    """"""
    Returns the leading one of the last group of 1s in the binary
    representation of num. For example, if num = 0b10111, the leading one of
    the last group of 1s is 0b100.
    """"""
    leadingOne = 1
    while (num & leadingOne) > 0:
      leadingOne <<= 1
    return leadingOne >> 1"
"3315","class Solution:
  # Same as 3314. Construct the Minimum Bitwise Array I
  def minBitwiseArray(self, nums: list[int]) -> list[int]:
    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)
            for num in nums]

  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:
    """"""
    Returns the leading one of the last group of 1s in the binary
    representation of num. For example, if num = 0b10111, the leading one of
    the last group of 1s is 0b100.
    """"""
    leadingOne = 1
    while (num & leadingOne) > 0:
      leadingOne <<= 1
    return leadingOne >> 1"
"3316","class Solution:
  def maxRemovals(
      self,
      source: str,
      pattern: str,
      targetIndices: list[int]
  ) -> int:
    m = len(source)
    n = len(pattern)
    target = set(targetIndices)
    # dp[i][j] := the maximum number of operations that can be performed for
    # source[i..m) and pattern[j..n)
    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]
    dp[m][n] = 0

    for i in reversed(range(m)):
      dp[i][n] = int(i in target) + dp[i + 1][n]
      for j in reversed(range(n)):
        pick = dp[i + 1][j + 1] if source[i] == pattern[j] else -math.inf
        skip = int(i in target) + dp[i + 1][j]
        dp[i][j] = max(pick, skip)

    return 0 if dp[0][0] == -math.inf else dp[0][0]"
"3317","class Solution:
  def numberOfWays(self, n: int, x: int, y: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    @functools.lru_cache(None)
    def nCk(n: int, k: int) -> int:
      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod

    @functools.lru_cache(None)
    def stirling(n: int, k: int) -> int:
      """"""
      Returns the number of ways to partition a set of n objects into k
      non-empty subsets.

      https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
      """"""
      if k == 0 or n < k:
        return 0
      if k == 1 or n == k:
        return 1
      return (k * stirling(n - 1, k) + stirling(n - 1, k - 1)) % kMod

    # 1. Choose `k` stages from `x` stages.
    # 2. Partition `n` performers into `k` stages.
    # 3. Permute `k` stages.
    # 4. Score `k` stages with score in the range [1, y], so y^k ways.
    return sum(nCk(x, k) * stirling(n, k) * fact(k) * pow(y, k, kMod) % kMod
               for k in range(1, min(n, x) + 1)) % kMod"
"3318","from sortedcontainers import SortedList


class Solution:
  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:
    ans = []
    windowSum = 0
    count = collections.Counter()
    top = SortedList()
    bot = SortedList()

    def update(num: int, freq: int) -> None:
      """"""Updates the count of num by freq and the window sum accordingly.""""""
      nonlocal windowSum
      if count[num] > 0:  # Clean up old values.
        if [count[num], num] in bot:
          bot.remove([count[num], num])
        else:
          top.remove([count[num], num])
          windowSum -= num * count[num]
      count[num] += freq
      if count[num] > 0:
        bot.add([count[num], num])

    for i, num in enumerate(nums):
      update(num, 1)
      if i >= k:
        update(nums[i - k], -1)
      # Move the bottom element to the top if needed.
      while bot and len(top) < x:
        countB, b = bot.pop()
        top.add([countB, b])
        windowSum += b * countB
      # Swap the bottom and top elements if needed.
      while bot and bot[-1] > top[0]:
        countB, b = bot.pop()
        countT, t = top.pop(0)
        bot.add([countT, t])
        windowSum -= t * countT
        top.add([countB, b])
        windowSum += b * countB
      if i >= k - 1:
        ans.append(windowSum)

    return ans"
"3319","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  isPerfect: bool
  sz: int


class Solution:
  def kthLargestPerfectSubtree(self, root: TreeNode | None, k: int) -> int:
    ans = []
    self._dfs(root, ans)
    if len(ans) < k:
      return -1
    return sorted(ans, reverse=True)[k - 1]

  def _dfs(self, root: TreeNode, ans: list[int]) -> T:
    if not root:
      return T(True, 0)
    l = self._dfs(root.left, ans)
    r = self._dfs(root.right, ans)
    if l.isPerfect and r.isPerfect and l.sz == r.sz:
      sz = 1 + l.sz + r.sz
      ans.append(sz)
      return T(True, sz)
    return T(False, 0)"
"332","class Solution:
  def findItinerary(self, tickets: list[list[str]]) -> list[str]:
    ans = []
    graph = collections.defaultdict(list)

    for a, b in reversed(sorted(tickets)):
      graph[a].append(b)

    def dfs(u: str) -> None:
      while u in graph and graph[u]:
        dfs(graph[u].pop())
      ans.append(u)

    dfs('JFK')
    return ans[::-1]"
"3320","class Solution:
  def countWinningSequences(self, s: str) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, prev: int, bob: int) -> int:
      """"""
      Returns the number of distinct sequences Bob can use to beat Alice for
      s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the
      number of points that Bob is having is `bob`.
      """"""
      if i == len(s):
        return int(bob > 0)

      f = 0  # If Bob summons a Fire Dragon at i.
      w = 0  # If Bob summons a Water Serpent at i.
      e = 0  # If Bob summons a Earth Golem at i.

      match s[i]:
        case 'F':
          if prev != 0:
            f = dp(i + 1, 0, bob) % kMod
          if prev != 1:
            w = dp(i + 1, 1, bob + 1) % kMod
          if prev != 2:
            e = dp(i + 1, 2, bob - 1) % kMod
        case 'W':
          if prev != 0:
            f = dp(i + 1, 0, bob - 1) % kMod
          if prev != 1:
            w = dp(i + 1, 1, bob) % kMod
          if prev != 2:
            e = dp(i + 1, 2, bob + 1) % kMod
        case 'E':
          if prev != 0:
            f = dp(i + 1, 0, bob + 1) % kMod
          if prev != 1:
            w = dp(i + 1, 1, bob - 1) % kMod
          if prev != 2:
            e = dp(i + 1, 2, bob) % kMod

      return f + w + e

    return (dp(0, 0, 0) + dp(0, 1, 0) + dp(0, 2, 0)) // 2 % kMod"
"3321","from sortedcontainers import SortedList


class Solution:
  # Same as 3318. Find X-Sum of All K-Long Subarrays I
  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:
    ans = []
    windowSum = 0
    count = collections.Counter()
    top = SortedList()  # the top x elements
    bot = SortedList()  # the rest of the elements

    def update(num: int, freq: int) -> None:
      """"""Updates the count of num by freq and the window sum accordingly.""""""
      nonlocal windowSum
      if count[num] > 0:  # Clean up the old count.
        if [count[num], num] in bot:
          bot.remove([count[num], num])
        else:
          top.remove([count[num], num])
          windowSum -= num * count[num]
      count[num] += freq
      if count[num] > 0:
        bot.add([count[num], num])

    for i, num in enumerate(nums):
      update(num, 1)
      if i >= k:
        update(nums[i - k], -1)
      # Move the bottom elements to the top if needed.
      while bot and len(top) < x:
        countB, b = bot.pop()
        top.add([countB, b])
        windowSum += b * countB
      # Swap the bottom and top elements if needed.
      while bot and bot[-1] > top[0]:
        countB, b = bot.pop()
        countT, t = top.pop(0)
        bot.add([countT, t])
        top.add([countB, b])
        windowSum += b * countB
        windowSum -= t * countT
      if i >= k - 1:
        ans.append(windowSum)

    return ans"
"3322","WITH
  TeamPoints AS (
    SELECT
      season_id,
      team_id,
      team_name,
      wins * 3 + draws AS points,
      goals_for - goals_against AS goal_difference
    FROM SeasonStats
  ),
  RankedTeams AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY season_id
        ORDER BY points DESC, goal_difference DESC, team_name
      ) AS position
    FROM TeamPoints
  )
SELECT * FROM RankedTeams
ORDER BY season_id, position, team_name;"
"3323","class Solution:
  def minConnectedGroups(self, intervals: list[list[int]], k: int) -> int:
    mergedIntervals = 0
    maxMergedIntervals = 0

    intervals = self._merge(intervals)

    i = 0
    for _, end in intervals:
      while i < len(intervals) and end + k >= intervals[i][0]:
        mergedIntervals += 1
        i += 1
      mergedIntervals -= 1  # Exclude intervals[i].
      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals)

    return len(intervals) - maxMergedIntervals

  # Same as 56. Merge Intervals
  def _merge(self, intervals: list[list[int]]) -> list[list[int]]:
    res = []
    for interval in sorted(intervals):
      if not res or res[-1][1] < interval[0]:
        res.append(interval)
      else:
        res[-1][1] = max(res[-1][1], interval[1])
    return res"
"3324","class Solution:
  def stringSequence(self, target: str) -> list[str]:
    ans = []
    s = []

    for targetChar in target:
      s.append('a')
      ans.append(''.join(s))
      for offset in range(ord('b'), ord(targetChar) + 1):
        s[-1] = chr(offset)
        ans.append(''.join(s))

    return ans"
"3325","class Solution:
  def numberOfSubstrings(self, s: str, k: int) -> int:
    n = len(s)
    ans = n * (n + 1) // 2
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] == k:
        count[s[l]] -= 1
        l += 1
      ans -= r - l + 1

    return ans"
"3326","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    ans = 0

    for i in range(len(nums) - 2, -1, -1):
      if nums[i] > nums[i + 1]:
        minDivisor = self._getMinDivisor(nums[i])
        if minDivisor > nums[i + 1]:
          return -1
        nums[i] = minDivisor
        ans += 1

    return ans

  def _getMinDivisor(self, num: int) -> int:
    for divisor in range(2, math.isqrt(num) + 1):
      if num % divisor == 0:
        return divisor
    return num"
"3327","class Solution:
  def findAnswer(self, parent: list[int], s: str) -> list[bool]:
    n = len(parent)
    tree = [[] for _ in parent]
    start = [0] * n  # start[i] := the start index of `dfsStr` of node i
    end = [0] * n  # end[i] := the end index of `dfsStr` of node i
    dfsStr = []

    for i in range(1, n):
      tree[parent[i]].append(i)

    self._dfs(tree, 0, 0, s, start, end, dfsStr)
    t = '#'.join('@' + ''.join(dfsStr) + '$')
    p = self._manacher(t)
    return [self._isPalindrome(s, e, p)
            for s, e in zip(start, end)]

  def _dfs(
      self,
      tree: list[list[int]],
      u: int,
      index: int,
      s: str,
      start: list[int],
      end: list[int],
      dfsStr: list[str]
  ) -> int:
    """"""Returns the start index of the ""DFS string"" of u's next node.""""""
    start[u] = index
    for v in tree[u]:
      index = self._dfs(tree, v, index, s, start, end, dfsStr)
    end[u] = index
    dfsStr.append(s[u])
    return index + 1

  def _manacher(self, t: str) -> list[int]:
    """"""
    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome
    centered at `t[i]`, where `t` is a string with delimiters and sentinels.
    """"""
    p = [0] * len(t)
    center = 0
    for i in range(1, len(t) - 1):
      rightBoundary = center + p[center]
      mirrorIndex = center - (i - center)
      if rightBoundary > i:
        p[i] = min(rightBoundary - i, p[mirrorIndex])
      # Try to expand the palindrome centered at i.
      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
        p[i] += 1
      # If a palindrome centered at i expands past `rightBoundary`, adjust
      # the center based on the expanded palindrome.
      if i + p[i] > rightBoundary:
        center = i
    return p

  def _isPalindrome(self, s: int, e: int, p: list[int]) -> bool:
    """"""
    Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed
    array `p` from the Manacher's algorithm.

    The precomputed array `p` is based on the string `t` with delimiters and
    sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of
    `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`
    and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is
    `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.
    """"""
    length = e - s + 1
    center = s + e + 2
    return p[center] >= length"
"3328","SELECT
  state,
  GROUP_CONCAT(city ORDER BY city SEPARATOR ', ') AS cities,
  SUM(LEFT(city, 1) = LEFT(state, 1)) AS matching_letter_count
FROM Cities
GROUP BY 1
HAVING COUNT(*) >= 3 AND matching_letter_count > 0
ORDER BY matching_letter_count DESC, state;"
"3329","class Solution:
  def numberOfSubstrings(self, s: str, k: int) -> int:
    n = len(s)
    ans = n * (n + 1) // 2
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] == k:
        count[s[l]] -= 1
        l += 1
      ans -= r - l + 1

    return ans"
"333","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  mn: int  # the minimum value in the subtree
  mx: int  # the maximum value in the subtree
  size: int  # the size of the subtree


class Solution:
  def largestBSTSubtree(self, root: TreeNode | None) -> int:
    def dfs(root: TreeNode | None) -> T:
      if not root:
        return T(math.inf, -math.inf, 0)

      l = dfs(root.left)
      r = dfs(root.right)

      if l.mx < root.val < r.mn:
        return T(min(l.mn, root.val), max(r.mx, root.val), 1 + l.size + r.size)

      # Mark one as invalid, but still record the size of children.
      # Return (-inf, inf) because no node will be > inf or < -inf.
      return T(-math.inf, math.inf, max(l.size, r.size))

    return dfs(root).size"
"3330","class Solution:
  def possibleStringCount(self, word: str) -> int:
    return 1 + sum(a == b
                   for a, b in itertools.pairwise(word))"
"3331","class Solution:
  def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:
    n = len(parent)
    ans = [0] * n
    newParent = parent.copy()
    tree = [[] for _ in range(n)]

    for i in range(1, n):
      closest = self._findClosestAncestor(i, parent, s)
      if closest != -1:
        newParent[i] = closest

    for i in range(1, n):
      tree[newParent[i]].append(i)

    self._dfs(tree, 0, ans)
    return ans

  def _findClosestAncestor(self, u: int, parent: list[int], s: str) -> int:
    """"""
    Returns the closest ancestor of node `u` that has the same value as `u`.
    """"""
    curr = parent[u]
    while curr != -1:
      if s[curr] == s[u]:
        return curr
      curr = parent[curr]
    return -1

  def _dfs(self, tree: list[list[int]], u: int, ans: list[int]) -> int:
    sz = 1
    for v in tree[u]:
      sz += self._dfs(tree, v, ans)
    ans[u] = sz
    return sz"
"3332","class Solution:
  def maxScore(
      self,
      n: int,
      k: int,
      stayScore: list[list[int]],
      travelScore: list[list[int]]
  ) -> int:
    # dp[j] := the maximum score after days so far being at city j
    dp = [0] * n

    for i in range(k):
      newDp = [0] * n
      for dest in range(n):
        # 1. Stay at the current city.
        newDp[dest] = dp[dest] + stayScore[i][dest]
        # 2. Travel from any other city.
        for curr in range(n):
          if curr != dest:
            newDp[dest] = max(newDp[dest],
                              dp[curr] + travelScore[curr][dest])
      dp = newDp

    return max(dp)"
"3333","class Solution:
  def possibleStringCount(self, word: str, k: int) -> int:
    kMod = 1_000_000_007
    groups = self._getConsecutiveLetters(word)
    totalCombinations = functools.reduce(lambda subtotal, group:
                                         subtotal * group % kMod, groups)
    if k <= len(groups):
      return totalCombinations

    # dp[j] := the number of ways to form strings of length j using groups[0..i]
    dp = [0] * k
    dp[0] = 1  # Base case: empty string

    for i, group in enumerate(groups):
      newDp = [0] * k
      windowSum = 0
      for j in range(i, k):
        newDp[j] = (newDp[j] + windowSum) % kMod
        windowSum = (windowSum + dp[j]) % kMod
        if j >= group:
          windowSum = (windowSum - dp[j - group] + kMod) % kMod
      dp = newDp

    return (totalCombinations - sum(dp)) % kMod

  def _getConsecutiveLetters(self, word: str) -> list[int]:
    """"""
    Returns consecutive identical letters in the input string.
    e.g. ""aabbbc"" -> [2, 3, 1].
    """"""
    groups = []
    group = 1
    for i in range(1, len(word)):
      if word[i] == word[i - 1]:
        group += 1
      else:
        groups.append(group)
        group = 1
    groups.append(group)
    return groups"
"3334","class Solution:
  def maxScore(self, nums: list[int]) -> int:
    n = len(nums)
    # prefixGcd[i] := GCD of nums[0..i]
    # prefixLcm[i] := LCM of nums[0..i]
    prefixGcd, prefixLcm = self._getPrefix(nums)
    # suffixGcd[i] := GCD of nums[i..n - 1]
    # suffixLcm[i] := LCM of nums[i..n - 1]
    suffixGcd, suffixLcm = self._getSuffix(nums)
    ans = suffixGcd[0] * suffixLcm[0]

    for i in range(n):
      gcd1 = prefixGcd[i - 1] if i > 0 else 0
      gcd2 = suffixGcd[i + 1] if i + 1 < n else 0
      lcm1 = prefixLcm[i - 1] if i > 0 else 1
      lcm2 = suffixLcm[i + 1] if i + 1 < n else 1
      score = math.gcd(gcd1, gcd2) * math.lcm(lcm1, lcm2)
      ans = max(ans, score)

    return ans

  def _getPrefix(self, nums: list[int]) -> tuple[list[int], list[int]]:
    """"""Returns the prefix GCD and LCM arrays.""""""
    prefixGcd = []
    prefixLcm = []
    currGcd = 0
    currLcm = 1
    for num in nums:
      currGcd = math.gcd(currGcd, num)
      currLcm = math.lcm(currLcm, num)
      prefixGcd.append(currGcd)
      prefixLcm.append(currLcm)
    return prefixGcd, prefixLcm

  def _getSuffix(self, nums: list[int]) -> tuple[list[int], list[int]]:
    """"""Returns the suffix GCD and LCM arrays.""""""
    suffixGcd = []
    suffixLcm = []
    currGcd = 0
    currLcm = 1
    for num in reversed(nums):
      currGcd = math.gcd(currGcd, num)
      currLcm = math.lcm(currLcm, num)
      suffixGcd.append(currGcd)
      suffixLcm.append(currLcm)
    return list(reversed(suffixGcd)), list(reversed(suffixLcm))"
"3335","class Solution:
  def lengthAfterTransformations(self, s: str, t: int) -> int:
    kMod = 1_000_000_007
    count = [0] * 26

    for c in s:
      count[ord(c) - ord('a')] += 1

    for _ in range(t):
      newCount = [0] * 26
      # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'
      for i in range(25):
        newCount[i + 1] = count[i]
      # 'z' -> 'ab'
      newCount[0] = count[25]
      newCount[1] = (newCount[1] + count[25]) % kMod
      count = newCount

    return sum(count) % kMod"
"3336","class Solution:
  def subsequencePairCount(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    maxNum = max(nums)
    # dp[i][x][y] := number of disjoint pairs `seq1` and `seq2` of
    # nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y
    dp = [[[0] * (maxNum + 1)
          for _ in range(maxNum + 1)]
          for _ in range(len(nums) + 1)]
    dp[0][0][0] = 1

    for i, num in enumerate(nums):
      for x in range(maxNum + 1):
        for y in range(maxNum + 1):
          # 1. Skip nums[i].
          dp[i + 1][x][y] += dp[i][x][y]
          dp[i + 1][x][y] %= kMod
          # 2. Pick nums[i] in the first subsequence.
          newX = math.gcd(x, num)
          dp[i + 1][newX][y] += dp[i][x][y]
          dp[i + 1][newX][y] %= kMod
          # 3. Pick nums[i] in the second subsequence.
          newY = math.gcd(y, num)
          dp[i + 1][x][newY] += dp[i][x][y]
          dp[i + 1][x][newY] %= kMod

    return sum(dp[-1][g][g]
               for g in range(1, maxNum + 1)) % kMod"
"3337","class Solution:
  # Similar to 3335. Total Characters in String After Transformations I
  def lengthAfterTransformations(self, s: str, t: int, nums: list[int]) -> int:
    kMod = 1_000_000_007

    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:
      """"""Returns A * B.""""""
      sz = len(A)
      C = [[0] * sz for _ in range(sz)]
      for i in range(sz):
        for j in range(sz):
          for k in range(sz):
            C[i][j] += A[i][k] * B[k][j]
            C[i][j] %= kMod
      return C

    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:
      """"""Returns M^n.""""""
      if n == 0:
        return [[1 if i == j else 0  # identity matrix
                for j in range(len(M))]
                for i in range(len(M))]
      if n % 2 == 1:
        return matrixMult(M, matrixPow(M, n - 1))
      return matrixPow(matrixMult(M, M), n // 2)

    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)
    T = self._getTransformationMatrix(nums)
    poweredT = matrixPow(T, t)
    count = [0] * 26
    lengths = [0] * 26

    for c in s:
      count[string.ascii_lowercase.index(c)] += 1

    for i in range(26):
      for j in range(26):
        lengths[j] += count[i] * poweredT[i][j]
        lengths[j] %= kMod

    return sum(lengths) % kMod

  def _getTransformationMatrix(self, nums: list[int]) -> list[list[int]]:
    T = [[0] * 26 for _ in range(26)]
    for i, steps in enumerate(nums):
      for step in range(1, steps + 1):
        T[i][(i + step) % 26] += 1
    return T"
"3338","WITH
  RankedEmployees AS (
    SELECT *, DENSE_RANK() OVER(
      PARTITION BY dept
      ORDER BY salary DESC
    ) AS `rank`
    FROM Employees
  )
SELECT emp_id, dept
FROM RankedEmployees
WHERE `rank` = 2
ORDER BY 1;"
"3339","class Solution:
  def countOfArrays(self, n: int, m: int, k: int) -> int:
    kMod = 10**9 + 7
    even = m // 2  # the number of even numbers in [1, m]
    odd = m - even  # the number of odd numbers in [1, m]
    # dp[j][0/1] := the number of arrays of length so far i with j consecutive
    # even number pairs ending in an even number (0) or an odd number (1)
    dp = [[0] * 2 for _ in range(k + 1)]

    # Base case: arrays of length 1
    # For an array of length 1, we can't have any even number pairs yet.
    dp[0][0] = even
    dp[0][1] = odd

    for _ in range(2, n + 1):
      nextDp = [[0] * 2 for _ in range(k + 1)]
      for j in range(k + 1):
        # 1. Appending an even number to an array ending in an even number
        #    creates a new consecutive even number pair.
        # 2. Appending an even number to an array ending in an odd number.
        nextDp[j][0] = ((dp[j - 1][0] if j > 0 else 0) * even +
                        dp[j][1] * even) % kMod
        # 3. Appending an odd number to an array.
        nextDp[j][1] = sum(dp[j]) * odd % kMod
      dp = nextDp

    return sum(dp[k]) % kMod"
"334","class Solution:
  def increasingTriplet(self, nums: list[int]) -> bool:
    first = math.inf
    second = math.inf

    for num in nums:
      if num <= first:
        first = num
      elif num <= second:  # first < num <= second
        second = num
      else:
        return True  # first < second < num (third)

    return False"
"3340","class Solution:
  def isBalanced(self, num: str) -> bool:
    nums = list(map(int, num))
    return sum(nums[::2]) == sum(nums[1::2])"
"3341","class Solution:
  def minTimeToReach(self, moveTime: list[list[int]]) -> int:
    return self._dijkstra(moveTime,
                          (0, 0),
                          (len(moveTime) - 1, len(moveTime[0]) - 1))

  def _dijkstra(
      self,
      moveTime: list[list[int]],
      src: tuple[int, int],
      dst: tuple[int, int]
  ) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(moveTime)
    n = len(moveTime[0])
    dist = [[math.inf] * n for _ in range(m)]

    dist[0][0] = 0
    minHeap = [(0, src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if u == dst:
        return d
      i, j = u
      if d > dist[i][j]:
        continue
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        newDist = max(moveTime[x][y], d) + 1
        if newDist < dist[x][y]:
          dist[x][y] = newDist
          heapq.heappush(minHeap, (newDist, (x, y)))

    return -1"
"3342","class Solution:
  # Similar to 3341. Find Minimum Time to Reach Last Room I
  def minTimeToReach(self, moveTime: list[list[int]]) -> int:
    return self._dijkstra(moveTime,
                          (0, 0),
                          (len(moveTime) - 1, len(moveTime[0]) - 1))

  def _dijkstra(
      self,
      moveTime: list[list[int]],
      src: tuple[int, int],
      dst: tuple[int, int]
  ) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(moveTime)
    n = len(moveTime[0])
    dist = [[math.inf] * n for _ in range(m)]

    dist[0][0] = 0
    minHeap = [(0, src)]  # (d, (ux, uy))

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if u == dst:
        return d
      i, j = u
      if d > dist[i][j]:
        continue
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        newDist = max(moveTime[x][y], d) + (i + j) % 2 + 1
        if newDist < dist[x][y]:
          dist[x][y] = newDist
          heapq.heappush(minHeap, (newDist, (x, y)))

    return -1"
"3343","class Solution:
  def countBalancedPermutations(self, num: str) -> int:
    nums = list(map(int, num))
    summ = sum(nums)
    if summ % 2 == 1:
      return 0

    nums.sort(reverse=True)

    @functools.lru_cache(None)
    def dp(even: int, odd: int, evenBalance: int) -> int:
      """"""
      Returns the number of permutations where there are `even` even indices
      left, `odd` odd indices left, and `evenBalance` is the target sum of the
      remaining numbers to be placed in even indices.
      """"""
      if evenBalance < 0:
        return 0
      if even == 0:
        return (evenBalance == 0) * math.factorial(odd)
      if odd == 0:
        return (sum(nums[-(even + odd):]) == evenBalance) * math.factorial(even)
      return (dp(even - 1, odd, evenBalance - nums[-(odd + even)]) * even +
              dp(even, odd - 1, evenBalance) * odd)

    kMod = 1_000_000_007
    perm = functools.reduce(lambda x, y: x * math.factorial(y),
                            collections.Counter(nums).values(), 1)
    return (dp(even=(len(nums) + 1) // 2,
               odd=len(nums) // 2,
               evenBalance=summ // 2) // perm) % kMod"
"3344","class Solution:
  def maxSizedArray(self, s: int) -> int:
    def getNumbersWithBitSet(n: int, i: int) -> int:
      """"""
      Returns the number of integers in [0, n - 1] with the i-th bit set.

      For the i-th bit, numbers in the range [0, n - 1] can be divided into
      groups of 2^(i + 1) numbers. In each group, exactly half of the numbers
      have the i-th bit set.
      """"""
      groupSize = 1 << (i + 1)
      halfGroupSize = 1 << i
      fullGroups = n // groupSize
      remaining = max(0, (n % groupSize) - halfGroupSize)
      return fullGroups * halfGroupSize + remaining

    def getArraySum(n: int) -> int:
      """"""
      Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.

        sum(i * (j OR k)), where 0 <= i, j, k < n
      = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)
      = (0 + 1 + ... + n - 1) * sum(j OR k)
      = (n * (n - 1) / 2) * sum(j OR k)
      """"""
      arithmeticSum = n * (n - 1) // 2  # 0 + 1 + ... + n - 1
      orSum = 0  # the sum of (j OR k) values in 2D arrays of size n^2
      for i in range(n.bit_length()):
        numbersWithoutBit = n - getNumbersWithBitSet(n, i)
        pairsWithBit = n**2 - numbersWithoutBit**2
        orSum += pairsWithBit * (1 << i)  # Add contribution of this bit.
      return arithmeticSum * orSum

    if s == 0:
      return 1
    return bisect.bisect_right(range(s + 1), s, key=getArraySum) - 1"
"3345","class Solution:
  def smallestNumber(self, n: int, t: int) -> int:
    return next(num for num in range(n, n + 10)
                if self._getDigitProd(num) % t == 0)

  def _getDigitProd(self, num: int) -> int:
    digitProd = 1
    while num > 0:
      digitProd *= num % 10
      num //= 10
    return digitProd"
"3346","from sortedcontainers import SortedDict


class Solution:
  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:
    ans = 1
    adjustable = 0
    count = collections.Counter(nums)
    line = SortedDict()
    candidates = set()

    for num in nums:
      line[num - k] = line.get(num - k, 0) + 1
      line[num + k + 1] = line.get(num + k + 1, 0) - 1
      candidates.add(num)
      candidates.add(num - k)
      candidates.add(num + k + 1)

    for num in sorted(candidates):
      adjustable += line.get(num, 0)
      adjusted = adjustable - count[num]
      ans = max(ans, count[num] + min(numOperations, adjusted))

    return ans"
"3347","from sortedcontainers import SortedDict


class Solution:
  # Same as 3346. Maximum Frequency of an Element After Performing Operations I
  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:
    ans = 1
    adjustable = 0
    count = collections.Counter(nums)
    line = SortedDict()
    candidates = set()

    for num in nums:
      line[num - k] = line.get(num - k, 0) + 1
      line[num + k + 1] = line.get(num + k + 1, 0) - 1
      candidates.add(num)
      candidates.add(num - k)
      candidates.add(num + k + 1)

    for num in sorted(candidates):
      adjustable += line.get(num, 0)
      adjusted = adjustable - count[num]
      ans = max(ans, count[num] + min(numOperations, adjusted))

    return ans"
"3348","kFactorCounts = {
    0: collections.Counter(),
    1: collections.Counter(),
    2: collections.Counter([2]),
    3: collections.Counter([3]),
    4: collections.Counter([2, 2]),
    5: collections.Counter([5]),
    6: collections.Counter([2, 3]),
    7: collections.Counter([7]),
    8: collections.Counter([2, 2, 2]),
    9: collections.Counter([3, 3]),
}


class Solution:
  def smallestNumber(self, num: str, t: int) -> str:
    primeCount, isDivisible = self._getPrimeCount(t)
    if not isDivisible:
      return '-1'

    factorCount = self._getFactorCount(primeCount)
    if sum(factorCount.values()) > len(num):
      return ''.join(factor * freq for factor, freq in factorCount.items())

    primeCountPrefix = sum((kFactorCounts[int(c)]
                            for c in num), start=collections.Counter())
    firstZeroIndex = next((i for i, d in enumerate(num) if d == '0'), len(num))
    if firstZeroIndex == len(num) and primeCount <= primeCountPrefix:
      return num

    for i, c in reversed(list(enumerate(num))):
      d = int(c)
      # Remove the current digit's factors from primeCountPrefix.
      primeCountPrefix -= kFactorCounts[d]
      spaceAfterThisDigit = len(num) - 1 - i
      if i <= firstZeroIndex:
        for biggerDigit in range(d + 1, 10):
          # Compute the required factors after replacing with a larger digit.
          factorsAfterReplacement = self._getFactorCount(
              primeCount - primeCountPrefix - kFactorCounts[biggerDigit]
          )
          # Check if the replacement is possible within the available space.
          if sum(factorsAfterReplacement.values()) <= spaceAfterThisDigit:
            # Fill extra space with '1', if any, and construct the result.
            fillOnes = spaceAfterThisDigit - sum(
                factorsAfterReplacement.values())
            return (
                num[:i]  # Keep the prefix unchanged.
                + str(biggerDigit)  # Replace the current digit.
                + '1' * fillOnes  # Fill remaining space with '1'.
                + ''.join(factor * freq for factor,
                          freq in factorsAfterReplacement.items())
            )

    # No solution of the same length exists, so we need to extend the number
    # by prepending '1's and adding the required factors.
    factorCount = self._getFactorCount(primeCount)
    return (
        '1' * (len(num) + 1 - sum(factorCount.values()))
        + ''.join(factor * freq for factor, freq in factorCount.items())
    )

  def _getPrimeCount(self, t: int) -> tuple[dict[int, int], bool]:
    """"""
    Returns the count of prime factors of t and if t is divisible by 2, 3, 5, 7.
    """"""
    count = collections.Counter()
    for prime in [2, 3, 5, 7]:
      while t % prime == 0:
        t //= prime
        count[prime] += 1
    return count, t == 1

  def _getFactorCount(self, count: dict[int, int]) -> dict[str, int]:
    """"""Returns the required factors to form the smallest number.""""""
    count8, remaining2 = divmod(count[2], 3)  # 2^3 = 8
    count9, count3 = divmod(count[3], 2)  # 3^2 = 9
    count4, count2 = divmod(remaining2, 2)  # 2^2 = 4
    # Combine 2 and 3 to 6 if both are present.
    count2, count3, count6 = ((0, 0, 1) if count2 == 1 and count3 == 1
                              else (count2, count3, 0))
    # Combine 3 and 4 to 2 and 6 if both are present.
    count2, count6, count3, count4 = ((1, 1, 0, 0)
                                      if count3 == 1 and count4 == 1
                                      else (count2, count6, count3, count4))
    return {'2': count2, '3': count3, '4': count4, '5': count[5],
            '6': count6, '7': count[7], '8': count8, '9': count9}"
"3349","class Solution:
  def hasIncreasingSubarrays(self, nums: list[int], k: int) -> bool:
    increasing = 1
    prevIncreasing = 0

    for a, b in itertools.pairwise(nums):
      if b > a:
        increasing += 1
      else:
        prevIncreasing = increasing
        increasing = 1
      if increasing // 2 >= k or min(prevIncreasing, increasing) >= k:
        return True

    return False"
"335","class Solution:
  def isSelfCrossing(self, x: list[int]) -> bool:
    if len(x) <= 3:
      return False

    for i in range(3, len(x)):
      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:
        return True
      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:
        return True
      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:
        return True

    return False"
"3350","class Solution:
  # Similar to 3349. Adjacent Increasing Subarrays Detection I
  def maxIncreasingSubarrays(self, nums: list[int]) -> int:
    ans = 0
    increasing = 1
    prevIncreasing = 0

    for a, b in itertools.pairwise(nums):
      if b > a:
        increasing += 1
      else:
        prevIncreasing = increasing
        increasing = 1
      ans = max(ans, increasing // 2)
      ans = max(ans, min(prevIncreasing, increasing))

    return ans"
"3351","class Solution:
  def sumOfGoodSubsequences(self, nums: list[int]) -> int:
    kMod = 10**9 + 7
    maxNum = max(nums)
    # endsIn[i] := the number of good subsequences ending in i
    endsIn = [0] * (maxNum + 2)
    # dp[i] := the sum of good subsequences ending in i
    dp = [0] * (maxNum + 2)

    for num in nums:
      seqsToAppend = 1 + endsIn[num - 1] + endsIn[num + 1]
      dp[num] = (seqsToAppend * num +
                 (dp[num] + dp[num - 1] + dp[num + 1])) % kMod
      endsIn[num] += seqsToAppend % kMod

    return sum(dp) % kMod"
"3352","class Solution:
  def countKReducibleNumbers(self, s: str, k: int) -> int:
    kMod = 1_000_000_007
    ops = self._getOps(s)

    @functools.lru_cache(None)
    def dp(i: int, setBits: int, isTight: bool) -> int:
      """"""
      Returns the number of positive integers less than n that are k-reducible,
      considering the i-th digit, where `setBits` is the number of set bits in
      the current number, and `isTight` indicates if the current digit is
      tightly bound.
      """"""
      if i == len(s):
        return int(ops[setBits] < k and not isTight)

      res = 0
      maxDigit = int(s[i]) if isTight else 1

      for d in range(maxDigit + 1):
        nextIsTight = isTight and (d == maxDigit)
        res += dp(i + 1, setBits + d, nextIsTight)
        res %= kMod
      return res

    return dp(0, 0, True) - 1  # - 0

  def _getOps(self, s: str) -> int:
    """"""Returns the number of operations to reduce a number to 0.""""""
    ops = [0] * (len(s) + 1)
    for num in range(2, len(s) + 1):
      ops[num] = 1 + ops[num.bit_count()]
    return ops"
"3353","class Solution:
  def minOperations(self, nums: list[int]) -> int:
    return sum(a != b for a, b in itertools.pairwise(nums))"
"3354","class Solution:
  def countValidSelections(self, nums: list[int]) -> int:
    ans = 0
    prefix = list(itertools.accumulate(nums))
    suffix = list(itertools.accumulate(nums[::-1]))[::-1]

    for i, num in enumerate(nums):
      if num > 0:
        continue
      if prefix[i] == suffix[i]:
        ans += 2  # Go to either direction.
      if abs(prefix[i] - suffix[i]) == 1:
        ans += 1  # Go to the direction with the larger sum.

    return ans"
"3355","class Solution:
  def isZeroArray(self, nums: list[int], queries: list[list[int]]) -> bool:
    line = [0] * (len(nums) + 1)
    decrement = 0

    for l, r in queries:
      line[l] += 1
      line[r + 1] -= 1

    for i, num in enumerate(nums):
      decrement += line[i]
      if decrement < num:
        return False

    return True"
"3356","class Solution:
  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:
    line = [0] * (len(nums) + 1)
    decrement = 0
    k = 0

    for i, num in enumerate(nums):
      while decrement + line[i] < num:
        if k == len(queries):
          return -1
        l, r, val = queries[k]
        k += 1
        if r < i:
          continue
        line[max(l, i)] += val
        line[r + 1] -= val
      decrement += line[i]

    return k"
"3357","class Solution:
  def minDifference(self, nums: list[int]) -> int:
    maxPositiveGap = 0
    mn = 1_000_000_000
    mx = 0

    for a, b in itertools.pairwise(nums):
      if (a == -1) != (b == -1):
        positive = max(a, b)
        mn = min(mn, positive)
        mx = max(mx, positive)
      else:
        maxPositiveGap = max(maxPositiveGap, abs(a - b))

    l = maxPositiveGap
    r = (mx - mn + 1) // 2
    return bisect.bisect_left(
        range(l, r + 1), True,
        key=lambda m: self._check(nums, m, mn + m, mx - m)) + l

  def _check(self, nums: list[int], m: int, x: int, y: int) -> bool:
    """"""
    Returns True if it's possible have `m` as maximum absolute difference
    between adjacent numbers, where -1s are replaced with `x` or `y`.
    """"""
    gapLength = 0
    prev = 0

    for num in nums:
      if num == -1:
        gapLength += 1
        continue
      if prev > 0 and gapLength > 0:
        if gapLength == 1 and not self._checkSingleGap(prev, num, m, x, y):
          return False
        if gapLength > 1 and not self._checkMultipleGaps(prev, num, m, x, y):
          return False
      prev = num
      gapLength = 0

    # Check leading gaps
    if nums[0] == -1:
      num = next((num for num in nums if num != -1), -1)
      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):
        return False

    # Check trailing gaps
    if nums[-1] == -1:
      num = next((num for num in reversed(nums) if num != -1), -1)
      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):
        return False

    return True

  def _checkSingleGap(self, a: int, b: int, m: int, x: int, y: int) -> bool:
    """"""
    Returns true if it's possible to have at most `m` as the minimized maximum
    difference for a sequence with a single -1 between two numbers.
    e.g. [a, -1, b] can be filled with either x or y.
    """"""
    gapWithX = max(abs(a - x), abs(b - x))  # [a, x, b]
    gapWithY = max(abs(a - y), abs(b - y))  # [a, y, b]
    return min(gapWithX, gapWithY) <= m

  def _checkMultipleGaps(self, a: int, b: int, m: int, x: int, y: int) -> bool:
    """"""
    Returns true if it's possible to have at most `m` as the minimized maximum
    difference for a sequence with multiple -1s between two numbers.
    e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.
    """"""
    ax = abs(a - x)
    ay = abs(a - y)
    bx = abs(b - x)
    by = abs(b - y)
    xy = abs(x - y)
    gapAllX = max(ax, bx)  # [a, x, x, ..., x, b]
    gapAllY = max(ay, by)  # [a, y, y, ..., y, b]
    gapXToY = max(ax, xy, by)  # [a, x, ..., y, b]
    gapYToX = max(ay, xy, bx)  # [a, y, ..., x, b]
    return min(gapAllX, gapAllY, gapXToY, gapYToX) <= m

  def _checkBoundaryGaps(self, a: int, m: int, x: int, y: int) -> bool:
    """"""
    Returns true if it's possible to have at most `m` as the minimized maximum
    difference for a boundary sequence starting or ending with -1s.
    e.g. [a, -1, -1, ...] or [..., -1, -1, a].
    """"""
    gapAllX = abs(a - x)  # [x, x, ..., x, a]
    gapAllY = abs(a - y)  # [y, y, ..., y, a]
    return min(gapAllX, gapAllY) <= m"
"3358","SELECT book_id, title, author, published_year
FROM Books
WHERE rating IS NULL
ORDER BY 1;"
"3359","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  subarrayWidth: int
  rowIndex: int
  accumulatedSubmatrices: int


class Solution:
  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    # dp[i][j] := the number of valid subarrays ending at grid[i][j]
    dp = [[0] * n for _ in range(m)]
    # stacks[j] := the stack of valid
    # (subarray width, row index, number of accumulated submatrices) ending at
    # column j
    stacks: list[T] = [[T(0, -1, 0)] for _ in range(n)]

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num > k:
          stacks[j] = [T(0, i, 0)]
        else:
          dp[i][j] = 1
          if j > 0 and row[j - 1] <= k and row[j - 1] >= row[j]:
            # Extend the valid subarrays to the current number.
            dp[i][j] += dp[i][j - 1]
          width = dp[i][j]
          # Remove subarray widths greater than the current count since they
          # will become invalid.
          while stacks[j] and width < stacks[j][-1].subarrayWidth:
            stacks[j].pop()
          height = i - stacks[j][-1].rowIndex
          newSubmatrices = width * height
          accumulatedSubmatrices = (stacks[j][-1].accumulatedSubmatrices +
                                    newSubmatrices)
          ans += accumulatedSubmatrices
          stacks[j].append(T(width, i, accumulatedSubmatrices))

    return ans"
"336","class Solution:
  def palindromePairs(self, words: list[str]) -> list[list[int]]:
    ans = []
    dict = {word[::-1]: i for i, word in enumerate(words)}

    for i, word in enumerate(words):
      if """" in dict and dict[""""] != i and word == word[::-1]:
        ans.append([i, dict[""""]])

      for j in range(1, len(word) + 1):
        l = word[:j]
        r = word[j:]
        if l in dict and dict[l] != i and r == r[::-1]:
          ans.append([i, dict[l]])
        if r in dict and dict[r] != i and l == l[::-1]:
          ans.append([dict[r], i])

    return ans"
"3360","class Solution:
  def canAliceWin(self, n: int) -> bool:
    for stones in range(10, -1, -1):
      if stones > n:
        return stones % 2 == 1
      n -= stones"
"3361","class Solution:
  def shiftDistance(
      self,
      s: str,
      t: str,
      nextCost: list[int],
      previousCost: list[int]
  ) -> int:
    ans = 0
    # prev[i][j]: the prev cost to shift from ('a' + i) to ('a' + j)
    prev = [[0] * 26 for _ in range(26)]
    # next[i][j]: the next cost to shift from ('a' + i) to ('a' + j)
    next = [[0] * 26 for _ in range(26)]

    for i in range(26):
      cost = 0
      for j in range(26):
        next[i][(i + j) % 26] = cost
        cost += nextCost[(i + j) % 26]

    for i in range(26):
      cost = 0
      for j in range(26):
        prev[i][(i - j + 26) % 26] = cost
        cost += previousCost[(i - j + 26) % 26]

    for a, b in zip(s, t):
      i = string.ascii_lowercase.index(a)
      j = string.ascii_lowercase.index(b)
      ans += min(next[i][j], prev[i][j])

    return ans"
"3362","from sortedcontainers import SortedList


class Solution:
  def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:
    q = collections.deque(sorted(queries))
    available = SortedList()  # available `r`s
    running = SortedList()  # running `r`s

    for i, num in enumerate(nums):
      while q and q[0][0] <= i:
        available.add(q.popleft()[1])
      while running and running[0] < i:
        running.pop(0)
      while num > len(running):
        if not available or available[-1] < i:
          return -1
        running.add(available.pop())

    return len(available)"
"3363","class Solution:
  def maxCollectedFruits(self, fruits: list[list[int]]) -> int:
    n = len(fruits)

    def getTopLeft() -> int:
      return sum(fruits[i][i] for i in range(n))

    def getTopRight() -> int:
      # dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)
      dp = [[0] * n for _ in range(n)]
      dp[0][-1] = fruits[0][-1]
      for x in range(n):
        for y in range(n):
          if x >= y and (x, y) != (n - 1, n - 1):
            continue
          for dx, dy in [(1, -1), (1, 0), (1, 1)]:
            i = x - dx
            j = y - dy
            if i < 0 or i == n or j < 0 or j == n:
              continue
            if i < j < n - 1 - i:
              continue
            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])
      return dp[-1][-1]

    def getBottomLeft() -> int:
      # dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)
      dp = [[0] * n for _ in range(n)]
      dp[-1][0] = fruits[-1][0]
      for y in range(n):
        for x in range(n):
          if x <= y and (x, y) != (n - 1, n - 1):
            continue
          for dx, dy in [(-1, 1), (0, 1), (1, 1)]:
            i = x - dx
            j = y - dy
            if i < 0 or i == n or j < 0 or j == n:
              continue
            if j < i < n - 1 - j:
              continue
            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])
      return dp[-1][-1]

    return getTopLeft() + getTopRight() + getBottomLeft() - 2 * fruits[-1][-1]"
"3364","class Solution:
  def minimumSumSubarray(self, nums: list[int], l: int, r: int) -> int:
    ans = math.inf

    for windowSize in range(l, r + 1):
      windowSum = sum(nums[:windowSize])
      if windowSum > 0:
        ans = min(ans, windowSum)
      for i in range(windowSize, len(nums)):
        windowSum -= nums[i - windowSize]
        windowSum += nums[i]
        if windowSum > 0:
          ans = min(ans, windowSum)

    return -1 if ans == math.inf else ans"
"3365","class Solution:
  def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:
    n = len(s)
    return (collections.Counter(s[i:i + n // k] for i in range(0, n, n // k)) ==
            collections.Counter(t[i:i + n // k] for i in range(0, n, n // k)))"
"3366","class Solution:
  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, op1: int, op2: int) -> int:
      """"""
      Returns the minimum sum of nums[i..n - 1] with `op1` operations of op1 and
      `op2` operations of op2.
      """"""
      if i == len(nums):
        return 0
      res = nums[i] + dp(i + 1, op1, op2)
      if op1 > 0:
        res = min(res, (nums[i] + 1) // 2 + dp(i + 1, op1 - 1, op2))
      if op2 > 0 and nums[i] >= k:
        res = min(res, nums[i] - k + dp(i + 1, op1, op2 - 1))
      if op1 > 0 and op2 > 0:
        if (nums[i] + 1) // 2 >= k:
          res = min(res, (nums[i] + 1) // 2 - k + dp(i + 1, op1 - 1, op2 - 1))
        if nums[i] >= k:
          res = min(res, (nums[i] - k + 1) // 2 + dp(i + 1, op1 - 1, op2 - 1))
      return res

    return dp(0, op1, op2)"
"3367","class Solution:
  def maximizeSumOfWeights(self, edges: list[list[int]], k: int) -> int:
    graph = [[] for _ in range(len(edges) + 1)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    def dfs(u: int, prev: int) -> tuple[int, int]:
      """"""
      Returns
      (the weight sum of the subtree rooted at u with at most k - 1 children,
       the weight sum of the subtree rooted at u with at most k children).
      """"""
      weightSum = 0
      diffs = []
      for v, w in graph[u]:
        if v == prev:
          continue
        subK1, subK = dfs(v, u)
        weightSum += subK
        # If picking (u, v) makes the sum larger, we should pick it.
        diffs.append(max(0, subK1 - subK + w))
      return (weightSum + sum(heapq.nlargest(k - 1, diffs)),
              weightSum + sum(heapq.nlargest(k, diffs)))

    return dfs(0, -1)[1]"
"3368","WITH
  RECURSIVE Words AS (
    -- Extract the first word and assign a token index.
    SELECT
      content_id,
      SUBSTRING_INDEX(content_text, ' ', 1) AS word,
      SUBSTRING(
        content_text,
        LENGTH(SUBSTRING_INDEX(content_text, ' ', 1)) + 2
      ) AS remaining_text,
      1 AS token_index
    FROM user_content
    UNION ALL
    -- Recursively extract the next word and increment the token index.
    SELECT
      content_id,
      SUBSTRING_INDEX(remaining_text, ' ', 1) AS word,
      SUBSTRING(
        remaining_text,
        LENGTH(SUBSTRING_INDEX(remaining_text, ' ', 1)) + 2
      ) AS remaining_text,
      token_index + 1 AS token_index
    FROM Words
    WHERE remaining_text != ''
  ),
  Converted AS (
    -- Combine the words back in original order with proper capitalization.
    SELECT
      content_id,
      GROUP_CONCAT(
        CONCAT(
          UPPER(SUBSTRING(word, 1, 1)),
          LOWER(SUBSTRING(word, 2))
        )
        ORDER BY token_index SEPARATOR ' '
      ) AS converted_text
    FROM Words
    GROUP BY 1
  )
SELECT
  UserContent.content_id,
  UserContent.content_text AS original_text,
  Converted.converted_text
FROM user_content AS UserContent
INNER JOIN Converted
  USING (content_id);"
"3369","from sortedcontainers import SortedList


class StatisticsTracker:
  def __init__(self):
    self.q = collections.deque()
    self.count = collections.Counter()
    self.sortedList = SortedList()
    self.modeMaxHeap = []  # (frequency, number)
    self.sum = 0

  def addNumber(self, number: int) -> None:
    self.q.append(number)
    self.count[number] += 1
    self.sortedList.add(number)
    heapq.heappush(self.modeMaxHeap, (-self.count[number], number))
    self.sum += number

  def removeFirstAddedNumber(self) -> None:
    number = self.q.popleft()
    self.count[number] -= 1
    self.sortedList.remove(number)
    # Note: No need to update the heap now; we'll clean up stale entries when
    # getting the mode.
    self.sum -= number

  def getMean(self) -> int:
    return self.sum // len(self.q)

  def getMedian(self) -> int:
    return self.sortedList[len(self.sortedList) // 2]

  def getMode(self) -> int:
    # Removes stale heap entries where frequency no longer matches.
    while self.modeMaxHeap:
      frequency = -self.modeMaxHeap[0][0]
      number = self.modeMaxHeap[0][1]
      if self.count[number] == frequency:
        return number
      heapq.heappop(self.modeMaxHeap)"
"337","class Solution:
  def rob(self, root: TreeNode | None) -> int:
    def robOrNot(root: TreeNode | None) -> tuple:
      if not root:
        return (0, 0)

      robLeft, notRobLeft = robOrNot(root.left)
      robRight, notRobRight = robOrNot(root.right)

      return (root.val + notRobLeft + notRobRight,
              max(robLeft, notRobLeft) + max(robRight, notRobRight))

    return max(robOrNot(root))"
"3370","class Solution:
  def smallestNumber(self, n: int) -> int:
    return (1 << n.bit_length()) - 1"
"3371","class Solution:
  def getLargestOutlier(self, nums: list[int]) -> int:
    ans = -math.inf
    summ = sum(nums)
    count = collections.Counter(nums)

    for num in nums:
      withoutNum = summ - num
      if withoutNum % 2 == 0:
        specialSum = withoutNum // 2  # the sum of special numbers
        if count[specialSum] > (1 if num == specialSum else 0):
          ans = max(ans, num)

    return ans"
"3372","class Solution:
  def maxTargetNodes(
      self,
      edges1: list[list[int]],
      edges2: list[list[int]],
      k: int
  ) -> list[int]:
    graph1 = self._buildGraph(edges1)
    graph2 = self._buildGraph(edges2)
    maxReachableInGraph2 = 0

    if k > 0:
      for i in range(len(edges2) + 1):
        maxReachableInGraph2 = max(maxReachableInGraph2,
                                   self._dfs(graph2, i, -1, k - 1))

    return [maxReachableInGraph2 + self._dfs(graph1, i, -1, k)
            for i in range(len(edges1) + 1)]

  def _dfs(self, graph: list[list[int]], u: int, prev: int, k: int) -> int:
    """"""Returns the number of nodes that can be reached from u with k steps.""""""
    if k == 0:
      return 1
    res = 0
    for v in graph[u]:
      if v != prev:
        res += self._dfs(graph, v, u, k - 1)
    return 1 + res

  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:
    graph = [[] for _ in range(len(edges) + 1)]
    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)
    return graph"
"3373","class Solution:
  def maxTargetNodes(
      self,
      edges1: list[list[int]],
      edges2: list[list[int]]
  ) -> list[int]:
    n = len(edges1) + 1
    m = len(edges2) + 1
    graph1 = self._buildGraph(edges1)
    graph2 = self._buildGraph(edges2)
    parity1 = [False] * n
    parity2 = [False] * m  # placeholder (parity2 is not used)
    even1 = self._dfs(graph1, 0, -1, parity1, True)
    even2 = self._dfs(graph2, 0, -1, parity2, True)
    odd1 = n - even1
    odd2 = m - even2

    # Can connect the current node in tree1 to either an even node or an odd
    # node in tree2.
    return [(even1 if parity1[i] else odd1) + max(even2, odd2)
            for i in range(n)]

  def _dfs(
      self,
      graph: list[list[int]],
      u: int,
      prev: int,
      parity: list[bool],
      isEven: bool
  ) -> int:
    """"""
    Returns the number of nodes that can be reached from u with even steps.
    """"""
    res = 1 if isEven else 0
    parity[u] = isEven
    for v in graph[u]:
      if v != prev:
        res += self._dfs(graph, v, u, parity, not isEven)
    return res

  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:
    graph = [[] for _ in range(len(edges) + 1)]
    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)
    return graph"
"3374","WITH
  RECURSIVE Words AS (
    -- Extract the first word and assign a token index.
    SELECT
      content_id,
      SUBSTRING_INDEX(content_text, ' ', 1) AS word,
      SUBSTRING(
        content_text,
        LENGTH(SUBSTRING_INDEX(content_text, ' ', 1)) + 2
      ) AS remaining_text,
      1 AS token_index
    FROM user_content
    UNION ALL
    -- Recursively extract the next word and increment the token index.
    SELECT
      content_id,
      SUBSTRING_INDEX(remaining_text, ' ', 1) AS word,
      SUBSTRING(
        remaining_text,
        LENGTH(SUBSTRING_INDEX(remaining_text, ' ', 1)) + 2
      ) AS remaining_text,
      token_index + 1 AS token_index
    FROM Words
    WHERE remaining_text != ''
  ),
  Converted AS (
    -- Combine the words back in original order with proper capitalization.
    SELECT
      content_id,
      GROUP_CONCAT(
        IF(
          word LIKE '%-%',
          CONCAT(
            UPPER(SUBSTRING(word, 1, 1)),
            LOWER(SUBSTRING(word, 2, LOCATE('-', word) - 2)),
            '-',
            UPPER(SUBSTRING(SUBSTRING_INDEX(word, '-', -1), 1, 1)),
            LOWER(SUBSTRING(SUBSTRING_INDEX(word, '-', -1), 2))
          ),
          CONCAT(
            UPPER(SUBSTRING(word, 1, 1)),
            LOWER(SUBSTRING(word, 2))
          )
        )
        ORDER BY token_index SEPARATOR ' '
      ) AS converted_text
    FROM Words
    GROUP BY 1
  )
SELECT
  UserContent.content_id,
  UserContent.content_text AS original_text,
  Converted.converted_text
FROM user_content AS UserContent
INNER JOIN Converted
  USING (content_id);"
"3375","class Solution:
  def minOperations(self, nums: list[int], k: int) -> int:
    numsSet = set(nums)
    mn = min(nums)
    if mn < k:
      return -1
    if mn > k:
      return len(numsSet)
    return len(numsSet) - 1"
"3376","class Solution {
 public:
  int findMinimumTime(vector<int>& strength, int K) {
    return find(strength, /*x=*/1, 0, K);
  }

 private:
  int find(const vector<int>& strength, int x, int mask, int k) {
    if (mask == (1 << strength.size()) - 1)
      return 0;
    int res = INT_MAX;
    for (int i = 0; i < strength.size(); ++i)
      if ((mask >> i & 1) == 0) {
        const int time = (strength[i] - 1) / x + 1;  // ceil(strength[i] / x)
        res = min(res, time + find(strength, x + k, mask | 1 << i, k));
      }
    return res;
  }
};"
"3377","class Solution:
  def minOperations(self, n: int, m: int) -> int:
    isPrime = self._sieveEratosthenes(10000)
    if isPrime[n] or isPrime[m]:
      return -1
    return self._dijkstra(n, m, isPrime)

  def _dijkstra(self, src: int, dst: int, isPrime: list[bool]) -> int:
    seen = {src}
    minHeap = [(src, src)]  # (cost, num)

    while minHeap:
      cost, curr = heapq.heappop(minHeap)
      if curr == dst:
        return cost
      s = list(str(curr))
      for i, c in enumerate(s):
        if c < '9':
          s[i] = str(int(c) + 1)
          nextNum = int(''.join(s))
          if not isPrime[nextNum] and nextNum not in seen:
            heapq.heappush(minHeap, (cost + nextNum, nextNum))
            seen.add(nextNum)
          s[i] = c
        if c > '0' and not (i == 0 and c == '1'):
          s[i] = str(int(c) - 1)
          nextNum = int(''.join(s))
          if not isPrime[nextNum] and nextNum not in seen:
            heapq.heappush(minHeap, (cost + nextNum, nextNum))
            seen.add(nextNum)
          s[i] = c

    return -1

  def _sieveEratosthenes(self, n: int) -> list[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime"
"3378","class UnionFind:
  def __init__(self):
    self.id = {}
    self.rank = collections.Counter()

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if u not in self.id:
      self.id[u] = u
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def countComponents(self, nums: list[int], threshold: int) -> int:
    uf = UnionFind()

    for num in nums:
      for multiple in range(2 * num, threshold + 1, num):
        uf.unionByRank(num, multiple)

    return len(set(uf.find(num) for num in nums))"
"3379","class Solution:
  def constructTransformedArray(self, nums: list[int]) -> list[int]:
    n = len(nums)
    return [nums[(i + num % n + n) % n]
            for i, num in enumerate(nums)]"
"338","class Solution:
  def countBits(self, n: int) -> list[int]:
    # f(i) := i's number of 1s in bitmask
    # f(i) = f(i / 2) + i % 2
    ans = [0] * (n + 1)

    for i in range(1, n + 1):
      ans[i] = ans[i // 2] + (i & 1)

    return ans"
"3380","class SegmentTree {
 public:
  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}

  // Updates nums[i] to val.
  void update(int i, int val) {
    update(0, 0, n - 1, i, val);
  }

  // Returns min(nums[i..j]).
  int query(int i, int j) const {
    return query(0, 0, n - 1, i, j);
  }

 private:
  const int kInf;    // the invalid value
  const int n;       // the size of the input array
  vector<int> tree;  // the segment tree

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      tree[treeIndex] = val;
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, val);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return kInf;
    const int mid = (lo + hi) / 2;
    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),
                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));
  }

  int merge(int left, int right) const {
    return max(left, right);
  }
};

class Solution {
 public:
  int maxRectangleArea(vector<vector<int>>& points) {
    int ans = -1;
    ranges::sort(points);
    const vector<int> ys = getUniqueAndSortedYs(points);
    SegmentTree tree(ys.size(), /*kInf=*/-1);
    unordered_map<int, int> yToIndex;
    unordered_map<int, int> yToX;

    for (int i = 0; i < ys.size(); ++i)
      yToIndex[ys[i]] = i;

    int prevX = points[0][0];
    int prevY = points[0][1];

    for (int i = 1; i < points.size(); ++i) {
      const int x = points[i][0];
      const int y = points[i][1];
      if (yToX.contains(prevY) && yToX.contains(y)) {
        const int xLeft = yToX[y];
        if (prevX == x && yToX[prevY] == xLeft &&
            xLeft > tree.query(yToIndex[prevY] + 1, yToIndex[y] - 1))
          ans = max(ans, (y - prevY) * (x - xLeft));
      }
      yToX[prevY] = prevX;
      tree.update(yToIndex[prevY], prevX);
      prevX = x;
      prevY = y;
    }

    return ans;
  }

 private:
  vector<int> getUniqueAndSortedYs(const vector<vector<int>>& points) {
    vector<int> ys;
    for (const vector<int>& point : points)
      ys.push_back(point[1]);
    ranges::sort(ys);
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    return ys;
  }
};"
"3381","class Solution:
  def maxSubarraySum(self, nums: list[int], k: int) -> int:
    ans = -math.inf
    prefix = 0
    # minPrefix[i % k] := the minimum prefix sum of the first i numbers
    minPrefix = [math.inf] * k
    minPrefix[k - 1] = 0

    for i, num in enumerate(nums):
      prefix += num
      ans = max(ans, prefix - minPrefix[i % k])
      minPrefix[i % k] = min(minPrefix[i % k], prefix)

    return ans"
"3382","class SegmentTree {
 public:
  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}

  // Updates nums[i] to val.
  void update(int i, int val) {
    update(0, 0, n - 1, i, val);
  }

  // Returns min(nums[i..j]).
  int query(int i, int j) const {
    return query(0, 0, n - 1, i, j);
  }

 private:
  const int kInf;    // the invalid value
  const int n;       // the size of the input array
  vector<int> tree;  // the segment tree

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      tree[treeIndex] = val;
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, val);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) const {
    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].
      return tree[treeIndex];
    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].
      return kInf;
    const int mid = (lo + hi) / 2;
    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),
                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));
  }

  int merge(int left, int right) const {
    return max(left, right);
  }
};

class Solution {
 public:
  // Same as 3380. Maximum Area Rectangle With Point Constraints I
  long long maxRectangleArea(vector<int>& xCoord, vector<int>& yCoord) {
    long ans = -1;
    const vector<pair<int, int>> points = getSortedPoints(xCoord, yCoord);
    const vector<int> ys = getUniqueAndSortedYs(yCoord);
    SegmentTree tree(ys.size(), /*kInf=*/-1);
    unordered_map<int, int> yToIndex;
    unordered_map<int, int> yToX;

    for (int i = 0; i < ys.size(); ++i)
      yToIndex[ys[i]] = i;

    auto [prevX, prevY] = points[0];
    for (int i = 1; i < points.size(); ++i) {
      const auto [x, y] = points[i];
      if (yToX.contains(prevY) && yToX.contains(y)) {
        const int xLeft = yToX[y];
        if (prevX == x && yToX[prevY] == xLeft &&
            xLeft > tree.query(yToIndex[prevY] + 1, yToIndex[y] - 1))
          ans = max(ans, static_cast<long>(y - prevY) * (x - xLeft));
      }
      yToX[prevY] = prevX;
      tree.update(yToIndex[prevY], prevX);
      prevX = x;
      prevY = y;
    }

    return ans;
  }

 private:
  vector<pair<int, int>> getSortedPoints(const vector<int>& xCoord,
                                         const vector<int>& yCoord) {
    vector<pair<int, int>> points;
    for (int i = 0; i < xCoord.size(); ++i)
      points.emplace_back(xCoord[i], yCoord[i]);
    ranges::sort(points);
    return points;
  }

  vector<int> getUniqueAndSortedYs(const vector<int>& yCoord) {
    vector<int> ys = yCoord;
    ranges::sort(ys);
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    return ys;
  }
};"
"3383","class Solution:
  def minRunesToAdd(
      self,
      n: int,
      crystals: list[int],
      flowFrom: list[int],
      flowTo: list[int]
  ) -> int:
    graph = [[] for _ in range(n)]
    reversedGraph = [[] for _ in range(n)]

    for u, v in zip(flowFrom, flowTo):
      graph[u].append(v)
      reversedGraph[v].append(u)

    # Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm.
    seen = set()
    orderStack = []
    componentIds = [-1] * n
    componentCount = 0

    for i in range(n):
      if i not in seen:
        self._kosaraju(graph, i, seen, orderStack)

    while orderStack:
      u = orderStack.pop()
      if componentIds[u] == -1:
        self._identifySCC(reversedGraph, u, componentIds, componentCount)
        componentCount += 1

    # Track crystal-containing components and inter-component edges.
    hasCrystal = [False] * componentCount
    hasInterComponentEdge = [False] * componentCount

    for u in crystals:
      hasCrystal[componentIds[u]] = True

    for u, v in zip(flowFrom, flowTo):
      id1 = componentIds[u]
      id2 = componentIds[v]
      if id1 != id2:  # Edge is inter-component.
        hasInterComponentEdge[id2] = True

    return sum(not hasCrystal[i] and not hasInterComponentEdge[i]
               for i in range(componentCount))

  def _kosaraju(
      self,
      graph: list[list[int]],
      u: int,
      seen: set[int],
      orderStack: list
  ) -> None:
    """"""Creates a topological order stack using Kosaraju's Algorithm.""""""
    seen.add(u)
    for v in graph[u]:
      if v not in seen:
        self._kosaraju(graph, v, seen, orderStack)
    orderStack.append(u)

  def _identifySCC(
      self,
      reversedGraph: list[list[int]],
      u: int,
      componentIds: list[int],
      componentId: int
  ) -> None:
    """"""Assigns component IDs during SCC identification in the second DFS.""""""
    if componentIds[u] != -1:
      return
    componentIds[u] = componentId
    for v in reversedGraph[u]:
      if componentIds[v] == -1:
        self._identifySCC(reversedGraph, v, componentIds, componentId)"
"3384","WITH
  PassDetails AS (
    SELECT
      Passes.pass_from,
      Passes.pass_to,
      Passes.time_stamp,
      Team1.team_name AS from_team,
      Team2.team_name AS to_team,
      CASE
        WHEN Passes.time_stamp BETWEEN '00:00' AND '45:00' THEN 1
        WHEN Passes.time_stamp BETWEEN '45:01' AND '90:00' THEN 2
      END AS half_number
    FROM Passes
    INNER JOIN Teams AS Team1
      ON (Passes.pass_from = Team1.player_id)
    INNER JOIN Teams AS Team2
      ON (Passes.pass_to = Team2.player_id)
  )
SELECT
  from_team AS team_name,
  half_number,
  SUM(IF(from_team = to_team, 1, -1)) AS dominance
FROM PassDetails
GROUP BY 1, 2
ORDER BY 1, 2;"
"3385","class Solution:
  def findMinimumTime(self, strength: list[int]) -> int:
    costs = [[(s + turn - 1) // turn
             for s in strength]
             for turn in range(1, len(strength) + 1)]
    return self._hungarian(costs)[-1]

  def _hungarian(self, costs):
    """"""
    Returns an array `res` of length n (costs.length), with `res[i]` equaling
    the minimum cost to assign the first (i + 1) turns to the first (i + 1)
    locks using Hungarian algorithm, where costs[i][j] is the energy required
    to break j-th lock in i-th turn.

    https://en.wikipedia.org/wiki/Hungarian_algorithm
    """"""
    numLocks = len(costs)
    turnPotentials = [0] * numLocks
    lockPotentials = [0] * (numLocks + 1)
    lockAssignments = [-1] * (numLocks + 1)
    res = []

    for currentTurn in range(numLocks):
      currentLock = numLocks
      lockAssignments[currentLock] = currentTurn
      minReducedCosts = [math.inf] * (numLocks + 1)
      previousLockAssignments = [-1] * (numLocks + 1)
      locksInOptimalPath = [False] * (numLocks + 1)

      while lockAssignments[currentLock] != -1:
        locksInOptimalPath[currentLock] = True
        assignedTurn = lockAssignments[currentLock]
        minCostDelta = math.inf
        nextLock = None

        for lock in range(numLocks):
          if not locksInOptimalPath[lock]:
            reducedCost = (
                costs[assignedTurn][lock] -
                turnPotentials[assignedTurn] -
                lockPotentials[lock]
            )
            oldMin = minReducedCosts[lock]
            minReducedCosts[lock] = min(oldMin, reducedCost)
            if minReducedCosts[lock] < oldMin:
              previousLockAssignments[lock] = currentLock
            if minReducedCosts[lock] < minCostDelta:
              minCostDelta = minReducedCosts[lock]
              nextLock = lock

        for lock in range(numLocks + 1):
          if locksInOptimalPath[lock]:
            turnPotentials[lockAssignments[lock]] += minCostDelta
            lockPotentials[lock] -= minCostDelta
          else:
            minReducedCosts[lock] -= minCostDelta

        currentLock = nextLock

      while currentLock != numLocks:
        lockAssignments[currentLock] = lockAssignments[previousLockAssignments[currentLock]]
        currentLock = previousLockAssignments[currentLock]

      res.append(-lockPotentials[numLocks])

    return res"
"339","class Solution:
  def depthSum(self, nestedList: list[NestedInteger]) -> int:
    ans = 0
    depth = 0
    q = collections.deque()

    def addIntegers(nestedList: list[NestedInteger]) -> None:
      for ni in nestedList:
        q.append(ni)

    addIntegers(nestedList)

    while q:
      depth += 1
      for _ in range(len(q)):
        ni = q.popleft()
        if ni.isInteger():
          ans += ni.getInteger() * depth
        else:
          addIntegers(ni.getList())

    return ans"
"34","class Solution:
  def searchRange(self, nums: list[int], target: int) -> list[int]:
    l = bisect_left(nums, target)
    if l == len(nums) or nums[l] != target:
      return -1, -1
    r = bisect_right(nums, target) - 1
    return l, r"
"340","class Solution:
  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
    ans = 0
    distinct = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        distinct += 1
      while distinct == k + 1:
        count[s[l]] -= 1
        if count[s[l]] == 0:
          distinct -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"341","class NestedIterator:
  def __init__(self, nestedList: list[NestedInteger]):
    self.stack: list[NestedInteger] = []
    self.addInteger(nestedList)

  def next(self) -> int:
    return self.stack.pop().getInteger()

  def hasNext(self) -> bool:
    while self.stack and not self.stack[-1].isInteger():
      self.addInteger(self.stack.pop().getList())
    return self.stack

  # addInteger([1, [4, [6]]]) . stack = [[4, [6]], 1]
  # addInteger([4, [6]]) . stack = [[6], 4]
  # addInteger([6]) . stack = [6]
  def addInteger(self, nestedList: list[NestedInteger]) -> None:
    for n in reversed(nestedList):
      self.stack.append(n)"
"342","class Solution:
  def isPowerOfFour(self, n: int) -> bool:
    # Why (4^n - 1) % 3 == 0?
    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are
    # three consecutive numbers; among one of them, there must be a multiple
    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.
    # Therefore, 4^n - 1 is a multiple of 3.
    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0"
"343","class Solution:
  def integerBreak(self, n: int) -> int:
    # If an optimal product contains a factor f >= 4, then we can replace it
    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,
    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3
    # (and 1 is wasteful).
    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.
    if n == 2:  # 1 * 1
      return 1
    if n == 3:  # 1 * 2
      return 2

    ans = 1

    while n > 4:
      n -= 3
      ans *= 3
    ans *= n

    return ans"
"344","class Solution:
  def reverseString(self, s: list[str]) -> None:
    l = 0
    r = len(s) - 1

    while l < r:
      s[l], s[r] = s[r], s[l]
      l += 1
      r -= 1"
"345","class Solution:
  def reverseVowels(self, s: str) -> str:
    chars = list(s)
    kVowels = 'aeiouAEIOU'
    l = 0
    r = len(s) - 1

    while l < r:
      while l < r and chars[l] not in kVowels:
        l += 1
      while l < r and chars[r] not in kVowels:
        r -= 1
      chars[l], chars[r] = chars[r], chars[l]
      l += 1
      r -= 1

    return ''.join(chars)"
"346","class MovingAverage:
  def __init__(self, size: int):
    self.size = size
    self.sum = 0
    self.q = collections.deque()

  def next(self, val: int) -> float:
    if len(self.q) == self.size:
      self.sum -= self.q.popleft()
    self.sum += val
    self.q.append(val)
    return self.sum / len(self.q)"
"347","class Solution:
  def topKFrequent(self, nums: list[int], k: int) -> list[int]:
    ans = []
    bucket = [[] for _ in range(len(nums) + 1)]

    for num, freq in collections.Counter(nums).items():
      bucket[freq].append(num)

    for b in reversed(bucket):
      ans += b
      if len(ans) == k:
        return ans"
"348","class TicTacToe:
  def __init__(self, n: int):
    self.n = n
    # Record count('X') - count('O').
    self.rows = [0] * n
    self.cols = [0] * n
    self.diag = 0
    self.antiDiag = 0

  """""" Player {player} makes a move at ({row}, {col}).

      @param row    The row of the board.
      @param col    The column of the board.
      @param player The player, can be either 1 or 2.
      @return The current winning condition, can be either:
              0: No one wins.
              1: Player 1 wins.
              2: Player 2 wins.
  """"""

  def move(self, row: int, col: int, player: int) -> int:
    toAdd = 1 if player == 1 else -1
    target = self.n if player == 1 else -self.n

    if row == col:
      self.diag += toAdd
      if self.diag == target:
        return player

    if row + col == self.n - 1:
      self.antiDiag += toAdd
      if self.antiDiag == target:
        return player

    self.rows[row] += toAdd
    if self.rows[row] == target:
      return player

    self.cols[col] += toAdd
    if self.cols[col] == target:
      return player

    return 0"
"349","class Solution:
  def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:
    ans = []
    nums1 = set(nums1)

    for num in nums2:
      if num in nums1:
        ans.append(num)
        nums1.remove(num)

    return ans"
"35","class Solution:
  def searchInsert(self, nums: list[int], target: int) -> int:
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l"
"350","class Solution:
  def intersect(self, nums1: list[int], nums2: list[int]) -> list[int]:
    if len(nums1) > len(nums2):
      return self.intersect(nums2, nums1)

    ans = []
    count = collections.Counter(nums1)

    for num in nums2:
      if count[num] > 0:
        ans.append(num)
        count[num] -= 1

    return ans"
"351","class Solution:
  def numberOfPatterns(self, m: int, n: int) -> int:
    seen = set()
    accross = [[0] * 10 for _ in range(10)]

    accross[1][3] = accross[3][1] = 2
    accross[1][7] = accross[7][1] = 4
    accross[3][9] = accross[9][3] = 6
    accross[7][9] = accross[9][7] = 8
    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \
        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5

    def dfs(u: int, depth: int) -> int:
      if depth > n:
        return 0

      seen.add(u)
      ans = 1 if depth >= m else 0

      for v in range(1, 10):
        if v == u or v in seen:
          continue
        accrossed = accross[u][v]
        if not accrossed or accrossed in seen:
          ans += dfs(v, depth + 1)

      seen.remove(u)
      return ans

    # 1, 3, 7, 9 are symmetric
    # 2, 4, 6, 8 are symmetric
    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)"
"352","from sortedcontainers import SortedDict


class SummaryRanges:
  def __init__(self):
    self.intervals = SortedDict()  # {start: (start, end)}

  def addNum(self, val: int) -> None:
    if val in self.intervals:
      return

    lo = self._lowerKey(val)
    hi = self._higherKey(val)

    # {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}
    if lo >= 0 and hi >= 0 and self.intervals[lo][1] + 1 == val and val + 1 == hi:
      self.intervals[lo][1] = self.intervals[hi][1]
      del self.intervals[hi]
      # {lo, map[lo][1]} + val = {lo, val}
      # Prevent adding duplicate entry by using '>=' instead of '=='.
    elif lo >= 0 and self.intervals[lo][1] + 1 >= val:
      self.intervals[lo][1] = max(self.intervals[lo][1], val)
    elif hi >= 0 and val + 1 == hi:
      # val + {hi, map[hi][1]} = {val, map[hi][1]}
      self.intervals[val] = [val, self.intervals[hi][1]]
      del self.intervals[hi]
    else:
      self.intervals[val] = [val, val]

  def getIntervals(self) -> list[list[int]]:
    return list(self.intervals.values())

  def _lowerKey(self, key: int):
    """"""Returns the maximum key in `self.intervals` < `key`.""""""
    i = self.intervals.bisect_left(key)
    if i == 0:
      return -1
    return self.intervals.peekitem(i - 1)[0]

  def _higherKey(self, key: int):
    """"""Returns the minimum key in `self.intervals` < `key`.""""""
    i = self.intervals.bisect_right(key)
    if i == len(self.intervals):
      return -1
    return self.intervals.peekitem(i)[0]"
"353","class SnakeGame:
  def __init__(self, width: int, height: int, food: list[list[int]]):
    """"""
    Initialize your data structure here.
    @param width - screen width
    @param height - screen height
    @param food - A list of food positions
    E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].
    """"""
    self.width = width
    self.height = height
    self.food = food
    self.score = 0
    self.k = 0  # food's index
    self.lookup = set([self.getId(0, 0)])
    self.body = collections.deque([self.getId(0, 0)])  # snake's body

  def move(self, direction: str) -> int:
    """"""
    Moves the snake.
    @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down
    @return The game's score after the move. Return -1 if game over.
    Game over when snake crosses the screen boundary or bites its body.
    """"""
    # the old head's position
    i = self.body[0] // self.width
    j = self.body[0] % self.width

    # Update the head's position and check if it's out-of-bounds.
    if direction == ""U"":
      i -= 1
      if i < 0:
        return -1
    if direction == ""L"":
      j -= 1
      if j < 0:
        return -1
    if direction == ""R"":
      j += 1
      if j == self.width:
        return -1
    if direction == ""D"":
      i += 1
      if i == self.height:
        return -1

    newHead = self.getId(i, j)

    # 1. Eat food and increase the size by 1.
    if self.k < len(self.food) and i == self.food[self.k][0] and j == self.food[self.k][1]:
      self.lookup.add(newHead)
      self.body.appendleft(newHead)
      self.k += 1
      self.score += 1
      return self.score

    # 2. new head != old tail and eat body!
    if newHead != self.body[-1] and newHead in self.lookup:
      return -1

    # 3. normal case
    # Remove the old tail first, then add new head because new head may be in
    # old tail's position.
    self.lookup.remove(self.body[-1])
    self.lookup.add(newHead)
    self.body.pop()
    self.body.appendleft(newHead)

    return self.score

  def getId(self, i: int, j: int) -> int:
    return i * self.width + j"
"354","class Solution:
  def maxEnvelopes(self, envelopes: list[list[int]]) -> int:
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    # Same as 300. Longest Increasing Subsequence
    ans = 0
    dp = [0] * len(envelopes)

    for _, h in envelopes:
      l = 0
      r = ans
      while l < r:
        m = (l + r) // 2
        if dp[m] >= h:
          r = m
        else:
          l = m + 1
      dp[l] = h
      if l == ans:
        ans += 1

    return ans"
"355","class Twitter:
  def __init__(self):
    self.timer = itertools.count(step=-1)
    self.tweets = collections.defaultdict(deque)
    self.followees = collections.defaultdict(set)

  def postTweet(self, userId: int, tweetId: int) -> None:
    self.tweets[userId].appendleft((next(self.timer), tweetId))
    if len(self.tweets[userId]) > 10:
      self.tweets[userId].pop()

  def getNewsFeed(self, userId: int) -> list[int]:
    tweets = list(
        heapq.merge(
            *
            (self.tweets[followee]
             for followee in self.followees[userId] | {userId})))
    return [tweetId for _, tweetId in tweets[:10]]

  def follow(self, followerId: int, followeeId: int) -> None:
    self.followees[followerId].add(followeeId)

  def unfollow(self, followerId: int, followeeId: int) -> None:
    self.followees[followerId].discard(followeeId)"
"356","class Solution:
  def isReflected(self, points: list[list[int]]) -> bool:
    minX = math.inf
    maxX = -math.inf
    seen = set()

    for x, y in points:
      minX = min(minX, x)
      maxX = max(maxX, x)
      seen.add((x, y))

    summ = minX + maxX
    # (leftX + rightX) / 2 = (minX + maxX) / 2
    #  leftX = minX + maxX - rightX
    # rightX = minX + maxX - leftX

    return all((summ - x, y) in seen for x, y in points)"
"357","class Solution:
  def countNumbersWithUniqueDigits(self, n: int) -> int:
    if n == 0:
      return 1

    ans = 10
    uniqueDigits = 9
    availableNum = 9

    while n > 1 and availableNum > 0:
      uniqueDigits *= availableNum
      ans += uniqueDigits
      n -= 1
      availableNum -= 1

    return ans"
"358","class Solution:
  def rearrangeString(self, s: str, k: int) -> str:
    n = len(s)
    ans = []
    count = collections.Counter(s)
    # valid[i] := the leftmost index i can appear
    valid = collections.Counter()

    def getBestLetter(index: int) -> str:
      """"""Returns the valid letter that has the most count.""""""
      maxCount = -1
      bestLetter = '*'

      for c in string.ascii_lowercase:
        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:
          bestLetter = c
          maxCount = count[c]

      return bestLetter

    for i in range(n):
      c = getBestLetter(i)
      if c == '*':
        return ''
      ans.append(c)
      count[c] -= 1
      valid[c] = i + k

    return ''.join(ans)"
"359","class Logger:
  def __init__(self):
    self.okTime = {}  # {message: ok time}

  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
    if timestamp < self.okTime.get(message, 0):
      return False

    self.okTime[message] = timestamp + 10
    return True"
"36","class Solution:
  def isValidSudoku(self, board: list[list[str]]) -> bool:
    seen = set()

    for i in range(9):
      for j in range(9):
        c = board[i][j]
        if c == '.':
          continue
        if (c + '@row ' + str(i) in seen or
            c + '@col ' + str(j) in seen or
                c + '@box ' + str(i // 3) + str(j // 3) in seen):
          return False
        seen.add(c + '@row ' + str(i))
        seen.add(c + '@col ' + str(j))
        seen.add(c + '@box ' + str(i // 3) + str(j // 3))

    return True"
"360","class Solution:
  def sortTransformedArray(
      self,
      nums: list[int],
      a: int,
      b: int,
      c: int,
  ) -> list[int]:
    n = len(nums)
    upward = a > 0
    ans = [0] * n

    # The concavity of f only depends on a's sign.
    def f(x: int, a: int, b: int, c: int) -> int:
      return (a * x + b) * x + c

    quad = [f(num, a, b, c) for num in nums]

    i = n - 1 if upward else 0
    l = 0
    r = n - 1
    while l <= r:
      if upward:  # is the maximum in the both ends
        if quad[l] > quad[r]:
          ans[i] = quad[l]
          l += 1
        else:
          ans[i] = quad[r]
          r -= 1
        i -= 1
      else:  # is the minimum in the both ends
        if quad[l] < quad[r]:
          ans[i] = quad[l]
          l += 1
        else:
          ans[i] = quad[r]
          r -= 1
        i += 1

    return ans"
"361","class Solution:
  def maxKilledEnemies(self, grid: list[list[str]]) -> int:
    m = len(grid)
    n = len(grid[0])
    enemyCount = 0
    # dp[i][j] := the maximum enemies grid[i][j] can kill
    dp = [[0] * n for _ in range(m)]

    def update(i: int, j: int) -> None:
      nonlocal enemyCount
      if grid[i][j] == '0':
        dp[i][j] += enemyCount
      elif grid[i][j] == 'E':
        enemyCount += 1
      else:  # grid[i][j] == 'W'
        enemyCount = 0

    # Extend the four directions, if meet 'W', need to start over from 0.
    for i in range(m):
      enemyCount = 0
      for j in range(n):
        update(i, j)
      enemyCount = 0
      for j in reversed(range(n)):
        update(i, j)

    for j in range(n):
      enemyCount = 0
      for i in range(m):
        update(i, j)
      enemyCount = 0
      for i in reversed(range(m)):
        update(i, j)

    # Returns sum(map(sum, dp))
    return max(map(max, dp))"
"362","class HitCounter:
  def __init__(self):
    self.timestamps = [0] * 300
    self.hits = [0] * 300

  def hit(self, timestamp: int) -> None:
    i = timestamp % 300
    if self.timestamps[i] == timestamp:
      self.hits[i] += 1
    else:
      self.timestamps[i] = timestamp
      self.hits[i] = 1  # Reset the hit count to 1.

  def getHits(self, timestamp: int) -> int:
    return sum(h for t, h in zip(self.timestamps, self.hits)
               if timestamp - t < 300)"
"363","from sortedcontainers import SortedList


class Solution:
  def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:
    m = len(matrix)
    n = len(matrix[0])
    ans = -math.inf

    for baseCol in range(n):
      # sums[i] := sum(matrix[i][baseCol..j])
      sums = [0] * m
      for j in range(baseCol, n):
        for i in range(m):
          sums[i] += matrix[i][j]
        # Find the maximum sum <= k of all the subarrays.
        accumulate = SortedList([0])
        prefix = 0
        for summ in sums:
          prefix += summ
          it = accumulate.bisect_left(prefix - k)
          if it != len(accumulate):
            ans = max(ans, prefix - accumulate[it])
          accumulate.add(prefix)

    return ans"
"364","class Solution:
  def depthSumInverse(self, nestedList: list[NestedInteger]) -> int:
    ans = 0
    prevSum = 0
    q = collections.deque(nestedList)

    while q:
      for _ in range(len(q)):
        ni = q.popleft()
        if ni.isInteger():
          prevSum += ni.getInteger()
        else:
          for nextNi in ni.getList():
            q.append(nextNi)
      ans += prevSum

    return ans"
"365","class Solution:
  def canMeasureWater(
      self,
      jug1Capacity: int,
      jug2Capacity: int,
      targetCapacity: int,
  ) -> bool:
    return (targetCapacity == 0 or
            jug1Capacity + jug2Capacity >= targetCapacity and
            targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0)"
"366","class Solution:
  def findLeaves(self, root: TreeNode | None) -> list[list[int]]:
    ans = []

    def depth(root: TreeNode | None) -> int:
      """"""Returns the depth of the root (0-indexed).""""""
      if not root:
        return -1

      l = depth(root.left)
      r = depth(root.right)
      h = 1 + max(l, r)

      if len(ans) == h:  # Meet a leaf
        ans.append([])

      ans[h].append(root.val)
      return h

    depth(root)
    return ans"
"367","class Solution:
  def isPerfectSquare(self, num: int) -> bool:
    l = bisect.bisect_left(range(num), num,
                           key=lambda m: m * m)
    return l**2 == num"
"368","class Solution:
  def largestDivisibleSubset(self, nums: list[int]) -> list[int]:
    n = len(nums)
    ans = []
    count = [1] * n
    prevIndex = [-1] * n
    maxCount = 0
    index = -1

    nums.sort()

    for i, num in enumerate(nums):
      for j in reversed(range(i)):
        if num % nums[j] == 0 and count[i] < count[j] + 1:
          count[i] = count[j] + 1
          prevIndex[i] = j
      if count[i] > maxCount:
        maxCount = count[i]
        index = i

    while index != -1:
      ans.append(nums[index])
      index = prevIndex[index]

    return ans"
"369","class Solution:
  def plusOne(self, head: ListNode) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    dummy.next = head

    while head:
      if head.val != 9:
        curr = head
      head = head.next
    # `curr` now points to the rightmost non-9 node.

    curr.val += 1
    while curr.next:
      curr.next.val = 0
      curr = curr.next

    return dummy.next if dummy.val == 0 else dummy"
"37","class Solution:
  def solveSudoku(self, board: list[list[str]]) -> None:
    def isValid(row: int, col: int, c: str) -> bool:
      for i in range(9):
        if (board[i][col] == c or
            board[row][i] == c or
                board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c):
          return False
      return True

    def solve(s: int) -> bool:
      if s == 81:
        return True

      i = s // 9
      j = s % 9

      if board[i][j] != '.':
        return solve(s + 1)

      for c in string.digits[1:]:
        if isValid(i, j, c):
          board[i][j] = c
          if solve(s + 1):
            return True
          board[i][j] = '.'

      return False

    solve(0)"
"370","class Solution:
  def getModifiedArray(
      self,
      length: int,
      updates: list[list[int]],
  ) -> list[int]:
    line = [0] * length

    for start, end, inc in updates:
      line[start] += inc
      if end + 1 < length:
        line[end + 1] -= inc

    return itertools.accumulate(line)"
"371","class Solution:
  def getSum(self, a: int, b: int) -> int:
    mask = 0xFFFFFFFF
    kMax = 2000

    while b != 0:
      a, b = (a ^ b) & mask, ((a & b) << 1) & mask

    return a if a < kMax else ~(a ^ mask)"
"372","class Solution:
  def superPow(self, a: int, b: list[int]) -> int:
    kMod = 1337
    ans = 1

    for i in b:
      ans = pow(ans, 10, kMod) * pow(a, i, kMod)

    return ans % kMod"
"373","class Solution:
  def kSmallestPairs(self, nums1: list[int],
                     nums2: list[int],
                     k: int) -> list[list[int]]:
    minHeap = []

    for i in range(min(k, len(nums1))):
      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))

    ans = []
    while minHeap and len(ans) < k:
      _, i, j = heapq.heappop(minHeap)
      ans.append([nums1[i], nums2[j]])
      if j + 1 < len(nums2):
        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))

    return ans"
"374","# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
  def guessNumber(self, n: int) -> int:
    l = 1
    r = n

    # Find the first guess number that >= the target number
    while l < r:
      m = (l + r) // 2
      if guess(m) <= 0:  # -1, 0
        r = m
      else:
        l = m + 1

    return l"
"375","class Solution:
  def getMoneyAmount(self, n: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """"""Returns the minimum money you need to guarantee a win of picking i..j.
      """"""
      if i >= j:
        return 0
      return min(max(dp(i, k - 1), dp(k + 1, j)) + k
                 for k in range(i, j + 1))

    return dp(1, n)"
"376","class Solution:
  def wiggleMaxLength(self, nums: list[int]) -> int:
    increasing = 1
    decreasing = 1

    for a, b in itertools.pairwise(nums):
      if b > a:
        increasing = decreasing + 1
      elif b < a:
        decreasing = increasing + 1

    return max(increasing, decreasing)"
"377","class Solution:
  def combinationSum4(self, nums: list[int], target: int) -> int:
    dp = [1] + [-1] * target

    def dfs(target: int) -> int:
      if target < 0:
        return 0
      if dp[target] != -1:
        return dp[target]

      dp[target] = sum(dfs(target - num) for num in nums)
      return dp[target]

    return dfs(target)"
"378","class Solution:
  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:
    minHeap = []  # (matrix[i][j], i, j)

    i = 0
    while i < k and i < len(matrix):
      heapq.heappush(minHeap, (matrix[i][0], i, 0))
      i += 1

    while k > 1:
      k -= 1
      _, i, j = heapq.heappop(minHeap)
      if j + 1 < len(matrix[0]):
        heapq.heappush(minHeap, (matrix[i][j + 1], i, j + 1))

    return minHeap[0][0]"
"379","class PhoneDirectory:
  def __init__(self, maxNumbers: int):
    # the next available numbers
    self.next = [i + 1 for i in range(maxNumbers - 1)] + [0]
    # the current possible available number
    self.number = 0

  def get(self) -> int:
    if self.next[self.number] == -1:
      return -1
    ans = self.number
    self.number = self.next[self.number]
    self.next[ans] = -1  # Mark as used.
    return ans

  def check(self, number: int) -> bool:
    return self.next[number] != -1

  def release(self, number: int) -> None:
    if self.next[number] != -1:
      return
    self.next[number] = self.number
    self.number = number"
"38","class Solution:
  def countAndSay(self, n: int) -> str:
    ans = '1'

    for _ in range(n - 1):
      nxt = ''
      i = 0
      while i < len(ans):
        count = 1
        while i + 1 < len(ans) and ans[i] == ans[i + 1]:
          count += 1
          i += 1
        nxt += str(count) + ans[i]
        i += 1
      ans = nxt

    return ans"
"380","class RandomizedSet:
  def __init__(self):
    self.vals = []
    self.valToIndex = collections.defaultdict(int)  # {val: index in vals}

  def insert(self, val: int) -> bool:
    if val in self.valToIndex:
      return False
    self.valToIndex[val] = len(self.vals)
    self.vals.append(val)
    return True

  def remove(self, val: int) -> bool:
    if val not in self.valToIndex:
      return False
    index = self.valToIndex[val]
    # The order of the following two lines is important when vals.size() == 1.
    self.valToIndex[self.vals[-1]] = index
    del self.valToIndex[val]
    self.vals[index] = self.vals[-1]
    self.vals.pop()
    return True

  def getRandom(self) -> int:
    index = random.randint(0, len(self.vals) - 1)
    return self.vals[index]"
"381","class RandomizedCollection:
  def __init__(self):
    self.vals = []
    self.valToIndices = collections.defaultdict(list)

  def insert(self, val: int) -> bool:
    self.valToIndices[val].append(len(self.vals))
    self.vals.append([val, len(self.valToIndices[val]) - 1])
    return len(self.valToIndices[val]) == 1

  def remove(self, val: int) -> bool:
    if val not in self.valToIndices or self.valToIndices[val] == []:
      return False

    index = self.valToIndices[val][-1]
    self.valToIndices[self.vals[-1][0]][self.vals[-1][1]] = index
    self.valToIndices[val].pop()
    self.vals[index] = self.vals[-1]
    self.vals.pop()
    return True

  def getRandom(self) -> int:
    index = random.randint(0, len(self.vals) - 1)
    return self.vals[index][0]"
"382","# Definition for singly-linked list.
# class ListNode:
#   def __init__(self, val=0, next=None):
#     self.val = val
#     self.next = next

class Solution:
  def __init__(self, head: ListNode | None):
    self.head = head

  def getRandom(self) -> int:
    res = -1
    i = 1
    curr = self.head

    while curr:
      if random.randint(0, i - 1) == 0:
        res = curr.val
      curr = curr.next
      i += 1

    return res"
"383","class Solution:
  def canConstruct(self, ransomNote: str, magazine: str) -> bool:
    count1 = collections.Counter(ransomNote)
    count2 = collections.Counter(magazine)
    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)"
"384","class Solution:
  def __init__(self, nums: list[int]):
    self.nums = nums

  def reset(self) -> list[int]:
    """"""
    Resets the array to its original configuration and return it.
    """"""
    return self.nums

  def shuffle(self) -> list[int]:
    """"""
    Returns a random shuffling of the array.
    """"""
    A = self.nums.copy()
    for i in range(len(A) - 1, 0, -1):
      j = random.randint(0, i)
      A[i], A[j] = A[j], A[i]
    return A"
"385","class Solution:
  def deserialize(self, s: str) -> NestedInteger:
    if s[0] != '[':
      return NestedInteger(int(s))

    stack = []

    for i, c in enumerate(s):
      if c == '[':
        stack.append(NestedInteger())
        start = i + 1
      elif c == ',':
        if i > start:
          num = int(s[start:i])
          stack[-1].add(NestedInteger(num))
        start = i + 1
      elif c == ']':
        popped = stack.pop()
        if i > start:
          num = int(s[start:i])
          popped.add(NestedInteger(num))
        if stack:
          stack[-1].add(popped)
        else:
          return popped
        start = i + 1"
"386","class Solution:
  def lexicalOrder(self, n: int) -> list[int]:
    ans = []
    curr = 1

    while len(ans) < n:
      ans.append(curr)
      if curr * 10 <= n:
        curr *= 10
      else:
        while curr % 10 == 9 or curr == n:
          curr //= 10
        curr += 1

    return ans"
"387","class Solution:
  def firstUniqChar(self, s: str) -> int:
    count = collections.Counter(s)

    for i, c in enumerate(s):
      if count[c] == 1:
        return i

    return -1"
"388","class Solution:
  def lengthLongestPath(self, input: str) -> int:
    ans = 0
    stack = [(-1, 0)]  # placeholder

    for token in input.split('\n'):
      depth = token.count('\t')
      token = token.replace('\t', '')
      while depth <= stack[-1][0]:
        stack.pop()
      if '.' in token:  # `token` is file.
        ans = max(ans, stack[-1][1] + len(token))
      else:  # directory + '/'
        stack.append((depth, stack[-1][1] + len(token) + 1))

    return ans"
"389","class Solution:
  def findTheDifference(self, s: str, t: str) -> str:
    sXors = chr(functools.reduce(operator.xor, map(ord, s), 0))
    tXors = chr(functools.reduce(operator.xor, map(ord, t), 0))
    return chr(ord(sXors) ^ ord(tXors))"
"39","class Solution:
  def combinationSum(self, candidates: list[int],
                     target: int) -> list[list[int]]:
    ans = []

    def dfs(s: int, target: int, path: list[int]) -> None:
      if target < 0:
        return
      if target == 0:
        ans.append(path.clone())
        return

      for i in range(s, len(candidates)):
        path.append(candidates[i])
        dfs(i, target - candidates[i], path)
        path.pop()

    candidates.sort()
    dfs(0, target, [])
    return ans"
"390","class Solution:
  def lastRemaining(self, n: int) -> int:
    return 1 if n == 1 else 2 * (1 + n // 2 - self.lastRemaining(n // 2))"
"391","class Solution:
  def isRectangleCover(self, rectangles: list[list[int]]) -> bool:
    area = 0
    x1 = math.inf
    y1 = math.inf
    x2 = -math.inf
    y2 = -math.inf
    corners: set[tuple[int, int]] = set()

    for x, y, a, b in rectangles:
      area += (a - x) * (b - y)
      x1 = min(x1, x)
      y1 = min(y1, y)
      x2 = max(x2, a)
      y2 = max(y2, b)

      # the four points of the current rectangle
      for point in [(x, y), (x, b), (a, y), (a, b)]:
        if point in corners:
          corners.remove(point)
        else:
          corners.add(point)

    if len(corners) != 4:
      return False
    if ((x1, y1) not in corners or
        (x1, y2) not in corners or
        (x2, y1) not in corners or
            (x2, y2) not in corners):
      return False
    return area == (x2 - x1) * (y2 - y1)"
"392","class Solution:
  def isSubsequence(self, s: str, t: str) -> bool:
    if not s:
      return True

    i = 0
    for c in t:
      if s[i] == c:
        i += 1
        if i == len(s):
          return True

    return False"
"393","class Solution:
  def validUtf8(self, data: list[int]) -> bool:
    followedBytes = 0

    for d in data:
      if followedBytes == 0:
        if (d >> 3) == 0b11110:
          followedBytes = 3
        elif (d >> 4) == 0b1110:
          followedBytes = 2
        elif (d >> 5) == 0b110:
          followedBytes = 1
        elif (d >> 7) == 0b0:
          followedBytes = 0
        else:
          return False
      else:
        if (d >> 6) != 0b10:
          return False
        followedBytes -= 1

    return followedBytes == 0"
"394","class Solution:
  def decodeString(self, s: str) -> str:
    ans = ''

    while self.i < len(s) and s[self.i] != ']':
      if s[self.i].isdigit():
        k = 0
        while self.i < len(s) and s[self.i].isdigit():
          k = k * 10 + int(s[self.i])
          self.i += 1
        self.i += 1  # '['
        decodedString = self.decodeString(s)
        self.i += 1  # ']'
        ans += k * decodedString
      else:
        ans += s[self.i]
        self.i += 1

    return ans

  i = 0"
"395","class Solution:
  def longestSubstring(self, s: str, k: int) -> int:
    def longestSubstringWithNUniqueLetters(n: int) -> int:
      res = 0
      uniqueLetters = 0  # the number of unique letters
      lettersHavingKFreq = 0  # the number of letters having frequency >= k
      count = collections.Counter()

      l = 0
      for r, c in enumerate(s):
        count[c] += 1
        if count[c] == 1:
          uniqueLetters += 1
        if count[c] == k:
          lettersHavingKFreq += 1
        while uniqueLetters > n:
          if count[s[l]] == k:
            lettersHavingKFreq -= 1
          count[s[l]] -= 1
          if count[s[l]] == 0:
            uniqueLetters -= 1
          l += 1
        # Since both the number of unique letters and the number of letters
        # having frequency >= k are equal to n, this is a valid window.
        if lettersHavingKFreq == n:  # Implicit: uniqueLetters == n
          res = max(res, r - l + 1)

      return res

    return max(longestSubstringWithNUniqueLetters(n)
               for n in range(1, 27))"
"396","class Solution:
  def maxRotateFunction(self, nums: list[int]) -> int:
    f = sum(i * num for i, num in enumerate(nums))
    ans = f
    summ = sum(nums)

    for a in reversed(nums):
      f += summ - len(nums) * a
      ans = max(ans, f)

    return ans"
"397","class Solution:
  def integerReplacement(self, n: int) -> int:
    ans = 0

    while n > 1:
      if n % 2 == 0:  # `n` ends in 0.
        n >>= 1
      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.
        n -= 1
      else:  # `n` ends in 0b11.
        n += 1
      ans += 1

    return ans"
"398","class Solution:
  def __init__(self, nums: list[int]):
    self.nums = nums

  def pick(self, target: int) -> int:
    ans = -1
    rng = 0
    for i, num in enumerate(self.nums):
      if num == target:
        rng += 1
        if random.randint(0, rng - 1) == 0:
          ans = i
    return ans"
"399","class Solution:
  def calcEquation(
      self,
      equations: list[list[str]],
      values: list[float],
      queries: list[list[str]],
  ) -> list[float]:
    ans = []
    # graph[A][B] := A / B
    graph = collections.defaultdict(dict)

    for (A, B), value in zip(equations, values):
      graph[A][B] = value
      graph[B][A] = 1 / value

    def devide(A: str, C: str, seen: set[str]) -> float:
      """"""Returns A / C.""""""
      if A == C:
        return 1.0

      seen.add(A)

      # value := A / B
      for B, value in graph[A].items():
        if B in seen:
          continue
        res = devide(B, C, seen)  # B / C
        if res > 0:  # valid result
          return value * res  # (A / B) * (B / C) = A / C

      return -1.0  # invalid result

    for A, C in queries:
      if A not in graph or C not in graph:
        ans.append(-1.0)
      else:
        ans.append(devide(A, C, set()))

    return ans"
"4","class Solution:
  def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
    n1 = len(nums1)
    n2 = len(nums2)
    if n1 > n2:
      return self.findMedianSortedArrays(nums2, nums1)

    l = 0
    r = n1

    while l <= r:
      partition1 = (l + r) // 2
      partition2 = (n1 + n2 + 1) // 2 - partition1
      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]
      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]
      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]
      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]
      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)
      elif maxLeft1 > minRight2:
        r = partition1 - 1
      else:
        l = partition1 + 1"
"40","class Solution:
  def combinationSum2(self, candidates: list[int],
                      target: int) -> list[list[int]]:
    ans = []

    def dfs(s: int, target: int, path: list[int]) -> None:
      if target < 0:
        return
      if target == 0:
        ans.append(path.copy())
        return

      for i in range(s, len(candidates)):
        if i > s and candidates[i] == candidates[i - 1]:
          continue
        path.append(candidates[i])
        dfs(i + 1, target - candidates[i], path)
        path.pop()

    candidates.sort()
    dfs(0, target, [])
    return ans"
"400","class Solution:
  def findNthDigit(self, n: int) -> int:
    def getDigit(num: int, pos: int, digitSize: int):
      if pos == 0:
        return num % 10
      for _ in range(digitSize - pos):
        num //= 10
      return num % 10

    digitSize = 1
    startNum = 1
    count = 9

    while digitSize * count < n:
      n -= digitSize * count
      digitSize += 1
      startNum *= 10
      count *= 10

    targetNum = startNum + (n - 1) // digitSize
    pos = n % digitSize

    return getDigit(targetNum, pos, digitSize)"
"401","class Solution:
  def readBinaryWatch(self, turnedOn: int) -> list[str]:
    ans = []
    hours = [1, 2, 4, 8]
    minutes = [1, 2, 4, 8, 16, 32]

    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:
      if turnedOn == 0:
        time = str(h) + "":"" + (str(m).zfill(2))
        ans.append(time)
        return

      for i in range(s, len(hours) + len(minutes)):
        if i < 4 and h + hours[i] < 12:
          dfs(turnedOn - 1, i + 1, h + hours[i], m)
        elif i >= 4 and m + minutes[i - 4] < 60:
          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])

    dfs(turnedOn, 0, 0, 0)
    return ans"
"402","class Solution:
  def removeKdigits(self, num: str, k: int) -> str:
    if len(num) == k:
      return '0'

    ans = []
    stack = []

    for i, digit in enumerate(num):
      while k > 0 and stack and stack[-1] > digit:
        stack.pop()
        k -= 1
      stack.append(digit)

    for _ in range(k):
      stack.pop()

    for c in stack:
      if c == '0' and not ans:
        continue
      ans.append(c)

    return ''.join(ans) if ans else '0'"
"403","class Solution:
  def canCross(self, stones: list[int]) -> bool:
    n = len(stones)
    # dp[i][j] := True if a frog can make a size j jump from stones[i]
    dp = [[False] * (n + 1) for _ in range(n)]
    dp[0][1] = True

    for i in range(1, n):
      for j in range(i):
        k = stones[i] - stones[j]
        if k <= n and dp[j][k]:
          dp[i][k - 1] = True
          dp[i][k] = True
          dp[i][k + 1] = True

    return any(dp[-1])"
"404","class Solution:
  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:
    if not root:
      return 0

    ans = 0

    if root.left:
      if not root.left.left and not root.left.right:
        ans += root.left.val
      else:
        ans += self.sumOfLeftLeaves(root.left)
    ans += self.sumOfLeftLeaves(root.right)

    return ans"
"405","class Solution:
  def toHex(self, num: int) -> str:
    if num == 0:
      return '0'

    hex = '0123456789abcdef'
    ans = []

    # Handling negative numbers by using 32-bit unsigned representation Python's
    # bitwise operation works on signed numbers, so we convert to 32-bit
    # unsigned for negative numbers.
    if num < 0:
      num += 2**32

    while num > 0:
      ans.append(hex[num & 0xF])
      num >>= 4

    return ''.join(reversed(ans))"
"406","class Solution:
  def reconstructQueue(self, people: list[list[int]]) -> list[list[int]]:
    ans = []

    people.sort(key=lambda x: (-x[0], x[1]))

    for p in people:
      ans.insert(p[1], p)

    return ans"
"407","class Solution:
  def trapRainWater(self, heightMap: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(heightMap)
    n = len(heightMap[0])
    ans = 0
    minHeap = []
    seen = set()

    for i in range(m):
      heapq.heappush(minHeap, (heightMap[i][0], i, 0))
      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))
      seen.add((i, 0))
      seen.add((i, n - 1))

    for j in range(1, n - 1):
      heapq.heappush(minHeap, (heightMap[0][j], 0, j))
      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))
      seen.add((0, j))
      seen.add((m - 1, j))

    while minHeap:
      h, i, j = heapq.heappop(minHeap)
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        if heightMap[x][y] < h:
          ans += h - heightMap[x][y]
          # Fill water in grid[x][y].
          heapq.heappush(minHeap, (h, x, y))
        else:
          heapq.heappush(minHeap, (heightMap[x][y], x, y))
        seen.add((x, y))

    return ans"
"408","class Solution:
  def validWordAbbreviation(self, word: str, abbr: str) -> bool:
    i = 0  # word's index
    j = 0  # abbr's index

    while i < len(word) and j < len(abbr):
      if word[i] == abbr[j]:
        i += 1
        j += 1
        continue
      if not abbr[j].isdigit() or abbr[j] == '0':
        return False
      num = 0
      while j < len(abbr) and abbr[j].isdigit():
        num = num * 10 + int(abbr[j])
        j += 1
      i += num

    return i == len(word) and j == len(abbr)"
"409","class Solution:
  def longestPalindrome(self, s: str) -> int:
    ans = 0
    count = collections.Counter(s)

    for c in count.values():
      ans += c if c % 2 == 0 else c - 1

    hasOddCount = any(c % 2 == 1 for c in count.values())
    return ans + hasOddCount"
"41","class Solution:
  def firstMissingPositive(self, nums: list[int]) -> int:
    n = len(nums)

    # Correct slot:
    # nums[i] = i + 1
    # nums[i] - 1 = i
    # nums[nums[i] - 1] = nums[i]
    for i in range(n):
      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:
        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i, num in enumerate(nums):
      if num != i + 1:
        return i + 1

    return n + 1"
"410","class Solution:
  def splitArray(self, nums: list[int], k: int) -> int:
    prefix = list(itertools.accumulate(nums, initial=0))

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """"""
      Returns the minimum of the maximum sum to split the first i numbers into
      k groups.
      """"""
      if k == 1:
        return prefix[i]
      return min(max(dp(j, k - 1), prefix[i] - prefix[j])
                 for j in range(k - 1, i))

    return dp(len(nums), k)"
"411","class Solution:
  def minAbbreviation(self, target: str, dictionary: list[str]) -> str:
    m = len(target)

    def getMask(word: str) -> int:
      # mask[i] = 0 := target[i] == word[i]
      # mask[i] = 1 := target[i] != word[i]
      # e.g. target = ""apple""
      #        word = ""blade""
      #        mask =  11110
      mask = 0
      for i, c in enumerate(word):
        if c != target[i]:
          mask |= 1 << m - 1 - i
      return mask

    masks = [getMask(word) for word in dictionary if len(word) == m]
    if not masks:
      return str(m)

    abbrs = []

    def getAbbr(cand: int) -> str:
      abbr = []
      replacedCount = 0
      for i, c in enumerate(target):
        if cand >> m - 1 - i & 1:
          # If cand[i] = 1, `abbr` should show the original character.
          if replacedCount:
            abbr += str(replacedCount)
          abbr.append(c)
          replacedCount = 0
        else:
          # If cand[i] = 0, `abbr` can be replaced.
          replacedCount += 1
      if replacedCount:
        abbr.append(str(replacedCount))
      return ''.join(abbr)

    # all the candidate representation of the target
    for cand in range(2**m):
      # All the masks have at lease one bit different from the candidate.
      if all(cand & mask for mask in masks):
        abbr = getAbbr(cand)
        abbrs.append(abbr)

    def getAbbrLen(abbr: str) -> int:
      abbrLen = 0
      i = 0
      j = 0
      while i < len(abbr):
        if abbr[j].isalpha():
          j += 1
        else:
          while j < len(abbr) and abbr[j].isdigit():
            j += 1
        abbrLen += 1
        i = j
      return abbrLen

    return min(abbrs, key=lambda x: getAbbrLen(x))"
"412","class Solution:
  def fizzBuzz(self, n: int) -> list[str]:
    d = {3: 'Fizz', 5: 'Buzz'}
    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]"
"413","class Solution:
  def numberOfArithmeticSlices(self, nums: list[int]) -> int:
    ans = 0
    dp = 0

    for i in range(2, len(nums)):
      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
        dp += 1
        ans += dp
      else:
        dp = 0

    return ans"
"414","class Solution:
  def thirdMax(self, nums: list[int]) -> int:
    max1 = -math.inf  # the maximum
    max2 = -math.inf  # the second maximum
    max3 = -math.inf  # the third maximum

    for num in nums:
      if num > max1:
        max3 = max2
        max2 = max1
        max1 = num
      elif max1 > num and num > max2:
        max3 = max2
        max2 = num
      elif max2 > num and num > max3:
        max3 = num

    return max1 if max3 == -math.inf else max3"
"415","class Solution:
  def addStrings(self, num1: str, num2: str) -> str:
    ans = []
    carry = 0
    i = len(num1) - 1
    j = len(num2) - 1

    while i >= 0 or j >= 0 or carry:
      if i >= 0:
        carry += int(num1[i])
      if j >= 0:
        carry += int(num2[j])
      ans.append(str(carry % 10))
      carry //= 10
      i -= 1
      j -= 1

    return ''.join(reversed(ans))"
"416","class Solution:
  def canPartition(self, nums: list[int]) -> bool:
    summ = sum(nums)
    if summ % 2 == 1:
      return False
    return self.knapsack_(nums, summ // 2)

  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:
    n = len(nums)
    # dp[i][j] := True if j can be formed by nums[0..i)
    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]
    dp[0][0] = True

    for i in range(1, n + 1):
      num = nums[i - 1]
      for j in range(subsetSum + 1):
        if j < num:
          dp[i][j] = dp[i - 1][j]
        else:
          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]

    return dp[n][subsetSum]"
"417","class Solution:
  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:
    m = len(heights)
    n = len(heights[0])
    seenP = [[False] * n for _ in range(m)]
    seenA = [[False] * n for _ in range(m)]

    def dfs(i: int, j: int, h: int, seen: list[list[bool]]) -> None:
      if i < 0 or i == m or j < 0 or j == n:
        return
      if seen[i][j] or heights[i][j] < h:
        return

      seen[i][j] = True
      dfs(i + 1, j, heights[i][j], seen)
      dfs(i - 1, j, heights[i][j], seen)
      dfs(i, j + 1, heights[i][j], seen)
      dfs(i, j - 1, heights[i][j], seen)

    for i in range(m):
      dfs(i, 0, 0, seenP)
      dfs(i, n - 1, 0, seenA)

    for j in range(n):
      dfs(0, j, 0, seenP)
      dfs(m - 1, j, 0, seenA)

    return [[i, j]
            for i in range(m)
            for j in range(n)
            if seenP[i][j] and seenA[i][j]]"
"418","class Solution:
  def wordsTyping(self, sentence: list[str], rows: int, cols: int) -> int:
    combined = ' '.join(sentence) + ' '
    n = len(combined)
    i = 0

    for _ in range(rows):
      i += cols
      if combined[i % n] == ' ':
        i += 1
      else:
        while i > 0 and combined[(i - 1) % n] != ' ':
          i -= 1

    return i // n"
"419","class Solution:
  def countBattleships(self, board: list[list[str]]) -> int:
    ans = 0

    for i, row in enumerate(board):
      for j, cell in enumerate(row):
        if cell == '.':
          continue
        if i > 0 and board[i - 1][j] == 'X':
          continue
        if j > 0 and board[i][j - 1] == 'X':
          continue
        ans += 1

    return ans"
"42","class Solution:
  def trap(self, height: list[int]) -> int:
    if not height:
      return 0

    ans = 0
    l = 0
    r = len(height) - 1
    maxL = height[l]
    maxR = height[r]

    while l < r:
      if maxL < maxR:
        ans += maxL - height[l]
        l += 1
        maxL = max(maxL, height[l])
      else:
        ans += maxR - height[r]
        r -= 1
        maxR = max(maxR, height[r])

    return ans"
"420","class Solution:
  def strongPasswordChecker(self, password: str) -> int:
    n = len(password)
    missing = self._getMissing(password)
    # the number of replacements to deal with 3 repeating characters
    replaces = 0
    # the number of sequences that can be substituted with 1 deletions,
    # (3k)-seqs
    oneSeq = 0
    # the number of sequences that can be substituted with 2 deletions,
    # (3k + 1)-seqs
    twoSeq = 0

    i = 2
    while i < n:
      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:
        length = 2  # the length of the repeating password
        while i < n and password[i] == password[i - 1]:
          length += 1
          i += 1
        replaces += length // 3  # 'aaaaaaa' -> 'aaxaaxa'
        if length % 3 == 0:
          oneSeq += 1
        if length % 3 == 1:
          twoSeq += 1
      else:
        i += 1

    if n < 6:
      return max(6 - n, missing)
    if n <= 20:
      return max(replaces, missing)

    deletes = n - 20
    # Each replacement in (3k)-seqs can be substituted with 1 deletions.
    replaces -= min(oneSeq, deletes)
    # Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.
    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2
    # Each replacement in other seqs can be substituted with 3 deletions.
    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3
    return deletes + max(replaces, missing)

  def _getMissing(self, password: str) -> int:
    return (3
            - any(c.isupper() for c in password)
            - any(c.islower() for c in password)
            - any(c.isdigit() for c in password))"
"421","class Solution:
  def findMaximumXOR(self, nums: list[int]) -> int:
    maxNum = max(nums)
    if maxNum == 0:
      return 0
    maxBit = int(math.log2(maxNum))
    ans = 0
    prefixMask = 0  # `prefixMask` grows like: 10000 -> 11000 -> ... -> 11111.

    # If ans is 11100 when i = 2, it means that before we reach the last two
    # bits, 11100 is the maximum XOR we have, and we're going to explore if we
    # can get another two 1s and put them into `ans`.
    for i in range(maxBit, -1, -1):
      prefixMask |= 1 << i
      # We only care about the left parts,
      # If i = 2, nums = [1110, 1011, 0111]
      #    -> prefixes = [1100, 1000, 0100]
      prefixes = set([num & prefixMask for num in nums])
      # If i = 1 and before this iteration, the ans is 10100, it means that we
      # want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for
      # XOR of two prefixes = candidate.
      candidate = ans | 1 << i
      for prefix in prefixes:
        if prefix ^ candidate in prefixes:
          ans = candidate
          break

    return ans"
"422","class Solution:
  def validWordSquare(self, words: list[str]) -> bool:
    for i, word in enumerate(words):
      for j, c in enumerate(word):
        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds
          return False
        if c != words[j][i]:
          return False
    return True"
"423","class Solution:
  def originalDigits(self, s: str) -> str:
    count = [0] * 10

    for c in s:
      if c == 'z':
        count[0] += 1
      if c == 'o':
        count[1] += 1
      if c == 'w':
        count[2] += 1
      if c == 'h':
        count[3] += 1
      if c == 'u':
        count[4] += 1
      if c == 'f':
        count[5] += 1
      if c == 'x':
        count[6] += 1
      if c == 's':
        count[7] += 1
      if c == 'g':
        count[8] += 1
      if c == 'i':
        count[9] += 1

    count[1] -= count[0] + count[2] + count[4]
    count[3] -= count[8]
    count[5] -= count[4]
    count[7] -= count[6]
    count[9] -= count[5] + count[6] + count[8]
    return ''.join(chr(i + ord('0')) for i, c in enumerate(count)
                   for _ in range(c))"
"424","class Solution:
  def characterReplacement(self, s: str, k: int) -> int:
    ans = 0
    maxCount = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      maxCount = max(maxCount, count[c])
      while maxCount + k < r - l + 1:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"425","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.startsWith: list[str] = []


class Trie:
  def __init__(self, words: list[str]):
    self.root = TrieNode()
    for word in words:
      self._insert(word)

  def findBy(self, prefix: str) -> list[str]:
    node = self.root
    for c in prefix:
      if c not in node.children:
        return []
      node = node.children[c]
    return node.startsWith

  def _insert(self, word: str) -> None:
    node = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
      node.startsWith.append(word)


class Solution:
  def wordSquares(self, words: list[str]) -> list[list[str]]:
    if not words:
      return []

    n = len(words[0])
    ans = []
    path = []
    trie = Trie(words)

    for word in words:
      path.append(word)
      self._dfs(trie, n, path, ans)
      path.pop()

    return ans

  def _dfs(self, trie: Trie, n: int, path: list[str], ans: list[list[str]]):
    if len(path) == n:
      ans.append(path.copy())
      return

    prefix = self._getPrefix(path)

    for s in trie.findBy(prefix):
      path.append(s)
      self.dfs(trie, n, path, ans)
      path.pop()

  def _getPrefix(self, path: list[str]) -> str:
    """"""
    e.g. path = [""wall"",
                 ""area""]
       prefix =  ""le..""
    """"""
    prefix = []
    index = len(path)
    for s in path:
      prefix.append(s[index])
    return ''.join(prefix)"
"426","class Solution:
  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':
    if not root:
      return None

    stack = []
    first = None
    pred = None

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      if not first:
        first = root
      if pred:
        pred.right = root
        root.left = pred
      pred = root
      root = root.right

    pred.right = first
    first.left = pred
    return first"
"427","class Solution:
  def construct(self, grid: list[list[int]]) -> 'Node':
    return self._helper(grid, 0, 0, len(grid))

  def _helper(self, grid: list[list[int]], i: int, j: int, w: int) -> 'Node':
    if self._allSame(grid, i, j, w):
      return Node(grid[i][j] == 1, True)
    half = w // 2
    return Node(True, False,
                self._helper(grid, i, j, half),
                self._helper(grid, i, j + half, half),
                self._helper(grid, i + half, j, half),
                self._helper(grid, i + half, j + half, half))

  def _allSame(self, grid: list[list[int]], i: int, j: int, w: int) -> bool:
    return all(grid[x][y] == grid[i][j]
               for x in range(i, i + w)
               for y in range(j, j + w))"
"428","class Codec:
  def serialize(self, root: 'Node') -> str:
    """"""Encodes a tree to a single string.""""""
    if not root:
      return ''

    s = []
    q = collections.deque([root])
    s.append(str(root.val) + ' ')

    while q:
      for _ in range(len(q)):
        node = q.popleft()
        if not node.children:
          s.append('n')
        else:
          for child in node.children:
            q.append(child)
            s.append(str(child.val) + '#')
        s.append(' ')

    return ''.join(s)

  def deserialize(self, data: str) -> 'Node':
    """"""Decodes your encoded data to tree.""""""
    if not data:
      return None

    words = data.split()
    root = Node(int(words[0]))
    q = collections.deque([root])

    for word in words[1:]:
      parent = q.popleft()
      children = []
      for kid in word.split('#'):
        if kid in ('', 'n'):
          continue
        child = Node(int(kid))
        children.append(child)
        q.append(child)
      parent.children = children

    return root"
"429","class Solution:
  def levelOrder(self, root: 'Node') -> list[list[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      currLevel = []
      for _ in range(len(q)):
        node = q.popleft()
        currLevel.append(node.val)
        for child in node.children:
          q.append(child)
      ans.append(currLevel)

    return ans"
"43","class Solution:
  def multiply(self, num1: str, num2: str) -> str:
    s = [0] * (len(num1) + len(num2))

    for i in reversed(range(len(num1))):
      for j in reversed(range(len(num2))):
        mult = int(num1[i]) * int(num2[j])
        summ = mult + s[i + j + 1]
        s[i + j] += summ // 10
        s[i + j + 1] = summ % 10

    for i, c in enumerate(s):
      if c != 0:
        break

    return ''.join(map(str, s[i:]))"
"430","class Solution:
  def flatten(self, head: 'Node') -> 'Node':
    def flatten(head: 'Node', rest: 'Node') -> 'Node':
      if not head:
        return rest

      head.next = flatten(head.child, flatten(head.next, rest))
      if head.next:
        head.next.prev = head
      head.child = None
      return head

    return flatten(head, None)"
"431","class Codec:
  # Encodes an n-ary tree to a binary tree.
  def encode(self, root: 'Node') -> TreeNode | None:
    if not root:
      return None

    rootTreeNode = TreeNode(root.val)
    q = collections.deque([(root, rootTreeNode)])

    while q:
      parentNode, parentTreeNode = q.popleft()
      prevTreeNode = None
      headTreeNode = None
      for child in parentNode.children:
        currTreeNode = TreeNode(child.val)
        if prevTreeNode:
          prevTreeNode.right = currTreeNode
        else:
          headTreeNode = currTreeNode
        prevTreeNode = currTreeNode
        q.append((child, currTreeNode))
      parentTreeNode.left = headTreeNode

    return rootTreeNode

  # Decodes your binary tree to an n-ary tree.
  def decode(self, root: TreeNode | None) -> 'Node':
    if not root:
      return None

    rootNode = Node(root.val, [])
    q = collections.deque([(rootNode, root)])

    while q:
      parentNode, parentTreeNode = q.popleft()
      sibling = parentTreeNode.left
      while sibling:
        currNode = Node(sibling.val, [])
        parentNode.children.append(currNode)
        q.append((currNode, sibling))
        sibling = sibling.right

    return rootNode"
"432","from dataclasses import dataclass


@dataclass
class Node:
  def __init__(self, count: int, key: str | None = None):
    self.count = count
    self.keys: set[str] = {key} if key else set()
    self.prev: Node | None = None
    self.next: Node | None = None

  def __eq__(self, other) -> bool:
    if not isinstance(other, Node):
      return NotImplemented
    return self.count == other.count and self.keys == other.keys


class AllOne:
  def __init__(self):
    self.keyToNode: dict[str, Node] = {}
    self.head = Node(0)
    self.tail = Node(0)
    self.head.next = self.tail
    self.tail.prev = self.head

  def inc(self, key: str) -> None:
    if key in self.keyToNode:
      self._incrementExistingKey(key)
    else:
      self._addNewKey(key)

  def dec(self, key: str) -> None:
    # It is guaranteed that key exists in the data structure before the
    # decrement.
    self._decrementExistingKey(key)

  def getMaxKey(self) -> str:
    return '' if self.tail.prev == self.head \
        else next(iter(self.tail.prev.keys))

  def getMinKey(self) -> str:
    return '' if self.head.next == self.tail \
        else next(iter(self.head.next.keys))

  def _addNewKey(self, key: str) -> None:
    """"""Adds a new node with frequency 1.""""""
    if self.head.next.count == 1:
      self.head.next.keys.add(key)
    else:
      self._insertAfter(self.head, Node(1, key))
    self.keyToNode[key] = self.head.next

  def _incrementExistingKey(self, key: str) -> None:
    """"""Increments the frequency of the key by 1.""""""
    node = self.keyToNode[key]
    node.keys.remove(key)
    if node.next == self.tail or node.next.count > node.count + 1:
      self._insertAfter(node, Node(node.count + 1))
    node.next.keys.add(key)
    self.keyToNode[key] = node.next
    if not node.keys:
      self._remove(node)

  def _decrementExistingKey(self, key: str) -> None:
    """"""Decrements the count of the key by 1.""""""
    node = self.keyToNode[key]
    node.keys.remove(key)
    if node.count > 1:
      if node.prev == self.head or node.prev.count != node.count - 1:
        self._insertAfter(node.prev, Node(node.count - 1))
      node.prev.keys.add(key)
      self.keyToNode[key] = node.prev
    else:
      del self.keyToNode[key]
    if not node.keys:
      self._remove(node)

  def _insertAfter(self, node: Node, newNode: Node) -> None:
    newNode.prev = node
    newNode.next = node.next
    node.next.prev = newNode
    node.next = newNode

  def _remove(self, node: Node) -> None:
    node.prev.next = node.next
    node.next.prev = node.prev"
"433","class Solution:
  def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:
    bankSet = set(bank)
    if endGene not in bankSet:
      return -1

    kGenes = 'ACGT'
    q = collections.deque([startGene])

    step = 1
    while q:
      for _ in range(len(q)):
        wordList = list(q.popleft())
        for j, cache in enumerate(wordList):
          for c in kGenes:
            wordList[j] = c
            word = ''.join(wordList)
            if word == endGene:
              return step
            if word in bankSet:
              bankSet.remove(word)
              q.append(word)
          wordList[j] = cache
      step += 1

    return -1"
"434","class Solution:
  def countSegments(self, s: str) -> int:
    return len(s.split())"
"435","class Solution:
  def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:
    ans = 0
    currentEnd = -math.inf

    for interval in sorted(intervals, key=lambda x: x[1]):
      if interval[0] >= currentEnd:
        currentEnd = interval[1]
      else:
        ans += 1

    return ans"
"436","from sortedcontainers import SortedDict


class Solution:
  def findRightInterval(self, intervals: list[list[int]]) -> list[int]:
    ans = []
    startToIndex = SortedDict()

    for i, (start, end) in enumerate(intervals):
      startToIndex[start] = i

    for start, end in intervals:
      i = startToIndex.bisect_left(end)
      ans.append(-1 if i == len(startToIndex) else startToIndex.peekitem(i)[1])

    return ans"
"437","class Solution:
  def pathSum(self, root: TreeNode | None, summ: int) -> int:
    if not root:
      return 0

    def dfs(root: TreeNode, summ: int) -> int:
      if not root:
        return 0
      return (int(summ == root.val) +
              dfs(root.left, summ - root.val) +
              dfs(root.right, summ - root.val))

    return (dfs(root, summ) +
            self.pathSum(root.left, summ) +
            self.pathSum(root.right, summ))"
"438","class Solution:
  def findAnagrams(self, s: str, p: str) -> list[int]:
    ans = []
    count = collections.Counter(p)
    required = len(p)

    for r, c in enumerate(s):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      if r >= len(p):
        count[s[r - len(p)]] += 1
        if count[s[r - len(p)]] > 0:
          required += 1
      if required == 0:
        ans.append(r - len(p) + 1)

    return ans"
"439","class Solution:
  def parseTernary(self, expression: str) -> str:
    c = expression[self.i]

    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':
      self.i += 2
      return str(c)

    self.i += 2
    first = self.parseTernary(expression)
    second = self.parseTernary(expression)

    return first if c == 'T' else second

  i = 0"
"44","class Solution:
  def isMatch(self, s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    # dp[i][j] := True if s[0..i) matches p[0..j)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    def isMatch(i: int, j: int) -> bool:
      return i >= 0 and p[j] == '?' or s[i] == p[j]

    for j, c in enumerate(p):
      if c == '*':
        dp[0][j + 1] = dp[0][j]

    for i in range(m):
      for j in range(n):
        if p[j] == '*':
          matchEmpty = dp[i + 1][j]
          matchSome = dp[i][j + 1]
          dp[i + 1][j + 1] = matchEmpty or matchSome
        elif isMatch(i, j):
          dp[i + 1][j + 1] = dp[i][j]

    return dp[m][n]"
"440","class Solution:
  def findKthNumber(self, n: int, k: int) -> int:
    ans = 1

    i = 1
    while i < k:
      gap = self._getGap(ans, ans + 1, n)
      if i + gap <= k:
        i += gap
        ans += 1
      else:
        i += 1
        ans *= 10

    return ans

  def _getGap(self, a: int, b: int, n: int) -> int:
    gap = 0
    while a <= n:
      gap += min(n + 1, b) - a
      a *= 10
      b *= 10
    return gap"
"441","class Solution:
  def arrangeCoins(self, n: int) -> int:
    return int((-1 + math.sqrt(8 * n + 1)) // 2)"
"442","class Solution:
  def findDuplicates(self, nums: list[int]) -> list[int]:
    ans = []

    for num in nums:
      nums[abs(num) - 1] *= -1
      if nums[abs(num) - 1] > 0:
        ans.append(abs(num))

    return ans"
"443","class Solution:
  def compress(self, chars: list[str]) -> int:
    ans = 0
    i = 0

    while i < len(chars):
      letter = chars[i]
      count = 0
      while i < len(chars) and chars[i] == letter:
        count += 1
        i += 1
      chars[ans] = letter
      ans += 1
      if count > 1:
        for c in str(count):
          chars[ans] = c
          ans += 1

    return ans"
"444","class Solution:
  def sequenceReconstruction(
      self,
      org: list[int],
      seqs: list[list[int]],
  ) -> bool:
    if not seqs:
      return False

    n = len(org)
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n

    # Build the graph.
    for seq in seqs:
      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:
        return False
      for u, v in zip(seq, seq[1:]):
        if u < 1 or u > n or v < 1 or v > n:
          return False
        graph[u - 1].append(v - 1)
        inDegrees[v - 1] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])
    i = 0  # org's index

    while q:
      if len(q) > 1:
        return False
      u = q.popleft()
      if u != org[i] - 1:
        return False
      i += 1
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return i == n"
"445","class Solution:
  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
    stack1 = []
    stack2 = []

    while l1:
      stack1.append(l1)
      l1 = l1.next

    while l2:
      stack2.append(l2)
      l2 = l2.next

    head = None
    carry = 0

    while carry or stack1 or stack2:
      if stack1:
        carry += stack1.pop().val
      if stack2:
        carry += stack2.pop().val
      node = ListNode(carry % 10)
      node.next = head
      head = node
      carry //= 10

    return head"
"446","class Solution:
  def numberOfArithmeticSlices(self, nums: list[int]) -> int:
    n = len(nums)
    ans = 0
    # dp[i][j] := the number of subsequences end in nums[j] nums[i]
    dp = [[0] * n for _ in range(n)]
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    for i in range(n):
      for j in range(i):
        target = nums[j] * 2 - nums[i]
        if target in numToIndices:
          for k in numToIndices[target]:
            if k < j:
              dp[i][j] += dp[j][k] + 1
        ans += dp[i][j]

    return ans"
"447","class Solution:
  def numberOfBoomerangs(self, points: list[list[int]]) -> int:
    ans = 0

    for x1, y1 in points:
      count = collections.Counter()
      for x2, y2 in points:
        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]
        count[(x1 - x2)**2 + (y1 - y2)**2] += 1

    return ans"
"448","class Solution:
  def findDisappearedNumbers(self, nums: list[int]) -> list[int]:
    for num in nums:
      index = abs(num) - 1
      nums[index] = -abs(nums[index])

    return [i + 1 for i, num in enumerate(nums) if num > 0]"
"449","class Codec:
  def serialize(self, root: TreeNode | None) -> str:
    """"""Encodes a tree to a single string.""""""
    if not root:
      return ''
    chars = []
    self._serialize(root, chars)
    return ''.join(chars)

  def deserialize(self, data: str) -> TreeNode | None:
    """"""Decodes your encoded data to tree.""""""
    if not data:
      return None
    q = collections.deque(int(val) for val in data.split())
    return self._deserialize(-math.inf, math.inf, q)

  def _serialize(self, root: TreeNode | None, chars: list[str]) -> None:
    if not root:
      return
    chars.append(str(root.val))
    chars.append(' ')
    self._serialize(root.left, chars)
    self._serialize(root.right, chars)

  def _deserialize(
      self,
      mn: int,
      mx: int,
      q: collections.deque[int]
  ) -> TreeNode | None:
    if not q:
      return None

    val = q[0]
    if val < mn or val > mx:
      return None

    q.popleft()
    return TreeNode(val,
                    self._deserialize(mn, val, q),
                    self._deserialize(val, mx, q))"
"45","class Solution:
  def jump(self, nums: list[int]) -> int:
    ans = 0
    end = 0
    farthest = 0

    # Start an implicit BFS.
    for i in range(len(nums) - 1):
      farthest = max(farthest, i + nums[i])
      if farthest >= len(nums) - 1:
        ans += 1
        break
      if i == end:      # Visited all the items on the current level.
        ans += 1        # Increment the level.
        end = farthest  # Make the queue size for the next level.

    return ans"
"450","class Solution:
  def deleteNode(self, root: TreeNode | None, key: int) -> TreeNode | None:
    if not root:
      return None
    if root.val == key:
      if not root.left:
        return root.right
      if not root.right:
        return root.left
      minNode = self._getMin(root.right)
      root.right = self.deleteNode(root.right, minNode.val)
      minNode.left = root.left
      minNode.right = root.right
      root = minNode
    elif root.val < key:
      root.right = self.deleteNode(root.right, key)
    else:  # root.val > key
      root.left = self.deleteNode(root.left, key)
    return root

  def _getMin(self, node: TreeNode | None) -> TreeNode | None:
    while node.left:
      node = node.left
    return node"
"451","class Solution:
  def frequencySort(self, s: str) -> str:
    ans = []
    buckets = [[] for _ in range(len(s) + 1)]

    for c, freq in collections.Counter(s).items():
      buckets[freq].append(c)

    for freq in reversed(range(len(buckets))):
      for c in buckets[freq]:
        ans.append(c * freq)

    return ''.join(ans)"
"452","class Solution:
  def findMinArrowShots(self, points: list[list[int]]) -> int:
    ans = 0
    arrowX = -math.inf

    for point in sorted(points, key=lambda x: x[1]):
      if point[0] > arrowX:
        ans += 1
        arrowX = point[1]

    return ans"
"453","class Solution:
  def minMoves(self, nums: list[int]) -> int:
    mn = min(nums)
    return sum(num - mn for num in nums)"
"454","class Solution:
  def fourSumCount(self, nums1: list[int], nums2: list[int],
                   nums3: list[int], nums4: list[int]) -> int:
    count = collections.Counter(a + b for a in nums1 for b in nums2)
    return sum(count[-c - d] for c in nums3 for d in nums4)"
"455","class Solution:
  def findContentChildren(self, g: list[int], s: list[int]) -> int:
    g.sort()
    s.sort()

    i = 0
    for cookie in s:
      if i < len(g) and g[i] <= cookie:
        i += 1

    return i"
"456","class Solution:
  def find132pattern(self, nums: list[int]) -> bool:
    stack = []  # a decreasing stack
    ak = -math.inf  # Find a seq, where ai < ak < aj.

    for num in reversed(nums):
      # If ai < ak, done because ai must < aj.
      if num < ak:
        return True
      while stack and stack[-1] < num:
        ak = stack[-1]
        stack.pop()
      stack.append(num)  # `nums[i]` is a candidate of aj.

    return False"
"457","class Solution:
  def circularArrayLoop(self, nums: list[int]) -> bool:
    def advance(i: int) -> int:
      return (i + nums[i]) % len(nums)

    if len(nums) < 2:
      return False

    for i, num in enumerate(nums):
      if num == 0:
        continue

      slow = i
      fast = advance(slow)
      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:
        if slow == fast:
          if slow == advance(slow):
            break
          return True
        slow = advance(slow)
        fast = advance(advance(fast))

      slow = i
      sign = num
      while sign * nums[slow] > 0:
        next = advance(slow)
        nums[slow] = 0
        slow = next

    return False"
"458","class Solution:
  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
    base = minutesToTest // minutesToDie + 1
    ans = 0
    x = 1
    while x < buckets:
      ans += 1
      x *= base
    return ans"
"459","class Solution:
  def repeatedSubstringPattern(self, s: str) -> bool:
    return s in (s + s)[1:-1]"
"46","class Solution:
  def permute(self, nums: list[int]) -> list[list[int]]:
    ans = []
    used = [False] * len(nums)

    def dfs(path: list[int]) -> None:
      if len(path) == len(nums):
        ans.append(path.copy())
        return

      for i, num in enumerate(nums):
        if used[i]:
          continue
        used[i] = True
        path.append(num)
        dfs(path)
        path.pop()
        used[i] = False

    dfs([])
    return ans"
"460","struct Node {
  int key;
  int value;
  int freq;
  list<int>::const_iterator it;
};

class LFUCache {
 public:
  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}

  int get(int key) {
    const auto it = keyToNode.find(key);
    if (it == keyToNode.cend())
      return -1;

    Node& node = it->second;
    touch(node);
    return node.value;
  }

  void put(int key, int value) {
    if (capacity == 0)
      return;
    if (const auto it = keyToNode.find(key); it != keyToNode.cend()) {
      Node& node = it->second;
      node.value = value;
      touch(node);
      return;
    }

    if (keyToNode.size() == capacity) {
      // Evict an LRU key from `minFreq` list.
      const int keyToEvict = freqToList[minFreq].back();
      freqToList[minFreq].pop_back();
      keyToNode.erase(keyToEvict);
    }

    minFreq = 1;
    freqToList[1].push_front(key);
    keyToNode[key] = {key, value, 1, freqToList[1].cbegin()};
  }

 private:
  int capacity;
  int minFreq;
  unordered_map<int, Node> keyToNode;
  unordered_map<int, list<int>> freqToList;

  void touch(Node& node) {
    // Update the node's frequency.
    const int prevFreq = node.freq;
    const int newFreq = ++node.freq;

    // Remove the iterator from `prevFreq`'s list
    freqToList[prevFreq].erase(node.it);
    if (freqToList[prevFreq].empty()) {
      freqToList.erase(prevFreq);
      // Update `minFreq` if needed.
      if (prevFreq == minFreq)
        ++minFreq;
    }

    // Insert the key to the front of `newFreq`'s list.
    freqToList[newFreq].push_front(node.key);
    node.it = freqToList[newFreq].cbegin();
  }
};"
"461","class Solution:
  def hammingDistance(self, x: int, y: int) -> int:
    ans = 0

    while x > 0 or y > 0:
      ans += (x & 1) ^ (y & 1)
      x >>= 1
      y >>= 1

    return ans"
"462","import statistics


class Solution:
  def minMoves2(self, nums: list[int]) -> int:
    median = int(statistics.median(nums))
    return sum(abs(num - median) for num in nums)"
"463","class Solution:
  def islandPerimeter(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    islands = 0
    neighbors = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          islands += 1
          if i + 1 < m and grid[i + 1][j] == 1:
            neighbors += 1
          if j + 1 < n and grid[i][j + 1] == 1:
            neighbors += 1

    return islands * 4 - neighbors * 2"
"464","class Solution:
  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
    if desiredTotal <= 0:
      return True

    totalSum = maxChoosableInteger * (maxChoosableInteger + 1) // 2
    if totalSum < desiredTotal:
      return False

    @functools.lru_cache(None)
    def dp(total: int, used: int) -> bool:
      """"""
      Returns true if the first player can we, where `used` represents the use
      numbers.
      """"""
      if total <= 0:
        return False
      return any((used >> i & 1) == 0
                 and not dp(total - i, used | 1 << i)
                 for i in range(1, maxChoosableInteger + 1))

    return dp(desiredTotal, 0)"
"465","class Solution:
  def minTransfers(self, transactions: list[list[int]]) -> int:
    balance = [0] * 21

    for u, v, amount in transactions:
      balance[u] -= amount
      balance[v] += amount

    debts = [b for b in balance if b]

    def dfs(s: int) -> int:
      while s < len(debts) and not debts[s]:
        s += 1
      if s == len(debts):
        return 0

      ans = math.inf

      for i in range(s + 1, len(debts)):
        if debts[i] * debts[s] < 0:
          debts[i] += debts[s]  # `debts[s]` is settled.
          ans = min(ans, 1 + dfs(s + 1))
          debts[i] -= debts[s]  # Backtrack.

      return ans

    return dfs(0)"
"466","from dataclasses import dataclass


@dataclass
class Record:
  count: int
  nextIndex: int


class Solution:
  def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
    # records[i].count := the number of times that s2 starting from index i has
    # been fully matched with s1
    # records[i].nextIndex := the next index in s2 to be matched after
    # completing a full match starting from index i
    records = []

    for nextIndex in range(len(s2)):
      count = 0
      for c in s1:
        if s2[nextIndex] == c:
          nextIndex += 1
          if nextIndex == len(s2):  # There's a match.
            count += 1
            nextIndex = 0
      records.append(Record(count, nextIndex))

    matches = 0  # the number of matches between `s1` x n1 and `s2`
    i = 0  # the index in `s2` to start matching

    for _ in range(n1):
      matches += records[i].count
      i = records[i].nextIndex

    return matches // n2"
"467","class Solution {
 public:
  int findSubstringInWraproundString(string p) {
    int maxLength = 1;
    // count[i] := the number of substrings ending in ('a' + i)
    vector<int> count(26);

    for (int i = 0; i < p.length(); ++i) {
      if (i > 0 && (p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25))
        ++maxLength;
      else
        maxLength = 1;
      const int index = p[i] - 'a';
      count[index] = max(count[index], maxLength);
    }

    return accumulate(count.begin(), count.end(), 0);
  }
};"
"468","class Solution {
  public String validIPAddress(String IP) {
    if (IP.chars().filter(c -> c == '.').count() == 3) {
      for (final String digit : IP.split(""\\."", -1))
        if (!isIPv4(digit))
          return ""Neither"";
      return ""IPv4"";
    }

    if (IP.chars().filter(c -> c == ':').count() == 7) {
      for (final String digit : IP.split(""\\:"", -1))
        if (!isIPv6(digit))
          return ""Neither"";
      return ""IPv6"";
    }

    return ""Neither"";
  }

  private static final String validIPv6Chars = ""0123456789abcdefABCDEF"";

  private boolean isIPv4(final String digit) {
    if (digit.isEmpty() || digit.length() > 3)
      return false;
    if (digit.length() > 1 && digit.charAt(0) == '0')
      return false;

    for (final char c : digit.toCharArray())
      if (c < '0' || c > '9')
        return false;

    final int num = Integer.parseInt(digit);
    return 0 <= num && num <= 255;
  }

  private boolean isIPv6(final String digit) {
    if (digit.isEmpty() || digit.length() > 4)
      return false;

    for (final char c : digit.toCharArray())
      if (!validIPv6Chars.contains("""" + c))
        return false;

    return true;
  }
}"
"469","class Solution:
  def isConvex(self, points: list[list[int]]) -> bool:
    def getCross(p: list[int], q: list[int], r: list[int]):
      """"""Returns pq x qr.""""""
      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])

    sign = 0
    for i in range(len(points)):
      cross = getCross(points[i - 2], points[i - 1], points[i])
      if cross == 0:  # p, q, r are collinear.
        continue
      if sign == 0:  # Find the first cross that's not 0.
        sign = cross
      elif cross * sign < 0:
        return False

    return True"
"47","class Solution:
  def permuteUnique(self, nums: list[int]) -> list[list[int]]:
    ans = []
    used = [False] * len(nums)

    def dfs(path: list[int]) -> None:
      if len(path) == len(nums):
        ans.append(path.copy())
        return

      for i, num in enumerate(nums):
        if used[i]:
          continue
        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
          continue
        used[i] = True
        path.append(num)
        dfs(path)
        path.pop()
        used[i] = False

    nums.sort()
    dfs([])
    return ans"
"470","/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */

class Solution extends SolBase {
  public int rand10() {
    int num = 40;

    while (num >= 40)
      num = (rand7() - 1) * 7 + rand7() - 1;

    return num % 10 + 1;
  }
}"
"471","class Solution {
  public String encode(String s) {
    final int n = s.length();
    // dp[i][j] := shortest encoded String of s[i..j]
    String[][] dp = new String[n][n];

    for (int d = 0; d < n; ++d) {
      for (int i = 0; i + d < n; ++i) {
        final int j = i + d;
        final String curr = s.substring(i, j + 1);
        dp[i][j] = curr;

        if (dp[i][j].length() < 5)
          continue;

        // Try all the possible partitions.
        for (int k = i; k < j; ++k)
          if (dp[i][k].length() + dp[k + 1][j].length() < dp[i][j].length())
            dp[i][j] = dp[i][k] + dp[k + 1][j];

        // Try to compress the string.
        // e.g. s = aabaabaab -> 3[aab]
        for (int k = i; k <= j; ++k) {
          final String pattern = s.substring(i, k + 1);
          if (curr.length() % pattern.length() == 0 && curr.replaceAll(pattern, """").isEmpty()) {
            final String candidate =
                String.valueOf(curr.length() / pattern.length()) + ""["" + dp[i][k] + ""]"";
            if (candidate.length() < dp[i][j].length())
              dp[i][j] = candidate;
          }
        }
      }
    }

    return dp[0][n - 1];
  }
}"
"472","class Solution:
  def findAllConcatenatedWordsInADict(self, words: list[str]) -> list[str]:
    wordSet = set(words)

    @functools.lru_cache(None)
    def isConcat(word: str) -> bool:
      for i in range(1, len(word)):
        prefix = word[:i]
        suffix = word[i:]
        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):
          return True

      return False

    return [word for word in words if isConcat(word)]"
"473","class Solution:
  def makesquare(self, matchsticks: list[int]) -> bool:
    if len(matchsticks) < 4:
      return False

    perimeter = sum(matchsticks)
    if perimeter % 4 != 0:
      return False

    A = sorted(matchsticks)[::-1]

    def dfs(selected: int, edges: list[int]) -> bool:
      if selected == len(A):
        return all(edge == edges[0] for edge in edges)

      for i, edge in enumerate(edges):
        if A[selected] > edge:
          continue
        edges[i] -= A[selected]
        if dfs(selected + 1, edges):
          return True
        edges[i] += A[selected]

      return False

    return dfs(0, [perimeter // 4] * 4)"
"474","class Solution:
  def findMaxForm(self, strs: list[str], m: int, n: int) -> int:
    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are
    # available
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for s in strs:
      zeros = s.count('0')
      ones = len(s) - zeros
      for i in range(m, zeros - 1, -1):
        for j in range(n, ones - 1, -1):
          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)

    return dp[m][n]"
"475","class Solution {
  public int findRadius(int[] houses, int[] heaters) {
    Arrays.sort(houses);
    Arrays.sort(heaters);

    int ans = 0;
    int i = 0; // heaters' index (currently used)

    for (final int house : houses) {
      while (i + 1 < heaters.length && house - heaters[i] > heaters[i + 1] - house)
        ++i; // The next heater is better.
      ans = Math.max(ans, Math.abs(heaters[i] - house));
    }

    return ans;
  }
}"
"476","class Solution {
 public:
  int findComplement(long num) {
    for (long i = 1; i <= num; i <<= 1)
      num ^= i;
    return num;
  }
};"
"477","class Solution:
  def totalHammingDistance(self, nums: list[int]) -> int:
    kMaxBit = 30
    ans = 0

    for i in range(kMaxBit):
      ones = sum(num & (1 << i) > 0 for num in nums)
      zeros = len(nums) - ones
      ans += ones * zeros

    return ans"
"478","class Solution:
  def __init__(self, radius: float, x_center: float, y_center: float):
    self.radius = radius
    self.x_center = x_center
    self.y_center = y_center

  def randPoint(self) -> list[float]:
    length = math.sqrt(random.uniform(0, 1)) * self.radius
    degree = random.uniform(0, 1) * 2 * math.pi
    x = self.x_center + length * math.cos(degree)
    y = self.y_center + length * math.sin(degree)
    return [x, y]"
"479","class Solution:
  def largestPalindrome(self, n: int) -> int:
    if n == 1:
      return 9

    kMod = 1337
    upper = pow(10, n) - 1
    lower = pow(10, n - 1) - 1

    for i in range(upper, lower, -1):
      cand = int(str(i) + str(i)[::-1])
      j = upper
      while j * j >= cand:
        if cand % j == 0:
          return cand % kMod
        j -= 1"
"48","class Solution:
  def rotate(self, matrix: list[list[int]]) -> None:
    for mn in range(len(matrix) // 2):
      mx = len(matrix) - mn - 1
      for i in range(mn, mx):
        offset = i - mn
        top = matrix[mn][i]
        matrix[mn][i] = matrix[mx - offset][mn]
        matrix[mx - offset][mn] = matrix[mx][mx - offset]
        matrix[mx][mx - offset] = matrix[i][mx]
        matrix[i][mx] = top"
"480","class Solution {
 public:
  vector<double> medianSlidingWindow(vector<int>& nums, int k) {
    vector<double> ans;
    multiset<double> window(nums.begin(), nums.begin() + k);
    auto it = next(window.begin(), (k - 1) / 2);

    for (int i = k;; ++i) {
      const double median = k % 2 == 0 ? (*it + *next(it)) / 2.0 : *it;
      ans.push_back(median);
      if (i == nums.size())
        break;
      window.insert(nums[i]);
      if (nums[i] < *it)
        --it;
      if (nums[i - k] <= *it)
        ++it;
      window.erase(window.lower_bound(nums[i - k]));
    }

    return ans;
  }
};"
"481","class Solution {
 public:
  int magicalString(int n) {
    string s = "" 122"";

    for (int i = 3; i <= n; ++i)
      if (i % 2 == 1)
        s.append(s[i] - '0', '1');
      else
        s.append(s[i] - '0', '2');

    return count(s.begin(), s.begin() + n + 1, '1');
  }
};"
"482","class Solution:
  def licenseKeyFormatting(self, s: str, k: int) -> str:
    ans = []
    length = 0

    for i in reversed(range(len(s))):
      if s[i] == '-':
        continue
      if length > 0 and length % k == 0:
        ans += '-'
      ans += s[i].upper()
      length += 1

    return ''.join(reversed(ans))"
"483","class Solution:
  def smallestGoodBase(self, n: str) -> str:
    n = int(n)

    for m in range(int(math.log(n, 2)), 1, -1):
      k = int(n**m**-1)
      if (k**(m + 1) - 1) // (k - 1) == n:
        return str(k)

    return str(n - 1)"
"484","class Solution:
  def findPermutation(self, s: str) -> list[int]:
    ans = [i for i in range(1, len(s) + 2)]

    # For each D* group (s[i..j]), reverse ans[i..j + 1].
    i = -1
    j = -1

    def getNextIndex(c: str, start: int) -> int:
      for i in range(start, len(s)):
        if s[i] == c:
          return i
      return len(s)

    while True:
      i = getNextIndex('D', j + 1)
      if i == len(s):
        break
      j = getNextIndex('I', i + 1)
      ans[i:j + 1] = ans[i:j + 1][::-1]

    return ans"
"485","class Solution:
  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:
    ans = 0
    summ = 0

    for num in nums:
      if num == 0:
        summ = 0
      else:
        summ += num
        ans = max(ans, summ)

    return ans"
"486","class Solution {
 public:
  bool PredictTheWinner(vector<int>& nums) {
    const int n = nums.size();
    // dp[i][j] := the maximum number you can get more than your opponent in
    // nums[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = nums[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] >= 0;
  }
};"
"487","class Solution:
  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:
    ans = 0
    zeros = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        zeros += 1
      while zeros == 2:
        if nums[l] == 0:
          zeros -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"488","class Solution:
  def findMinStep(self, board: str, hand: str) -> int:
    def deDup(board):
      start = 0  # the start index of a color sequenece
      for i, c in enumerate(board):
        if c != board[start]:
          if i - start >= 3:
            return deDup(board[:start] + board[i:])
          start = i  # Meet a new sequence.
      return board

    @functools.lru_cache(None)
    def dfs(board: str, hand: str):
      board = deDup(board)
      if board == '#':
        return 0

      boardSet = set(board)
      # hand that is in board
      hand = ''.join(h for h in hand if h in boardSet)
      if not hand:  # infeasible
        return math.inf

      ans = math.inf

      for i in range(len(board)):
        for j, h in enumerate(hand):
          # Place hs[j] in board[i].
          newHand = hand[:j] + hand[j + 1:]
          newBoard = board[:i] + h + board[i:]
          ans = min(ans, 1 + dfs(newBoard, newHand))

      return ans

    ans = dfs(board + '#', hand)
    return -1 if ans == math.inf else ans"
"489","/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * interface Robot {
 *   // Returns true if the cell in front is open and robot moves into the cell.
 *   // Returns false if the cell in front is blocked and robot stays in the current cell.
 *   public boolean move();
 *
 *   // Robot will stay in the same cell after calling turnLeft/turnRight.
 *   // Each turn will be 90 degrees.
 *   public void turnLeft();
 *   public void turnRight();
 *
 *   // Clean the current cell.
 *   public void clean();
 * }
 */

class Solution {
  public void cleanRoom(Robot robot) {
    dfs(robot, 0, 0, 0, new HashSet<>());
  }

  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  private void dfs(Robot robot, int d, int i, int j, Set<Pair<Integer, Integer>> seen) {
    seen.add(new Pair<>(i, j));
    robot.clean();

    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <
    // The order is important since the idea is always turning right.
    for (int k = 0; k < 4; ++k) {
      final int newD = (d + k) % 4;
      final int x = i + dirs[newD][0];
      final int y = j + dirs[newD][1];
      if (!seen.contains(new Pair<>(x, y)) && robot.move()) {
        dfs(robot, newD, x, y, seen);
        // Go back to the previous cell.
        robot.turnRight();
        robot.turnRight();
        robot.move();
        // Go back to the original direction.
        robot.turnRight();
        robot.turnRight();
      }
      robot.turnRight(); // Always turn the robot clockwise.
    }
  }
}"
"49","class Solution:
  def groupAnagrams(self, strs: list[str]) -> list[list[str]]:
    dict = collections.defaultdict(list)

    for str in strs:
      key = ''.join(sorted(str))
      dict[key].append(str)

    return dict.values()"
"490","class Solution:
  def hasPath(
      self,
      maze: list[list[int]],
      start: list[int],
      destination: list[int],
  ) -> bool:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(maze)
    n = len(maze[0])

    seen = set()

    def isValid(x: int, y: int) -> bool:
      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0

    def dfs(i: int, j: int) -> bool:
      if [i, j] == destination:
        return True
      if (i, j) in seen:
        return False

      seen.add((i, j))

      for dx, dy in dirs:
        x = i
        y = j
        while isValid(x + dx, y + dy):
          x += dx
          y += dy
        if dfs(x, y):
          return True

      return False

    return dfs(start[0], start[1])"
"491","class Solution:
  def findSubsequences(self, nums: list[int]) -> list[list[int]]:
    ans = []

    def dfs(s: int, path: list[int]) -> None:
      if len(path) > 1:
        ans.append(path)

      used = set()

      for i in range(s, len(nums)):
        if nums[i] in used:
          continue
        if not path or nums[i] >= path[-1]:
          used.add(nums[i])
          dfs(i + 1, path + [nums[i]])

    dfs(0, [])
    return ans"
"492","class Solution {
 public:
  vector<int> constructRectangle(int area) {
    int width = sqrt(area);

    while (area % width)
      --width;

    return {area / width, width};
  }
};"
"493","class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void add(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int reversePairs(vector<int>& nums) {
    int ans = 0;
    const unordered_map<long, int> ranks = getRanks(nums);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const long num = nums[i];
      ans += tree.get(ranks.at(num) - 1);
      tree.add(ranks.at(num * 2), 1);
    }

    return ans;
  }

 private:
  unordered_map<long, int> getRanks(const vector<int>& nums) {
    unordered_map<long, int> ranks;
    set<long> sorted(nums.begin(), nums.end());
    for (const long num : nums)
      sorted.insert(num * 2);
    int rank = 0;
    for (const long num : sorted)
      ranks[num] = ++rank;
    return ranks;
  }
};"
"494","class Solution:
  def findTargetSumWays(self, nums: list[int], target: int) -> int:
    summ = sum(nums)
    if summ < abs(target) or (summ + target) % 2 == 1:
      return 0

    def knapsack(target: int) -> int:
      # dp[i] := the number of ways to sum to i by nums so far
      dp = [1] + [0] * summ

      for num in nums:
        for j in range(summ, num - 1, -1):
          dp[j] += dp[j - num]

      return dp[target]

    return knapsack((summ + target) // 2)"
"495","class Solution:
  def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:
    if duration == 0:
      return 0

    ans = 0

    for i in range(0, len(timeSeries) - 1):
      ans += min(timeSeries[i + 1] - timeSeries[i], duration)

    return ans + duration"
"496","class Solution:
  def nextGreaterElement(self, nums1: list[int], nums2: list[int]) -> list[int]:
    numToNextGreater = {}
    stack = []  # a decreasing stack

    for num in nums2:
      while stack and stack[-1] < num:
        numToNextGreater[stack.pop()] = num
      stack.append(num)

    return [numToNextGreater.get(num, -1) for num in nums1]"
"497","class Solution:
  def __init__(self, rects: list[list[int]]):
    self.rects = rects
    self.areas = list(itertools.accumulate(
        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))

  def pick(self) -> list[int]:
    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))
    x1, y1, x2, y2 = self.rects[index]
    return [random.randint(x1, x2), random.randint(y1, y2)]"
"498","class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans(m * n);
    int d = 1;  // left-bottom -> right-top
    int row = 0;
    int col = 0;

    for (int i = 0; i < m * n; ++i) {
      ans[i] = matrix[row][col];
      row -= d;
      col += d;
      // out-of-bounds
      if (row == m)
        row = m - 1, col += 2, d = -d;
      if (col == n)
        col = n - 1, row += 2, d = -d;
      if (row < 0)
        row = 0, d = -d;
      if (col < 0)
        col = 0, d = -d;
    }

    return ans;
  }
};"
"499","class Solution:
  def findShortestWay(
      self,
      maze: list[list[int]],
      ball: list[int],
      hole: list[int],
  ) -> str:
    ans = 'impossible'
    minSteps = math.inf

    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):
      nonlocal ans
      nonlocal minSteps
      if steps >= minSteps:
        return

      if dx != 0 or dy != 0:  # Both are zeros for the initial ball position.
        while (0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and
               maze[i + dx][j + dy] != 1):
          i += dx
          j += dy
          steps += 1
          if i == hole[0] and j == hole[1] and steps < minSteps:
            minSteps = steps
            ans = path

      if maze[i][j] == 0 or steps + 2 < maze[i][j]:
        maze[i][j] = steps + 2  # +2 because maze[i][j] == 0 || 1.
        if dx == 0:
          dfs(i, j, 1, 0, steps, path + 'd')
        if dy == 0:
          dfs(i, j, 0, -1, steps, path + 'l')
        if dy == 0:
          dfs(i, j, 0, 1, steps, path + 'r')
        if dx == 0:
          dfs(i, j, -1, 0, steps, path + 'u')

    dfs(ball[0], ball[1], 0, 0, 0, '')
    return ans"
"5","class Solution:
  def longestPalindrome(self, s: str) -> str:
    t = '#'.join('@' + s + '$')
    p = self._manacher(t)
    maxPalindromeLength, bestCenter = max((extend, i)
                                          for i, extend in enumerate(p))
    l = (bestCenter - maxPalindromeLength) // 2
    r = (bestCenter + maxPalindromeLength) // 2
    return s[l:r]

  def _manacher(self, t: str) -> list[int]:
    """"""
    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome
    centered at `t[i]`, where `t` is a string with delimiters and sentinels.
    """"""
    p = [0] * len(t)
    center = 0
    for i in range(1, len(t) - 1):
      rightBoundary = center + p[center]
      mirrorIndex = center - (i - center)
      if rightBoundary > i:
        p[i] = min(rightBoundary - i, p[mirrorIndex])
      # Try to expand the palindrome centered at i.
      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
        p[i] += 1
      # If a palindrome centered at i expands past `rightBoundary`, adjust
      # the center based on the expanded palindrome.
      if i + p[i] > rightBoundary:
        center = i
    return p"
"50","class Solution:
  def myPow(self, x: float, n: int) -> float:
    if n == 0:
      return 1
    if n < 0:
      return 1 / self.myPow(x, -n)
    if n % 2 == 1:
      return x * self.myPow(x, n - 1)
    return self.myPow(x * x, n // 2)"
"500","class Solution:
  def findWords(self, words: list[str]) -> list[str]:
    ans = []
    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]

    for word in words:
      lowerWord = set(word.lower())
      if any(lowerWord <= row for row in rows):
        ans.append(word)

    return ans"
"501","class Solution:
  def findMode(self, root: TreeNode | None) -> list[int]:
    self.ans = []
    self.pred = None
    self.count = 0
    self.maxCount = 0

    def updateCount(root: TreeNode | None) -> None:
      if self.pred and self.pred.val == root.val:
        self.count += 1
      else:
        self.count = 1

      if self.count > self.maxCount:
        self.maxCount = self.count
        self.ans = [root.val]
      elif self.count == self.maxCount:
        self.ans.append(root.val)

      self.pred = root

    def inorder(root: TreeNode | None) -> None:
      if not root:
        return

      inorder(root.left)
      updateCount(root)
      inorder(root.right)

    inorder(root)
    return self.ans"
"502","class Solution {
  public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    record T(int pro, int cap) {}
    Queue<T> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a.cap, b.cap));
    Queue<T> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b.pro, a.pro));

    for (int i = 0; i < capital.length; ++i)
      minHeap.offer(new T(profits[i], capital[i]));

    while (k-- > 0) {
      while (!minHeap.isEmpty() && minHeap.peek().cap <= w)
        maxHeap.offer(minHeap.poll());
      if (maxHeap.isEmpty())
        break;
      w += maxHeap.poll().pro;
    }

    return w;
  }
}"
"503","class Solution:
  def nextGreaterElements(self, nums: list[int]) -> list[int]:
    n = len(nums)
    ans = [-1] * n
    stack = []  # a decreasing stack storing indices

    for i in range(n * 2):
      num = nums[i % n]
      while stack and nums[stack[-1]] < num:
        ans[stack.pop()] = num
      if i < n:
        stack.append(i)

    return ans"
"504","class Solution {
 public:
  string convertToBase7(int num) {
    if (num < 0)
      return ""-"" + convertToBase7(-num);
    if (num < 7)
      return to_string(num);
    return convertToBase7(num / 7) + to_string(num % 7);
  }
};"
"505","class Solution {
 public:
  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,
                       vector<int>& destination) {
    vector<vector<int>> dist(maze.size(), vector<int>(maze[0].size(), INT_MAX));
    dist[start[0]][start[1]] = 0;

    dfs(maze, dist, start[0], start[1], destination);

    return dist[destination[0]][destination[1]] == INT_MAX
               ? -1
               : dist[destination[0]][destination[1]];
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  void dfs(vector<vector<int>>& maze, vector<vector<int>>& dist, int i, int j,
           const vector<int>& destination) {
    if (i == destination[0] && j == destination[1])
      return;

    for (const auto& [dx, dy] : dirs) {
      int x = i;
      int y = j;
      int step = dist[i][j];
      while (isValid(maze, x + dx, y + dy)) {
        x += dx;
        y += dy;
        ++step;
      }
      if (step < dist[x][y]) {
        dist[x][y] = step;
        dfs(maze, dist, x, y, destination);
      }
    }
  }

  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return x >= 0 && x < maze.size() && y >= 0 && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};"
"506","class Solution {
  public String[] findRelativeRanks(int[] nums) {
    final int n = nums.length;
    String[] ans = new String[n];
    List<Integer> indices = new ArrayList<>();

    for (int i = 0; i < n; ++i)
      indices.add(i);

    Collections.sort(indices, (a, b) -> Integer.compare(nums[b], nums[a]));

    for (int i = 0; i < n; ++i)
      if (i == 0)
        ans[indices.get(0)] = ""Gold Medal"";
      else if (i == 1)
        ans[indices.get(1)] = ""Silver Medal"";
      else if (i == 2)
        ans[indices.get(2)] = ""Bronze Medal"";
      else
        ans[indices.get(i)] = String.valueOf(i + 1);

    return ans;
  }
}"
"507","class Solution:
  def checkPerfectNumber(self, num: int) -> bool:
    return num in {6, 28, 496, 8128, 33550336}"
"508","class Solution:
  def findFrequentTreeSum(self, root: TreeNode | None) -> list[int]:
    if not root:
      return []

    count = collections.Counter()

    def dfs(root: TreeNode | None) -> int:
      if not root:
        return 0

      summ = root.val + dfs(root.left) + dfs(root.right)
      count[summ] += 1
      return summ

    dfs(root)
    maxFreq = max(count.values())
    return [summ for summ in count if count[summ] == maxFreq]"
"509","class Solution:
  def fib(self, n: int) -> int:
    if n < 2:
      return n

    dp = [0, 0, 1]

    for i in range(2, n + 1):
      dp[0] = dp[1]
      dp[1] = dp[2]
      dp[2] = dp[0] + dp[1]

    return dp[2]"
"51","class Solution:
  def solveNQueens(self, n: int) -> list[list[str]]:
    ans = []
    cols = [False] * n
    diag1 = [False] * (2 * n - 1)
    diag2 = [False] * (2 * n - 1)

    def dfs(i: int, board: list[int]) -> None:
      if i == n:
        ans.append(board)
        return

      for j in range(n):
        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:
          continue
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True
        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False

    dfs(0, [])
    return ans"
"510","class Solution {
  public Node inorderSuccessor(Node node) {
    // The successor is somewhere upper in the tree.
    if (node.right == null) {
      while (node.parent != null && node.parent.left != node)
        node = node.parent;
      return node.parent;
    }

    // The successor is somewhere lower in the right subtree.
    node = node.right;
    while (node.left != null)
      node = node.left;
    return node;
  }
}"
"511","SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY 1;"
"512","SELECT DISTINCT
  player_id,
  FIRST_VALUE(device_id) OVER(
    PARTITION by player_id
    ORDER BY event_date
  ) AS device_id
FROM Activity;"
"513","class Solution:
  def findBottomLeftValue(self, root: TreeNode | None) -> int:
    q = collections.deque([root])

    while q:
      root = q.popleft()
      if root.right:
        q.append(root.right)
      if root.left:
        q.append(root.left)

    return root.val"
"514","class Solution:
  def findRotateSteps(self, ring: str, key: str) -> int:
    @functools.lru_cache(None)
    def dfs(ring: str, index: int) -> int:
      """"""Returns the number of rotates of ring to match key[index..n).""""""
      if index == len(key):
        return 0

      ans = math.inf

      # For each ring[i] == key[index], we rotate the ring to match the ring[i]
      # with the key[index], then recursively match the newRing with the
      # key[index + 1..n).
      for i, r in enumerate(ring):
        if r == key[index]:
          minRotates = min(i, len(ring) - i)
          newRing = ring[i:] + ring[:i]
          remainingRotates = dfs(newRing, index + 1)
          ans = min(ans, minRotates + remainingRotates)

      return ans

    return dfs(ring, 0) + len(key)"
"515","class Solution:
  def largestValues(self, root: TreeNode | None) -> list[int]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      mx = -math.inf
      for _ in range(len(q)):
        root = q.popleft()
        mx = max(mx, root.val)
        if root.left:
          q.append(root.left)
        if root.right:
          q.append(root.right)
      ans.append(mx)

    return ans"
"516","class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]"
"517","class Solution:
  def findMinMoves(self, machines: list[int]) -> int:
    dresses = sum(machines)

    if dresses % len(machines) != 0:
      return -1

    ans = 0
    average = dresses // len(machines)
    inout = 0

    for dress in machines:
      inout += dress - average
      ans = max(ans, abs(inout), dress - average)

    return ans"
"518","class Solution:
  def change(self, amount: int, coins: list[int]) -> int:
    dp = [1] + [0] * amount

    for coin in coins:
      for i in range(coin, amount + 1):
        dp[i] += dp[i - coin]

    return dp[amount]"
"519","class Solution {
 public:
  Solution(int n_rows, int n_cols)
      : rows(n_rows), cols(n_cols), total(n_rows * n_cols) {}

  vector<int> flip() {
    // All the candidates are used out.
    if (used.size() == total)
      return {};
    int index = rand() % total;
    while (used.contains(index))
      index = ++index % total;
    used.insert(index);
    return {index / cols, index % cols};
  }

  void reset() {
    used = {};
  }

 private:
  unordered_set<int> used;
  int rows;
  int cols;
  int total;
};"
"52","class Solution:
  def totalNQueens(self, n: int) -> int:
    ans = 0
    cols = [False] * n
    diag1 = [False] * (2 * n - 1)
    diag2 = [False] * (2 * n - 1)

    def dfs(i: int) -> None:
      nonlocal ans
      if i == n:
        ans += 1
        return

      for j in range(n):
        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:
          continue
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True
        dfs(i + 1)
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False

    dfs(0)
    return ans"
"520","class Solution:
  def detectCapitalUse(self, word: str) -> bool:
    return word.isupper() or word.islower() or word.istitle()"
"521","class Solution:
  def findLUSlength(self, a: str, b: str) -> int:
    return -1 if a == b else max(len(a), len(b))"
"522","class Solution:
  def findLUSlength(self, strs: list[str]) -> int:
    def isSubsequence(a: str, b: str) -> bool:
      i = 0
      j = 0

      while i < len(a) and j < len(b):
        if a[i] == b[j]:
          i += 1
        j += 1

      return i == len(a)

    seen = set()
    duplicates = set()

    for s in strs:
      if s in seen:
        duplicates.add(s)
      seen.add(s)

    strs.sort(key=lambda x: -len(x))

    for i in range(len(strs)):
      if strs[i] in duplicates:
        continue
      isASubsequence = False
      for j in range(i):
        isASubsequence |= isSubsequence(strs[i], strs[j])
      if not isASubsequence:
        return len(strs[i])

    return -1"
"523","class Solution:
  def checkSubarraySum(self, nums: list[int], k: int) -> bool:
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      if k != 0:
        prefix %= k
      if prefix in prefixToIndex:
        if i - prefixToIndex[prefix] > 1:
          return True
      else:
        # Set a new key if it's absent because the previous index is better.
        prefixToIndex[prefix] = i

    return False"
"524","class Solution:
  def findLongestWord(self, s: str, d: list[str]) -> str:
    ans = ''

    for word in d:
      i = 0
      for c in s:
        if i < len(word) and c == word[i]:
          i += 1
      if i == len(word):
        if len(word) > len(ans) or len(word) == len(ans) and word < ans:
          ans = word

    return ans"
"525","class Solution:
  def findMaxLength(self, nums: list[int]) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += 1 if num else -1
      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))

    return ans"
"526","class Solution {
  public int countArrangement(int n) {
    final String filled = ""x"".repeat(n + 1);
    StringBuilder sb = new StringBuilder(filled);
    Map<String, Integer> mem = new HashMap<>();

    return dfs(n, 1, sb, mem);
  }

  private int dfs(int n, int num, StringBuilder sb, Map<String, Integer> mem) {
    if (num == n + 1)
      return 1;
    final String filled = sb.toString();
    if (mem.containsKey(filled))
      return mem.get(filled);

    int count = 0;

    for (int i = 1; i <= n; ++i)
      if (sb.charAt(i) == 'x' && (num % i == 0 || i % num == 0)) {
        sb.setCharAt(i, 'o');
        count += dfs(n, num + 1, sb, mem);
        sb.setCharAt(i, 'x');
      }

    mem.put(filled, count);
    return count;
  }
}"
"527","from dataclasses import dataclass


@dataclass
class IndexedWord:
  word: str
  index: int


class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.count = 0


class Solution:
  def wordsAbbreviation(self, words: list[str]) -> list[str]:
    n = len(words)
    ans = [''] * n

    def getAbbrev(s: str, prefixIndex: int) -> str:
      n = len(s)
      num = n - (prefixIndex + 1) - 1
      numLength = 1 if num < 10 else (2 if num < 100 else 3)
      abbrevLength = (prefixIndex + 1) + numLength + 1
      if abbrevLength >= n:
        return s
      return s[:prefixIndex + 1] + str(num) + s[-1]

    abbrevToIndexedWords = collections.defaultdict(list)

    for i, word in enumerate(words):
      abbrev = getAbbrev(word, 0)
      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))

    def insertWord(root: TrieNode | None, word: str) -> None:
      node = root
      for c in word:
        node = node.children.setdefault(c, TrieNode())
        node.count += 1

    def firstUniqueIndex(root: TrieNode | None, word: str) -> None:
      node = root
      for i, c in enumerate(word):
        node = node.children[c]
        if node.count == 1:
          return i
      return len(word)

    for indexedWords in abbrevToIndexedWords.values():
      root = TrieNode()
      for iw in indexedWords:
        insertWord(root, iw.word)
      for iw in indexedWords:
        index = firstUniqueIndex(root, iw.word)
        ans[iw.index] = getAbbrev(iw.word, index)

    return ans"
"528","class Solution:
  def __init__(self, w: list[int]):
    self.prefix = list(itertools.accumulate(w))

  def pickIndex(self) -> int:
    target = random.randint(0, self.prefix[-1] - 1)
    return bisect.bisect_right(range(len(self.prefix)), target,
                               key=lambda m: self.prefix[m])"
"529","class Solution:
  def updateBoard(self, board: list[list[str]],
                  click: list[int]) -> list[list[str]]:
    i, j = click
    if board[i][j] == 'M':
      board[i][j] = 'X'
      return board

    dirs = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
            (0, 1), (1, -1), (1, 0), (1, 1))

    def getMinesCount(i: int, j: int) -> int:
      minesCount = 0
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):
          continue
        if board[x][y] == 'M':
          minesCount += 1
      return minesCount

    def dfs(i: int, j: int) -> None:
      if i < 0 or i == len(board) or j < 0 or j == len(board[0]):
        return
      if board[i][j] != 'E':
        return

      minesCount = getMinesCount(i, j)
      board[i][j] = 'B' if minesCount == 0 else str(minesCount)

      if minesCount == 0:
        for dx, dy in dirs:
          dfs(i + dx, j + dy)

    dfs(i, j)
    return board"
"53","class Solution:
  def maxSubArray(self, nums: list[int]) -> int:
    ans = -math.inf
    summ = 0

    for num in nums:
      summ = max(num, summ + num)
      ans = max(ans, summ)

    return ans"
"530","class Solution {
  // Similar to 94. Binary Tree Inorder Traversal
  public int getMinimumDifference(TreeNode root) {
    int ans = Integer.MAX_VALUE;
    int prev = -1;
    Deque<TreeNode> stack = new ArrayDeque<>();

    while (root != null || !stack.isEmpty()) {
      while (root != null) {
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      if (prev >= 0)
        ans = Math.min(ans, root.val - prev);
      prev = root.val;
      root = root.right;
    }

    return ans;
  }
}"
"531","class Solution:
  def findLonelyPixel(self, picture: list[list[str]]) -> int:
    m = len(picture)
    n = len(picture[0])
    ans = 0
    rows = [0] * m  # rows[i] := the number of B's in rows i
    cols = [0] * n  # cols[i] := the number of B's in cols i

    for i in range(m):
      for j in range(n):
        if picture[i][j] == 'B':
          rows[i] += 1
          cols[j] += 1

    for i in range(m):
      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.
        for j in range(n):
          # After meeting a 'B' in this rows, break and search the next row.
          if picture[i][j] == 'B':
            if cols[j] == 1:
              ans += 1
            break

    return ans"
"532","class Solution:
  def findPairs(self, nums: list[int], k: int) -> int:
    ans = 0
    numToIndex = {num: i for i, num in enumerate(nums)}

    for i, num in enumerate(nums):
      target = num + k
      if target in numToIndex and numToIndex[target] != i:
        ans += 1
        del numToIndex[target]

    return ans"
"533","class Solution:
  def findBlackPixel(self, picture: list[list[str]], target: int) -> int:
    m = len(picture)
    n = len(picture[0])
    ans = 0
    rows = [row.count('B') for row in picture]
    cols = [col.count('B') for col in zip(*picture)]
    rowStrings = [''.join(row) for row in picture]
    countRowStrings = collections.Counter(rowStrings)

    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):
      if row == target and countRowStrings[stringRow] == target:
        for j, col in enumerate(cols):
          if picture[i][j] == 'B' and col == target:
            ans += 1

    return ans"
"534","SELECT
  Activity.player_id,
  Activity.event_date,
  SUM(PrevActivity.games_played) AS games_played_so_far
FROM Activity
INNER JOIN Activity AS PrevActivity
  ON (
    Activity.player_id = PrevActivity.player_id
    AND Activity.event_date >= PrevActivity.event_date)
GROUP BY 1, 2
ORDER BY 1, 2;"
"535","class Codec:
  alphabets = string.ascii_letters + '0123456789'
  urlToCode = {}
  codeToUrl = {}

  def encode(self, longUrl: str) -> str:
    while longUrl not in self.urlToCode:
      code = ''.join(random.choice(self.alphabets) for _ in range(6))
      if code not in self.codeToUrl:
        self.codeToUrl[code] = longUrl
        self.urlToCode[longUrl] = code
    return 'http://tinyurl.com/' + self.urlToCode[longUrl]

  def decode(self, shortUrl: str) -> str:
    return self.codeToUrl[shortUrl[-6:]]"
"536","class Solution {
  public TreeNode str2tree(String s) {
    if (s.isEmpty())
      return null;

    Deque<TreeNode> stack = new ArrayDeque<>();

    for (int l = 0, r = 0; r < s.length(); l = ++r)
      if (s.charAt(r) == ')') {
        stack.pop();
      } else if (Character.isDigit(s.charAt(r)) || s.charAt(r) == '-') {
        while (r + 1 < s.length() && Character.isDigit(s.charAt(r + 1)))
          ++r;
        final int val = Integer.parseInt(s.substring(l, r + 1));
        TreeNode node = new TreeNode(val);
        if (!stack.isEmpty()) {
          TreeNode parent = stack.peek();
          if (parent.left != null)
            parent.right = node;
          else
            parent.left = node;
        }
        stack.push(node);
      }

    return stack.peek();
  }
}"
"537","class Solution:
  def complexNumberMultiply(self, a: str, b: str) -> str:
    def getRealAndImag(s: str) -> tuple:
      return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])

    A, B = getRealAndImag(a)
    C, D = getRealAndImag(b)

    return str(A * C - B * D) + '+' + str(A * D + B * C) + 'i'"
"538","class Solution:
  def convertBST(self, root: TreeNode | None) -> TreeNode | None:
    prefix = 0

    def reversedInorder(root: TreeNode | None) -> None:
      nonlocal prefix
      if not root:
        return

      reversedInorder(root.right)
      prefix += root.val
      root.val = prefix
      reversedInorder(root.left)

    reversedInorder(root)
    return root"
"539","class Solution:
  def findMinDifference(self, timePoints: list[str]) -> int:
    ans = 24 * 60
    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])
                   for timePoint in timePoints])

    for a, b in zip(nums, nums[1:]):
      ans = min(ans, b - a)

    return min(ans, 24 * 60 - nums[-1] + nums[0])"
"54","class Solution:
  def spiralOrder(self, matrix: list[list[int]]) -> list[int]:
    if not matrix:
      return []

    m = len(matrix)
    n = len(matrix[0])
    ans = []
    r1 = 0
    c1 = 0
    r2 = m - 1
    c2 = n - 1

    # Repeatedly add matrix[r1..r2][c1..c2] to `ans`.
    while len(ans) < m * n:
      j = c1
      while j <= c2 and len(ans) < m * n:
        ans.append(matrix[r1][j])
        j += 1
      i = r1 + 1
      while i <= r2 - 1 and len(ans) < m * n:
        ans.append(matrix[i][c2])
        i += 1
      j = c2
      while j >= c1 and len(ans) < m * n:
        ans.append(matrix[r2][j])
        j -= 1
      i = r2 - 1
      while i >= r1 + 1 and len(ans) < m * n:
        ans.append(matrix[i][c1])
        i -= 1
      r1 += 1
      c1 += 1
      r2 -= 1
      c2 -= 1

    return ans"
"540","class Solution:
  def singleNonDuplicate(self, nums: list[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if m % 2 == 1:
        m -= 1
      if nums[m] == nums[m + 1]:
        l = m + 2
      else:
        r = m

    return nums[l]"
"541","class Solution:
  def reverseStr(self, s: str, k: int) -> str:
    return s[:k][::-1] + s[k:2 * k] + self.reverseStr(s[2 * k:], k) if s else """""
"542","class Solution:
  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(mat)
    n = len(mat[0])
    q = collections.deque()

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 0:
          q.append((i, j))
        else:
          mat[i][j] = math.inf

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if mat[x][y] <= mat[i][j] + 1:
          continue
        q.append((x, y))
        mat[x][y] = mat[i][j] + 1

    return mat"
"543","class Solution:
  def diameterOfBinaryTree(self, root: TreeNode | None) -> int:
    ans = 0

    def maxDepth(root: TreeNode | None) -> int:
      nonlocal ans
      if not root:
        return 0

      l = maxDepth(root.left)
      r = maxDepth(root.right)
      ans = max(ans, l + r)
      return 1 + max(l, r)

    maxDepth(root)
    return ans"
"544","class Solution:
  def findContestMatch(self, n: int) -> str:
    def generateMatches(matches: list[str]) -> str:
      if len(matches) == 1:
        return matches[0]

      nextMatches = []

      for i in range(len(matches) // 2):
        nextMatches.append(
            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')

      return generateMatches(nextMatches)

    return generateMatches([str(i + 1) for i in range(n)])"
"545","class Solution:
  def boundaryOfBinaryTree(self, root: TreeNode | None) -> list[int]:
    if not root:
      return []

    ans = [root.val]

    def dfs(root: TreeNode | None, lb: bool, rb: bool):
      """"""
      1. root.left is left boundary if root is left boundary.
         root.right if left boundary if root.left is None.
      2. Same applys for right boundary.
      3. If root is left boundary, add it before 2 children - preorder.
         If root is right boundary, add it after 2 children - postorder.
      4. A leaf that is neighter left/right boundary belongs to the bottom.
      """"""
      if not root:
        return
      if lb:
        ans.append(root.val)
      if not lb and not rb and not root.left and not root.right:
        ans.append(root.val)

      dfs(root.left, lb, rb and not root.right)
      dfs(root.right, lb and not root.left, rb)
      if rb:
        ans.append(root.val)

    dfs(root.left, True, False)
    dfs(root.right, False, True)
    return ans"
"546","class Solution:
  def removeBoxes(self, boxes: list[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """"""
      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].
      """"""
      if i > j:
        return 0

      r = j
      sameBoxes = k + 1
      while r > 0 and boxes[r - 1] == boxes[r]:
        r -= 1
        sameBoxes += 1
      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes

      for p in range(i, r):
        if boxes[p] == boxes[r]:
          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))

      return res

    return dp(0, len(boxes) - 1, 0)"
"547","class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findCircleNum(self, isConnected: list[list[int]]) -> int:
    n = len(isConnected)
    uf = UnionFind(n)

    for i in range(n):
      for j in range(i, n):
        if isConnected[i][j] == 1:
          uf.unionByRank(i, j)

    return uf.count"
"548","class Solution {
  public boolean splitArray(int[] nums) {
    final int n = nums.length;
    if (n < 7)
      return false;

    int[] prefix = new int[n];

    for (int i = 0; i < n; ++i)
      prefix[i] = i == 0 ? nums[0] : prefix[i - 1] + nums[i];

    for (int j = 3; j < n - 3; ++j) {
      HashSet<Integer> seen = new HashSet<>();
      for (int i = 1; i < j - 1; ++i)
        if (prefix[i - 1] == prefix[j - 1] - prefix[i])
          seen.add(prefix[i - 1]);
      for (int k = j + 2; k < n - 1; ++k)
        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&
            seen.contains(prefix[k - 1] - prefix[j]))
          return true;
    }

    return false;
  }
}"
"549","class T {
  public int inc; // the length of longest incrementing branch
  public int dec; // the length of longest decrementing branch

  public T(int inc, int dec) {
    this.inc = inc;
    this.dec = dec;
  }
}

class Solution {
  public int longestConsecutive(TreeNode root) {
    longestPath(root);
    return ans;
  }

  private int ans = 0;

  private T longestPath(TreeNode root) {
    if (root == null)
      return new T(0, 0);

    int inc = 1;
    int dec = 1;

    if (root.left != null) {
      T l = longestPath(root.left);
      if (root.val + 1 == root.left.val)
        inc = l.inc + 1;
      else if (root.val - 1 == root.left.val)
        dec = l.dec + 1;
    }

    if (root.right != null) {
      T r = longestPath(root.right);
      if (root.val + 1 == root.right.val)
        inc = Math.max(inc, r.inc + 1);
      else if (root.val - 1 == root.right.val)
        dec = Math.max(dec, r.dec + 1);
    }

    ans = Math.max(ans, inc + dec - 1);
    return new T(inc, dec);
  }
}"
"55","class Solution:
  def canJump(self, nums: list[int]) -> bool:
    i = 0
    reach = 0

    while i < len(nums) and i <= reach:
      reach = max(reach, i + nums[i])
      i += 1

    return i == len(nums)"
"550","WITH
  Players AS (
    SELECT player_id, MIN(event_date) AS first_login
    FROM Activity
    GROUP BY 1
  )
SELECT ROUND(
    COUNT(Players.player_id) / (
      SELECT COUNT(DISTINCT Activity.player_id)
      FROM Activity
    ),
    2
  ) AS fraction
FROM Players
INNER JOIN Activity
  ON (
    Players.player_id = Activity.player_id
    AND DATEDIFF(Players.first_login, Activity.event_date) = -1)"
"551","class Solution:
  def checkRecord(self, s: str) -> bool:
    return s.count('A') <= 1 and 'LLL' not in s"
"552","class Solution:
  def checkRecord(self, n: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j] := the length so far with i A's and the last letters are j L's
    dp = [[0] * 3 for _ in range(2)]
    dp[0][0] = 1

    for _ in range(n):
      prev = [A[:] for A in dp]

      # Append a P.
      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % kMod

      # Append an L.
      dp[0][1] = prev[0][0]

      # Append an L.
      dp[0][2] = prev[0][1]

      # Append an A or append a P.
      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +
                  prev[1][0] + prev[1][1] + prev[1][2]) % kMod

      # Append an L.
      dp[1][1] = prev[1][0]

      # Append an L.
      dp[1][2] = prev[1][1]

    return (sum(dp[0]) + sum(dp[1])) % kMod"
"553","class Solution:
  def optimalDivision(self, nums: list[int]) -> str:
    ans = str(nums[0])

    if len(nums) == 1:
      return ans
    if len(nums) == 2:
      return ans + '/' + str(nums[1])

    ans += '/(' + str(nums[1])
    for i in range(2, len(nums)):
      ans += '/' + str(nums[i])
    ans += ')'
    return ans"
"554","class Solution:
  def leastBricks(self, wall: list[list[int]]) -> int:
    maxFreq = 0
    count = collections.defaultdict(int)

    for row in wall:
      prefix = 0
      for i in range(len(row) - 1):
        prefix += row[i]
        count[prefix] += 1
        maxFreq = max(maxFreq, count[prefix])

    return len(wall) - maxFreq"
"555","class Solution:
  def splitLoopedString(self, strs: list[str]) -> str:
    ans = ''
    sortedStrs = [max(s, s[::-1]) for s in strs]

    for i, sortedStr in enumerate(sortedStrs):
      for s in (sortedStr, sortedStr[::-1]):
        for j in range(len(s) + 1):
          ans = max(
              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])

    return ans"
"556","class Solution:
  def nextGreaterElement(self, n: int) -> int:
    def nextPermutation(s: list[str]) -> str:
      i = len(s) - 2
      while i >= 0:
        if s[i] < s[i + 1]:
          break
        i -= 1

      if i >= 0:
        for j in range(len(s) - 1, i, -1):
          if s[j] > s[i]:
            break
        s[i], s[j] = s[j], s[i]

      reverse(s, i + 1, len(s) - 1)
      return ''.join(s)

    def reverse(s: list[str], l: int, r: int):
      while l < r:
        s[l], s[r] = s[r], s[l]
        l += 1
        r -= 1

    s = nextPermutation(list(str(n)))
    ans = int(s)
    return -1 if ans > 2**31 - 1 or ans <= n else ans"
"557","class Solution {
 public:
  string reverseWords(string s) {
    int i = 0;
    int j = 0;

    while (i < s.length()) {
      while (i < j || i < s.length() && s[i] == ' ')
        ++i;
      while (j < i || j < s.length() && s[j] != ' ')
        ++j;
      reverse(s.begin() + i, s.begin() + j);
    }

    return s;
  }
};"
"558","class Solution {
  public Node intersect(Node quadTree1, Node quadTree2) {
    if (quadTree1.isLeaf)
      return quadTree1.val ? quadTree1 : quadTree2;
    if (quadTree2.isLeaf)
      return quadTree2.val ? quadTree2 : quadTree1;

    Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);
    Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);
    Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);
    Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);

    if (topLeft.val == topRight.val &&       //
        topLeft.val == bottomLeft.val &&     //
        topLeft.val == bottomRight.val &&    //
        topLeft.isLeaf && topRight.isLeaf && //
        bottomLeft.isLeaf && bottomRight.isLeaf)
      return new Node(topLeft.val, true);
    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);
  }
}"
"559","class Solution:
  def maxDepth(self, root: 'Node') -> int:
    if not root:
      return 0
    if not root.children:
      return 1
    return 1 + max(self.maxDepth(child) for child in root.children)"
"56","class Solution:
  def merge(self, intervals: list[list[int]]) -> list[list[int]]:
    ans = []

    for interval in sorted(intervals):
      if not ans or ans[-1][1] < interval[0]:
        ans.append(interval)
      else:
        ans[-1][1] = max(ans[-1][1], interval[1])

    return ans"
"560","class Solution:
  def subarraySum(self, nums: list[int], k: int) -> int:
    ans = 0
    prefix = 0
    count = collections.Counter({0: 1})

    for num in nums:
      prefix += num
      ans += count[prefix - k]
      count[prefix] += 1

    return ans"
"561","class Solution:
  def arrayPairSum(self, nums: list[int]) -> int:
    return sum(sorted(nums)[::2])"
"562","class Solution:
  def longestLine(self, mat: list[list[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    # dp[i][j][0] := horizontal
    # dp[i][j][1] := vertical
    # dp[i][j][2] := diagonal
    # dp[i][j][3] := anti-diagonal
    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1:
          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1
          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1
          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1
          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1
          ans = max(ans, max(dp[i][j]))

    return ans"
"563","class Solution:
  def findTilt(self, root: TreeNode | None) -> int:
    ans = 0

    def summ(root: TreeNode | None) -> None:
      nonlocal ans
      if not root:
        return 0

      l = summ(root.left)
      r = summ(root.right)
      ans += abs(l - r)
      return root.val + l + r

    summ(root)
    return ans"
"564","class Solution:
  def nearestPalindromic(self, n: str) -> str:
    prevPalindrome, nextPalindrome = self._getPalindromes(n)
    return (str(prevPalindrome)
            if abs(prevPalindrome - int(n)) <= abs(nextPalindrome - int(n))
            else str(nextPalindrome))

  def _getPalindromes(self, s: str) -> tuple[str, str]:
    """"""Returns the two closest palindromes to the given number.""""""
    num = int(s)
    sz = len(s)
    palindromes = []
    half = s[0:(sz + 1) // 2]
    reversedHalf = half[:sz // 2][::-1]
    candidate = int(half + reversedHalf)

    if candidate < num:
      palindromes.append(candidate)
    else:
      prevHalf = str(int(half) - 1)
      reversedPrevHalf = prevHalf[:sz // 2][::-1]
      if sz % 2 == 0 and int(prevHalf) == 0:
        palindromes.append(9)
      elif sz % 2 == 0 and prevHalf == '9':
        palindromes.append(int(prevHalf + '9' + reversedPrevHalf))
      else:
        palindromes.append(int(prevHalf + reversedPrevHalf))

    if candidate > num:
      palindromes.append(candidate)
    else:
      nextHalf = str(int(half) + 1)
      reversedNextHalf = nextHalf[:sz // 2][::-1]
      palindromes.append(int(nextHalf + reversedNextHalf))

    return palindromes"
"565","class Solution:
  def arrayNesting(self, nums: list[int]) -> int:
    ans = 0

    for num in nums:
      if num == -1:
        continue
      index = num
      count = 0
      while nums[index] != -1:
        cache = index
        index = nums[index]
        nums[cache] = -1
        count += 1
      ans = max(ans, count)

    return ans"
"566","class Solution:
  def matrixReshape(self, nums: list[list[int]],
                    r: int, c: int) -> list[list[int]]:
    if nums == [] or r * c != len(nums) * len(nums[0]):
      return nums

    ans = [[0 for j in range(c)] for i in range(r)]
    k = 0

    for row in nums:
      for num in row:
        ans[k // c][k % c] = num
        k += 1

    return ans"
"567","class Solution:
  def checkInclusion(self, s1: str, s2: str) -> bool:
    count = collections.Counter(s1)
    required = len(s1)

    for r, c in enumerate(s2):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      if r >= len(s1):  # The window is oversized.
        count[s2[r - len(s1)]] += 1
        if count[s2[r - len(s1)]] > 0:
          required += 1
      if required == 0:
        return True

    return False"
"568","class Solution {
 public:
  int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {
    vector<vector<int>> mem(days.size(), vector<int>(days[0].size(), INT_MIN));
    return maxVacationDays(flights, days, 0, 0, mem);
  }

 private:
  // Returns the number of vacations that can be taken from the i-th city and
  // the k-th week.
  int maxVacationDays(const vector<vector<int>>& flights,
                      const vector<vector<int>>& days, int i, int k,
                      vector<vector<int>>& mem) {
    if (k == days[0].size())
      return 0;
    if (mem[i][k] != INT_MIN)
      return mem[i][k];

    // Stay at the j-th city or fly from the i-th city to the j-th city.
    for (int j = 0; j < flights.size(); ++j)
      if (j == i || flights[i][j] == 1)
        mem[i][k] = max(mem[i][k], days[j][k] + maxVacationDays(flights, days,
                                                                j, k + 1, mem));

    return mem[i][k];
  }
};"
"569","WITH
  EmployeesWithRowNumberInCompany AS (
    SELECT
      id,
      company,
      salary,
      ROW_NUMBER() OVER(
        PARTITION BY company
        ORDER BY salary
      ) AS `row_number`,
      COUNT(*) OVER(PARTITION BY company) AS `count`
    FROM Employee
  )
SELECT id, company, salary
FROM EmployeesWithRowNumberInCompany
WHERE
  `row_number` >= `count` / 2
  AND `row_number` <= `count` / 2 + 1;"
"57","class Solution:
  def insert(self, intervals: list[list[int]],
             newInterval: list[int]) -> list[list[int]]:
    n = len(intervals)
    ans = []
    i = 0

    while i < n and intervals[i][1] < newInterval[0]:
      ans.append(intervals[i])
      i += 1

    # Merge overlapping intervals.
    while i < n and intervals[i][0] <= newInterval[1]:
      newInterval[0] = min(newInterval[0], intervals[i][0])
      newInterval[1] = max(newInterval[1], intervals[i][1])
      i += 1

    ans.append(newInterval)

    while i < n:
      ans.append(intervals[i])
      i += 1

    return ans"
"570","SELECT Manager.name
FROM Employee
INNER JOIN Employee AS Manager
  ON (Employee.managerId = Manager.id)
GROUP BY Manager.id
HAVING COUNT(*) >= 5;"
"571","WITH
  NumbersMetadata AS (
    SELECT
      *,
      SUM(frequency) OVER(ORDER BY num) AS running_frequency,
      (SUM(frequency) OVER()) / 2 AS median_frequency
    FROM Numbers
  )
SELECT AVG(num) AS median
FROM NumbersMetadata
WHERE median_frequency BETWEEN running_frequency - frequency AND running_frequency;"
"572","class Solution {
 public:
  bool isSubtree(TreeNode* s, TreeNode* t) {
    if (s == nullptr)
      return false;
    if (isSameTree(s, t))
      return true;
    return isSubtree(s->left, t) || isSubtree(s->right, t);
  }

 private:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};"
"573","class Solution:
  def minDistance(
      self,
      height: int,
      width: int,
      tree: list[int],
      squirrel: list[int],
      nuts: list[list[int]],
  ) -> int:
    def dist(a: list[int], b: list[int]) -> int:
      return abs(a[0] - b[0]) + abs(a[1] - b[1])

    totDist = sum(dist(nut, tree) for nut in nuts) * 2
    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)
    return totDist - maxSave"
"574","SELECT Candidate.name
FROM Candidate
INNER JOIN Vote
  ON (Candidate.id = Vote.candidateId)
GROUP BY Candidate.id
ORDER BY COUNT(*) DESC
LIMIT 1;"
"575","class Solution:
  def distributeCandies(self, candies: list[int]) -> int:
    return min(len(candies) // 2, len(set(candies)))"
"576","class Solution:
  def findPaths(
      self,
      m: int,
      n: int,
      maxMove: int,
      startRow: int,
      startColumn: int,
  ) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kMod = 1_000_000_007
    ans = 0
    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds
    dp = [[0] * n for _ in range(m)]
    dp[startRow][startColumn] = 1

    for _ in range(maxMove):
      newDp = [[0] * n for _ in range(m)]
      for i in range(m):
        for j in range(n):
          if dp[i][j] > 0:
            for dx, dy in dirs:
              x = i + dx
              y = j + dy
              if x < 0 or x == m or y < 0 or y == n:
                ans = (ans + dp[i][j]) % kMod
              else:
                newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod
      dp = newDp

    return ans"
"577","SELECT Employee.name, Bonus.bonus
FROM Employee
LEFT JOIN Bonus
  USING (empId)
WHERE IFNULL(Bonus.bonus, 0) < 1000;"
"578","SELECT question_id AS survey_log
FROM SurveyLog
GROUP BY 1
ORDER BY
  COUNT(answer_id) / COUNT(*) DESC,
  question_id ASC
LIMIT 1;"
"579","WITH
  CurrMonth AS (
    SELECT
      *,
      MAX(month) OVER(PARTITION BY id) AS max_month
    FROM Employee
  )
SELECT
  CurrMonth.id,
  CurrMonth.month,
  SUM(PrevMonth.salary) AS salary
FROM CurrMonth
INNER JOIN Employee AS PrevMonth
  ON (CurrMonth.id = PrevMonth.id AND CurrMonth.month - PrevMonth.month BETWEEN 0 AND 2)
WHERE CurrMonth.month != CurrMonth.max_month
GROUP BY 1, 2
ORDER BY 1, 2 DESC;"
"58","class Solution:
  def lengthOfLastWord(self, s: str) -> int:
    i = len(s) - 1

    while i >= 0 and s[i] == ' ':
      i -= 1
    lastIndex = i
    while i >= 0 and s[i] != ' ':
      i -= 1

    return lastIndex - i"
"580","SELECT
  Department.dept_name,
  COUNT(Student.student_id) AS student_number
FROM Department
LEFT JOIN Student
  USING (dept_id)
GROUP BY 1
ORDER BY 2 DESC, 1;"
"581","class Solution:
  def findUnsortedSubarray(self, nums: list[int]) -> int:
    mn = math.inf
    mx = -math.inf
    flag = False

    for i in range(1, len(nums)):
      if nums[i] < nums[i - 1]:
        flag = True
      if flag:
        mn = min(mn, nums[i])

    flag = False

    for i in reversed(range(len(nums) - 1)):
      if nums[i] > nums[i + 1]:
        flag = True
      if flag:
        mx = max(mx, nums[i])

    for l in range(len(nums)):
      if nums[l] > mn:
        break

    for r, num in reversed(list(enumerate(nums))):
      if num < mx:
        break

    return 0 if l >= r else r - l + 1"
"582","class Solution:
  def killProcess(
      self,
      pid: list[int],
      ppid: list[int],
      kill: int,
  ) -> list[int]:
    ans = []
    tree = collections.defaultdict(list)

    for v, u in zip(pid, ppid):
      if u == 0:
        continue
      tree[u].append(v)

    def dfs(u: int) -> None:
      ans.append(u)
      for v in tree.get(u, []):
        dfs(v)

    dfs(kill)
    return ans"
"583","class Solution:
  def minDistance(self, word1: str, word2: str) -> int:
    k = self._lcs(word1, word2)
    return (len(word1) - k) + (len(word2) - k)

  def _lcs(self, a: str, b: str) -> int:
    m = len(a)
    n = len(b)
    # dp[i][j] := the length of LCS(a[0..i), b[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if a[i - 1] == b[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]
        else:
          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]"
"584","SELECT name
FROM Customer
WHERE referee_id IS NULL OR referee_id != 2;"
"585","WITH
  InsuranceWithCounts AS (
    SELECT
      tiv_2016,
      COUNT(*) OVER(PARTITION by tiv_2015) AS tiv_2015_count,
      COUNT(*) OVER(PARTITION by lat, lon) AS city_count
    FROM Insurance
  )
SELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016
FROM InsuranceWithCounts
WHERE tiv_2015_count > 1
  AND city_count = 1;"
"586","SELECT customer_number
FROM Orders
GROUP BY 1
ORDER BY COUNT(*) DESC
LIMIT 1;"
"587","class Solution:
  def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:
    hull = []

    trees.sort(key=lambda x: (x[0], x[1]))

    def cross(p: list[int], q: list[int], r: list[int]) -> int:
      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])

    # Build the lower hull: left-to-right scan.
    for tree in trees:
      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:
        hull.pop()
      hull.append(tuple(tree))
    hull.pop()

    # Build the upper hull: right-to-left scan.
    for tree in reversed(trees):
      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:
        hull.pop()
      hull.append(tuple(tree))

    # Remove the redundant elements from the stack.
    return list(set(hull))"
"588","struct TrieNode {
  map<string, shared_ptr<TrieNode>> children;  // lexicographical
  bool isFile = false;
  string content;
};

class FileSystem {
 public:
  vector<string> ls(string path) {
    auto [node, lastDir] = createDirAndGetPair(path);
    if (node->isFile)
      return {lastDir};

    vector<string> ans;

    for (const auto& [file, _] : node->children)
      ans.push_back(file);

    return ans;
  }

  void mkdir(string path) {
    createDirAndGetPair(path);
  }

  void addContentToFile(string filePath, string content) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    node->isFile = true;
    node->content += content;
  }

  string readContentFromFile(string filePath) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    return node->content;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  // e.g. createDirAndGetPair(""/a//b"") -> {TrieNode b, string ""b""}
  pair<shared_ptr<TrieNode>, string> createDirAndGetPair(const string& path) {
    const vector<string> dirs = getDirs(path);
    shared_ptr<TrieNode> node = root;

    for (const string& dir : dirs) {
      if (!node->children.contains(dir))
        node->children[dir] = make_shared<TrieNode>();
      node = node->children[dir];
    }

    return {node, dirs.empty() ? """" : dirs.back()};
  }

  // e.g. getDirs(""/a//b"") -> [""a"", ""b""]
  vector<string> getDirs(const string& path) {
    vector<string> dirs;
    istringstream iss(path);

    for (string dir; getline(iss, dir, '/');)
      if (!dir.empty())  // Make sure that ""/a//b"" == ""/a/b"".
        dirs.push_back(dir);

    return dirs;
  }
};"
"589","class Solution {
  public List<Integer> preorder(Node root) {
    if (root == null)
      return new ArrayList<>();

    List<Integer> ans = new ArrayList<>();
    Deque<Node> stack = new ArrayDeque<>();
    stack.push(root);

    while (!stack.isEmpty()) {
      root = stack.pop();
      ans.add(root.val);
      for (int i = root.children.size() - 1; i >= 0; --i)
        stack.push(root.children.get(i));
    }

    return ans;
  }
}"
"59","class Solution:
  def generateMatrix(self, n: int) -> list[list[int]]:
    ans = [[0] * n for _ in range(n)]
    count = 1

    for mn in range(n // 2):
      mx = n - mn - 1
      for i in range(mn, mx):
        ans[mn][i] = count
        count += 1
      for i in range(mn, mx):
        ans[i][mx] = count
        count += 1
      for i in range(mx, mn, -1):
        ans[mx][i] = count
        count += 1
      for i in range(mx, mn, -1):
        ans[i][mn] = count
        count += 1

    if n % 2 == 1:
      ans[n // 2][n // 2] = count

    return ans"
"590","class Solution {
 public:
  vector<int> postorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (Node* child : root->children)
        stack.push(child);
    }

    ranges::reverse(ans);
    return ans;
  }
};"
"591","class Solution:
  def isValid(self, code: str) -> bool:
    if code[0] != '<' or code[-1] != '>':
      return False

    containsTag = False
    stack = []

    def isValidCdata(s: str) -> bool:
      return s.find('[CDATA[') == 0

    def isValidTagName(tagName: str, isEndTag: bool) -> bool:
      nonlocal containsTag
      if not tagName or len(tagName) > 9:
        return False
      if any(not c.isupper() for c in tagName):
        return False

      if isEndTag:
        return stack and stack.pop() == tagName

      containsTag = True
      stack.append(tagName)
      return True

    i = 0
    while i < len(code):
      if not stack and containsTag:
        return False
      if code[i] == '<':
        # It's inside a tag, so check if it's a cdata.
        if stack and code[i + 1] == '!':
          closeIndex = code.find(']]>', i + 2)
          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):
            return False
        elif code[i + 1] == '/':  # the end tag
          closeIndex = code.find('>', i + 2)
          if closeIndex == -1 or not isValidTagName(
                  code[i + 2: closeIndex],
                  True):
            return False
        else:  # the start tag
          closeIndex = code.find('>', i + 1)
          if closeIndex == -1 or not isValidTagName(
                  code[i + 1: closeIndex],
                  False):
            return False
        i = closeIndex
      i += 1

    return not stack and containsTag"
"592","class Solution:
  def fractionAddition(self, expression: str) -> str:
    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))
    A = 0
    B = 1

    for a, b in zip(ints[::2], ints[1::2]):
      A = A * b + a * B
      B *= b
      g = math.gcd(A, B)
      A //= g
      B //= g

    return str(A) + '/' + str(B)"
"593","class Solution:
  def validSquare(
      self,
      p1: list[int],
      p2: list[int],
      p3: list[int],
      p4: list[int],
  ) -> bool:
    def dist(p1: list[int], p2: list[int]) -> int:
      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2

    distSet = set([dist(*pair)
                   for pair in list(
                       itertools.combinations([p1, p2, p3, p4], 2))])
    return 0 not in distSet and len(distSet) == 2"
"594","class Solution:
  def findLHS(self, nums: list[int]) -> int:
    ans = 0
    count = collections.Counter(nums)

    for num, freq in count.items():
      if num + 1 in count:
        ans = max(ans, freq + count[num + 1])

    return ans"
"595","SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;"
"596","SELECT class
FROM Courses
GROUP BY 1
HAVING COUNT(*) >= 5;"
"597","WITH
  Request AS (
    SELECT COUNT(DISTINCT sender_id, send_to_id) AS `count`
    FROM FriendRequest
  ),
  Accepted AS (
    SELECT IFNULL(COUNT(DISTINCT requester_id, accepter_id), 0) AS `count`
    FROM RequestAccepted
  )
SELECT IF(
    `Request`.count = 0,
    0,
    ROUND(Accepted.`count` / Request.`count`, 2)
  ) AS accept_rate
FROM Request, Accepted;"
"598","class Solution:
  def maxCount(self, m: int, n: int, ops: list[list[int]]) -> int:
    minY = m
    minX = n

    for y, x in ops:
      minY = min(minY, y)
      minX = min(minX, x)

    return minX * minY"
"599","class Solution:
  def findRestaurant(self, list1: list[str], list2: list[str]) -> list[str]:
    ans = []
    restaurantToIndex = {restaurant: i for i,
                         restaurant in enumerate(list1)}
    minSum = math.inf

    for i, restaurant in enumerate(list2):
      if restaurant in restaurantToIndex:
        summ = restaurantToIndex[restaurant] + i
        if summ < minSum:
          ans.clear()
        if summ <= minSum:
          ans.append(restaurant)
          minSum = summ

    return ans"
"6","class Solution:
  def convert(self, s: str, numRows: int) -> str:
    rows = [''] * numRows
    k = 0
    direction = (numRows == 1) - 1

    for c in s:
      rows[k] += c
      if k == 0 or k == numRows - 1:
        direction *= -1
      k += direction

    return ''.join(rows)"
"60","class Solution:
  def getPermutation(self, n: int, k: int) -> str:
    ans = ''
    nums = [i + 1 for i in range(n)]
    fact = [1] * (n + 1)  # fact[i] := i!

    for i in range(2, n + 1):
      fact[i] = fact[i - 1] * i

    k -= 1  # 0-indexed

    for i in reversed(range(n)):
      j = k // fact[i]
      k %= fact[i]
      ans += str(nums[j])
      nums.pop(j)

    return ans"
"600","class Solution {
  public int findIntegers(int num) {
    StringBuilder bits = new StringBuilder();
    for (; num > 0; num >>= 1)
      bits.append(num & 1);

    final int n = bits.length();
    int[] zero = new int[n];
    int[] one = new int[n];

    zero[0] = 1;
    one[0] = 1;

    for (int i = 1; i < n; ++i) {
      zero[i] = zero[i - 1] + one[i - 1];
      one[i] = zero[i - 1];
    }

    int ans = zero[n - 1] + one[n - 1];

    for (int i = n - 2; i >= 0; --i) {
      // The numbers > num and <= 2^n - 1 are invalid.
      if (bits.charAt(i) == '1' && bits.charAt(i + 1) == '1')
        break;
      if (bits.charAt(i) == '0' && bits.charAt(i + 1) == '0')
        ans -= one[i];
    }

    return ans;
  }
}"
"601","WITH
  StadiumWithGroupId AS (
    SELECT
      id,
      visit_date,
      people,
      id - ROW_NUMBER() OVER(ORDER BY id) AS group_id
    FROM Stadium
    WHERE people >= 100
  )
SELECT id, visit_date, people
FROM StadiumWithGroupId
WHERE group_id IN (
    SELECT group_id
    FROM StadiumWithGroupId
    GROUP BY group_id
    HAVING COUNT(*) >= 3
  )
ORDER BY visit_date;"
"602","WITH
  AllIds AS (
    SELECT requester_id AS id FROM RequestAccepted
    UNION ALL
    SELECT accepter_id FROM RequestAccepted
  )
SELECT
  id,
  COUNT(*) AS num
FROM AllIds
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1;"
"603","WITH CinemaNeighbors AS (
  SELECT
    *,
    LAG(free) OVER(ORDER BY seat_id) AS prev_free,
    LEAD(free) OVER(ORDER BY seat_id) AS next_free
  FROM Cinema
)
SELECT seat_id
FROM CinemaNeighbors
WHERE free = 1
  AND (prev_free = 1 OR next_free = 1)
ORDER BY 1;"
"604","class StringIterator:
  def __init__(self, compressedString: str):
    self.q = collections.deque()  # (currentChar, num)

    i = 0  # compressedString's index
    while i < len(compressedString):
      c = compressedString[i]
      i += 1
      num = 0
      while i < len(compressedString) and compressedString[i].isdigit():
        num = num * 10 + int(compressedString[i])
        i += 1
      self.q.append((c, num))

  def next(self) -> str:
    if not self.hasNext():
      return ' '

    c, num = self.q.popleft()
    if num > 1:
      self.q.appendleft((c, num - 1))
    return c

  def hasNext(self) -> bool:
    return self.q"
"605","class Solution:
  def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:
    for i, flower in enumerate(flowerbed):
      if flower == 0 and (
              i == 0 or flowerbed[i - 1] == 0) and (
              i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):
        flowerbed[i] = 1
        n -= 1
      if n <= 0:
        return True

    return False"
"606","class Solution:
  def tree2str(self, t: TreeNode | None) -> str:
    def dfs(root: TreeNode | None) -> str:
      if not root:
        return ''
      if root.right:
        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'
      if root.left:
        return str(root.val) + '(' + dfs(root.left) + ')'
      return str(root.val)
    return dfs(t)"
"607","SELECT SalesPerson.name
FROM Orders
INNER JOIN Company
  ON (Orders.com_id = Company.com_id AND Company.name = 'RED')
RIGHT JOIN SalesPerson
  USING (sales_id)
WHERE Orders.sales_id IS NULL;"
"608","SELECT DISTINCT Parent.id,
  (
    CASE
      WHEN Parent.p_id IS NULL THEN 'Root'
      WHEN Parent.p_id IS NOT NULL AND Child.p_id IS NOT NULL THEN 'Inner'
      WHEN Parent.p_id IS NOT NULL AND Child.p_id IS NULL THEN 'Leaf'
    END
  ) AS type
FROM Tree AS Parent
LEFT JOIN Tree AS Child
  ON (Parent.id = Child.p_id);"
"609","class Solution:
  def findDuplicate(self, paths: list[str]) -> list[list[str]]:
    contentToPathFiles = collections.defaultdict(list)

    for path in paths:
      words = path.split(' ')
      rootPath = words[0]  # ""root/d1/d2/.../dm""
      for fileAndContent in words[1:]:  # ""fn.txt(fn_content)""
        l = fileAndContent.find('(')
        r = fileAndContent.find(')')
        # ""fn.txt""
        file = fileAndContent[:l]
        # ""fn_content""
        content = fileAndContent[l + 1:r]
        # ""root/d1/d2/.../dm/fn.txt""
        filePath = rootPath + '/' + file
        contentToPathFiles[content].append(filePath)

    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]"
"61","class Solution:
  def rotateRight(self, head: ListNode, k: int) -> ListNode:
    if not head or not head.next or k == 0:
      return head

    tail = head
    length = 1
    while tail.next:
      tail = tail.next
      length += 1
    tail.next = head  # Circle the list.

    t = length - k % length
    for _ in range(t):
      tail = tail.next
    newHead = tail.next
    tail.next = None

    return newHead"
"610","SELECT
  *,
  IF(x + y > z AND x + z > y AND y + z > x, 'Yes', 'No') AS triangle
FROM Triangle;"
"611","class Solution:
  def triangleNumber(self, nums: list[int]) -> int:
    ans = 0

    nums.sort()

    for k in range(len(nums) - 1, 1, -1):
      i = 0
      j = k - 1
      while i < j:
        if nums[i] + nums[j] > nums[k]:
          ans += j - i
          j -= 1
        else:
          i += 1

    return ans"
"612","SELECT ROUND(
    MIN(SQRT(POW(P1.x - P2.x, 2) + POW(P1.y - P2.y, 2))),
    2
  ) AS shortest
FROM Point2D AS P1
LEFT JOIN Point2D AS P2
  ON (P1.x, P1.y) != (P2.x, P2.y);"
"613","SELECT MIN(P1.x - P2.x) AS shortest
FROM Point AS P1, Point AS P2
WHERE P1.x > P2.x;"
"614","SELECT
  Follower.follower,
  COUNT(DISTINCT Followee.follower) AS num
FROM Follow AS Follower
INNER JOIN Follow AS Followee
  ON (Follower.follower = Followee.followee)
GROUP BY 1
ORDER BY 1;"
"615","WITH
  AvgSalary AS (
    SELECT DISTINCT
      DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,
      Employee.department_id,
      AVG(amount) OVER(
        PARTITION BY Employee.department_id,
        Salary.pay_date
      ) AS department_avg_salary,
      AVG(amount) OVER(PARTITION BY Salary.pay_date) AS company_avg_salary
    FROM Salary
    INNER JOIN Employee
      USING (employee_id)
  )
SELECT DISTINCT
  pay_month,
  department_id,
  (
    CASE
      WHEN department_avg_salary > company_avg_salary THEN 'higher'
      WHEN department_avg_salary < company_avg_salary THEN 'lower'
      ELSE 'same'
    END
  ) AS comparison
FROM AvgSalary;"
"616","class Solution:
  def addBoldTag(self, s: str, words: list[str]) -> str:
    n = len(s)
    ans = []
    # bold[i] := True if s[i] should be bolded
    bold = [0] * n

    boldEnd = -1  # s[i:boldEnd] should be bolded
    for i in range(n):
      for word in words:
        if s[i:].startswith(word):
          boldEnd = max(boldEnd, i + len(word))
      bold[i] = boldEnd > i

    # Construct the with bold tags
    i = 0
    while i < n:
      if bold[i]:
        j = i
        while j < n and bold[j]:
          j += 1
        # `s[i..j)` should be bolded.
        ans.append('<b>' + s[i:j] + '</b>')
        i = j
      else:
        ans.append(s[i])
        i += 1

    return ''.join(ans)"
"617","class Solution:
  def mergeTrees(
      self,
      root1: TreeNode | None,
      root2: TreeNode | None,
  ) -> TreeNode | None:
    if not root1 and not root2:
      return None
    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)
    root = TreeNode(val)
    root.left = self.mergeTrees(root1.left if root1 else None,
                                root2.left if root2 else None)
    root.right = self.mergeTrees(root1.right if root1 else None,
                                 root2.right if root2 else None)
    return root"
"618","WITH
  StudentWithIdInContinent AS (
    SELECT
      *,
      ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS id
    FROM Student
  )
SELECT
  MAX(CASE WHEN continent = 'America' THEN name END) AS America,
  MAX(CASE WHEN continent = 'Asia' THEN name END) AS Asia,
  MAX(CASE WHEN continent = 'Europe' THEN name END) AS Europe,
  id
FROM StudentWithIdInContinent
GROUP BY id;"
"619","WITH
  UniqueNumbers AS (
    SELECT num
    FROM MyNumbers
    GROUP BY 1
    HAVING COUNT(num) = 1
  )
SELECT MAX(num) AS num
FROM UniqueNumbers;"
"62","class Solution:
  def uniquePaths(self, m: int, n: int) -> int:
    dp = [1] * n

    for _ in range(1, m):
      for j in range(1, n):
        dp[j] += dp[j - 1]

    return dp[n - 1]"
"620","SELECT *
FROM Cinema
WHERE
  MOD(id, 2) = 1
  AND description != 'boring'
ORDER BY rating DESC;"
"621","class Solution:
  def leastInterval(self, tasks: list[str], n: int) -> int:
    count = collections.Counter(tasks)
    maxFreq = max(count.values())
    # Put the most frequent task in the slot first.
    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)
    # Get the number of tasks with same frequency as maxFreq, we'll append them after the
    # `maxFreqTaskOccupy`.
    nMaxFreq = sum(value == maxFreq for value in count.values())
    # max(
    #   the most frequent task is frequent enough to force some idle slots,
    #   the most frequent task is not frequent enough to force idle slots
    # )
    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))"
"622","class MyCircularQueue {
  /** Initialize your data structure here. Set the size of the queue to be k. */
  public MyCircularQueue(int k) {
    this.k = k;
    this.q = new int[k];
    this.rear = k - 1;
  }

  /** Insert an element into the circular queue. Return true if the operation is successful. */
  public boolean enQueue(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Delete an element from the circular queue. Return true if the operation is successful. */
  public boolean deQueue() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Get the front item from the queue. */
  public int Front() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the queue. */
  public int Rear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular queue is empty or not. */
  public boolean isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular queue is full or not. */
  public boolean isFull() {
    return size == k;
  }

  private final int k;
  private int[] q;
  private int size = 0;
  private int front = 0;
  private int rear;
}"
"623","class Solution {
  public TreeNode addOneRow(TreeNode root, int v, int d) {
    if (d == 1) {
      TreeNode newRoot = new TreeNode(v);
      newRoot.left = root;
      return newRoot;
    }

    int depth = 0;
    Queue<TreeNode> q = new ArrayDeque<>(List.of(root));

    while (!q.isEmpty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode node = q.poll();
        if (node.left != null)
          q.offer(node.left);
        if (node.right != null)
          q.offer(node.right);
        if (depth == d - 1) {
          TreeNode cachedLeft = node.left;
          TreeNode cachedRight = node.right;
          node.left = new TreeNode(v);
          node.right = new TreeNode(v);
          node.left.left = cachedLeft;
          node.right.right = cachedRight;
        }
      }
      if (depth == d - 1)
        break;
    }

    return root;
  }
}"
"624","class Solution:
  def maxDistance(self, arrays: list[list[int]]) -> int:
    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))
    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))
    if index_min1 != index_max1:
      return max1 - min1

    min2, index_min2 = min((A[0], i)
                           for i, A in enumerate(arrays) if i != index_min1)
    max2, index_min2 = max((A[-1], i)
                           for i, A in enumerate(arrays) if i != index_max1)
    return max(max1 - min2, max2 - min1)"
"625","class Solution:
  def smallestFactorization(self, num: int) -> int:
    if num == 1:
      return 1

    ans = 0
    base = 1

    for i in range(9, 1, -1):
      while num % i == 0:
        num //= i
        ans = base * i + ans
        base *= 10

    return ans if num == 1 and ans < 2**31 - 1 else 0"
"626","SELECT
  ROW_NUMBER() OVER(ORDER BY IF(MOD(id, 2) = 0, id - 1, id + 1)) AS id,
  student
FROM Seat;"
"627","UPDATE Salary
SET sex = IF(sex = 'm', 'f', 'm');"
"628","class Solution:
  def maximumProduct(self, nums: list[int]) -> int:
    nums.sort()
    return max(nums[-1] * nums[0] * nums[1],
               nums[-1] * nums[-2] * nums[-3])"
"629","class Solution:
  def kInversePairs(self, n: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    # If there's no inverse pair, the permutation is unique '123..i'
    for i in range(n + 1):
      dp[i][0] = 1

    for i in range(1, n + 1):
      for j in range(1, k + 1):
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod
        if j - i >= 0:
          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod

    return dp[n][k]"
"63","class Solution:
  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    dp = [0] * n
    dp[0] = 1

    for i in range(m):
      for j in range(n):
        if obstacleGrid[i][j]:
          dp[j] = 0
        elif j > 0:
          dp[j] += dp[j - 1]

    return dp[n - 1]"
"630","class Solution:
  def scheduleCourse(self, courses: list[list[int]]) -> int:
    time = 0
    maxHeap = []

    for duration, lastDay in sorted(courses, key=lambda x: x[1]):
      heapq.heappush(maxHeap, -duration)
      time += duration
      # If the current course cannot be taken, check if it can be swapped with
      # a previously taken course that has a larger duration to increase the
      # time available to take upcoming courses.
      if time > lastDay:
        time += heapq.heappop(maxHeap)

    return len(maxHeap)"
"631","from dataclasses import dataclass


@dataclass
class Cell:
  val: int = 0
  posCount: dict[tuple[int, int], int] | None = None


class Excel:
  def __init__(self, height: int, width: str):
    self.width = ord(width) - ord('A') + 1
    self.sheet = [[Cell() for _ in range(self.width)] for _ in range(height)]

  def set(self, row: int, column: str, val: int) -> None:
    self._getCell(row, column).val = val
    self._getCell(row, column).posCount = {}

  def get(self, row: int, column: str) -> int:
    cell = self._getCell(row, column)
    if not cell.posCount:
      return cell.val
    val = 0
    for pos, count in cell.posCount.items():
      val += self.get(pos // self.width + 1, chr(pos %
                      self.width + ord('A'))) * count
    return val

  def sum(self, row: int, column: str, numbers: list[str]) -> int:
    self._getCell(row, column).posCount = self._parse(numbers)
    return self.get(row, column)

  def _getCell(self, row: int, column: str) -> Cell:
    return self.sheet[row - 1][ord(column) - ord('A')]

  def _parse(self, numbers: list[str]) -> dict[int, int]:
    count: dict[int, int] = {}
    for s in numbers:
      startRow, startCol, endRow, endCol = self._parseRange(s)
      for i in range(startRow - 1, endRow):
        for j in range(ord(startCol) - ord('A'), ord(endCol) - ord('A') + 1):
          pos = i * self.width + j
          count[pos] = count.get(pos, 0) + 1
    return count

  def _parseRange(self, s: str) -> tuple[int, str, int, str]:
    if ':' not in s:
      return int(s[1:]), s[0], int(s[1:]), s[0]
    l, r = s.split(':')
    return int(l[1:]), l[0], int(r[1:]), r[0]"
"632","class Solution:
  def smallestRange(self, nums: list[list[int]]) -> list[int]:
    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]
    heapq.heapify(minHeap)

    maxRange = max(row[0] for row in nums)
    minRange = heapq.nsmallest(1, minHeap)[0][0]
    ans = [minRange, maxRange]

    while len(minHeap) == len(nums):
      num, r, c = heapq.heappop(minHeap)
      if c + 1 < len(nums[r]):
        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))
        maxRange = max(maxRange, nums[r][c + 1])
        minRange = heapq.nsmallest(1, minHeap)[0][0]
        if maxRange - minRange < ans[1] - ans[0]:
          ans[0], ans[1] = minRange, maxRange

    return ans"
"633","class Solution:
  def judgeSquareSum(self, c: int) -> bool:
    l = 0
    r = math.isqrt(c)

    while l <= r:
      summ = l * l + r * r
      if summ == c:
        return True
      if summ < c:
        l += 1
      else:
        r -= 1

    return False"
"634","class Solution:
  def findDerangement(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = [1] + [0] * n

    for i in range(2, n + 1):
      dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % kMod

    return dp[n]"
"635","class LogSystem:
  def __init__(self):
    self.granularityToIndices = {'Year': 4, 'Month': 7, 'Day': 10,
                                 'Hour': 13, 'Minute': 16, 'Second': 19}
    self.idAndTimestamps = []

  def put(self, id: int, timestamp: str) -> None:
    self.idAndTimestamps.append((id, timestamp))

  def retrieve(self, start: str, end: str, granularity: str) -> list[int]:
    index = self.granularityToIndices[granularity]
    s = start[:index]
    e = end[:index]
    return [id for id, timestamp in self.idAndTimestamps
            if s <= timestamp[:index] <= e]"
"636","class Solution {
 public:
  vector<int> exclusiveTime(int n, vector<string>& logs) {
    vector<int> ans(n);
    stack<int> stack;  // [oldest_id, ..., latest_id]
    int prevTime;

    for (const string& log : logs) {
      // Get the seperators' indices.
      const int colon1 = log.find_first_of(':');
      const int colon2 = log.find_last_of(':');
      // Get the function_id, the label, and the timestamp.
      const int id = stoi(log.substr(0, colon1));  // {function_id}
      const char label = log[colon1 + 1];  // {""s"" (""start"") | ""e"" (""end"") }
      const int timestamp = stoi(log.substr(colon2 + 1));  // {timestamp}
      if (label == 's') {
        if (!stack.empty())
          ans[stack.top()] += timestamp - prevTime;
        stack.push(id);
        prevTime = timestamp;
      } else {
        ans[stack.top()] += timestamp - prevTime + 1, stack.pop();
        prevTime = timestamp + 1;
      }
    }

    return ans;
  }
};"
"637","class Solution {
 public:
  vector<double> averageOfLevels(TreeNode* root) {
    vector<double> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      long sum = 0;
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        sum += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(sum / (double)size);
    }

    return ans;
  }
};"
"638","class Solution:
  def shoppingOffers(
      self,
      price: list[int],
      special: list[list[int]],
      needs: list[int]
  ) -> int:
    def dfs(s: int) -> int:
      ans = 0
      for i, need in enumerate(needs):
        ans += need * price[i]

      for i in range(s, len(special)):
        offer = special[i]
        if all(offer[j] <= need for j, need in enumerate(needs)):
          # Use the special[i].
          for j in range(len(needs)):
            needs[j] -= offer[j]
          ans = min(ans, offer[-1] + dfs(i))
          # Unuse the special[i] (backtracking).
          for j in range(len(needs)):
            needs[j] += offer[j]

      return ans

    return dfs(0)"
"639","class Solution {
  public int numDecodings(String s) {
    final int kMod = 1_000_000_007;
    final int n = s.length();
    // dp[i] := the number of ways to decode s[i..n - 1]
    long[] dp = new long[n + 1];
    dp[n] = 1;
    dp[n - 1] = count(s.charAt(n - 1));

    for (int i = n - 2; i >= 0; --i) {
      dp[i] += count(s.charAt(i), s.charAt(i + 1)) * dp[i + 2];
      dp[i] += count(s.charAt(i)) * dp[i + 1];
      dp[i] %= kMod;
    }

    return (int) dp[0];
  }

  private int count(char c) {
    if (c == '*')
      return 9;
    return c == '0' ? 0 : 1;
  }

  private int count(char c1, char c2) {
    if (c1 == '*' && c2 == '*')
      return 15; // c1c2: [11-19, 21-26]
    if (c1 == '*') {
      if ('0' <= c2 && c2 <= '6')
        return 2; // c1: [1-2]
      else
        return 1; // c1: [1]
    }
    if (c2 == '*') {
      if (c1 == '1')
        return 9; // c2: [1-9]
      if (c1 == '2')
        return 6; // c2: [1-6]
      return 0;
    }
    return (c1 == '1' || (c1 == '2' && c2 <= '6')) ? 1 : 0;
  }
}"
"64","class Solution:
  def minPathSum(self, grid: list[list[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    for i in range(m):
      for j in range(n):
        if i > 0 and j > 0:
          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        elif i > 0:
          grid[i][0] += grid[i - 1][0]
        elif j > 0:
          grid[0][j] += grid[0][j - 1]

    return grid[m - 1][n - 1]"
"640","class Solution:
  def solveEquation(self, equation: str) -> str:
    def calculate(s: str) -> tuple:
      coefficient = 0
      constant = 0
      num = 0
      sign = 1

      for i, c in enumerate(s):
        if c.isdigit():
          num = num * 10 + int(c)
        elif c in '+-':
          constant += sign * num
          sign = 1 if c == '+' else -1
          num = 0
        else:
          if i > 0 and num == 0 and s[i - 1] == '0':
            continue
          coefficient += sign if num == 0 else sign * num
          num = 0

      return coefficient, constant + sign * num

    lhsEquation, rhsEquation = equation.split('=')
    lhsCoefficient, lhsConstant = calculate(lhsEquation)
    rhsCoefficient, rhsConstant = calculate(rhsEquation)
    coefficient = lhsCoefficient - rhsCoefficient
    constant = rhsConstant - lhsConstant

    if coefficient == 0 and constant == 0:
      return ""Infinite solutions""
    if coefficient == 0 and constant != 0:
      return ""No solution""
    return ""x="" + str(constant // coefficient)"
"641","class MyCircularDeque {
 public:
  /** Initialize your data structure here. Set the size of the deque to be k. */
  MyCircularDeque(int k) : k(k), q(k), rear(k - 1) {}

  /** Adds an item at the front of Deque. Return true if the operation is
   * successful. */
  bool insertFront(int value) {
    if (isFull())
      return false;

    front = (--front + k) % k;
    q[front] = value;
    ++size;
    return true;
  }

  /** Adds an item at the rear of Deque. Return true if the operation is
   * successful. */
  bool insertLast(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Deletes an item from the front of Deque. Return true if the operation is
   * successful. */
  bool deleteFront() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Deletes an item from the rear of Deque. Return true if the operation is
   * successful. */
  bool deleteLast() {
    if (isEmpty())
      return false;

    rear = (--rear + k) % k;
    --size;
    return true;
  }

  /** Get the front item from the deque. */
  int getFront() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the deque. */
  int getRear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular deque is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular deque is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};"
"642","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.s: str | None = None
    self.time = 0
    self.top3: list[TrieNode] = []

  def __lt__(self, other):
    if self.time == other.time:
      return self.s < other.s
    return self.time > other.time

  def update(self, node) -> None:
    if node not in self.top3:
      self.top3.append(node)
    self.top3.sort()
    if len(self.top3) > 3:
      self.top3.pop()


class AutocompleteSystem:
  def __init__(self, sentences: list[str], times: list[int]):
    self.root = TrieNode()
    self.curr = self.root
    self.s: list[str] = []

    for sentence, time in zip(sentences, times):
      self._insert(sentence, time)

  def input(self, c: str) -> list[str]:
    if c == '#':
      self._insert(''.join(self.s), 1)
      self.curr = self.root
      self.s = []
      return []

    self.s.append(c)

    if self.curr:
      self.curr = self.curr.children.get(c, None)
    if not self.curr:
      return []
    return [node.s for node in self.curr.top3]

  def _insert(self, sentence: str, time: int) -> None:
    node = self.root
    for c in sentence:
      node = node.children.setdefault(c, TrieNode())
    node.s = sentence
    node.time += time

    leaf = node
    node: TrieNode = self.root
    for c in sentence:
      node = node.children[c]
      node.update(leaf)"
"643","class Solution:
  def findMaxAverage(self, nums: list[int], k: int) -> float:
    summ = sum(nums[:k])
    ans = summ

    for i in range(k, len(nums)):
      summ += nums[i] - nums[i - k]
      ans = max(ans, summ)

    return ans / k"
"644","class Solution:
  def findMaxAverage(self, nums: list[int], k: int) -> float:
    kErr = 1e-5
    l = min(nums)
    r = max(nums)

    def check(m: float) -> bool:
      """"""
      Returns True if there's a subarray, where its length >= k and its average
      sum >= m.
      """"""
      summ = 0
      prevSum = 0
      minPrevSum = 0

      for i, num in enumerate(nums):
        # Need to substract m for each `num` so that we can check if the sum of
        # the subarray >= 0.
        summ += num - m
        if i >= k:
          prevSum += nums[i - k] - m
          minPrevSum = min(minPrevSum, prevSum)
        if i + 1 >= k and summ >= minPrevSum:
          return True

      return False

    while r - l > kErr:
      m = (l + r) / 2
      if check(m):
        l = m
      else:
        r = m

    return l"
"645","class Solution:
  def findErrorNums(self, nums: list[int]) -> list[int]:
    for num in nums:
      if nums[abs(num) - 1] < 0:
        duplicate = abs(num)
      else:
        nums[abs(num) - 1] *= -1

    for i, num in enumerate(nums):
      if num > 0:
        return [duplicate, i + 1]"
"646","class Solution:
  def findLongestChain(self, pairs: list[list[int]]) -> int:
    ans = 0
    prevEnd = -math.inf

    for s, e in sorted(pairs, key=lambda x: x[1]):
      if s > prevEnd:
        ans += 1
        prevEnd = e

    return ans"
"647","class Solution:
  def countSubstrings(self, s: str) -> int:
    def extendPalindromes(l: int, r: int) -> int:
      count = 0

      while l >= 0 and r < len(s) and s[l] == s[r]:
        count += 1
        l -= 1
        r += 1

      return count

    ans = 0

    for i in range(len(s)):
      ans += extendPalindromes(i, i)
      ans += extendPalindromes(i, i + 1)

    return ans"
"648","class Solution:
  def __init__(self):
    self.root = {}

  def insert(self, word: str) -> None:
    node = self.root
    for c in word:
      if c not in node:
        node[c] = {}
      node = node[c]
    node['word'] = word

  def search(self, word: str) -> str:
    node = self.root
    for c in word:
      if 'word' in node:
        return node['word']
      if c not in node:
        return word
      node = node[c]
    return word

  def replaceWords(self, dictionary: list[str], sentence: str) -> str:
    for word in dictionary:
      self.insert(word)

    words = sentence.split(' ')
    return ' '.join([self.search(word) for word in words])"
"649","class Solution {
 public:
  string predictPartyVictory(string senate) {
    const int n = senate.length();
    queue<int> qR;
    queue<int> qD;

    for (int i = 0; i < n; ++i)
      if (senate[i] == 'R')
        qR.push(i);
      else
        qD.push(i);

    while (!qR.empty() && !qD.empty()) {
      const int indexR = qR.front();
      qR.pop();
      const int indexD = qD.front();
      qD.pop();
      if (indexR < indexD)
        qR.push(indexR + n);
      else
        qD.push(indexD + n);
    }

    return qR.empty() ? ""Dire"" : ""Radiant"";
  }
};"
"65","class Solution:
  def isNumber(self, s: str) -> bool:
    s = s.strip()
    if not s:
      return False

    seenNum = False
    seenDot = False
    seenE = False

    for i, c in enumerate(s):
      if c == '.':
        if seenDot or seenE:
          return False
        seenDot = True
      elif c == 'e' or c == 'E':
        if seenE or not seenNum:
          return False
        seenE = True
        seenNum = False
      elif c in '+-':
        if i > 0 and s[i - 1] not in 'eE':
          return False
        seenNum = False
      else:
        if not c.isdigit():
          return False
        seenNum = True

    return seenNum"
"650","class Solution:
  def minSteps(self, n: int) -> int:
    if n <= 1:
      return 0

    # dp[i] := the minimum steps to get i 'A's
    # Copy 'A', then paste 'A' i - 1 times.
    dp = [i for i in range(n + 1)]

    for i in range(2, n + 1):
      for j in range(i // 2, 2, -1):
        if i % j == 0:
          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.
          break

    return dp[n]"
"651","class Solution {
 public:
  int maxA(int n) {
    int ans = n;

    for (int i = 1; i <= n - 3; ++i)
      ans = max(ans, maxA(i) * (n - 1 - i));

    return ans;
  }
};"
"652","class Solution:
  def findDuplicateSubtrees(self, root: TreeNode | None) -> list[TreeNode | None]:
    ans = []
    count = collections.Counter()

    def encode(root: TreeNode | None) -> str:
      if not root:
        return ''

      encoded = (str(root.val) + '#' +
                 encode(root.left) + '#' +
                 encode(root.right))
      count[encoded] += 1
      if count[encoded] == 2:
        ans.append(root)
      return encoded

    encode(root)
    return ans"
"653","class BSTIterator:
  def __init__(self, root: TreeNode | None, leftToRight: bool):
    self.stack = []
    self.leftToRight = leftToRight
    self._pushUntilNone(root)

  def next(self) -> int:
    node = self.stack.pop()
    if self.leftToRight:
      self._pushUntilNone(node.right)
    else:
      self._pushUntilNone(node.left)
    return node.val

  def _pushUntilNone(self, root: TreeNode | None):
    while root:
      self.stack.append(root)
      root = root.left if self.leftToRight else root.right


class Solution:
  def findTarget(self, root: TreeNode | None, k: int) -> bool:
    if not root:
      return False

    left = BSTIterator(root, True)
    right = BSTIterator(root, False)

    l = left.next()
    r = right.next()
    while l < r:
      summ = l + r
      if summ == k:
        return True
      if summ < k:
        l = left.next()
      else:
        r = right.next()

    return False"
"654","class Solution:
  def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode | None:
    def build(i: int, j: int) -> TreeNode | None:
      if i > j:
        return None

      maxNum = max(nums[i:j + 1])
      maxIndex = nums.index(maxNum)

      root = TreeNode(maxNum)
      root.left = build(i, maxIndex - 1)
      root.right = build(maxIndex + 1, j)
      return root

    return build(0, len(nums) - 1)"
"655","class Solution:
  def printTree(self, root: TreeNode | None) -> list[list[str]]:
    def maxHeight(root: TreeNode | None) -> int:
      if not root:
        return 0
      return 1 + max(maxHeight(root.left), maxHeight(root.right))

    def dfs(root: TreeNode | None, row: int, left: int, right: int) -> None:
      if not root:
        return

      mid = (left + right) // 2
      ans[row][mid] = str(root.val)
      dfs(root.left, row + 1, left, mid - 1)
      dfs(root.right, row + 1, mid + 1, right)

    m = maxHeight(root)
    n = pow(2, m) - 1
    ans = [[''] * n for _ in range(m)]
    dfs(root, 0, 0, len(ans[0]) - 1)
    return ans"
"656","class Solution:
  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:
    if coins[-1] == -1:
      return []

    n = len(coins)
    # dp[i] := the minimum cost to jump from i to n - 1
    dp = [math.inf] * n
    next = [-1] * n

    def cheapestJump(i: int) -> int:
      if i == len(coins) - 1:
        dp[i] = coins[i]
        return dp[i]
      if dp[i] < math.inf:
        return dp[i]
      if coins[i] == -1:
        return math.inf

      for j in range(i + 1, min(i + maxJump + 1, n)):
        res = cheapestJump(j)
        if res == math.inf:
          continue
        cost = coins[i] + res
        if cost < dp[i]:
          dp[i] = cost
          next[i] = j

      return dp[i]

    cheapestJump(0)
    if dp[0] == math.inf:
      return []
    return self._constructPath(next, 0)

  def _constructPath(self, next: list[int], i: int) -> list[int]:
    ans = []
    while i != -1:
      ans.append(i + 1)  # 1-indexed
      i = next[i]
    return ans"
"657","class Solution:
  def judgeCircle(self, moves: str) -> bool:
    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')"
"658","class Solution:
  def findClosestElements(self, arr: list[int], k: int, x: int) -> list[int]:
    l = 0
    r = len(arr) - k

    while l < r:
      m = (l + r) // 2
      if x - arr[m] <= arr[m + k] - x:
        r = m
      else:
        l = m + 1

    return arr[l:l + k]"
"659","class Solution {
  public boolean isPossible(int[] nums) {
    Map<Integer, Integer> count = new HashMap<>();
    List<Integer> starts = new ArrayList<>(); // the start indices of each subsequence
    List<Integer> ends = new ArrayList<>();   // the end indices of each subsequence

    for (final int num : nums)
      count.merge(num, 1, Integer::sum);

    for (int i = 0; i < nums.length; ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      final int num = nums[i];
      final int currCount = count.get(num);
      final int prevCount = count.getOrDefault(num - 1, 0);
      final int nextCount = count.getOrDefault(num + 1, 0);
      for (int j = 0; j < currCount - prevCount; ++j)
        starts.add(num);
      for (int j = 0; j < currCount - nextCount; ++j)
        ends.add(num);
    }

    for (int i = 0; i < starts.size(); ++i)
      if (ends.get(i) - starts.get(i) < 2)
        return false;

    return true;
  }
}"
"66","class Solution:
  def plusOne(self, digits: list[int]) -> list[int]:
    for i, d in reversed(list(enumerate(digits))):
      if d < 9:
        digits[i] += 1
        return digits
      digits[i] = 0

    return [1] + digits"
"660","class Solution:
  def newInteger(self, n: int) -> int:
    ans = []
    while n:
      ans.append(str(n % 9))
      n //= 9
    return ''.join(reversed(ans))"
"661","class Solution:
  def imageSmoother(self, M: list[list[int]]) -> list[list[int]]:
    m = len(M)
    n = len(M[0])
    ans = [[0 for j in range(n)] for i in range(m)]

    for i in range(m):
      for j in range(n):
        ones = 0
        count = 0
        for y in range(max(0, i - 1), min(m, i + 2)):
          for x in range(max(0, j - 1), min(n, j + 2)):
            ones += M[y][x]
            count += 1
        ans[i][j] = ones // count

    return ans"
"662","class Solution {
 public:
  int widthOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return 0;

    long ans = 0;
    dfs(root, 0, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int level, long index, vector<long>&& startOfLevel,
           long& ans) {
    if (root == nullptr)
      return;
    if (startOfLevel.size() == level)
      startOfLevel.push_back(index);

    ans = max(ans, index - startOfLevel[level] + 1);
    dfs(root->left, level + 1, index * 2, std::move(startOfLevel), ans);
    dfs(root->right, level + 1, index * 2 + 1, std::move(startOfLevel), ans);
  }
};"
"663","class Solution:
  def checkEqualTree(self, root: TreeNode | None) -> bool:
    if not root:
      return False

    seen = set()

    def dfs(root: TreeNode | None) -> int:
      if not root:
        return 0

      summ = root.val + dfs(root.left) + dfs(root.right)
      seen.add(summ)
      return summ

    summ = root.val + dfs(root.left) + dfs(root.right)
    return summ % 2 == 0 and summ // 2 in seen"
"664","class Solution {
 public:
  int strangePrinter(string s) {
    if (s.empty())
      return 0;

    const int n = s.size();
    // dp[i][j] := the minimum number of turns to print s[i..j]
    vector<vector<int>> dp(n, vector<int>(n, n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int j = 0; j < n; ++j)
      for (int i = j; i >= 0; --i)
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] - (s[k] == s[j]));

    return dp[0][n - 1];
  }
};"
"665","class Solution:
  def checkPossibility(self, nums: list[int]) -> bool:
    j = None

    for i in range(len(nums) - 1):
      if nums[i] > nums[i + 1]:
        if j is not None:
          return False
        j = i

    return (j is None or j == 0 or j == len(nums) - 2 or
            nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2])"
"666","class Solution:
  def pathSum(self, nums: list[int]) -> int:
    ans = 0
    tree = [[-1] * 8 for _ in range(4)]

    for num in nums:
      d = num // 100 - 1
      p = (num % 100) // 10 - 1
      v = num % 10
      tree[d][p] = v

    def dfs(i: int, j: int, path: int) -> None:
      nonlocal ans
      if tree[i][j] == -1:
        return
      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:
        ans += path + tree[i][j]
        return

      dfs(i + 1, j * 2, path + tree[i][j])
      dfs(i + 1, j * 2 + 1, path + tree[i][j])

    dfs(0, 0, 0)
    return ans"
"667","class Solution:
  def constructArray(self, n: int, k: int) -> list[int]:
    ans = list(range(1, n - k + 1))

    for i in range(k):
      if i % 2 == 0:
        ans.append(n - i // 2)
      else:
        ans.append(n - k + (i + 1) // 2)

    return ans"
"668","class Solution {
  public int findKthNumber(int m, int n, int k) {
    int l = 1;
    int r = m * n;

    while (l < r) {
      final int mid = (l + r) / 2;
      if (numsNoGreaterThan(m, n, mid) >= k)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }

  private int numsNoGreaterThan(int m, int n, int target) {
    int count = 0;
    // For each row i, count the number of numbers <= target.
    for (int i = 1; i <= m; ++i)
      count += Math.min(target / i, n);
    return count;
  }
}"
"669","class Solution {
  public TreeNode trimBST(TreeNode root, int low, int high) {
    if (root == null)
      return null;
    if (root.val < low)
      return trimBST(root.right, low, high);
    if (root.val > high)
      return trimBST(root.left, low, high);
    root.left = trimBST(root.left, low, high);
    root.right = trimBST(root.right, low, high);
    return root;
  }
}"
"67","class Solution:
  def addBinary(self, a: str, b: str) -> str:
    ans = []
    carry = 0
    i = len(a) - 1
    j = len(b) - 1

    while i >= 0 or j >= 0 or carry:
      if i >= 0:
        carry += int(a[i])
        i -= 1
      if j >= 0:
        carry += int(b[j])
        j -= 1
      ans.append(str(carry % 2))
      carry //= 2

    return ''.join(reversed(ans))"
"670","class Solution:
  def maximumSwap(self, num: int) -> int:
    s = list(str(num))
    dict = {c: i for i, c in enumerate(s)}

    for i, c in enumerate(s):
      for digit in reversed(string.digits):
        if digit <= c:
          break
        if digit in dict and dict[digit] > i:
          s[i], s[dict[digit]] = digit, s[i]
          return int(''.join(s))

    return num"
"671","class Solution {
 public:
  int findSecondMinimumValue(TreeNode* root) {
    if (root == nullptr)
      return -1;
    return findSecondMinimumValue(root, root->val);
  }

 private:
  int findSecondMinimumValue(TreeNode* root, int mn) {
    if (root == nullptr)
      return -1;
    if (root->val > mn)
      return root->val;

    const int leftMin = findSecondMinimumValue(root->left, mn);
    const int rightMin = findSecondMinimumValue(root->right, mn);

    if (leftMin == -1 || rightMin == -1)
      return max(leftMin, rightMin);
    return min(leftMin, rightMin);
  }
};"
"672","class Solution:
  def flipLights(self, n: int, m: int) -> int:
    n = min(n, 3)

    if m == 0:
      return 1
    if m == 1:
      return [2, 3, 4][n - 1]
    if m == 2:
      return [2, 4, 7][n - 1]

    return [2, 4, 8][n - 1]"
"673","class Solution:
  def findNumberOfLIS(self, nums: list[int]) -> int:
    ans = 0
    maxLength = 0
    # length[i] := the length of the LIS ending in nums[i]
    length = [1] * len(nums)
    # count[i] := the number of LIS's ending in nums[i]
    count = [1] * len(nums)

    # Calculate the `length` and `count` arrays.
    for i, num in enumerate(nums):
      for j in range(i):
        if nums[j] < num:
          if length[i] < length[j] + 1:
            length[i] = length[j] + 1
            count[i] = count[j]
          elif length[i] == length[j] + 1:
            count[i] += count[j]

    # Get the number of LIS.
    for i, l in enumerate(length):
      if l > maxLength:
        maxLength = l
        ans = count[i]
      elif l == maxLength:
        ans += count[i]

    return ans"
"674","class Solution:
  def findLengthOfLCIS(self, nums: list[int]) -> int:
    ans = 0
    j = 0

    for i in range(len(nums)):
      if i > 0 and nums[i] <= nums[i - 1]:
        j = i
      ans = max(ans, i - j + 1)

    return ans"
"675","class T {
  public int i;
  public int j;
  public int height;
  public T(int i, int j, int height) {
    this.i = i;
    this.j = j;
    this.height = height;
  }
}

class Solution {
  public int cutOffTree(List<List<Integer>> forest) {
    Queue<T> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a.height, b.height));

    for (int i = 0; i < forest.size(); ++i)
      for (int j = 0; j < forest.get(0).size(); ++j)
        if (forest.get(i).get(j) > 1)
          minHeap.offer(new T(i, j, forest.get(i).get(j)));

    int ans = 0;
    int x = 0;
    int y = 0;

    while (!minHeap.isEmpty()) {
      final int i = minHeap.peek().i;
      final int j = minHeap.poll().j;
      // Walk from (x, y) to (i, j).
      final int step = bfs(forest, x, y, i, j);
      if (step < 0)
        return -1;
      ans += step;
      x = i;
      y = j;
    }

    return ans;
  }

  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  private int bfs(List<List<Integer>> forest, int si, int sj, int ei, int ej) {
    final int m = forest.size();
    final int n = forest.get(0).size();
    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(si, sj)));
    boolean[][] seen = new boolean[m][n];
    seen[si][sj] = true;

    for (int step = 0; !q.isEmpty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        final int i = q.peek().getKey();
        final int j = q.poll().getValue();
        if (i == ei && j == ej)
          return step;
        for (int[] dir : dirs) {
          final int x = i + dir[0];
          final int y = j + dir[1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || forest.get(x).get(y) == 0)
            continue;
          q.offer(new Pair<>(x, y));
          seen[x][y] = true;
        }
      }

    return -1;
  };
}"
"676","class MagicDictionary:
  def __init__(self):
    self.dict = {}

  def buildDict(self, dictionary: list[str]) -> None:
    for word in dictionary:
      for i, c in enumerate(word):
        replaced = self._getReplaced(word, i)
        self.dict[replaced] = '*' if replaced in self.dict else c

  def search(self, searchWord: str) -> bool:
    for i, c in enumerate(searchWord):
      replaced = self._getReplaced(searchWord, i)
      if self.dict.get(replaced, c) != c:
        return True
    return False

  def _getReplaced(self, s: str, i: int) -> str:
    return s[:i] + '*' + s[i + 1:]"
"677","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.sum = 0


class MapSum:
  def __init__(self):
    self.root = TrieNode()
    self.keyToVal = {}

  def insert(self, key: str, val: int) -> None:
    diff = val - self.keyToVal.get(key, 0)
    node: TrieNode = self.root
    for c in key:
      node = node.children.setdefault(c, TrieNode())
      node.sum += diff
    self.keyToVal[key] = val

  def sum(self, prefix: str) -> int:
    node: TrieNode = self.root
    for c in prefix:
      if c not in node.children:
        return 0
      node = node.children[c]
    return node.sum"
"678","class Solution:
  def checkValidString(self, s: str) -> bool:
    low = 0
    high = 0

    for c in s:
      if c == '(':
        low += 1
        high += 1
      elif c == ')':
        if low > 0:
          low -= 1
        high -= 1
      else:
        if low > 0:
          low -= 1
        high += 1
      if high < 0:
        return False

    return low == 0"
"679","class Solution:
  def judgePoint24(self, nums: list[int]) -> bool:
    def generate(a: float, b: float) -> list[float]:
      return [a * b,
              math.inf if b == 0 else a / b,
              math.inf if a == 0 else b / a,
              a + b, a - b, b - a]

    def dfs(nums: list[float]) -> bool:
      if len(nums) == 1:
        return abs(nums[0] - 24.0) < 0.001

      for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
          for num in generate(nums[i], nums[j]):
            nextRound = [num]
            for k in range(len(nums)):
              if k == i or k == j:
                continue
              nextRound.append(nums[k])
            if dfs(nextRound):
              return True

      return False

    return dfs(nums)"
"68","class Solution:
  def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:
    ans = []
    row = []
    rowLetters = 0

    for word in words:
      # If we place the word in this row, it will exceed the maximum width.
      # Therefore, we cannot put the word in this row and have to pad spaces
      # for each word in this row.
      if rowLetters + len(word) + len(row) > maxWidth:
        for i in range(maxWidth - rowLetters):
          row[i % (len(row) - 1 or 1)] += ' '
        ans.append(''.join(row))
        row = []
        rowLetters = 0
      row.append(word)
      rowLetters += len(word)

    return ans + [' '.join(row).ljust(maxWidth)]"
"680","class Solution:
  def validPalindrome(self, s: str) -> bool:
    def validPalindrome(l: int, r: int) -> bool:
      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))

    n = len(s)

    for i in range(n // 2):
      if s[i] != s[~i]:
        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)

    return True"
"681","class Solution:
  def nextClosestTime(self, time: str) -> str:
    ans = list(time)
    digits = sorted(ans)

    def nextClosest(digit: str, limit: str) -> str:
      next = bisect_right(digits, digit)
      return digits[0] if next == 4 or digits[next] > limit else digits[next]

    ans[4] = nextClosest(ans[4], '9')
    if time[4] < ans[4]:
      return ''.join(ans)

    ans[3] = nextClosest(ans[3], '5')
    if time[3] < ans[3]:
      return ''.join(ans)

    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')
    if time[1] < ans[1]:
      return ''.join(ans)

    ans[0] = nextClosest(ans[0], '2')
    return ''.join(ans)"
"682","class Solution:
  def calPoints(self, operations: list[str]) -> int:
    scores = []

    for operation in operations:
      match operation:
        case '+':
          scores.append(scores[-1] + scores[-2])
        case 'D':
          scores.append(scores[-1] * 2)
        case 'C':
          scores.pop()
        case default:
          scores.append(int(operation))

    return sum(scores)"
"683","class Solution:
  def kEmptySlots(self, bulbs: list[int], k: int) -> int:
    n = len(bulbs)
    ans = math.inf
    # day[i] := the day when bulbs[i] is turned on
    day = [0] * n

    for i, bulb in enumerate(bulbs):
      day[bulb - 1] = i + 1

    # Find a subarray of day[l..r], where its length is k + 2.
    # For each l < i < r, day[i] > max(day[l], day[r]).
    l = 0
    r = l + k + 1
    i = 1
    while r < n:
      if i == r:
        ans = min(ans, max(day[l], day[r]))
        l = i
        r = i + k + 1
      elif day[i] < max(day[l], day[r]):
        l = i
        r = i + k + 1
      i += 1

    return -1 if ans == math.inf else ans"
"684","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:
    uf = UnionFind(len(edges) + 1)

    for edge in edges:
      u, v = edge
      if not uf.unionByRank(u, v):
        return edge"
"685","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findRedundantDirectedConnection(
      self, edges: list[list[int]],
  ) -> list[int]:
    ids = [0] * (len(edges) + 1)
    nodeWithTwoParents = 0

    for _, v in edges:
      ids[v] += 1
      if ids[v] == 2:
        nodeWithTwoParents = v

    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> list[int]:
      uf = UnionFind(len(edges) + 1)

      for i, edge in enumerate(edges):
        if i == skippedEdgeIndex:
          continue
        if not uf.unionByRank(edge[0], edge[1]):
          return edge

      return []

    # If there is no edge with two ids, don't skip any edge.
    if nodeWithTwoParents == 0:
      return findRedundantDirectedConnection(-1)

    for i in reversed(range(len(edges))):
      _, v = edges[i]
      if v == nodeWithTwoParents:
        # Try to delete the edges[i].
        if not findRedundantDirectedConnection(i):
          return edges[i]"
"686","class Solution:
  def repeatedStringMatch(self, a: str, b: str) -> int:
    n = math.ceil(len(b) / len(a))
    s = a * n
    if b in s:
      return n
    if b in s + a:
      return n + 1
    return -1"
"687","class Solution:
  def longestUnivaluePath(self, root: TreeNode | None) -> int:
    ans = 0

    def longestUnivaluePathDownFrom(root: TreeNode | None) -> int:
      nonlocal ans
      if not root:
        return 0

      l = longestUnivaluePathDownFrom(root.left)
      r = longestUnivaluePathDownFrom(root.right)
      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0
      arrowRight = r + 1 if root.right and root.right.val == root.val else 0
      ans = max(ans, arrowLeft + arrowRight)
      return max(arrowLeft, arrowRight)

    longestUnivaluePathDownFrom(root)
    return ans"
"688","class Solution:
  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    # dp[i][j] := the probability to stand on (i, j)
    dp = [[0] * n for _ in range(n)]
    dp[row][column] = 1.0

    for _ in range(k):
      newDp = [[0] * n for _ in range(n)]
      for i in range(n):
        for j in range(n):
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if 0 <= x < n and 0 <= y < n:
              newDp[i][j] += dp[x][y]
      dp = newDp

    return sum(map(sum, dp)) / 8**k"
"689","class Solution:
  def maxSumOfThreeSubarrays(self, nums: list[int], k: int) -> list[int]:
    n = len(nums) - k + 1
    # sums[i] := sum(nums[i..i + k))
    sums = [0] * n
    # l[i] := the index in [0..i] that has the maximum sums[i]
    l = [0] * n
    # r[i] := the index in [i..n) that has the maximum sums[i]
    r = [0] * n

    summ = 0
    for i, num in enumerate(nums):
      summ += num
      if i >= k:
        summ -= nums[i - k]
      if i >= k - 1:
        sums[i - k + 1] = summ

    maxIndex = 0
    for i in range(n):
      if sums[i] > sums[maxIndex]:
        maxIndex = i
      l[i] = maxIndex

    maxIndex = n - 1
    for i in range(n - 1, -1, -1):
      if sums[i] >= sums[maxIndex]:
        maxIndex = i
      r[i] = maxIndex

    ans = [-1, -1, -1]

    for i in range(k, n - k):
      if (ans[0] == -1 or
          sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <
              sums[l[i - k]] + sums[i] + sums[r[i + k]]):
        ans[0] = l[i - k]
        ans[1] = i
        ans[2] = r[i + k]

    return ans"
"69","class Solution:
  def mySqrt(self, x: int) -> int:
    return bisect.bisect_right(range(x + 1), x,
                               key=lambda m: m * m) - 1"
"690","class Solution:
  def getImportance(self, employees: list['Employee'], id: int) -> int:
    idToEmployee = {employee.id: employee for employee in employees}

    def dfs(id: int) -> int:
      values = idToEmployee[id].importance
      for subId in idToEmployee[id].subordinates:
        values += dfs(subId)
      return values

    return dfs(id)"
"691","class Solution:
  def minStickers(self, stickers: list[str], target: str) -> int:
    maxMask = 1 << len(target)
    # dp[i] := the minimum number of stickers to spell out i, where i is the
    # bit mask of target
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(maxMask):
      if dp[mask] == math.inf:
        continue
      # Try to expand from `mask` by using each sticker.
      for sticker in stickers:
        superMask = mask
        for c in sticker:
          for i, t in enumerate(target):
            # Try to apply it on a missing letter.
            if c == t and not (superMask >> i & 1):
              superMask |= 1 << i
              break
        dp[superMask] = min(dp[superMask], dp[mask] + 1)

    return -1 if dp[-1] == math.inf else dp[-1]"
"692","from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  word: str
  freq: int

  def __lt__(self, other):
    if self.freq == other.freq:
      return self.word > other.word
    return self.freq < other.freq


class Solution:
  def topKFrequent(self, words: list[str], k: int) -> list[str]:
    ans = []
    heap = []

    for word, freq in collections.Counter(words).items():
      heapq.heappush(heap, T(word, freq))
      if len(heap) > k:
        heapq.heappop(heap)

    while heap:
      ans.append(heapq.heappop(heap).word)

    return ans[::-1]"
"693","class Solution:
  def hasAlternatingBits(self, n: int) -> bool:
    #            n = 0b010101
    #       n >> 2 = 0b000101
    # n ^ (n >> 2) = 0b010000 = a
    #        a - 1 = 0b001111
    #  a & (a - 1) = 0
    a = n ^ (n >> 2)
    return (a & (a - 1)) == 0"
"694","class Solution:
  def numDistinctIslands(self, grid: list[list[int]]) -> int:
    seen = set()

    def dfs(i: int, j: int, i0: int, j0: int):
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return
      if grid[i][j] == 0 or (i, j) in seen:
        return

      seen.add((i, j))
      island.append((i - i0, j - j0))
      dfs(i + 1, j, i0, j0)
      dfs(i - 1, j, i0, j0)
      dfs(i, j + 1, i0, j0)
      dfs(i, j - 1, i0, j0)

    islands = set()  # all the different islands

    for i in range(len(grid)):
      for j in range(len(grid[0])):
        island = []
        dfs(i, j, i, j)
        if island:
          islands.add(frozenset(island))

    return len(islands)"
"695","class Solution:
  def maxAreaOfIsland(self, grid: list[list[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return 0
      if grid[i][j] != 1:
        return 0

      grid[i][j] = 2

      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)

    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))"
"696","class Solution:
  def countBinarySubstrings(self, s: str) -> int:
    ans = 0
    prevCount = 0
    equals = 1

    for i in range(len(s) - 1):
      if s[i] == s[i + 1]:
        equals += 1
      else:
        ans += min(prevCount, equals)
        prevCount = equals
        equals = 1

    return ans + min(prevCount, equals)"
"697","class Solution:
  def findShortestSubArray(self, nums: list[int]) -> int:
    ans = 0
    degree = 0
    debut = {}
    count = collections.Counter()

    for i, num in enumerate(nums):
      debut.setdefault(num, i)
      count[num] += 1
      if count[num] > degree:
        degree = count[num]
        ans = i - debut[num] + 1
      elif count[num] == degree:
        ans = min(ans, i - debut[num] + 1)

    return ans"
"698","class Solution:
  def canPartitionKSubsets(self, nums: list[int], k: int) -> bool:
    summ = sum(nums)
    if summ % k != 0:
      return False

    target = summ // k  # the target sum of each subset
    if any(num > target for num in nums):
      return False

    def dfs(s: int, remainingGroups: int, currSum: int, used: int) -> bool:
      if remainingGroups == 0:
        return True
      if currSum > target:
        return False
      if currSum == target:  # Find a valid group, so fresh start.
        return dfs(0, remainingGroups - 1, 0, used)

      for i in range(s, len(nums)):
        if used >> i & 1:
          continue
        if dfs(i + 1, remainingGroups, currSum + nums[i], used | 1 << i):
          return True

      return False

    nums.sort(reverse=True)
    return dfs(0, k, 0, 0)"
"699","class Solution {
 public:
  vector<int> fallingSquares(vector<vector<int>>& positions) {
    vector<int> ans;
    map<pair<int, int>, int> xsToHeight;  // {(xStart, xEnd), height}
    int maxHeight = INT_MIN;

    for (const vector<int>& p : positions) {
      const int left = p[0];
      const int sideLength = p[1];
      const int right = left + sideLength;
      // Find the first range that intersects with [left, right).
      auto it = xsToHeight.upper_bound({left, right});
      if (it != xsToHeight.begin() && (--it)->first.second <= left)
        ++it;
      int maxHeightInRange = 0;
      vector<tuple<int, int, int>> ranges;
      while (it != xsToHeight.end() && it->first.first < right) {
        const int l = it->first.first;
        const int r = it->first.second;
        const int h = it->second;
        if (l < left)
          ranges.emplace_back(l, left, h);
        if (right < r)
          ranges.emplace_back(right, r, h);
        maxHeightInRange = max(maxHeightInRange, h);
        it = xsToHeight.erase(it);
      }
      const int newHeight = maxHeightInRange + sideLength;
      xsToHeight[{left, right}] = newHeight;
      for (const auto& [l, r, h] : ranges)
        xsToHeight[{l, r}] = h;
      maxHeight = max(maxHeight, newHeight);
      ans.push_back(maxHeight);
    }

    return ans;
  }
};"
"7","class Solution:
  def reverse(self, x: int) -> int:
    ans = 0
    sign = -1 if x < 0 else 1
    x *= sign

    while x:
      ans = ans * 10 + x % 10
      x //= 10

    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans"
"70","class Solution:
  def climbStairs(self, n: int) -> int:
    # dp[i] := the number of ways to climb to the i-th stair
    dp = [1, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
      dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]"
"700","class Solution:
  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:
    if not root:
      return None
    if root.val == val:
      return root
    if root.val > val:
      return self.searchBST(root.left, val)
    return self.searchBST(root.right, val)"
"701","class Solution:
  def insertIntoBST(self, root: TreeNode | None, val: int) -> TreeNode | None:
    if not root:
      return TreeNode(val)
    if root.val > val:
      root.left = self.insertIntoBST(root.left, val)
    else:
      root.right = self.insertIntoBST(root.right, val)
    return root"
"702","# """"""
# This is ArrayReader's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# Class ArrayReader:
#   def get(self, index: int) -> int:

class Solution:
  def search(self, reader: 'ArrayReader', target: int) -> int:
    l = bisect.bisect_left(range(10**4), target,
                           key=lambda m: reader.get(m))
    return l if reader.get(l) == target else -1"
"703","class KthLargest {
  public KthLargest(int k, int[] nums) {
    this.k = k;
    for (final int num : nums)
      heapify(num);
  }

  public int add(int val) {
    heapify(val);
    return minHeap.peek();
  }

  private final int k;
  private Queue<Integer> minHeap = new PriorityQueue<>();

  private void heapify(int val) {
    minHeap.offer(val);
    if (minHeap.size() > k)
      minHeap.poll();
  }
}"
"704","class Solution:
  def search(self, nums: list[int], target: int) -> int:
    i = bisect.bisect_left(nums, target)
    return -1 if i == len(nums) or nums[i] != target else i"
"705","class MyHashSet:
  def __init__(self):
    self.set = [False] * 1000001

  def add(self, key: int) -> None:
    self.set[key] = True

  def remove(self, key: int) -> None:
    self.set[key] = False

  def contains(self, key: int) -> bool:
    return self.set[key]"
"706","class MyHashMap {
  public MyHashMap() {
    lists = new List[kSize];
    for (int i = 0; i < kSize; ++i)
      lists[i] = new ArrayList<>();
  }

  public void put(int key, int value) {
    for (int[] pair : lists[key % kSize])
      if (pair[0] == key) {
        pair[1] = value;
        return;
      }
    lists[key % kSize].add(new int[] {key, value});
  }

  public int get(int key) {
    for (int[] pair : lists[key % kSize])
      if (pair[0] == key)
        return pair[1];
    return -1;
  }

  public void remove(int key) {
    for (int i = 0; i < lists[key % kSize].size(); ++i)
      if (lists[key % kSize].get(i)[0] == key) {
        lists[key % kSize].remove(i);
        return;
      }
  }

  private static final int kSize = 10000;
  List<int[]>[] lists; // Each slot stores the (key, value) list.
}"
"707","from dataclasses import dataclass


@dataclass
class ListNode:
  val: int
  next: ListNode | None = None


class MyLinkedList:
  def __init__(self):
    self.length = 0
    self.dummy = ListNode(0)

  def get(self, index: int) -> int:
    if index < 0 or index >= self.length:
      return -1
    curr = self.dummy.next
    for _ in range(index):
      curr = curr.next
    return curr.val

  def addAtHead(self, val: int) -> None:
    curr = self.dummy.next
    self.dummy.next = ListNode(val)
    self.dummy.next.next = curr
    self.length += 1

  def addAtTail(self, val: int) -> None:
    curr = self.dummy
    while curr.next:
      curr = curr.next
    curr.next = ListNode(val)
    self.length += 1

  def addAtIndex(self, index: int, val: int) -> None:
    if index > self.length:
      return
    curr = self.dummy
    for _ in range(index):
      curr = curr.next
    temp = curr.next
    curr.next = ListNode(val)
    curr.next.next = temp
    self.length += 1

  def deleteAtIndex(self, index: int) -> None:
    if index < 0 or index >= self.length:
      return
    curr = self.dummy
    for _ in range(index):
      curr = curr.next
    temp = curr.next
    curr.next = temp.next
    self.length -= 1"
"708","class Solution {
 public:
  Node* insert(Node* head, int insertVal) {
    if (head == nullptr) {
      Node* newNode = new Node(insertVal);
      newNode->next = newNode;
      return newNode;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != head) {
      // 1. the minimum <= insertVal <= the maximum
      // 2. insertVal >= the maximum or insertVal <= the minimum
      if ((prev->val <= insertVal && insertVal <= curr->val) ||
          // `prev` is the maximum and `curr` is the minimum
          (prev->val > curr->val &&
           (insertVal >= prev->val || insertVal <= curr->val))) {
        // Insert the node between `prev` and `curr`.
        prev->next = new Node(insertVal, curr);
        return head;
      }
      prev = prev->next;
      curr = curr->next;
    }

    // All the values in the list are identical.
    prev->next = new Node(insertVal, curr);
    return head;
  }
};"
"709","class Solution:
  def toLowerCase(self, str: str) -> str:
    return ''.join(chr(ord(c) + 32) if 'A' <= c <= 'Z' else c for c in str)"
"71","class Solution:
  def simplifyPath(self, path: str) -> str:
    stack = []

    for str in path.split('/'):
      if str in ('', '.'):
        continue
      if str == '..':
        if stack:
          stack.pop()
      else:
        stack.append(str)

    return '/' + '/'.join(stack)"
"710","class Solution:
  def __init__(self, n: int, blacklist: list[int]):
    self.validRange = n - len(blacklist)
    self.dict = {}

    maxAvailable = n - 1

    for b in blacklist:
      self.dict[b] = -1

    for b in blacklist:
      if b < self.validRange:
        # Find the slot that haven't been used.
        while maxAvailable in self.dict:
          maxAvailable -= 1
        self.dict[b] = maxAvailable
        maxAvailable -= 1

  def pick(self) -> int:
    value = random.randint(0, self.validRange - 1)

    if value in self.dict:
      return self.dict[value]

    return value"
"711","class Solution:
  def numDistinctIslands2(self, grid: list[list[int]]) -> int:
    seen = set()

    def dfs(i: int, j: int):
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return
      if grid[i][j] == 0 or (i, j) in seen:
        return

      seen.add((i, j))
      island.append((i, j))
      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    def normalize(island: list[tuple]) -> list[tuple]:
      # points[i] := 8 different rotations/reflections of an island
      points = [[] for _ in range(8)]

      for i, j in island:
        points[0].append((i, j))
        points[1].append((i, -j))
        points[2].append((-i, j))
        points[3].append((-i, -j))
        points[4].append((j, i))
        points[5].append((j, -i))
        points[6].append((-j, i))
        points[7].append((-j, -i))

      points = [sorted(p) for p in points]

      # Normalize each p by substracting p[1..7] with p[0].
      for p in points:
        for i in range(1, len(island)):
          p[i] = (p[i][0] - p[0][0],
                  p[i][1] - p[0][1])
        p[0] = (0, 0)

      return sorted(points)[0]

    islands = set()  # all the islands with different shapes

    for i in range(len(grid)):
      for j in range(len(grid[0])):
        island = []
        dfs(i, j)
        if island:
          islands.add(frozenset(normalize(island)))

    return len(islands)"
"712","class Solution {
 public:
  int minimumDeleteSum(string s1, string s2) {
    const int m = s1.length();
    const int n = s2.length();
    // dp[i][j] := the minimum cost to make s1[0..i) and s2[0..j) equal
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Delete s1[i - 1].
    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] + s1[i - 1];

    // Delete s2[j - 1].
    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] + s2[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s1[i - 1] == s2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);

    return dp[m][n];
  }
};"
"713","class Solution:
  def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:
    if k <= 1:
      return 0

    ans = 0
    prod = 1

    j = 0
    for i, num in enumerate(nums):
      prod *= num
      while prod >= k:
        prod /= nums[j]
        j += 1
      ans += i - j + 1

    return ans"
"714","class Solution:
  def maxProfit(self, prices: list[int], fee: int) -> int:
    sell = 0
    hold = -math.inf

    for price in prices:
      sell = max(sell, hold + price)
      hold = max(hold, sell - price - fee)

    return sell"
"715","class RangeModule:
  def __init__(self):
    self.A = []

  def addRange(self, left: int, right: int) -> None:
    i = bisect_left(self.A, left)
    j = bisect_right(self.A, right)
    self.A[i:j] = [left] * (i % 2 == 0) + [right] * (j % 2 == 0)

  def queryRange(self, left: int, right: int) -> bool:
    i = bisect_right(self.A, left)
    j = bisect_left(self.A, right)
    return i == j and i % 2 == 1

  def removeRange(self, left: int, right: int) -> None:
    i = bisect_left(self.A, left)
    j = bisect_right(self.A, right)
    self.A[i:j] = [left] * (i % 2 == 1) + [right] * (j % 2 == 1)"
"716","class MaxStack {
 public:
  void push(int x) {
    list.push_front(x);
    keyToIterators[x].push_back(list.begin());
  }

  int pop() {
    const int x = list.front();
    list.pop_front();
    auto& iterators = keyToIterators[x];
    iterators.pop_back();
    if (iterators.empty())
      keyToIterators.erase(x);
    return x;
  }

  int top() {
    return list.front();
  }

  int peekMax() {
    return keyToIterators.begin()->first;
  }

  int popMax() {
    const int x = peekMax();
    auto& iterators = keyToIterators.begin()->second;
    auto it = iterators.back();
    list.erase(it);
    iterators.pop_back();
    if (iterators.empty())
      keyToIterators.erase(keyToIterators.begin());
    return x;
  }

 private:
  std::list<int> list;
  map<int, vector<std::list<int>::iterator>, greater<>> keyToIterators;
};"
"717","class Solution:
  def isOneBitCharacter(self, bits: list[int]) -> bool:
    i = 0
    while i < len(bits) - 1:
      i += bits[i] + 1

    return i == len(bits) - 1"
"718","class Solution:
  def findLength(self, nums1: list[int], nums2: list[int]) -> int:
    m = len(nums1)
    n = len(nums2)
    ans = 0
    # dp[i][j] := the maximum length of a subarray that appears in both
    # nums1[i..m) and nums2[j..n)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        if nums1[i] == nums2[j]:
          dp[i][j] = dp[i + 1][j + 1] + 1
          ans = max(ans, dp[i][j])

    return ans"
"719","class Solution:
  def smallestDistancePair(self, nums: list[int], k: int) -> int:
    nums.sort()

    def numPairDistancesNoGreaterThan(m: int) -> int:
      count = 0
      j = 1
      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,
      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.
      for i, num in enumerate(nums):
        while j < len(nums) and nums[j] <= num + m:
          j += 1
        count += j - i - 1
      return count

    return bisect.bisect_left(range(nums[-1] - nums[0]), k,
                              key=lambda m: numPairDistancesNoGreaterThan(m))"
"72","class Solution:
  def minDistance(self, word1: str, word2: str) -> int:
    m = len(word1)
    n = len(word2)
    # dp[i][j] := the minimum number of operations to convert word1[0..i) to
    # word2[0..j)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      dp[i][0] = i

    for j in range(1, n + 1):
      dp[0][j] = j

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if word1[i - 1] == word2[j - 1]:
          dp[i][j] = dp[i - 1][j - 1]
        else:
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

    return dp[m][n]"
"720","class Solution:
  def longestWord(self, words: list[str]) -> str:
    root = {}

    for word in words:
      node = root
      for c in word:
        if c not in node:
          node[c] = {}
        node = node[c]
      node['word'] = word

    def dfs(node: dict) -> str:
      ans = node['word'] if 'word' in node else ''

      for child in node:
        if 'word' in node[child] and len(node[child]['word']) > 0:
          childWord = dfs(node[child])
          if len(childWord) > len(ans) or (
                  len(childWord) == len(ans) and childWord < ans):
            ans = childWord

      return ans

    return dfs(root)"
"721","class UnionFind {
  public UnionFind(List<List<String>> accounts) {
    for (List<String> account : accounts)
      for (int i = 1; i < account.size(); ++i) {
        final String email = account.get(i);
        id.putIfAbsent(email, email);
      }
  }

  public void union(final String u, final String v) {
    id.put(find(u), find(v));
  }

  public String find(final String u) {
    if (u != id.get(u))
      id.put(u, find(id.get(u)));
    return id.get(u);
  }

  private Map<String, String> id = new HashMap<>();
}

class Solution {
  public List<List<String>> accountsMerge(List<List<String>> accounts) {
    List<List<String>> ans = new ArrayList<>();
    Map<String, String> emailToName = new HashMap<>();
    Map<String, TreeSet<String>> idEmailToEmails = new HashMap<>();
    UnionFind uf = new UnionFind(accounts);

    for (final List<String> account : accounts)
      for (int i = 1; i < account.size(); ++i)
        emailToName.putIfAbsent(account.get(i), account.get(0));

    for (final List<String> account : accounts)
      for (int i = 2; i < account.size(); ++i)
        uf.union(account.get(i), account.get(i - 1));

    for (final List<String> account : accounts)
      for (int i = 1; i < account.size(); ++i) {
        final String id = uf.find(account.get(i));
        idEmailToEmails.putIfAbsent(id, new TreeSet<>());
        idEmailToEmails.get(id).add(account.get(i));
      }

    for (final String idEmail : idEmailToEmails.keySet()) {
      List<String> emails = new ArrayList<>(idEmailToEmails.get(idEmail));
      final String name = emailToName.get(idEmail);
      emails.add(0, name);
      ans.add(emails);
    }

    return ans;
  }
}"
"722","class Solution:
  def removeComments(self, source: list[str]) -> list[str]:
    ans = []
    commenting = False
    modified = ''

    for line in source:
      i = 0
      while i < len(line):
        if i + 1 == len(line):
          if not commenting:
            modified += line[i]
          i += 1
          break
        twoChars = line[i:i + 2]
        if twoChars == '/*' and not commenting:
          commenting = True
          i += 2
        elif twoChars == '*/' and commenting:
          commenting = False
          i += 2
        elif twoChars == '//':
          if not commenting:
            break
          else:
            i += 2
        else:
          if not commenting:
            modified += line[i]
          i += 1
      if modified and not commenting:
        ans.append(modified)
        modified = ''

    return ans"
"723","class Solution {
 public:
  vector<vector<int>> candyCrush(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();
    bool haveCrushes = true;

    while (haveCrushes) {
      haveCrushes = false;

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
          const int val = abs(board[i][j]);
          if (val == 0)
            continue;
          // Crush the vertical candies.
          if (j + 2 < n && abs(board[i][j + 1]) == val &&
              abs(board[i][j + 2]) == val) {
            haveCrushes = true;
            for (int k = j; k < j + 3; ++k)
              board[i][k] = -val;
          }
          // Crush the horizontal candies.
          if (i + 2 < m && abs(board[i + 1][j]) == val &&
              abs(board[i + 2][j]) == val) {
            haveCrushes = true;
            for (int k = i; k < i + 3; ++k)
              board[k][j] = -val;
          }
        }

      if (haveCrushes) {
        // For each column, drop the candies.
        for (int j = 0; j < n; ++j) {
          int nextIndex = m - 1;
          for (int i = m - 1; i >= 0; --i)
            if (board[i][j] > 0)
              board[nextIndex--][j] = board[i][j];
          // Set board[0..nextIndex][j] to 0s.
          for (int i = nextIndex; i >= 0; --i)
            board[i][j] = 0;
        }
      }
    }

    return board;
  }
};"
"724","class Solution:
  def pivotIndex(self, nums: list[int]) -> int:
    summ = sum(nums)
    prefix = 0

    for i, num in enumerate(nums):
      if prefix == summ - prefix - num:
        return i
      prefix += num

    return -1"
"725","class Solution:
  def splitListToParts(self, root: ListNode, k: int) -> list[ListNode]:
    ans = [[] for _ in range(k)]
    length = 0
    curr = root
    while curr:
      length += 1
      curr = curr.next
    subLength = length // k
    remainder = length % k

    prev = None
    head = root

    for i in range(k):
      ans[i] = head
      for j in range(subLength + (1 if remainder > 0 else 0)):
        prev = head
        head = head.next
      if prev:
        prev.next = None
      remainder -= 1

    return ans"
"726","class Solution:
  def countOfAtoms(self, formula: str) -> str:
    def parse() -> dict:
      ans = collections.defaultdict(int)

      nonlocal i
      while i < n:
        if formula[i] == '(':
          i += 1
          for elem, freq in parse().items():
            ans[elem] += freq
        elif formula[i] == ')':
          i += 1
          numStart = i
          while i < n and formula[i].isdigit():
            i += 1
          factor = int(formula[numStart:i])
          for elem, freq in ans.items():
            ans[elem] *= factor
          return ans
        elif formula[i].isupper():
          elemStart = i
          i += 1
          while i < n and formula[i].islower():
            i += 1
          elem = formula[elemStart:i]
          numStart = i
          while i < n and formula[i].isdigit():
            i += 1
          num = 1 if i == numStart else int(
              formula[numStart:i])
          ans[elem] += num

      return ans

    n = len(formula)

    ans = """"
    i = 0
    count = parse()

    for elem in sorted(count.keys()):
      ans += elem
      if count[elem] > 1:
        ans += str(count[elem])

    return ans"
"727","class Solution {
  public String minWindow(String s1, String s2) {
    final int m = s2.length();
    final int n = s1.length();
    // dp[i][j] := the start index (1-indexed) of the minimum window of s2[0..i)
    // and s1[0..j).
    int[][] dp = new int[m + 1][n + 1];

    // Fill in the placeholder values.
    for (int j = 0; j <= n; ++j)
      dp[0][j] = j + 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s2.charAt(i - 1) == s1.charAt(j - 1))
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = dp[i][j - 1];

    int bestLeft = 0;
    int minLength = Integer.MAX_VALUE;

    for (int j = 1; j <= n; ++j)
      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {
        bestLeft = dp[m][j] - 1;
        minLength = j - dp[m][j] + 1;
      }

    return minLength == Integer.MAX_VALUE ? """" : s1.substring(bestLeft, bestLeft + minLength);
  }
}"
"728","class Solution:
  def selfDividingNumbers(self, left: int, right: int) -> list[int]:
    return [num for num in range(left, right + 1) if all(n != 0 and num % n == 0 for n in map(int, str(num)))]"
"729","class MyCalendar:
  def __init__(self):
    self.timeline = []

  def book(self, start: int, end: int) -> bool:
    for s, e in self.timeline:
      if max(start, s) < min(end, e):
        return False
    self.timeline.append((start, end))
    return True"
"73","class Solution:
  def setZeroes(self, matrix: list[list[int]]) -> None:
    m = len(matrix)
    n = len(matrix[0])
    shouldFillFirstRow = 0 in matrix[0]
    shouldFillFirstCol = 0 in list(zip(*matrix))[0]

    # Store the information in the first row and the first column.
    for i in range(1, m):
      for j in range(1, n):
        if matrix[i][j] == 0:
          matrix[i][0] = 0
          matrix[0][j] = 0

    # Fill 0s for the matrix except the first row and the first column.
    for i in range(1, m):
      for j in range(1, n):
        if matrix[i][0] == 0 or matrix[0][j] == 0:
          matrix[i][j] = 0

    # Fill 0s for the first row if needed.
    if shouldFillFirstRow:
      matrix[0] = [0] * n

    # Fill 0s for the first column if needed.
    if shouldFillFirstCol:
      for row in matrix:
        row[0] = 0"
"730","class Solution:
  def countPalindromicSubsequences(self, s: str) -> int:
    kMod = 1_000_000_007
    n = len(s)
    # dp[i][j] := the number of different non-empty palindromic subsequences in
    # s[i..j]
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          lo = i + 1
          hi = j - 1
          while lo <= hi and s[lo] != s[i]:
            lo += 1
          while lo <= hi and s[hi] != s[i]:
            hi -= 1
          if lo > hi:
            dp[i][j] = dp[i + 1][j - 1] * 2 + 2
          elif lo == hi:
            dp[i][j] = dp[i + 1][j - 1] * 2 + 1
          else:
            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]
        else:
          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]
        dp[i][j] = (dp[i][j] + kMod) % kMod

    return dp[0][n - 1]"
"731","class MyCalendarTwo {
  public boolean book(int start, int end) {
    for (int[] overlap : overlaps)
      if (Math.max(start, overlap[0]) < Math.min(end, overlap[1]))
        return false;

    for (int[] range : ranges) {
      final int maxStart = Math.max(start, range[0]);
      final int minEnd = Math.min(end, range[1]);
      if (maxStart < minEnd)
        overlaps.add(new int[] {maxStart, minEnd});
    }

    ranges.add(new int[] {start, end});
    return true;
  }

  List<int[]> ranges = new ArrayList<>();
  List<int[]> overlaps = new ArrayList<>();
}"
"732","from sortedcontainers import SortedDict


class MyCalendarThree:
  def __init__(self):
    self.timeline = SortedDict()

  def book(self, start: int, end: int) -> int:
    self.timeline[start] = self.timeline.get(start, 0) + 1
    self.timeline[end] = self.timeline.get(end, 0) - 1

    ans = 0
    activeEvents = 0

    for count in self.timeline.values():
      activeEvents += count
      ans = max(ans, activeEvents)

    return ans"
"733","class Solution:
  def floodFill(self, image: list[list[int]],
                sr: int, sc: int, newColor: int) -> list[list[int]]:
    startColor = image[sr][sc]
    seen = set()

    def dfs(i: int, j: int) -> None:
      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):
        return
      if image[i][j] != startColor or (i, j) in seen:
        return

      image[i][j] = newColor
      seen.add((i, j))

      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    dfs(sr, sc)
    return image"
"734","class Solution:
  def areSentencesSimilar(
      self,
      sentence1: list[str],
      sentence2: list[str],
      similarPairs: list[list[str]],
  ) -> bool:
    if len(sentence1) != len(sentence2):
      return False

    # map[key] := all the similar words of key
    map = collections.defaultdict(set)

    for a, b in similarPairs:
      map[a].add(b)
      map[b].add(a)

    for word1, word2 in zip(sentence1, sentence2):
      if word1 == word2:
        continue
      if word1 not in map:
        return False
      if word2 not in map[word1]:
        return False

    return True"
"735","class Solution:
  def asteroidCollision(self, asteroids: list[int]) -> list[int]:
    stack = []

    for a in asteroids:
      if a > 0:
        stack.append(a)
      else:  # a < 0
        # Destroy the previous positive one(s).
        while stack and stack[-1] > 0 and stack[-1] < -a:
          stack.pop()
        if not stack or stack[-1] < 0:
          stack.append(a)
        elif stack[-1] == -a:
          stack.pop()  # Both asteroids explode.
        else:  # stack[-1] > the current asteroid.
          pass  # Destroy the current asteroid, so do nothing.

    return stack"
"736","class Solution:
  def evaluate(self, expression: str) -> int:
    def evaluate(e: str, prevScope: dict) -> int:
      if e[0].isdigit() or e[0] == '-':
        return int(e)
      if e in prevScope:
        return prevScope[e]

      scope = prevScope.copy()
      nextExpression = e[e.index(' ') + 1:-1]
      tokens = parse(nextExpression)

      if e[1] == 'm':  # 'mult'
        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)
      if e[1] == 'a':  # 'add'
        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)

      # 'let'
      for i in range(0, len(tokens) - 2, 2):
        scope[tokens[i]] = evaluate(tokens[i + 1], scope)

      return evaluate(tokens[-1], scope)

    def parse(e: str):
      tokens = []
      s = ''
      opened = 0

      for c in e:
        if c == '(':
          opened += 1
        elif c == ')':
          opened -= 1
        if opened == 0 and c == ' ':
          tokens.append(s)
          s = ''
        else:
          s += c

      if len(s) > 0:
        tokens.append(s)
      return tokens

    return evaluate(expression, {})"
"737","class Solution:
  def areSentencesSimilarTwo(
      self,
      words1: list[str],
      words2: list[str],
      pairs: list[list[str]],
  ) -> bool:
    if len(words1) != len(words2):
      return False

    # graph[key] := all the similar words of key
    graph = collections.defaultdict(set)

    for a, b in pairs:
      graph[a].add(b)
      graph[b].add(a)

    def dfs(word1: str, word2: str, seen: set) -> bool:
      if word1 in graph[word2]:
        return True

      seen.add(word1)

      for child in graph[word1]:
        if child in seen:
          continue
        if dfs(child, word2, seen):
          return True

      return False

    for word1, word2 in zip(words1, words2):
      if word1 == word2:
        continue
      if word1 not in graph:
        return False
      if not dfs(word1, word2, set()):
        return False

    return True"
"738","class Solution {
 public:
  int monotoneIncreasingDigits(int n) {
    string s = to_string(n);
    const int n = s.length();
    int k = n;  // s[k..n) -> '9'

    for (int i = n - 1; i > 0; --i)
      if (s[i] < s[i - 1]) {
        --s[i - 1];
        k = i;
      }

    for (int i = k; i < n; ++i)
      s[i] = '9';

    return stoi(s);
  }
};"
"739","class Solution:
  def dailyTemperatures(self, temperatures: list[int]) -> list[int]:
    ans = [0] * len(temperatures)
    stack = []  # a decreasing stack

    for i, temperature in enumerate(temperatures):
      while stack and temperature > temperatures[stack[-1]]:
        index = stack.pop()
        ans[index] = i - index
      stack.append(i)

    return ans"
"74","class Solution:
  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:
    if not matrix:
      return False

    m = len(matrix)
    n = len(matrix[0])
    l = 0
    r = m * n

    while l < r:
      mid = (l + r) // 2
      i = mid // n
      j = mid % n
      if matrix[i][j] == target:
        return True
      if matrix[i][j] < target:
        l = mid + 1
      else:
        r = mid

    return False"
"740","class Solution {
 public:
  int deleteAndEarn(vector<int>& nums) {
    // Reduce to 198. House Robber
    vector<int> bucket(10001);

    for (const int num : nums)
      bucket[num] += num;

    int prev1 = 0;
    int prev2 = 0;

    for (const int num : bucket) {
      const int dp = max(prev1, prev2 + num);
      prev2 = prev1;
      prev1 = dp;
    }

    return prev1;
  }
};"
"741","class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    // The problem is identical as two people start picking cherries from
    // grid[0][0] simultaneously.
    const int n = grid.size();
    vector<vector<vector<int>>> mem(
        n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INT_MIN)));
    return max(0, cherryPickup(grid, 0, 0, 0, mem));
  }

 private:
  // Returns the maximum cherries we could pick from g[0][0] ->
  // g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1], where y2 = x1 + y1 - x2
  // (reducing states from 4 to 3).
  int cherryPickup(const vector<vector<int>>& grid, int x1, int y1, int x2,
                   vector<vector<vector<int>>>& mem) {
    const int n = grid.size();
    const int y2 = x1 + y1 - x2;
    if (x1 == n || y1 == n || x2 == n || y2 == n)
      return -1;
    if (x1 == n - 1 && y1 == n - 1)
      return grid[x1][y1];
    if (grid[x1][y1] == -1 || grid[x2][y2] == -1)
      return -1;
    int& res = mem[x1][y1][x2];
    if (mem[x1][y1][x2] > INT_MIN)
      return res;

    res = max({cherryPickup(grid, x1 + 1, y1, x2, mem),
               cherryPickup(grid, x1 + 1, y1, x2 + 1, mem),
               cherryPickup(grid, x1, y1 + 1, x2, mem),
               cherryPickup(grid, x1, y1 + 1, x2 + 1, mem)});
    if (res == -1)
      return res;

    res += grid[x1][y1];  // Pick some cherries.
    if (x1 != x2)         // Two people are on the different grids.
      res += grid[x2][y2];

    return res;
  }
};"
"742","class Solution {
 public:
  int findClosestLeaf(TreeNode* root, int k) {
    int ans = -1;
    int minDist = 1000;
    // {node: distance to TreeNode(k)}
    unordered_map<TreeNode*, int> nodeToDist;

    getDists(root, k, nodeToDist);
    getClosestLeaf(root, 0, nodeToDist, minDist, ans);

    return ans;
  }

 private:
  void getDists(TreeNode* root, int k,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root->val == k) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {
      // The TreeNode(k) is in the left subtree.
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())
      // The TreeNode(k) is in the right subtree.
      nodeToDist[root] = it->second + 1;
  }

  void getClosestLeaf(TreeNode* root, int dist,
                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,
                      int& ans) {
    if (root == nullptr)
      return;
    if (nodeToDist.contains(root))
      dist = nodeToDist[root];
    if (root->left == nullptr && root->right == nullptr) {
      if (dist < minDist) {
        minDist = dist;
        ans = root->val;
      }
      return;
    }

    getClosestLeaf(root->left, dist + 1, nodeToDist, minDist, ans);
    getClosestLeaf(root->right, dist + 1, nodeToDist, minDist, ans);
  }
};"
"743","class Solution:
  def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in times:
      graph[u - 1].append((v - 1, w))

    return self._dijkstra(graph, k - 1)

  def _dijkstra(self, graph: list[list[tuple[int, int]]], src: int) -> int:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    maxDist = max(dist)
    return maxDist if maxDist != math.inf else -1"
"744","class Solution:
  def nextGreatestLetter(self, letters: list[str], target: str) -> str:
    l = bisect.bisect_right(range(len(letters)), target,
                            key=lambda m: letters[m])
    return letters[l % len(letters)]"
"745","class WordFilter {
 public:
  WordFilter(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      vector<string> prefixes;
      vector<string> suffixes;
      for (int j = 0; j <= word.length(); ++j) {
        const string prefix = word.substr(0, j);
        const string suffix = word.substr(j);
        prefixes.push_back(prefix);
        suffixes.push_back(suffix);
      }
      for (const string& prefix : prefixes)
        for (const string& suffix : suffixes)
          keyToIndex[prefix + '_' + suffix] = i;
    }
  }

  int f(string prefix, string suffix) {
    const string key = prefix + '_' + suffix;
    if (const auto it = keyToIndex.find(key); it != keyToIndex.cend())
      return it->second;
    return -1;
  }

 private:
  unordered_map<string, int> keyToIndex;
};"
"746","class Solution:
  def minCostClimbingStairs(self, cost: list[int]) -> int:
    cost.append(0)

    for i in range(2, len(cost)):
      cost[i] += min(cost[i - 1], cost[i - 2])

    return cost[-1]"
"747","class Solution:
  def dominantIndex(self, nums: list[int]) -> int:
    mx = 0
    secondMax = 0

    for i, num in enumerate(nums):
      if num > mx:
        secondMax = mx
        mx = num
        ans = i
      elif num > secondMax:
        secondMax = num

    return ans if mx >= 2 * secondMax else -1"
"748","class Solution:
  def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:
    def isMatch(word: str) -> bool:
      wordCount = collections.Counter(word)
      return False if any(
          wordCount[i] < count[i] for i in string.ascii_letters) else True

    ans = '*' * 16
    count = collections.defaultdict(int)

    for c in licensePlate:
      if c.isalpha():
        count[c.lower()] += 1

    for word in words:
      if len(word) < len(ans) and isMatch(word):
        ans = word

    return ans"
"749","class Region {
  // Given m = the number of rows and n = the number of columns, (x, y) will be
  // hashed as x * n + y.
  public Set<Integer> infected = new HashSet<>();
  public Set<Integer> noninfected = new HashSet<>();
  public int wallsRequired = 0;
}

class Solution {
  public int containVirus(int[][] isInfected) {
    final int m = isInfected.length;
    final int n = isInfected[0].length;
    int ans = 0;

    while (true) {
      List<Region> regions = new ArrayList<>();
      boolean[][] seen = new boolean[m][n];

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (isInfected[i][j] == 1 && !seen[i][j]) {
            Region region = new Region();
            // Use DFS to find all the regions (1s).
            dfs(isInfected, i, j, region, seen);
            if (!region.noninfected.isEmpty())
              regions.add(region);
          }

      if (regions.isEmpty())
        break; // No region causes further infection.

      // Regions that infect the most neighbors will be sorted to the back of
      // the array.
      Collections.sort(regions, (a, b) -> a.noninfected.size() - b.noninfected.size());

      // Build walls around the region that infects the most neighbors.
      Region mostInfectedRegion = regions.get(regions.size() - 1);
      regions.remove(regions.size() - 1);
      ans += mostInfectedRegion.wallsRequired;

      for (final int neighbor : mostInfectedRegion.infected) {
        final int i = neighbor / n;
        final int j = neighbor % n;
        // The isInfected is now contained and won't be infected anymore.
        isInfected[i][j] = 2;
      }

      // For remaining regions, infect their neighbors.
      for (final Region region : regions)
        for (final int neighbor : region.noninfected) {
          final int i = neighbor / n;
          final int j = neighbor % n;
          isInfected[i][j] = 1;
        }
    }

    return ans;
  }

  private void dfs(int[][] isInfected, int i, int j, Region region, boolean[][] seen) {
    if (i < 0 || i == isInfected.length || j < 0 || j == isInfected[0].length)
      return;
    if (seen[i][j] || isInfected[i][j] == 2)
      return;
    if (isInfected[i][j] == 0) {
      region.noninfected.add(i * isInfected[0].length + j);
      ++region.wallsRequired;
      return;
    }

    // isInfected[i][j] == 1
    seen[i][j] = true;
    region.infected.add(i * isInfected[0].length + j);

    dfs(isInfected, i + 1, j, region, seen);
    dfs(isInfected, i - 1, j, region, seen);
    dfs(isInfected, i, j + 1, region, seen);
    dfs(isInfected, i, j - 1, region, seen);
  }
}"
"75","class Solution:
  def sortColors(self, nums: list[int]) -> None:
    l = 0  # The next 0 should be placed in l.
    r = len(nums) - 1  # THe next 2 should be placed in r.

    i = 0
    while i <= r:
      if nums[i] == 0:
        nums[i], nums[l] = nums[l], nums[i]
        i += 1
        l += 1
      elif nums[i] == 1:
        i += 1
      else:
        # We may swap a 0 to index i, but we're still not sure whether this 0
        # is placed in the correct index, so we can't move pointer i.
        nums[i], nums[r] = nums[r], nums[i]
        r -= 1"
"750","class Solution {
 public:
  int countCornerRectangles(vector<vector<int>>& grid) {
    int ans = 0;

    for (int row1 = 0; row1 < grid.size() - 1; ++row1)
      for (int row2 = row1 + 1; row2 < grid.size(); ++row2) {
        int count = 0;
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[row1][j] && grid[row2][j])
            ++count;
        ans += count * (count - 1) / 2;
      }

    return ans;
  }
};"
"751","class Solution:
  def ipToCIDR(self, ip: str, n: int) -> list[str]:
    ans = []
    num = self._getNum(ip.split('.'))

    while n > 0:
      lowbit = num & -num
      count = self._maxLow(n) if lowbit == 0 else self._firstFit(lowbit, n)
      ans.append(self._getCIDR(num, self._getPrefix(count)))
      n -= count
      num += count

    return ans

  def _getNum(self, x: list[str]) -> int:
    num = 0
    for i in range(4):
      num = num * 256 + int(x[i])
    return num

  def _maxLow(self, n: int) -> int | None:
    """"""Returns the maximum i s.t. 2^i < n.""""""
    for i in range(32):
      if 1 << i + 1 > n:
        return 1 << i

  def _firstFit(self, lowbit: int, n: int) -> int:
    while lowbit > n:
      lowbit >>= 1
    return lowbit

  def _getCIDR(self, num: int, prefix: int) -> str:
    d = num & 255
    num >>= 8
    c = num & 255
    num >>= 8
    b = num & 255
    num >>= 8
    a = num & 255
    return '.'.join([str(s) for s in [a, b, c, d]]) + '/' + str(prefix)

  def _getPrefix(self, count: int) -> int | None:
    """"""
    e.g. count = 8 = 2^3 . prefix = 32 - 3 = 29
         count = 1 = 2^0 . prefix = 32 - 0 = 32
    """"""
    for i in range(32):
      if count == 1 << i:
        return 32 - i"
"752","class Solution {
 public:
  int openLock(vector<string>& deadends, string target) {
    unordered_set<string> seen{deadends.begin(), deadends.end()};
    if (seen.contains(""0000""))
      return -1;
    if (target == ""0000"")
      return 0;

    queue<string> q{{""0000""}};

    for (int step = 1; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
          const char cache = word[i];
          // Increase the i-th digit by 1.
          word[i] = word[i] == '9' ? '0' : word[i] + 1;
          if (word == target)
            return step;
          if (!seen.contains(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
          // Decrease the i-th digit by 1.
          word[i] = word[i] == '0' ? '9' : word[i] - 1;
          if (word == target)
            return step;
          if (!seen.contains(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
        }
      }

    return -1;
  }
};"
"753","class Solution:
  def crackSafe(self, n: int, k: int) -> str:
    passwordSize = k**n
    path = '0' * n
    seen = set()
    seen.add(path)

    def dfs(path: str) -> str:
      if len(seen) == passwordSize:
        return path

      for c in map(str, range(k)):
        node = path[-n + 1:] + c if n > 1 else c
        if node not in seen:
          seen.add(node)
          res = dfs(path + c)
          if res:
            return res
          seen.remove(node)

    return dfs(path)"
"754","class Solution:
  def reachNumber(self, target: int) -> int:
    ans = 0
    pos = 0
    target = abs(target)

    while pos < target:
      ans += 1
      pos += ans

    while (pos - target) % 2 == 1:
      ans += 1
      pos += ans

    return ans"
"755","class Solution:
  def pourWater(self, heights: list[int], volume: int, k: int) -> list[int]:
    i = k

    while volume > 0:
      volume -= 1
      while i > 0 and heights[i] >= heights[i - 1]:
        i -= 1
      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:
        i += 1
      while i > k and heights[i] == heights[i - 1]:
        i -= 1
      heights[i] += 1

    return heights"
"756","class Solution:
  def pyramidTransition(self, bottom: str, allowed: list[str]) -> bool:
    prefixToBlocks = collections.defaultdict(list)

    for a in allowed:
      prefixToBlocks[a[:2]].append(a[2])

    def dfs(row: str, nextRow: str, i: int) -> bool:
      if len(row) == 1:
        return True
      if len(nextRow) + 1 == len(row):
        return dfs(nextRow, '', 0)

      for c in prefixToBlocks[row[i:i + 2]]:
        if dfs(row, nextRow + c, i + 1):
          return True

      return False

    return dfs(bottom, '', 0)"
"757","class Solution {
 public:
  int intersectionSizeTwo(vector<vector<int>>& intervals) {
    int ans = 0;
    int mx = -1;
    int secondMax = -1;

    ranges::sort(intervals, [](const vector<int>& a, const vector<int>& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
    });

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      // The maximum and the second maximum still satisfy.
      if (mx >= a && secondMax >= a)
        continue;
      if (mx >= a) {  // The maximum still satisfy.
        secondMax = mx;
        mx = b;  // Add b to the set S.
        ans += 1;
      } else {              // The maximum and the second maximum can't satisfy.
        mx = b;             // Add b to the set S.
        secondMax = b - 1;  // Add b - 1 to the set S.
        ans += 2;
      }
    }

    return ans;
  }
};"
"758","class Solution:
  def boldWords(self, words: list[str], s: str) -> str:
    n = len(s)
    ans = []
    # bold[i] := True if s[i] should be bolded
    bold = [0] * n

    boldEnd = -1  # s[i:boldEnd] should be bolded
    for i in range(n):
      for word in words:
        if s[i:].startswith(word):
          boldEnd = max(boldEnd, i + len(word))
      bold[i] = boldEnd > i

    # Construct the string with the bold tags.
    i = 0
    while i < n:
      if bold[i]:
        j = i
        while j < n and bold[j]:
          j += 1
        # s[i..j) should be bolded.
        ans.append('<b>' + s[i:j] + '</b>')
        i = j
      else:
        ans.append(s[i])
        i += 1

    return ''.join(ans)"
"759","class Solution:
  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
    ans = []
    intervals = []

    for s in schedule:
      intervals.extend(s)

    intervals.sort(key=lambda x: x.start)

    prevEnd = intervals[0].end

    for interval in intervals:
      if interval.start > prevEnd:
        ans.append(Interval(prevEnd, interval.start))
      prevEnd = max(prevEnd, interval.end)

    return ans"
"76","class Solution:
  def minWindow(self, s: str, t: str) -> str:
    count = collections.Counter(t)
    required = len(t)
    bestLeft = -1
    minLength = len(s) + 1

    l = 0
    for r, c in enumerate(s):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      while required == 0:
        if r - l + 1 < minLength:
          bestLeft = l
          minLength = r - l + 1
        count[s[l]] += 1
        if count[s[l]] > 0:
          required += 1
        l += 1

    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]"
"760","class Solution:
  def anagramMappings(self, nums1: list[int], nums2: list[int]) -> list[int]:
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums2):
      numToIndices[num].append(i)

    return [numToIndices[num].pop() for num in nums1]"
"761","class Solution:
  def makeLargestSpecial(self, s: str) -> str:
    specials = []
    count = 0

    i = 0
    for j, c in enumerate(s):
      count += 1 if c == '1' else -1
      if count == 0:
        specials.append(
            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')
        i = j + 1

    return ''.join(sorted(specials)[::-1])"
"762","class Solution {
  public int countPrimeSetBits(int left, int right) {
    // {2, 3, 5, 7, 11, 13, 17, 19}-th bits are 1s.
    // 0b10100010100010101100 = 665772
    final int magic = 665772;
    int ans = 0;

    for (int num = left; num <= right; ++num)
      if ((magic >> Integer.bitCount(num) & 1) == 1)
        ++ans;

    return ans;
  }
}"
"763","class Solution:
  def partitionLabels(self, s: str) -> list[int]:
    ans = []
    letterToRightmostIndex = {c: i for i, c in enumerate(s)}

    l = 0  # the leftmost index of the current running string
    r = 0  # the rightmost index of the current running string

    for i, c in enumerate(s):
      r = max(r, letterToRightmostIndex[c])
      if i == r:
        ans.append(r - l + 1)
        l = r + 1

    return ans"
"764","class Solution {
 public:
  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    vector<vector<int>> grid(n, vector<int>(n, n));

    for (const vector<int>& mine : mines)
      grid[mine[0]][mine[1]] = 0;

    // Extend the four directions. If meet 0, need to start over from 0.
    for (int i = 0; i < n; ++i) {
      for (int j = 0, leftToRight = 0; j < n; ++j) {
        leftToRight = (grid[i][j] == 0 ? 0 : leftToRight + 1);
        grid[i][j] = min(grid[i][j], leftToRight);
      }
      for (int j = n - 1, rightToLeft = 0; j >= 0; --j) {
        rightToLeft = (grid[i][j] == 0 ? 0 : rightToLeft + 1);
        grid[i][j] = min(grid[i][j], rightToLeft);
      }
      for (int j = 0, upToDown = 0; j < n; ++j) {
        upToDown = (grid[j][i] == 0 ? 0 : upToDown + 1);
        grid[j][i] = min(grid[j][i], upToDown);
      }
      for (int j = n - 1, downToUp = 0; j >= 0; --j) {
        downToUp = (grid[j][i] == 0) ? 0 : downToUp + 1;
        grid[j][i] = min(grid[j][i], downToUp);
      }
    }

    int ans = 0;

    for (const vector<int>& row : grid)
      ans = max(ans, ranges::max(row));

    return ans;
  }
};"
"765","class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int minSwapsCouples(vector<int>& row) {
    const int n = row.size() / 2;
    UnionFind uf(n);

    for (int i = 0; i < n; ++i) {
      const int a = row[2 * i];
      const int b = row[2 * i + 1];
      uf.unionByRank(a / 2, b / 2);
    }

    return n - uf.getCount();
  }
};"
"766","class Solution:
  def isToeplitzMatrix(self, matrix: list[list[int]]) -> bool:
    for i in range(len(matrix) - 1):
      for j in range(len(matrix[0]) - 1):
        if matrix[i][j] != matrix[i + 1][j + 1]:
          return False

    return True"
"767","class Solution:
  def reorganizeString(self, s: str) -> str:
    count = collections.Counter(s)
    if max(count.values()) > (len(s) + 1) // 2:
      return ''

    ans = []
    maxHeap = [(-freq, c) for c, freq in count.items()]
    heapq.heapify(maxHeap)
    prevFreq = 0
    prevChar = '@'

    while maxHeap:
      # Get the letter with the maximum frequency.
      freq, c = heapq.heappop(maxHeap)
      ans.append(c)
      # Add the previous letter back s.t. any two adjacent characters are not
      # the same.
      if prevFreq < 0:
        heapq.heappush(maxHeap, (prevFreq, prevChar))
      prevFreq = freq + 1
      prevChar = c

    return ''.join(ans)"
"768","class Solution:
  def maxChunksToSorted(self, arr: list[int]) -> int:
    n = len(arr)
    ans = 0
    mx = -math.inf
    mn = [arr[-1]] * n

    for i in reversed(range(n - 1)):
      mn[i] = min(mn[i + 1], arr[i])

    for i in range(n - 1):
      mx = max(mx, arr[i])
      if mx <= mn[i + 1]:
        ans += 1

    return ans + 1"
"769","class Solution:
  def maxChunksToSorted(self, arr: list[int]) -> int:
    ans = 0
    mx = -math.inf

    for i, a in enumerate(arr):
      mx = max(mx, a)
      if mx == i:
        ans += 1

    return ans"
"77","class Solution:
  def combine(self, n: int, k: int) -> list[list[int]]:
    ans = []

    def dfs(s: int, path: list[int]) -> None:
      if len(path) == k:
        ans.append(path.copy())
        return

      for i in range(s, n + 1):
        path.append(i)
        dfs(i + 1, path)
        path.pop()

    dfs(1, [])
    return ans"
"770","class Poly:
  def __init__(self, term: str = None, coef: int = None):
    if term and coef:
      self.terms = collections.Counter({term: coef})
    else:
      self.terms = collections.Counter()

  def __add__(self, other):
    for term, coef in other.terms.items():
      self.terms[term] += coef
    return self

  def __sub__(self, other):
    for term, coef in other.terms.items():
      self.terms[term] -= coef
    return self

  def __mul__(self, other):
    res = Poly()
    for a, aCoef in self.terms.items():
      for b, bCoef in other.terms.items():
        res.terms[self._merge(a, b)] += aCoef * bCoef
    return res

  # Def __str__(self):
  #   res = []
  #   for term, coef in self.terms.items():
  #     res.append(term + ': ' + str(coef))
  #   return '{' + ', '.join(res) + '}'

  def toList(self) -> list[str]:
    for term in list(self.terms.keys()):
      if not self.terms[term]:
        del self.terms[term]

    def cmp(term: str) -> tuple:
      # the minimum degree is the last
      if term == '1':
        return (0,)
      var = term.split('*')
      # the maximum degree is the first
      # Break ties by their lexicographic orders.
      return (-len(var), term)

    def concat(term: str) -> str:
      if term == '1':
        return str(self.terms[term])
      return str(self.terms[term]) + '*' + term

    terms = list(self.terms.keys())
    terms.sort(key=cmp)
    return [concat(term) for term in terms]

  def _merge(self, a: str, b: str) -> str:
    if a == '1':
      return b
    if b == '1':
      return a
    res = []
    A = a.split('*')
    B = b.split('*')
    i = 0  # A's index
    j = 0  # B's index
    while i < len(A) and j < len(B):
      if A[i] < B[j]:
        res.append(A[i])
        i += 1
      else:
        res.append(B[j])
        j += 1
    return '*'.join(res + A[i:] + B[j:])


class Solution:
  def basicCalculatorIV(
      self,
      expression: str,
      evalvars: list[str],
      evalints: list[int],
  ) -> list[str]:
    tokens = list(self._getTokens(expression))
    evalMap = {a: b for a, b in zip(evalvars, evalints)}

    for i, token in enumerate(tokens):
      if token in evalMap:
        tokens[i] = str(evalMap[token])

    postfix = self._infixToPostfix(tokens)
    return self._evaluate(postfix).toList()

  def _getTokens(self, s: str) -> Iterator[str]:
    i = 0
    for j, c in enumerate(s):
      if c == ' ':
        if i < j:
          yield s[i:j]
        i = j + 1
      elif c in '()+-*':
        if i < j:
          yield s[i:j]
        yield c
        i = j + 1
    if i < len(s):
      yield s[i:]

  def _infixToPostfix(self, tokens: list[str]) -> list[str]:
    postfix = []
    ops = []

    def precedes(prevOp: str, currOp: str) -> bool:
      if prevOp == '(':
        return False
      return prevOp == '*' or currOp in '+-'

    for token in tokens:
      if token == '(':
        ops.append(token)
      elif token == ')':
        while ops[-1] != '(':
          postfix.append(ops.pop())
        ops.pop()
      elif token in '+-*':  # isOperator(token)
        while ops and precedes(ops[-1], token):
          postfix.append(ops.pop())
        ops.append(token)
      else:  # isOperand(token)
        postfix.append(token)
    return postfix + ops[::-1]

  def _evaluate(self, postfix: list[str]) -> Poly:
    polys: list[Poly] = []
    for token in postfix:
      if token in '+-*':
        b = polys.pop()
        a = polys.pop()
        if token == '+':
          polys.append(a + b)
        elif token == '-':
          polys.append(a - b)
        else:  # token == '*'
          polys.append(a * b)
      elif token.lstrip('-').isnumeric():
        polys.append(Poly(""1"", int(token)))
      else:
        polys.append(Poly(token, 1))
    return polys[0]"
"771","class Solution:
  def numJewelsInStones(self, jewels: str, stones: str) -> int:
    jewelsSet = set(jewels)
    return sum(stone in jewelsSet for stone in stones)"
"772","class Solution:
  def calculate(self, s: str) -> int:
    nums = []
    ops = []

    def calc():
      b = nums.pop()
      a = nums.pop()
      op = ops.pop()
      if op == '+':
        nums.append(a + b)
      elif op == '-':
        nums.append(a - b)
      elif op == '*':
        nums.append(a * b)
      else:  # op == '/'
        nums.append(int(a / b))

    def precedes(prev: str, curr: str) -> bool:
      """"""
      Returns True if the previous character is a operator and the priority of
      the previous operator >= the priority of the current character (operator).
      """"""
      if prev == '(':
        return False
      return prev in '*/' or curr in '+-'

    i = 0
    hasPrevNum = False

    while i < len(s):
      c = s[i]
      if c.isdigit():
        num = int(c)
        while i + 1 < len(s) and s[i + 1].isdigit():
          num = num * 10 + int(s[i + 1])
          i += 1
        nums.append(num)
        hasPrevNum = True
      elif c == '(':
        ops.append('(')
        hasPrevNum = False
      elif c == ')':
        while ops[-1] != '(':
          calc()
        ops.pop()  # Pop '('
      elif c in '+-*/':
        if not hasPrevNum:  # Handle input like ""-1-(-1)""
          num.append(0)
        while ops and precedes(ops[-1], c):
          calc()
        ops.append(c)
      i += 1

    while ops:
      calc()

    return nums.pop()"
"773","class Solution {
 public:
  int slidingPuzzle(vector<vector<int>>& board) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    constexpr int m = 2;
    constexpr int n = 3;
    constexpr char goal[] = ""123450"";
    string start;

    // Hash the 2D vector into a string.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        start += '0' + board[i][j];

    if (start == goal)
      return 0;

    queue<string> q{{start}};
    unordered_set<string> seen{start};

    for (int step = 1; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        string s = q.front();
        q.pop();
        const int zeroIndex = s.find('0');
        const int i = zeroIndex / n;
        const int j = zeroIndex % n;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const int swappedIndex = x * n + y;
          swap(s[zeroIndex], s[swappedIndex]);
          if (s == goal)
            return step;
          if (!seen.contains(s)) {
            q.push(s);
            seen.insert(s);
          }
          swap(s[zeroIndex], s[swappedIndex]);
        }
      }

    return -1;
  }
};"
"774","class Solution:
  def minmaxGasDist(self, stations: list[int], k: int) -> float:
    kErr = 1e-6
    l = 0
    r = stations[-1] - stations[0]

    def possible(k: int, m: float) -> bool:
      """"""
      Returns True if can use <= k gas stations to ensure that each adjacent
      distance between gas stations <= m.
      """"""
      for a, b in zip(stations, stations[1:]):
        diff = b - a
        if diff > m:
          k -= math.ceil(diff / m) - 1
          if k < 0:
            return False
      return True

    while r - l > kErr:
      m = (l + r) / 2
      if possible(k, m):
        r = m
      else:
        l = m

    return l"
"775","class Solution:
  def isIdealPermutation(self, nums: list[int]) -> bool:
    for i, num in enumerate(nums):
      if abs(num - i) > 1:
        return False
    return True"
"776","class Solution:
  def splitBST(self, root: TreeNode | None, target: int) -> list[TreeNode | None]:
    if not root:
      return None, None
    if root.val > target:
      left, right = self.splitBST(root.left, target)
      root.left = right
      return left, root
    else:  # root.val <= target
      left, right = self.splitBST(root.right, target)
      root.right = left
      return root, right"
"777","class Solution:
  def canTransform(self, start: str, end: str) -> bool:
    if start.replace('X', '') != end.replace('X', ''):
      return False

    i = 0  # start's index
    j = 0  # end's index

    while i < len(start) and j < len(end):
      while i < len(start) and start[i] == 'X':
        i += 1
      while j < len(end) and end[j] == 'X':
        j += 1
      if i == len(start) and j == len(end):
        return True
      if i == len(start) or j == len(end):
        return False
      # L can only move to left.
      if start[i] == 'L' and i < j:
        return False
      # R can only move to right.
      if start[i] == 'R' and i > j:
        return False
      i += 1
      j += 1

    return True"
"778","class Solution {
 public:
  int swimInWater(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int n = grid.size();
    int ans = grid[0][0];
    using T = tuple<int, int, int>;  // (grid[i][j], i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<bool>> seen(n, vector<bool>(n));

    minHeap.emplace(grid[0][0], 0, 0);
    seen[0][0] = true;

    while (!minHeap.empty()) {
      const auto [height, i, j] = minHeap.top();
      minHeap.pop();
      ans = max(ans, height);
      if (i == n - 1 && j == n - 1)
        break;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == n || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        minHeap.emplace(grid[x][y], x, y);
        seen[x][y] = true;
      }
    }

    return ans;
  }
};"
"779","class Solution {
 public:
  int kthGrammar(int n, int k) {
    if (n == 1)
      return 0;
    if (k % 2 == 1)
      return kthGrammar(n - 1, (k + 1) / 2) != 0;  // the left node
    return kthGrammar(n - 1, k / 2) == 0;          // the right node
  }
};"
"78","class Solution:
  def subsets(self, nums: list[int]) -> list[list[int]]:
    ans = []

    def dfs(s: int, path: list[int]) -> None:
      ans.append(path)

      for i in range(s, len(nums)):
        dfs(i + 1, path + [nums[i]])

    dfs(0, [])
    return ans"
"780","class Solution:
  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
    while sx < tx and sy < ty:
      tx, ty = tx % ty, ty % tx

    return (sx == tx and sy <= ty and (ty - sy) % tx == 0 or
            sy == ty and sx <= tx and (tx - sx) % ty == 0)"
"781","class Solution:
  def numRabbits(self, answers: list[int]) -> int:
    ans = 0
    count = collections.Counter()

    for answer in answers:
      if count[answer] % (answer + 1) == 0:
        ans += answer + 1
      count[answer] += 1

    return ans"
"782","class Solution:
  def movesToChessboard(self, board: list[list[int]]) -> int:
    n = len(board)

    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]
           for i in range(n) for j in range(n)):
      return -1

    rowSum = sum(board[0])
    colSum = sum(board[i][0] for i in range(n))

    if rowSum != n // 2 and rowSum != (n + 1) // 2:
      return -1
    if colSum != n // 2 and colSum != (n + 1) // 2:
      return -1

    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))
    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))

    if n % 2 == 1:
      if rowSwaps % 2 == 1:
        rowSwaps = n - rowSwaps
      if colSwaps % 2 == 1:
        colSwaps = n - colSwaps
    else:
      rowSwaps = min(rowSwaps, n - rowSwaps)
      colSwaps = min(colSwaps, n - colSwaps)

    return (rowSwaps + colSwaps) // 2"
"783","class Solution {
 public:
  int minDiffInBST(TreeNode* root) {
    int ans = INT_MAX;
    inorder(root, ans);
    return ans;
  }

 private:
  int pred = -1;

  void inorder(TreeNode* root, int& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, ans);
    if (pred >= 0)
      ans = min(ans, root->val - pred);
    pred = root->val;
    inorder(root->right, ans);
  }
};"
"784","class Solution {
 public:
  vector<string> letterCasePermutation(string s) {
    vector<string> ans;
    dfs(s, 0, ans);
    return ans;
  }

 private:
  void dfs(string& s, int i, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(s);
      return;
    }
    if (isdigit(s[i])) {
      dfs(s, i + 1, ans);
      return;
    }

    s[i] = tolower(s[i]);
    dfs(s, i + 1, ans);
    s[i] = toupper(s[i]);
    dfs(s, i + 1, ans);
  }
};"
"785","from enum import Enum


class Color(Enum):
  kWhite = 0
  kRed = 1
  kGreen = 2


class Solution:
  def isBipartite(self, graph: list[list[int]]) -> bool:
    colors = [Color.kWhite] * len(graph)

    for i in range(len(graph)):
      # This node has been colored, so do nothing.
      if colors[i] != Color.kWhite:
        continue
      # Always paint red for a white node.
      colors[i] = Color.kRed
      # BFS.
      q = collections.deque([i])
      while q:
        for _ in range(len(q)):
          u = q.popleft()
          for v in graph[u]:
            if colors[v] == colors[u]:
              return False
            if colors[v] == Color.kWhite:
              colors[v] = Color.kRed if colors[u] == Color.kGreen else Color.kGreen
              q.append(v)

    return True"
"786","class Solution:
  def kthSmallestPrimeFraction(self, arr: list[int], k: int) -> list[int]:
    n = len(arr)
    ans = [0, 1]
    l = 0
    r = 1

    while True:
      m = (l + r) / 2
      ans[0] = 0
      count = 0
      j = 1

      for i in range(n):
        while j < n and arr[i] > m * arr[j]:
          j += 1
        count += n - j
        if j == n:
          break
        if ans[0] * arr[j] < ans[1] * arr[i]:
          ans[0] = arr[i]
          ans[1] = arr[j]

      if count < k:
        l = m
      elif count > k:
        r = m
      else:
        return ans"
"787","class Solution:
  def findCheapestPrice(
      self,
      n: int,
      flights: list[list[int]],
      src: int,
      dst: int,
      k: int,
  ) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in flights:
      graph[u].append((v, w))

    return self._dijkstra(graph, src, dst, k)

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      dst: int,
      k: int,
  ) -> int:
    dist = [[math.inf] * (k + 2) for _ in range(len(graph))]

    dist[src][k + 1] = 0
    minHeap = [(dist[src][k + 1], src, k + 1)]  # (d, u, stops)

    while minHeap:
      d, u, stops = heapq.heappop(minHeap)
      if u == dst:
        return d
      if stops == 0 or d > dist[u][stops]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v][stops - 1]:
          dist[v][stops - 1] = d + w
          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))

    return -1"
"788","class Solution:
  def rotatedDigits(self, n: int) -> int:
    def isGoodNumber(i: int) -> bool:
      isRotated = False

      for c in str(i):
        if c == '0' or c == '1' or c == '8':
          continue
        if c == '2' or c == '5' or c == '6' or c == '9':
          isRotated = True
        else:
          return False

      return isRotated

    return sum(isGoodNumber(i) for i in range(1, n + 1))"
"789","class Solution:
  def escapeGhosts(self, ghosts: list[list[int]], target: list[int]) -> bool:
    ghostSteps = min(abs(x - target[0]) +
                     abs(y - target[1]) for x, y in ghosts)

    return abs(target[0]) + abs(target[1]) < ghostSteps"
"79","class Solution:
  def exist(self, board: list[list[str]], word: str) -> bool:
    m = len(board)
    n = len(board[0])

    def dfs(i: int, j: int, s: int) -> bool:
      if i < 0 or i == m or j < 0 or j == n:
        return False
      if board[i][j] != word[s] or board[i][j] == '*':
        return False
      if s == len(word) - 1:
        return True

      cache = board[i][j]
      board[i][j] = '*'
      isExist = (dfs(i + 1, j, s + 1) or
                 dfs(i - 1, j, s + 1) or
                 dfs(i, j + 1, s + 1) or
                 dfs(i, j - 1, s + 1))
      board[i][j] = cache

      return isExist

    return any(dfs(i, j, 0)
               for i in range(m)
               for j in range(n))"
"790","class Solution:
  def numTilings(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = [0, 1, 2, 5] + [0] * 997

    for i in range(4, n + 1):
      dp[i] = 2 * dp[i - 1] + dp[i - 3]

    return dp[n] % kMod"
"791","class Solution:
  def customSortString(self, order: str, s: str) -> str:
    ans = """"
    count = [0] * 26

    for c in s:
      count[string.ascii_lowercase.index(c)] += 1

    for c in order:
      while count[string.ascii_lowercase.index(c)] > 0:
        ans += c
        count[string.ascii_lowercase.index(c)] -= 1

    for c in string.ascii_lowercase:
      for _ in range(count[string.ascii_lowercase.index(c)]):
        ans += c

    return ans"
"792","class Solution:
  def numMatchingSubseq(self, s: str, words: list[str]) -> int:
    ans = 0
    # [(i, j)] := words[i] and the letter words[i][j] is waiting for
    bucket = [[] for _ in range(26)]

    # For each word, it's waiting for word[0].
    for i, word in enumerate(words):
      bucket[ord(word[0]) - ord('a')].append((i, 0))

    for c in s:
      # Let prevBucket = bucket[c] and clear bucket[c].
      index = string.ascii_lowercase.index(c)
      prevBucket = bucket[index]
      bucket[index] = []
      for i, j in prevBucket:
        j += 1
        if j == len(words[i]):  # All the letters in words[i] are matched.
          ans += 1
        else:
          bucket[ord(words[i][j]) - ord('a')].append((i, j))

    return ans"
"793","class Solution {
 public:
  int preimageSizeFZF(int k) {
    long l = 0;
    long r = 5L * k;

    while (l < r) {
      const long m = (l + r) / 2;
      if (trailingZeroes(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return trailingZeroes(l) == k ? 5 : 0;
  }

 private:
  // Same as 172. Factorial Trailing Zeroes
  int trailingZeroes(long n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};"
"794","class Solution:
  def validTicTacToe(self, board: list[str]) -> bool:
    def isWin(c: str) -> bool:
      return (any(row.count(c) == 3 for row in board) or
              any(row.count(c) == 3 for row in list(zip(*board))) or
              all(board[i][i] == c for i in range(3)) or
              all(board[i][2 - i] == c for i in range(3)))

    countX = sum(row.count('X') for row in board)
    countO = sum(row.count('O') for row in board)

    if countX < countO or countX - countO > 1:
      return False
    if isWin('X') and countX == countO or isWin('O') and countX != countO:
      return False

    return True"
"795","class Solution:
  def numSubarrayBoundedMax(
      self,
      nums: list[int],
      left: int,
      right: int,
  ) -> int:
    ans = 0
    l = -1
    r = -1

    for i, num in enumerate(nums):
      if num > right:  # Handle the reset value.
        l = i
      if num >= left:  # Handle the reset and the needed value.
        r = i
      ans += r - l

    return ans"
"796","class Solution:
  def rotateString(self, s: str, goal: str) -> bool:
    return len(s) == len(goal) and goal in s + s"
"797","class Solution:
  def allPathsSourceTarget(self, graph: list[list[int]]) -> list[list[int]]:
    ans = []

    def dfs(u: int, path: list[int]) -> None:
      if u == len(graph) - 1:
        ans.append(path)
        return

      for v in graph[u]:
        dfs(v, path + [v])

    dfs(0, [0])
    return ans"
"798","class Solution {
  public int bestRotation(int[] nums) {
    final int n = nums.length;
    // rotate[i] := the number of points lost after rotating left i times
    int[] rotate = new int[n];

    // Rotating i - nums[i] times makes nums[i] == its new index.
    // So, rotating i - nums[i] + 1 times will ""start"" to make nums[i] > its
    // index, which is the starting index to lose point.
    for (int i = 0; i < n; ++i)
      --rotate[(i - nums[i] + 1 + n) % n];

    // Each time of the rotation, make index 0 to index n - 1 to get 1 point.
    for (int i = 1; i < n; ++i)
      rotate[i] += rotate[i - 1] + 1;

    int mx = Integer.MIN_VnumsLUE;
    int maxIndex = 0;

    for (int i = 0; i < n; ++i)
      if (rotate[i] > mx) {
        mx = rotate[i];
        maxIndex = i;
      }

    return maxIndex;
  }
}"
"799","class Solution {
 public:
  double champagneTower(int poured, int query_row, int query_glass) {
    vector<double> dp(query_row + 1);
    dp[0] = poured;

    for (int i = 0; i < query_row; ++i) {
      vector<double> newDp(query_row + 1);
      for (int j = 0; j <= i; ++j)
        if (dp[j] > 1) {
          newDp[j] += (dp[j] - 1) / 2.0;
          newDp[j + 1] += (dp[j] - 1) / 2.0;
        }
      dp = std::move(newDp);
    }

    return min(1.0, dp[query_glass]);
  }
};"
"8","class Solution:
  def myAtoi(self, s: str) -> int:
    s = s.strip()
    if not s:
      return 0

    sign = -1 if s[0] == '-' else 1
    if s[0] in {'-', '+'}:
      s = s[1:]

    num = 0

    for c in s:
      if not c.isdigit():
        break
      num = num * 10 + int(c)
      if sign * num <= -2**31:
        return -2**31
      if sign * num >= 2**31 - 1:
        return 2**31 - 1

    return sign * num"
"80","class Solution:
  def removeDuplicates(self, nums: list[int]) -> int:
    i = 0

    for num in nums:
      if i < 2 or num != nums[i - 2]:
        nums[i] = num
        i += 1

    return i"
"800","class Solution:
  def similarRGB(self, color: str) -> str:
    kShorthands = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',
                   'aa', 'bb', 'cc', 'dd', 'ee', 'ff']
    ans = ['#']

    for i in range(1, len(color), 2):
      currValue = int(color[i:i + 2], 16)
      closestShorthand = min(kShorthands,
                             key=lambda x: (currValue - int(x, 16))**2)
      ans.append(closestShorthand)

    return ''.join(ans)"
"801","class Solution:
  def minSwap(self, nums1: list[int], nums2: list[int]) -> int:
    keepAt = [math.inf] * len(nums1)
    swapAt = [math.inf] * len(nums1)
    keepAt[0] = 0
    swapAt[0] = 1

    for i in range(1, len(nums1)):
      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:
        keepAt[i] = keepAt[i - 1]
        swapAt[i] = swapAt[i - 1] + 1
      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:
        keepAt[i] = min(keepAt[i], swapAt[i - 1])
        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)

    return min(keepAt[-1], swapAt[-1])"
"802","from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:
    states = [State.kInit] * len(graph)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited

    return [i for i in range(len(graph)) if not hasCycle(i)]"
"803","class UnionFind {
  public UnionFind(int n) {
    id = new int[n];
    sz = new int[n];
    for (int i = 0; i < n; ++i)
      id[i] = i;
    Arrays.fill(sz, 1);
  }

  public void unionBySize(int u, int v) {
    final int i = find(u);
    final int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  public int getStableSize() {
    // Bricks connected with 0 (top) are stable.
    return sz[find(0)];
  }

  private int[] id;
  private int[] sz;

  private int find(int u) {
    return id[u] == u ? u : (id[u] = find(id[u]));
  }
}
class Solution {
  public int[] hitBricks(int[][] grid, int[][] hits) {
    this.m = grid.length;
    this.n = grid[0].length;

    UnionFind uf = new UnionFind(m * n + 1); // 0 := top (stable)

    // Mark cells to hit as 2.
    for (int[] hit : hits) {
      final int i = hit[0];
      final int j = hit[1];
      if (grid[i][j] == 1)
        grid[i][j] = 2;
    }

    // Union all the 1s.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          unionNeighbors(grid, uf, i, j);

    int[] ans = new int[hits.length];
    int stableSize = uf.getStableSize();

    for (int i = hits.length - 1; i >= 0; --i) {
      final int x = hits[i][0];
      final int y = hits[i][1];
      if (grid[x][y] == 2) { // cells marked from 1 to 2
        grid[x][y] = 1;      // Unhit and restore it back to 1.
        unionNeighbors(grid, uf, x, y);
        final int newStableSize = uf.getStableSize();
        if (newStableSize > stableSize)
          ans[i] = newStableSize - stableSize - 1; // 1 := the hit cell
        stableSize = newStableSize;
      }
    }

    return ans;
  }

  private int m;
  private int n;
  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  private void unionNeighbors(int[][] grid, UnionFind uf, int i, int j) {
    final int hash = getHash(i, j);

    for (int[] dir : dirs) {
      final int x = i + dir[0];
      final int y = j + dir[1];
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (grid[x][y] != 1)
        continue;
      uf.unionBySize(hash, getHash(x, y));
    }

    if (i == 0)
      uf.unionBySize(hash, 0);
  }

  private int getHash(int i, int j) {
    return i * n + j + 1;
  }
}"
"804","class Solution:
  def uniqueMorseRepresentations(self, words: list[str]) -> int:
    morse = ["".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."", ""...."", "".."",
             "".---"", ""-.-"", "".-.."", ""--"", ""-."", ""---"", "".--."", ""--.-"", "".-."",
             ""..."", ""-"", ""..-"", ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""]
    transformations = set()

    for word in words:
      transformation = ''.join(
          morse[string.ascii_lowercase.index(c)] for c in word)
      transformations.add(transformation)

    return len(transformations)"
"805","class Solution:
  def splitArraySameAverage(self, nums: list[int]) -> bool:
    n = len(nums)
    summ = sum(nums)
    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):
      return False

    sums = [set() for _ in range(n // 2 + 1)]
    sums[0].add(0)

    for num in nums:
      for i in range(n // 2, 0, -1):
        for val in sums[i - 1]:
          sums[i].add(num + val)

    for i in range(1, n // 2 + 1):
      if i * summ % n == 0 and i * summ // n in sums[i]:
        return True

    return False"
"806","class Solution:
  def numberOfLines(self, widths: list[int], s: str) -> list[int]:
    numLines = 1
    runningWidth = 0

    for c in s:
      width = widths[string.ascii_lowercase.index(c)]
      if runningWidth + width <= 100:
        runningWidth += width
      else:
        numLines += 1
        runningWidth = width

    return [numLines, runningWidth]"
"807","class Solution:
  def maxIncreaseKeepingSkyline(self, grid: list[list[int]]) -> int:
    rowMax = list(map(max, grid))
    colMax = list(map(max, zip(*grid)))
    return sum(min(i, j) for i in rowMax for j in colMax) - sum(map(sum, grid))"
"808","class Solution:
  def soupServings(self, n: int) -> float:
    @functools.lru_cache(None)
    def dfs(a: int, b: int) -> float:
      if a <= 0 and b <= 0:
        return 0.5
      if a <= 0:
        return 1.0
      if b <= 0:
        return 0.0
      return 0.25 * (dfs(a - 4, b) +
                     dfs(a - 3, b - 1) +
                     dfs(a - 2, b - 2) +
                     dfs(a - 1, b - 3))

    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)"
"809","class Solution:
  def expressiveWords(self, s: str, words: list[str]) -> int:
    def isStretchy(word: str) -> bool:
      n = len(s)
      m = len(word)

      j = 0
      for i in range(n):
        if j < m and s[i] == word[j]:
          j += 1
        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:
          continue
        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:
          continue
        else:
          return False

      return j == m

    return sum(isStretchy(word) for word in words)"
"81","class Solution:
  def search(self, nums: list[int], target: int) -> bool:
    l = 0
    r = len(nums) - 1

    while l <= r:
      m = (l + r) // 2
      if nums[m] == target:
        return True
      if nums[l] == nums[m] == nums[r]:
        l += 1
        r -= 1
      elif nums[l] <= nums[m]:  # nums[l..m] are sorted
        if nums[l] <= target < nums[m]:
          r = m - 1
        else:
          l = m + 1
      else:  # nums[m..n - 1] are sorted
        if nums[m] < target <= nums[r]:
          l = m + 1
        else:
          r = m - 1

    return False"
"810","class Solution:
  def xorGame(self, nums: list[int]) -> bool:
    return functools.reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0"
"811","class Solution:
  def subdomainVisits(self, cpdomains: list[str]) -> list[str]:
    ans = []
    count = collections.Counter()

    for cpdomain in cpdomains:
      num, domains = cpdomain.split()
      num, domains = int(num), domains.split('.')
      for i in reversed(range(len(domains))):
        count['.'.join(domains[i:])] += num

    return [str(freq) + ' ' + domain for domain, freq in count.items()]"
"812","class Solution:
  def largestTriangleArea(self, points: list[list[int]]) -> float:
    ans = 0

    for Ax, Ay in points:
      for Bx, By in points:
        for Cx, Cy in points:
          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -
                                   (Cx - Ax) * (By - Ay)))

    return ans"
"813","class Solution {
 public:
  double largestSumOfAverages(vector<int>& nums, int K) {
    const int n = nums.size();
    // dp[i][k] := the maximum score to partition the first i nums into k groups
    vector<vector<double>> dp(n + 1, vector<double>(K + 1));
    vector<double> prefix(n + 1);

    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);

    for (int i = 1; i <= n; ++i)
      dp[i][1] = prefix[i] / i;

    for (int k = 2; k <= K; ++k)
      for (int i = k; i <= n; ++i)
        for (int j = k - 1; j < i; ++j) {
          const double average = (prefix[i] - prefix[j]) / (i - j);
          dp[i][k] = max(dp[i][k], dp[j][k - 1] + average);
        }

    return dp[n][K];
  }
};"
"814","class Solution:
  def pruneTree(self, root: TreeNode | None) -> TreeNode | None:
    if not root:
      return None
    root.left = self.pruneTree(root.left)
    root.right = self.pruneTree(root.right)
    if not root.left and not root.right and not root.val:
      return None
    return root"
"815","class Solution:
  def numBusesToDestination(
      self,
      routes: list[list[int]],
      source: int,
      target: int,
  ) -> int:
    if source == target:
      return 0

    graph = collections.defaultdict(list)
    usedBuses = set()

    for i in range(len(routes)):
      for route in routes[i]:
        graph[route].append(i)

    q = collections.deque([source])

    step = 1
    while q:
      for _ in range(len(q)):
        for bus in graph[q.popleft()]:
          if bus in usedBuses:
            continue
          usedBuses.add(bus)
          for nextRoute in routes[bus]:
            if nextRoute == target:
              return step
            q.append(nextRoute)
      step += 1

    return -1"
"816","class Solution:
  def ambiguousCoordinates(self, s: str) -> list[str]:
    def splits(s: str) -> list[str]:
      if not s or len(s) > 1 and s[0] == s[-1] == '0':
        return []
      if s[-1] == '0':
        return [s]
      if s[0] == '0':
        return [s[0] + '.' + s[1:]]
      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]

    ans = []
    s = s[1:-1]

    for i in range(1, len(s)):
      for x in splits(s[:i]):
        for y in splits(s[i:]):
          ans.append('(%s, %s)' % (x, y))

    return ans"
"817","class Solution:
  def numComponents(self, head: ListNode | None, nums: list[int]) -> int:
    ans = 0
    numsSet = set(nums)

    while head:
      if head.val in numsSet and (
              head.next == None or head.next.val not in numsSet):
        ans += 1
      head = head.next

    return ans"
"818","class Solution {
  public int racecar(int target) {
    int[] mem = new int[target + 1];
    Arrays.fill(mem, -1);
    return racecar(target, mem);
  }

  private int racecar(int i, int[] mem) {
    if (mem[i] >= 0)
      return mem[i];

    int res = Integer.MAX_VALUE;
    int x = 1;            // xA := (2^x - 1) unit distance
    int j = (1 << x) - 1; // j = 2^x - 1, k = 2^y - 1

    // (xA + 1R) + (yA + 1R) + racecar(i - (j - k))
    for (; j < i; j = (1 << ++x) - 1)
      for (int y = 0, k = 0; k < j; k = (1 << ++y) - 1)
        res = Math.min(res, (x + 1) + (y + 1) + racecar(i - (j - k), mem));

    // xA || (xA + 1R) + racecar(j - i)
    return mem[i] = Math.min(res, i == j ? x : x + 1 + racecar(j - i, mem));
  }
}"
"819","class Solution:
  def mostCommonWord(self, paragraph: str, banned: list[str]) -> str:
    banned = set(banned)
    words = re.findall(r'\w+', paragraph.lower())
    return collections.Counter(
        word for word in words if word not in banned).most_common(1)[0][0]"
"82","class Solution:
  def deleteDuplicates(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while head:
      while head.next and head.val == head.next.val:
        head = head.next
      if prev.next == head:
        prev = prev.next
      else:
        prev.next = head.next
      head = head.next

    return dummy.next"
"820","class TrieNode:
  def __init__(self):
    self.children: dict[str, TrieNode] = {}
    self.depth = 0


class Solution:
  def minimumLengthEncoding(self, words: list[str]) -> int:
    root = TrieNode()
    leaves = []

    def insert(word: str) -> TrieNode:
      node = root
      for c in reversed(word):
        node = node.children.setdefault(c, TrieNode())
      node.depth = len(word)
      return node

    for word in set(words):
      leaves.append(insert(word))

    return sum(leaf.depth + 1 for leaf in leaves
               if not len(leaf.children))"
"821","class Solution:
  def shortestToChar(self, s: str, c: str) -> list[int]:
    n = len(s)
    ans = [0] * n
    prev = -n

    for i in range(n):
      if s[i] == c:
        prev = i
      ans[i] = i - prev

    for i in range(prev - 1, -1, -1):
      if s[i] == c:
        prev = i
      ans[i] = min(ans[i], prev - i)

    return ans"
"822","class Solution:
  def flipgame(self, fronts: list[int], backs: list[int]) -> int:
    same = {front
            for front, back in zip(fronts, backs)
            if front == back}
    return min([num for num in fronts + backs
                if num not in same] or [0])"
"823","class Solution:
  def numFactoredBinaryTrees(self, arr: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(arr)
    # dp[i] := the number of binary trees with arr[i] as the root
    dp = [1] * n
    arr.sort()
    numToIndex = {a: i for i, a in enumerate(arr)}

    for i, root in enumerate(arr):  # arr[i] is the root
      for j in range(i):
        if root % arr[j] == 0:  # arr[j] is the left subtree
          right = root // arr[j]
          if right in numToIndex:
            dp[i] += dp[j] * dp[numToIndex[right]]
            dp[i] %= kMod

    return sum(dp) % kMod"
"824","class Solution:
  def toGoatLatin(self, sentence: str) -> str:
    ans = []
    kVowels = 'aeiouAEIOU'

    i = 1
    for word in sentence.split():
      if i > 1:
        ans.append(' ')
      if word[0] in kVowels:
        ans.append(word)
      else:
        ans.append(word[1:] + word[0])
      ans.append('ma' + 'a' * i)
      i += 1

    return ''.join(ans)"
"825","class Solution:
  def numFriendRequests(self, ages: list[int]) -> int:
    ans = 0
    count = [0] * 121

    for age in ages:
      count[age] += 1

    for i in range(15, 121):
      ans += count[i] * (count[i] - 1)

    for i in range(15, 121):
      for j in range(i // 2 + 8, i):
        ans += count[i] * count[j]

    return ans"
"826","class Solution:
  def maxProfitAssignment(
      self,
      difficulty: list[int],
      profit: list[int],
      worker: list[int],
  ) -> int:
    ans = 0
    jobs = sorted(zip(difficulty, profit))
    worker.sort(reverse=1)

    i = 0
    maxProfit = 0

    for w in sorted(worker):
      while i < len(jobs) and w >= jobs[i][0]:
        maxProfit = max(maxProfit, jobs[i][1])
        i += 1
      ans += maxProfit

    return ans"
"827","class Solution {
  public int largestIsland(int[][] grid) {
    final int m = grid.length;
    final int n = grid[0].length;
    int maxSize = 0;
    // sizes[i] := the size of the i-th connected component (starting from 2)
    List<Integer> sizes = new ArrayList<>(List.of(0, 0));

    // For each 1 in the grid, paint all the connected 1s with the next
    // available color (2, 3, and so on). Also, remember the size of the island
    // we just painted with that color.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          sizes.add(paint(grid, i, j, sizes.size())); // Paint 2, 3, ...
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          Set<Integer> neighborIds =
              new HashSet<>(Arrays.asList(getId(grid, i - 1, j), getId(grid, i + 1, j),
                                          getId(grid, i, j + 1), getId(grid, i, j - 1)));
          maxSize = Math.max(maxSize, 1 + getSize(grid, neighborIds, sizes));
        }

    return maxSize == 0 ? m * n : maxSize;
  }

  private int paint(int[][] grid, int i, int j, int id) {
    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)
      return 0;
    if (grid[i][j] != 1)
      return 0;
    grid[i][j] = id; // grid[i][j] is part of the id-th connected component.
    return 1 + paint(grid, i + 1, j, id) + paint(grid, i - 1, j, id) + paint(grid, i, j + 1, id) +
        paint(grid, i, j - 1, id);
  }

  // Gets the id of grid[i][j] and returns 0 if it's out-of-bounds.
  private int getId(int[][] grid, int i, int j) {
    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)
      return 0; // Invalid
    return grid[i][j];
  }

  private int getSize(int[][] grid, Set<Integer> neighborIds, List<Integer> sizes) {
    int size = 0;
    for (final int neighborId : neighborIds)
      size += sizes.get(neighborId);
    return size;
  }
}"
"828","class Solution:
  def uniqueLetterString(self, s: str) -> int:
    ans = 0
    # lastSeen[c] := the index of the last time ('a' + i) appeared
    lastSeen = collections.defaultdict(lambda: -1)
    # prevSeen[c] := the previous index of the last time ('a' + i) appeared
    prevLastSeen = collections.defaultdict(lambda: -1)

    for i, c in enumerate(s):
      if c in lastSeen:
        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])
      prevLastSeen[c] = lastSeen[c]
      lastSeen[c] = i

    for c in string.ascii_uppercase:
      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])

    return ans"
"829","class Solution:
  def consecutiveNumbersSum(self, n: int) -> int:
    ans = 0
    i = 1
    triangleNum = 1
    while triangleNum <= n:
      if (n - triangleNum) % i == 0:
        ans += 1
      i += 1
      triangleNum += i
    return ans"
"83","class Solution:
  def deleteDuplicates(self, head: ListNode) -> ListNode:
    curr = head

    while curr:
      while curr.next and curr.val == curr.next.val:
        curr.next = curr.next.next
      curr = curr.next

    return head"
"830","class Solution:
  def largeGroupPositions(self, s: str) -> list[list[int]]:
    n = len(s)
    ans = []
    i = 0
    j = 0

    while i < n:
      while j < n and s[j] == s[i]:
        j += 1
      if j - i >= 3:
        ans.append([i, j - 1])
      i = j

    return ans"
"831","class Solution:
  def maskPII(self, s: str) -> str:
    atIndex = s.find('@')
    if atIndex != -1:
      s = s.lower()
      return s[0] + '*' * 5 + s[atIndex - 1:]

    ans = ''.join(c for c in s if c.isdigit())

    if len(ans) == 10:
      return '***-***-' + ans[-4:]
    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]"
"832","class Solution:
  def flipAndInvertImage(self, A: list[list[int]]) -> list[list[int]]:
    n = len(A)

    for i in range(n):
      for j in range((n + 2) // 2):
        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1

    return A"
"833","class Solution:
  def findReplaceString(self, s: str, indexes: list[int],
                        sources: list[str], targets: list[str]) -> str:
    for index, source, target in sorted(
            zip(indexes, sources, targets),
            reverse=True):
      if s[index:index + len(source)] == source:
        s = s[:index] + target + s[index + len(source):]
    return s"
"834","class Solution:
  def sumOfDistancesInTree(self, n: int, edges: list[list[int]]) -> list[int]:
    ans = [0] * n
    count = [1] * n
    tree = [set() for _ in range(n)]

    for u, v in edges:
      tree[u].add(v)
      tree[v].add(u)

    def postorder(u: int, prev: int) -> None:
      for v in tree[u]:
        if v == prev:
          continue
        postorder(v, u)
        count[u] += count[v]
        ans[u] += ans[v] + count[v]

    def preorder(u: int, prev: int) -> None:
      for v in tree[u]:
        if v == prev:
          continue
        # count[v] us are 1 step closer from v than prev.
        # (n - count[v]) us are 1 step farther from v than prev.
        ans[v] = ans[u] - count[v] + (n - count[v])
        preorder(v, u)

    postorder(0, -1)
    preorder(0, -1)
    return ans"
"835","class Solution:
  def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:
    kMagic = 100
    ones1 = [(i, j)
             for i, row in enumerate(img1)
             for j, num in enumerate(row)
             if num == 1]
    ones2 = [(i, j)
             for i, row in enumerate(img2)
             for j, num in enumerate(row)
             if num == 1]
    offsetCount = collections.Counter()

    for ax, ay in ones1:
      for bx, by in ones2:
        offsetCount[(ax - bx) * kMagic + (ay - by)] += 1

    return max(offsetCount.values()) if offsetCount else 0"
"836","class Solution:
  def isRectangleOverlap(self, rec1: list[int], rec2: list[int]) -> bool:
    return rec1[0] < rec2[2] and rec2[0] < rec1[2] and rec1[1] < rec2[3] and rec2[1] < rec1[3]"
"837","class Solution:
  def new21Game(self, n: int, k: int, maxPts: int) -> float:
    # When the game ends, the point is in [k..k - 1 maxPts].
    #   P = 1, if n >= k - 1 + maxPts
    #   P = 0, if n < k (note that the constraints already have k <= n)
    if k == 0 or n >= k - 1 + maxPts:
      return 1.0

    ans = 0.0
    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points
    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)

    for i in range(1, n + 1):
      # The probability to get i points is
      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts
      dp[i] = windowSum / maxPts
      if i < k:
        windowSum += dp[i]
      else:  # The game ends.
        ans += dp[i]
      if i - maxPts >= 0:
        windowSum -= dp[i - maxPts]

    return ans"
"838","class Solution:
  def pushDominoes(self, dominoes: str) -> str:
    ans = list(dominoes)
    L = -1
    R = -1

    for i in range(len(dominoes) + 1):
      if i == len(dominoes) or dominoes[i] == 'R':
        if L < R:
          while R < i:
            ans[R] = 'R'
            R += 1
        R = i
      elif dominoes[i] == 'L':
        if R < L or (L, R) == (-1, -1):
          if (L, R) == (-1, -1):
            L += 1
          while L < i:
            ans[L] = 'L'
            L += 1
        else:
          l = R + 1
          r = i - 1
          while l < r:
            ans[l] = 'R'
            ans[r] = 'L'
            l += 1
            r -= 1
        L = i

    return ''.join(ans)"
"839","class Solution {
  public int numSimilarGroups(String[] strs) {
    int ans = 0;
    boolean[] seen = new boolean[strs.length];

    for (int i = 0; i < strs.length; ++i)
      if (!seen[i]) {
        dfs(strs, i, seen);
        ++ans;
      }

    return ans;
  }

  private void dfs(final String[] strs, int i, boolean[] seen) {
    seen[i] = true;
    for (int j = 0; j < strs.length; ++j)
      if (!seen[j] && isSimilar(strs[i], strs[j]))
        dfs(strs, j, seen);
  }

  private boolean isSimilar(final String X, final String Y) {
    int diff = 0;
    for (int i = 0; i < X.length(); ++i)
      if (X.charAt(i) != Y.charAt(i) && ++diff > 2)
        return false;
    return true;
  }
}"
"84","class Solution:
  def largestRectangleArea(self, heights: list[int]) -> int:
    ans = 0
    stack = []

    for i in range(len(heights) + 1):
      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):
        h = heights[stack.pop()]
        w = i - stack[-1] - 1 if stack else i
        ans = max(ans, h * w)
      stack.append(i)

    return ans"
"840","class Solution:
  def numMagicSquaresInside(self, grid: list[list[int]]) -> int:
    def isMagic(i: int, j: int) -> int:
      s = """".join(str(grid[i + num // 3][j + num % 3])
                  for num in [0, 1, 2, 5, 8, 7, 6, 3])
      return s in ""43816729"" * 2 or s in ""43816729""[::-1] * 2

    ans = 0

    for i in range(len(grid) - 2):
      for j in range(len(grid[0]) - 2):
        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:
          ans += isMagic(i, j)

    return ans"
"841","class Solution:
  def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:
    seen = [False] * len(rooms)

    def dfs(node: int) -> None:
      seen[node] = True
      for child in rooms[node]:
        if not seen[child]:
          dfs(child)

    dfs(0)
    return all(seen)"
"842","class Solution {
  public List<Integer> splitIntoFibonacci(String num) {
    List<Integer> ans = new ArrayList<>();
    dfs(num, 0, ans);
    return ans;
  }

  private boolean dfs(final String num, int s, List<Integer> ans) {
    if (s == num.length() && ans.size() >= 3)
      return true;

    for (int i = s; i < num.length(); ++i) {
      if (num.charAt(s) == '0' && i > s)
        break;
      final long val = Long.valueOf(num.substring(s, i + 1));
      if (val > Integer.MAX_VALUE)
        break;
      if (ans.size() >= 2 && val > ans.get(ans.size() - 2) + ans.get(ans.size() - 1))
        break;
      if (ans.size() <= 1 || val == ans.get(ans.size() - 2) + ans.get(ans.size() - 1)) {
        ans.add((int) val);
        if (dfs(num, i + 1, ans))
          return true;
        ans.remove(ans.size() - 1);
      }
    }

    return false;
  }
}"
"843","# """"""
# This is Master's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# Class Master:
#   def guess(self, word: str) -> int:

class Solution:
  def findSecretWord(self, words: list[str], master: 'Master') -> None:
    for _ in range(10):
      guessedWord = words[random.randint(0, len(words) - 1)]
      matches = master.guess(guessedWord)
      if matches == 6:
        break
      words = [
          word for word in words
          if sum(c1 == c2 for c1, c2 in zip(guessedWord, word)) == matches]"
"844","class Solution:
  def backspaceCompare(self, s: str, t: str) -> bool:
    def backspace(s: str) -> str:
      stack = []
      for c in s:
        if c != '#':
          stack.append(c)
        elif stack:
          stack.pop()
      return stack

    return backspace(s) == backspace(t)"
"845","class Solution:
  def longestMountain(self, arr: list[int]) -> int:
    ans = 0
    i = 0

    while i + 1 < len(arr):
      while i + 1 < len(arr) and arr[i] == arr[i + 1]:
        i += 1

      increasing = 0
      decreasing = 0

      while i + 1 < len(arr) and arr[i] < arr[i + 1]:
        increasing += 1
        i += 1

      while i + 1 < len(arr) and arr[i] > arr[i + 1]:
        decreasing += 1
        i += 1

      if increasing > 0 and decreasing > 0:
        ans = max(ans, increasing + decreasing + 1)

    return ans"
"846","class Solution:
  def isNStraightHand(self, hand: list[int], groupSize: int) -> bool:
    count = collections.Counter(hand)

    for start in sorted(count):
      value = count[start]
      if value > 0:
        for i in range(start, start + groupSize):
          count[i] -= value
          if count[i] < 0:
            return False

    return True"
"847","class Solution:
  def shortestPathLength(self, graph: list[list[int]]) -> int:
    n = len(graph)
    goal = (1 << n) - 1
    q = collections.deque()  # (u, state)
    seen = set()

    for i in range(n):
      q.append((i, 1 << i))

    step = 0
    while q:
      for _ in range(len(q)):
        u, state = q.popleft()
        if state == goal:
          return step
        if (u, state) in seen:
          continue
        seen.add((u, state))
        for v in graph[u]:
          q.append((v, state | 1 << v))
      step += 1

    return -1"
"848","class Solution:
  def shiftingLetters(self, s: str, shifts: list[int]) -> str:
    ans = []

    for i in reversed(range(len(shifts) - 1)):
      shifts[i] += shifts[i + 1]

    for c, shift in zip(s, shifts):
      ans.append(chr((string.ascii_lowercase.index(c) + shift) % 26 + ord('a')))

    return ''.join(ans)"
"849","class Solution:
  def maxDistToClosest(self, seats: list[int]) -> int:
    n = len(seats)
    ans = 0
    j = -1

    for i in range(n):
      if seats[i] == 1:
        ans = i if j == -1 else max(ans, (i - j) // 2)
        j = i

    return max(ans, n - j - 1)"
"85","class Solution:
  def maximalRectangle(self, matrix: list[list[str]]) -> int:
    if not matrix:
      return 0

    ans = 0
    hist = [0] * len(matrix[0])

    def largestRectangleArea(heights: list[int]) -> int:
      ans = 0
      stack = []

      for i in range(len(heights) + 1):
        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):
          h = heights[stack.pop()]
          w = i - stack[-1] - 1 if stack else i
          ans = max(ans, h * w)
        stack.append(i)

      return ans

    for row in matrix:
      for i, num in enumerate(row):
        hist[i] = 0 if num == '0' else hist[i] + 1
      ans = max(ans, largestRectangleArea(hist))

    return ans"
"850","class Solution:
  def rectangleArea(self, rectangles: list[list[int]]) -> int:
    events = []

    for x1, y1, x2, y2 in rectangles:
      events.append((x1, y1, y2, 's'))
      events.append((x2, y1, y2, 'e'))

    events.sort(key=lambda x: x[0])

    ans = 0
    prevX = 0
    yPairs = []

    def getHeight(yPairs: list[tuple[int, int]]) -> int:
      height = 0
      prevY = 0

      for y1, y2 in yPairs:
        prevY = max(prevY, y1)
        if y2 > prevY:
          height += y2 - prevY
          prevY = y2

      return height

    for currX, y1, y2, type in events:
      if currX > prevX:
        width = currX - prevX
        ans += width * getHeight(yPairs)
        prevX = currX
      if type == 's':
        yPairs.append((y1, y2))
        yPairs.sort()
      else:  # type == 'e'
        yPairs.remove((y1, y2))

    return ans % (10**9 + 7)"
"851","class Solution:
  def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:
    graph = [[] for _ in range(len(quiet))]

    for v, u in richer:
      graph[u].append(v)

    @functools.lru_cache(None)
    def dfs(u: int) -> int:
      ans = u

      for v in graph[u]:
        res = dfs(v)
        if quiet[res] < quiet[ans]:
          ans = res

      return ans

    return map(dfs, range(len(graph)))"
"852","class Solution:
  def peakIndexInMountainArray(self, arr: list[int]) -> int:
    l = 0
    r = len(arr) - 1

    while l < r:
      m = (l + r) // 2
      if arr[m] >= arr[m + 1]:
        r = m
      else:
        l = m + 1

    return l"
"853","class Solution:
  def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:
    ans = 0
    times = [
        float(target - p) / s for p, s in sorted(zip(position, speed),
                                                 reverse=True)]
    maxTime = 0  # the time of the slowest car to reach the target

    for time in times:
      # A car needs more time to reach the target, so it becomes the slowest.
      if time > maxTime:
        maxTime = time
        ans += 1

    return ans"
"854","class Solution:
  def kSimilarity(self, s1: str, s2: str) -> int:
    q = collections.deque([s1])
    seen = {s1}

    step = 0
    while q:
      for _ in range(len(q)):
        curr = q.popleft()
        if curr == s2:
          return step
        for child in self._getChildren(curr, s2):
          if child in seen:
            continue
          q.append(child)
          seen.add(child)
      step += 1

    return -1

  def _getChildren(self, curr: str, target: str) -> list[str]:
    children = []
    s = list(curr)
    i = 0  # the first index s.t. curr[i] != target[i]
    while curr[i] == target[i]:
      i += 1

    for j in range(i + 1, len(s)):
      if s[j] == target[i]:
        s[i], s[j] = s[j], s[i]
        children.append(''.join(s))
        s[i], s[j] = s[j], s[i]

    return children"
"855","class Node {
  public Node prev;
  public Node next;
  public int value;

  public Node(int value) {
    this.value = value;
  }
}

class ExamRoom {
  public ExamRoom(int n) {
    this.n = n;
    join(head, tail);
  }

  public int seat() {
    if (head.next == tail) {
      Node node = new Node(0);
      join(head, node);
      join(node, tail);
      map.put(0, node);
      return 0;
    }

    int prevStudent = -1;
    int maxDistToClosest = 0;
    int val = 0;     // the inserted value
    Node pos = null; // the inserted position

    for (Node node = head; node != tail; node = node.next) {
      if (prevStudent == -1) {         // We haven't insert anything before.
        maxDistToClosest = node.value; // the distance between it and the begining
        pos = node;
      } else if ((node.value - prevStudent) / 2 > maxDistToClosest) {
        maxDistToClosest = (node.value - prevStudent) / 2;
        val = (node.value + prevStudent) / 2;
        pos = node;
      }
      prevStudent = node.value;
    }

    if (n - 1 - tail.prev.value > maxDistToClosest) {
      pos = tail;
      val = n - 1;
    }

    Node insertedNode = new Node(val);
    join(pos.prev, insertedNode);
    join(insertedNode, pos);

    map.put(val, insertedNode);
    return val;
  }

  public void leave(int p) {
    Node removedNode = map.get(p);
    join(removedNode.prev, removedNode.next);
  }

  private int n;
  private Node head = new Node(-1);
  private Node tail = new Node(-1);
  private Map<Integer, Node> map = new HashMap<>(); // {p: student iterator}

  private void join(Node node1, Node node2) {
    node1.next = node2;
    node2.prev = node1;
  }

  private void remove(Node node) {
    join(node.prev, node.next);
  }
}"
"856","class Solution:
  def scoreOfParentheses(self, s: str) -> int:
    ans = 0
    layer = 0

    for a, b in itertools.pairwise(s):
      if a + b == '()':
        ans += 1 << layer
      layer += 1 if a == '(' else -1

    return ans"
"857","class Solution:
  def mincostToHireWorkers(
      self,
      quality: list[int],
      wage: list[int],
      k: int,
  ) -> float:
    ans = math.inf
    qualitySum = 0
    # (wagePerQuality, quality) sorted by wagePerQuality
    workers = sorted((w / q, q) for q, w in zip(quality, wage))
    maxHeap = []

    for wagePerQuality, q in workers:
      heapq.heappush(maxHeap, -q)
      qualitySum += q
      if len(maxHeap) > k:
        qualitySum += heapq.heappop(maxHeap)
      if len(maxHeap) == k:
        ans = min(ans, qualitySum * wagePerQuality)

    return ans"
"858","class Solution:
  def mirrorReflection(self, p: int, q: int) -> int:
    while p % 2 == 0 and q % 2 == 0:
      p //= 2
      q //= 2

    if p % 2 == 0:
      return 2
    if q % 2 == 0:
      return 0
    return 1"
"859","class Solution:
  def buddyStrings(self, s: str, goal: str) -> bool:
    if len(s) != len(goal):
      return False
    if s == goal and len(set(s)) < len(s):
      return True
    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))
                   if a != b]
    return (len(diffIndices) == 2 and
            s[diffIndices[0]] == goal[diffIndices[1]] and
            s[diffIndices[1]] == goal[diffIndices[0]])"
"86","class Solution:
  def partition(self, head: ListNode, x: int) -> ListNode:
    beforeHead = ListNode(0)
    afterHead = ListNode(0)
    before = beforeHead
    after = afterHead

    while head:
      if head.val < x:
        before.next = head
        before = head
      else:
        after.next = head
        after = head
      head = head.next

    after.next = None
    before.next = afterHead.next

    return beforeHead.next"
"860","class Solution:
  def lemonadeChange(self, bills: list[int]) -> bool:
    fives = 0
    tens = 0

    for bill in bills:
      if bill == 5:
        fives += 1
      elif bill == 10:
        fives -= 1
        tens += 1
      else:  # bill == 20
        if tens > 0:
          tens -= 1
          fives -= 1
        else:
          fives -= 3
      if fives < 0:
        return False

    return True"
"861","class Solution:
  def matrixScore(self, grid: list[list[int]]) -> int:
    # Flip the rows with a leading 0.
    for row in grid:
      if row[0] == 0:
        self._flip(row)

    # Flip the columns with 1s < 0s.
    for j, col in enumerate(list(zip(*grid))):
      if sum(col) * 2 < len(grid):
        self._flipCol(grid, j)

    # Add a binary number for each row.
    return sum(self._binary(row) for row in grid)

  def _flip(self, row: list[int]) -> None:
    for i in range(len(row)):
      row[i] ^= 1

  def _flipCol(self, grid: list[list[int]], j: int) -> None:
    for i in range(len(grid)):
      grid[i][j] ^= 1

  def _binary(self, row: list[int]) -> int:
    res = row[0]
    for j in range(1, len(row)):
      res = res * 2 + row[j]
    return res"
"862","class Solution:
  def shortestSubarray(self, nums: list[int], k: int) -> int:
    n = len(nums)
    ans = n + 1
    dq = collections.deque()
    prefix = list(itertools.accumulate(nums, initial=0))

    for i in range(n + 1):
      while dq and prefix[i] - prefix[dq[0]] >= k:
        ans = min(ans, i - dq.popleft())
      while dq and prefix[i] <= prefix[dq[-1]]:
        dq.pop()
      dq.append(i)

    return ans if ans <= n else -1"
"863","class Solution {
  public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
    List<Integer> ans = new ArrayList<>();
    Map<TreeNode, Integer> nodeToDist = new HashMap<>(); // {node: distance to target}

    getDists(root, target, nodeToDist);
    dfs(root, k, 0, nodeToDist, ans);

    return ans;
  }

  private void getDists(TreeNode root, TreeNode target, Map<TreeNode, Integer> nodeToDist) {
    if (root == null)
      return;
    if (root == target) {
      nodeToDist.put(root, 0);
      return;
    }

    getDists(root.left, target, nodeToDist);
    if (nodeToDist.containsKey(root.left)) {
      // The target is in the left subtree.
      nodeToDist.put(root, nodeToDist.get(root.left) + 1);
      return;
    }

    getDists(root.right, target, nodeToDist);
    if (nodeToDist.containsKey(root.right))
      // The target is in the right subtree.
      nodeToDist.put(root, nodeToDist.get(root.right) + 1);
  }

  private void dfs(TreeNode root, int k, int dist, Map<TreeNode, Integer> nodeToDist,
                   List<Integer> ans) {
    if (root == null)
      return;
    if (nodeToDist.containsKey(root))
      dist = nodeToDist.get(root);
    if (dist == k)
      ans.add(root.val);

    dfs(root.left, k, dist + 1, nodeToDist, ans);
    dfs(root.right, k, dist + 1, nodeToDist, ans);
  }
}"
"864","class T {
  public int i;
  public int j;
  public int keys; // the keys in the bitmask
  public T(int i, int j, int keys) {
    this.i = i;
    this.j = j;
    this.keys = keys;
  }
}

class Solution {
  public int shortestPathAllKeys(String[] grid) {
    final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    final int m = grid.length;
    final int n = grid[0].length();
    final int keysCount = getKeysCount(grid);
    final int kKeys = (1 << keysCount) - 1;
    final int[] start = getStart(grid);
    Queue<T> q = new ArrayDeque<>(List.of(new T(start[0], start[1], 0)));
    boolean[][][] seen = new boolean[m][n][kKeys];
    seen[start[0]][start[1]][0] = true;

    for (int step = 1; !q.isEmpty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        final int i = q.peek().i;
        final int j = q.peek().j;
        final int keys = q.poll().keys;
        for (int[] dir : dirs) {
          final int x = i + dir[0];
          final int y = j + dir[1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          final char c = grid[x].charAt(y);
          if (c == '#')
            continue;
          final int newKeys = 'a' <= c && c <= 'f' ? keys | 1 << c - 'a' : keys;
          if (newKeys == kKeys)
            return step;
          if (seen[x][y][newKeys])
            continue;
          if ('A' <= c && c <= 'F' && (newKeys >> c - 'A' & 1) == 0)
            continue;
          q.offer(new T(x, y, newKeys));
          seen[x][y][newKeys] = true;
        }
      }

    return -1;
  }

  private int getKeysCount(String[] grid) {
    int count = 0;
    for (final String s : grid)
      count += (int) s.chars().filter(c -> 'a' <= c && c <= 'f').count();
    return count;
  }

  private int[] getStart(String[] grid) {
    for (int i = 0; i < grid.length; ++i)
      for (int j = 0; j < grid[0].length(); ++j)
        if (grid[i].charAt(j) == '@')
          return new int[] {i, j};
    throw new IllegalArgumentException();
  }
}"
"865","struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* subtreeWithAllDeepest(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};

    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};"
"866","class Solution:
  def primePalindrome(self, n: int) -> int:
    def getPalindromes(n: int) -> int:
      length = n // 2
      for i in range(10**(length - 1), 10**length):
        s = str(i)
        for j in range(10):
          yield int(s + str(j) + s[::-1])

    def isPrime(num: int) -> bool:
      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))

    if n <= 2:
      return 2
    if n == 3:
      return 3
    if n <= 5:
      return 5
    if n <= 7:
      return 7
    if n <= 11:
      return 11

    nLength = len(str(n))

    while True:
      for num in getPalindromes(nLength):
        if num >= n and isPrime(num):
          return num
      nLength += 1"
"867","class Solution:
  def transpose(self, A: list[list[int]]) -> list[list[int]]:
    ans = [[0] * len(A) for _ in range(len(A[0]))]

    for i in range(len(A)):
      for j in range(len(A[0])):
        ans[j][i] = A[i][j]

    return ans"
"868","class Solution:
  def binaryGap(self, n: int) -> int:
    ans = 0
    d = -32  # the distance between any two 1s

    while n:
      if n % 2 == 1:
        ans = max(ans, d)
        d = 0
      n //= 2
      d += 1

    return ans"
"869","class Solution:
  def reorderedPowerOf2(self, n: int) -> bool:
    count = collections.Counter(str(n))
    return any(Counter(str(1 << i)) == count for i in range(30))"
"87","class Solution:
  @functools.lru_cache(None)
  def isScramble(self, s1: str, s2: str) -> bool:
    if s1 == s2:
      return True
    if collections.Counter(s1) != collections.Counter(s2):
      return False

    for i in range(1, len(s1)):
      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
        return True
      if (self.isScramble(s1[:i], s2[len(s2) - i:]) and
              self.isScramble(s1[i:], s2[: len(s2) - i])):
        return True

    return False"
"870","from sortedcontainers import SortedList


class Solution:
  def advantageCount(self, nums1: list[int], nums2: list[int]) -> list[int]:
    sl = SortedList(nums1)

    for i, num in enumerate(nums2):
      index = 0 if sl[-1] <= num else sl.bisect_right(num)
      nums1[i] = sl[index]
      del sl[index]

    return nums1"
"871","class Solution:
  def minRefuelStops(
      self,
      target: int,
      startFuel: int,
      stations: list[list[int]],
  ) -> int:
    # dp[i] := the farthest position we can reach w / i refuels
    dp = [startFuel] + [0] * len(stations)

    for i, station in enumerate(stations):
      for j in range(i + 1, 0, -1):
        if dp[j - 1] >= station[0]:
          dp[j] = max(dp[j], dp[j - 1] + station[1])

    for i, d in enumerate(dp):
      if d >= target:
        return i

    return -1"
"872","class Solution:
  def leafSimilar(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:
    def dfs(root: TreeNode | None) -> None:
      if not root:
        return
      if not root.left and not root.right:
        yield root.val
        return

      yield from dfs(root.left)
      yield from dfs(root.right)

    return list(dfs(root1)) == list(dfs(root2))"
"873","class Solution:
  def lenLongestFibSubseq(self, arr: list[int]) -> int:
    n = len(arr)
    ans = 0
    numToIndex = {a: i for i, a in enumerate(arr)}
    dp = [[2] * n for _ in range(n)]

    for j in range(n):
      for k in range(j + 1, n):
        ai = arr[k] - arr[j]
        if ai < arr[j] and ai in numToIndex:
          i = numToIndex[ai]
          dp[j][k] = dp[i][j] + 1
          ans = max(ans, dp[j][k])

    return ans"
"874","class Solution:
  def robotSim(self, commands: list[int], obstacles: list[list[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = 0
    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west
    x = 0  # the start x
    y = 0  # the start y
    obstaclesSet = {(x, y) for x, y in obstacles}

    for command in commands:
      if command == -1:
        d = (d + 1) % 4
      elif command == -2:
        d = (d + 3) % 4
      else:
        for _ in range(command):
          if (x + dirs[d][0], y + dirs[d][1]) in obstaclesSet:
            break
          x += dirs[d][0]
          y += dirs[d][1]
      ans = max(ans, x * x + y * y)

    return ans"
"875","class Solution:
  def minEatingSpeed(self, piles: list[int], h: int) -> int:
    def eatHours(m: int) -> bool:
      """"""Returns True if Koko can eat all piles with speed m.""""""
      return sum((pile - 1) // m + 1 for pile in piles) <= h
    return bisect.bisect_left(range(1, max(piles)), True,
                              key=lambda m: eatHours(m)) + 1"
"876","class Solution:
  def middleNode(self, head: ListNode) -> ListNode:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next

    return slow"
"877","class Solution:
  def stoneGame(self, piles: list[int]) -> bool:
    n = len(piles)
    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]
    dp = [[0] * n for _ in range(n)]

    for i, pile in enumerate(piles):
      dp[i][i] = pile

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        dp[i][j] = max(piles[i] - dp[i + 1][j],
                       piles[j] - dp[i][j - 1])

    return dp[0][n - 1] > 0"
"878","class Solution:
  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
    lcm = a * b // math.gcd(a, b)
    l = bisect.bisect_left(range(min(a, b), min(a, b) * n), n,
                           key=lambda m: m // a + m // b - m // lcm) + min(a, b)
    return l % (10**9 + 7)"
"879","class Solution {
  public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
    final int kMod = 1_000_000_007;
    // dp[k][i][j] := the number of schemes, where the first k crimes are
    // committed by <= i members, generating >= j profits
    int[][][] dp = new int[group.length + 1][n + 1][minProfit + 1];

    // No crimes, no profits, and any number of members.
    for (int i = 0; i <= n; ++i)
      dp[0][i][0] = 1;

    for (int k = 1; k <= group.length; ++k) {
      final int g = group[k - 1];
      final int p = profit[k - 1];
      for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= minProfit; ++j)
          if (i < g) {
            dp[k][i][j] = dp[k - 1][i][j];
          } else {
            dp[k][i][j] = dp[k - 1][i][j] + dp[k - 1][i - g][Math.max(0, j - p)];
            dp[k][i][j] %= kMod;
          }
    }

    return dp[group.length][n][minProfit];
  }
}"
"88","class Solution:
  def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:
    i = m - 1  # nums1's index (the actual nums)
    j = n - 1  # nums2's index
    k = m + n - 1  # nums1's index (the next filled position)

    while j >= 0:
      if i >= 0 and nums1[i] > nums2[j]:
        nums1[k] = nums1[i]
        k -= 1
        i -= 1
      else:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1"
"880","class Solution:
  def decodeAtIndex(self, s: str, k: int) -> str:
    size = 0

    for c in s:
      if c.isdigit():
        size *= int(c)
      else:
        size += 1

    for c in reversed(s):
      k %= size
      if k == 0 and c.isalpha():
        return c
      if c.isdigit():
        size //= int(c)
      else:
        size -= 1"
"881","class Solution:
  def numRescueBoats(self, people: list[int], limit: int) -> int:
    ans = 0
    i = 0
    j = len(people) - 1

    people.sort()

    while i <= j:
      remain = limit - people[j]
      j -= 1
      if people[i] <= remain:
        i += 1
      ans += 1

    return ans"
"882","class Solution:
  def reachableNodes(
      self,
      edges: list[list[int]],
      maxMoves: int,
      n: int,
  ) -> int:
    graph = [[] for _ in range(n)]
    dist = [maxMoves + 1] * n

    for u, v, cnt in edges:
      graph[u].append((v, cnt))
      graph[v].append((u, cnt))

    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)
    reachableSubnodes = 0

    for u, v, cnt in edges:
      # the number of reachable nodes of (u, v) from `u`
      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)
      # the number of reachable nodes of (u, v) from `v`
      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)
      reachableSubnodes += min(a + b, cnt)

    return reachableNodes + reachableSubnodes

  def _dijkstra(
      self,
      graph: list[list[tuple[int, int]]],
      src: int,
      maxMoves: int,
      dist: list[int],
  ) -> int:
    dist[src] = 0
    minHeap = [(dist[src], src)]  # (d, u)

    while minHeap:
      d, u = heapq.heappop(minHeap)
      # Already took `maxMoves` to reach `u`, so can't explore anymore.
      if dist[u] >= maxMoves:
        break
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        newDist = d + w + 1
        if newDist < dist[v]:
          dist[v] = newDist
          heapq.heappush(minHeap, (newDist, v))

    return sum(d <= maxMoves for d in dist)"
"883","class Solution:
  def projectionArea(self, grid: list[list[int]]) -> int:
    return sum(
        a > 0 for row in grid for a in row) + sum(
        max(row) for row in grid) + sum(
        max(col) for col in zip(*grid))"
"884","class Solution:
  def uncommonFromSentences(self, A: str, B: str) -> list[str]:
    count = collections.Counter((A + ' ' + B).split())
    return [word for word, freq in count.items() if freq == 1]"
"885","class Solution:
  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> list[list[int]]:
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]
    ans = [[rStart, cStart]]
    i = 0

    while len(ans) < rows * cols:
      for _ in range(i // 2 + 1):
        rStart += dy[i % 4]
        cStart += dx[i % 4]
        if 0 <= rStart < rows and 0 <= cStart < cols:
          ans.append([rStart, cStart])
      i += 1

    return ans"
"886","from enum import Enum


class Color(Enum):
  kWhite = 0
  kRed = 1
  kGreen = 2


class Solution:
  def possibleBipartition(self, n: int, dislikes: list[list[int]]) -> bool:
    graph = [[] for _ in range(n + 1)]
    colors = [Color.kWhite] * (n + 1)

    for u, v in dislikes:
      graph[u].append(v)
      graph[v].append(u)

    # Reduce to 785. Is Graph Bipartite?
    def isValidColor(u: int, color: Color) -> bool:
      # Always paint red for a white node.
      if colors[u] != Color.kWhite:
        return colors[u] == color

      colors[u] = color  # Always paint the node with `color`.

      # All the children should have valid colors.
      childrenColor = Color.kRed if colors[u] == Color.kGreen else Color.kGreen
      return all(isValidColor(v, childrenColor) for v in graph[u])

    return all(colors[i] != Color.kWhite or isValidColor(i, Color.kRed)
               for i in range(1, n + 1))"
"887","class Solution:
  def superEggDrop(self, k: int, n: int) -> int:
    moves = 0
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    while dp[moves][k] < n:
      moves += 1
      for eggs in range(1, k + 1):
        dp[moves][eggs] = (dp[moves - 1][eggs - 1] +
                           dp[moves - 1][eggs] + 1)

    return moves"
"888","class Solution:
  def fairCandySwap(
      self,
      aliceSizes: list[int],
      bobSizes: list[int],
  ) -> list[int]:
    diff = (sum(aliceSizes) - sum(bobSizes)) // 2
    bobSizesSet = set(bobSizes)

    for aliceSize in aliceSizes:
      target = aliceSize - diff
      if target in bobSizesSet:
        return [aliceSize, target]"
"889","class Solution:
  def constructFromPrePost(
      self,
      pre: list[int],
      post: list[int],
  ) -> TreeNode | None:
    postToIndex = {num: i for i, num in enumerate(post)}

    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> TreeNode | None:
      if preStart > preEnd:
        return None
      if preStart == preEnd:
        return TreeNode(pre[preStart])

      rootVal = pre[preStart]
      leftRootVal = pre[preStart + 1]
      leftRootPostIndex = postToIndex[leftRootVal]
      leftSize = leftRootPostIndex - postStart + 1

      root = TreeNode(rootVal)
      root.left = build(preStart + 1, preStart + leftSize,
                        postStart, leftRootPostIndex)
      root.right = build(preStart + leftSize + 1, preEnd,
                         leftRootPostIndex + 1, postEnd - 1)
      return root

    return build(0, len(pre) - 1, 0, len(post) - 1)"
"89","class Solution:
  def grayCode(self, n: int) -> list[int]:
    ans = [0]

    for i in range(n):
      for j in reversed(range(len(ans))):
        ans.append(ans[j] | 1 << i)

    return ans"
"890","class Solution:
  def findAndReplacePattern(self, words: list[str], pattern: str) -> list[str]:
    def isIsomorphic(w: str, p: str) -> bool:
      return [*map(w.index, w)] == [*map(p.index, p)]
    return [word for word in words if isIsomorphic(word, pattern)]"
"891","class Solution:
  def sumSubseqWidths(self, nums: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0
    exp = 1

    nums.sort()

    for i in range(n):
      ans += (nums[i] - nums[n - 1 - i]) * exp
      ans %= kMod
      exp = exp * 2 % kMod

    return ans"
"892","class Solution:
  def surfaceArea(self, grid: list[list[int]]) -> int:
    ans = 0

    for i in range(len(grid)):
      for j in range(len(grid)):
        if grid[i][j]:
          ans += grid[i][j] * 4 + 2
        if i > 0:
          ans -= min(grid[i][j], grid[i - 1][j]) * 2
        if j > 0:
          ans -= min(grid[i][j], grid[i][j - 1]) * 2

    return ans"
"893","class Solution:
  def numSpecialEquivGroups(self, words: list[str]) -> int:
    return len({''.join(sorted(word[::2])) + ''.join(sorted(word[1::2]))
                for word in words})"
"894","class Solution:
  @functools.lru_cache(None)
  def allPossibleFBT(self, n: int) -> list[TreeNode | None]:
    if n % 2 == 0:
      return []
    if n == 1:
      return [TreeNode(0)]

    ans = []

    for leftCount in range(n):
      rightCount = n - 1 - leftCount
      for left in self.allPossibleFBT(leftCount):
        for right in self.allPossibleFBT(rightCount):
          ans.append(TreeNode(0))
          ans[-1].left = left
          ans[-1].right = right

    return ans"
"895","class FreqStack:
  def __init__(self):
    self.maxFreq = 0
    self.count = collections.Counter()
    self.countToStack = collections.defaultdict(list)

  def push(self, val: int) -> None:
    self.count[val] += 1
    self.countToStack[self.count[val]].append(val)
    self.maxFreq = max(self.maxFreq, self.count[val])

  def pop(self) -> int:
    val = self.countToStack[self.maxFreq].pop()
    self.count[val] -= 1
    if not self.countToStack[self.maxFreq]:
      self.maxFreq -= 1
    return val"
"896","class Solution:
  def isMonotonic(self, nums: list[int]) -> bool:
    increasing = True
    decreasing = True

    for i in range(1, len(nums)):
      increasing &= nums[i - 1] <= nums[i]
      decreasing &= nums[i - 1] >= nums[i]

    return increasing or decreasing"
"897","class Solution:
  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:
    if not root:
      return tail

    res = self.increasingBST(root.left, root)
    root.left = None
    root.right = self.increasingBST(root.right, tail)
    return res"
"898","class Solution {
 public:
  int subarrayBitwiseORs(vector<int>& arr) {
    vector<int> s;
    int l = 0;

    for (const int a : arr) {
      const int r = s.size();
      s.push_back(a);
      // s[l..r) are values generated in the previous iteration
      for (int i = l; i < r; ++i)
        if (s.back() != (s[i] | a))
          s.push_back(s[i] | a);
      l = r;
    }

    return unordered_set<int>(s.begin(), s.end()).size();
  }
};"
"899","class Solution:
  def orderlyQueue(self, s: str, k: int) -> str:
    return (''.join(sorted(s)) if k > 1
            else min(s[i:] + s[:i] for i in range(len(s))))"
"9","class Solution:
  def isPalindrome(self, x: int) -> bool:
    if x < 0:
      return False

    rev = 0
    y = x

    while y:
      rev = rev * 10 + y % 10
      y //= 10

    return rev == x"
"90","class Solution:
  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:
    ans = []

    def dfs(s: int, path: list[int]) -> None:
      ans.append(path)
      if s == len(nums):
        return

      for i in range(s, len(nums)):
        if i > s and nums[i] == nums[i - 1]:
          continue
        dfs(i + 1, path + [nums[i]])

    nums.sort()
    dfs(0, [])
    return ans"
"900","class RLEIterator:
  def __init__(self, encoding: list[int]):
    self.encoding = encoding
    self.index = 0

  def next(self, n: int) -> int:
    while self.index < len(self.encoding) and self.encoding[self.index] < n:
      n -= self.encoding[self.index]
      self.index += 2

    if self.index == len(self.encoding):
      return -1

    self.encoding[self.index] -= n
    return self.encoding[self.index + 1]"
"901","class StockSpanner:
  def __init__(self):
    self.stack = []  # (price, span)

  def next(self, price: int) -> int:
    span = 1
    while self.stack and self.stack[-1][0] <= price:
      span += self.stack.pop()[1]
    self.stack.append((price, span))
    return span"
"902","class Solution:
  def atMostNGivenDigitSet(self, digits: list[str], n: int) -> int:
    ans = 0
    num = str(n)

    for i in range(1, len(num)):
      ans += pow(len(digits), i)

    for i, c in enumerate(num):
      dHasSameNum = False
      for digit in digits:
        if digit[0] < c:
          ans += pow(len(digits), len(num) - i - 1)
        elif digit[0] == c:
          dHasSameNum = True
      if not dHasSameNum:
        return ans

    return ans + 1"
"903","class Solution {
 public:
  int numPermsDISequence(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i][j] := the number of valid permutations with i + 1 digits, where
    // s[i] is j-th Digit of remaining digits
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    // When there's only one digit, the number of permutations is 1.
    for (int j = 0; j <= n; ++j)
      dp[0][j] = 1;

    for (int i = 1; i <= n; ++i)
      if (s[i - 1] == 'I') {  // s[i - 1] == 'I'
        // Calculate the postfix sum to prevent duplicate calculation.
        int postfixsum = 0;
        for (int j = n - i; j >= 0; --j) {
          postfixsum = (postfixsum + dp[i - 1][j + 1]) % kMod;
          dp[i][j] = postfixsum;
        }
      } else {  // s[i - 1] == 'D'
        // Calculate the prefix sum to prevent duplicate calculation.
        int prefix = 0;
        for (int j = 0; j <= n - i; ++j) {
          prefix = (prefix + dp[i - 1][j]) % kMod;
          dp[i][j] = prefix;
        }
      }

    return dp[n][0];
  }
};"
"904","class Solution:
  def totalFruit(self, fruits: list[int]) -> int:
    ans = 0
    count = collections.defaultdict(int)

    l = 0
    for r, fruit in enumerate(fruits):
      count[fruit] += 1
      while len(count) > 2:
        count[fruits[l]] -= 1
        if count[fruits[l]] == 0:
          del count[fruits[l]]
        l += 1
      ans = max(ans, r - l + 1)

    return ans"
"905","class Solution:
  def sortArrayByParity(self, nums: list[int]) -> list[int]:
    l = 0
    r = len(nums) - 1

    while l < r:
      if nums[l] % 2 == 1 and nums[r] % 2 == 0:
        nums[l], nums[r] = nums[r], nums[l]
      if nums[l] % 2 == 0:
        l += 1
      if nums[r] % 2 == 1:
        r -= 1

    return nums"
"906","class Solution:
  def superpalindromesInRange(self, left: str, right: str) -> int:
    def nextPalindrome(num: int) -> int:
      s = str(num)
      n = len(s)

      half = s[0:(n + 1) // 2]
      reversedHalf = half[:n // 2][::-1]
      candidate = int(half + reversedHalf)
      if candidate >= num:
        return candidate

      half = str(int(half) + 1)
      reversedHalf = half[:n // 2][::-1]
      return int(half + reversedHalf)

    def isPalindrome(num: int) -> bool:
      s = str(num)
      l = 0
      r = len(s) - 1

      while l < r:
        if s[l] != s[r]:
          return False
        l += 1
        r -= 1

      return True

    ans = 0
    l = int(left)
    r = int(right)
    i = math.isqrt(l)

    while i * i <= r:
      palindrome = nextPalindrome(i)
      squared = palindrome**2
      if squared <= r and isPalindrome(squared):
        ans += 1
      i = palindrome + 1

    return ans"
"907","class Solution:
  def sumSubarrayMins(self, arr: list[int]) -> int:
    kMod = 1_000_000_007
    n = len(arr)
    ans = 0
    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]
    prevMin = [-1] * n
    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]
    nextMin = [n] * n
    stack = []

    for i, a in enumerate(arr):
      while stack and arr[stack[-1]] > a:
        index = stack.pop()
        nextMin[index] = i
      if stack:
        prevMin[i] = stack[-1]
      stack.append(i)

    for i, a in enumerate(arr):
      ans += a * (i - prevMin[i]) * (nextMin[i] - i)
      ans %= kMod

    return ans"
"908","class Solution:
  def smallestRangeI(self, nums: list[int], k: int) -> int:
    return max(0, max(nums) - min(nums) - 2 * k)"
"909","class Solution:
  def snakesAndLadders(self, board: list[list[int]]) -> int:
    n = len(board)
    q = collections.deque([1])
    seen = set()
    A = [0] * (1 + n * n)  # 2D -> 1D

    for i in range(n):
      for j in range(n):
        A[(n - 1 - i) * n + (n - j if (n - i) % 2 == 0 else j + 1)] = board[i][j]

    step = 1
    while q:
      for _ in range(len(q)):
        curr = q.popleft()
        for next in range(curr + 1, min(curr + 6, n * n) + 1):
          dest = A[next] if A[next] > 0 else next
          if dest == n * n:
            return step
          if dest in seen:
            continue
          q.append(dest)
          seen.add(dest)
      step += 1

    return -1"
"91","class Solution:
  def numDecodings(self, s: str) -> int:
    n = len(s)
    # dp[i] := the number of ways to decode s[i..n)
    dp = [0] * n + [1]

    def isValid(a: str, b=None) -> bool:
      if b:
        return a == '1' or a == '2' and b < '7'
      return a != '0'

    if isValid(s[-1]):
      dp[n - 1] = 1

    for i in reversed(range(n - 1)):
      if isValid(s[i]):
        dp[i] += dp[i + 1]
      if isValid(s[i], s[i + 1]):
        dp[i] += dp[i + 2]

    return dp[0]"
"910","class Solution:
  def smallestRangeII(self, nums: list[int], k: int) -> int:
    nums.sort()

    ans = nums[-1] - nums[0]
    left = nums[0] + k
    right = nums[-1] - k

    for a, b in itertools.pairwise(nums):
      mn = min(left, b - k)
      mx = max(right, a + k)
      ans = min(ans, mx - mn)

    return ans"
"911","class TopVotedCandidate:
  def __init__(self, persons: list[int], times: list[int]):
    self.times = times
    self.timeToLead = {}
    count = collections.Counter()  # {person: voted}
    lead = -1

    for person, time in zip(persons, times):
      count[person] += 1
      if count[person] >= count[lead]:
        lead = person
      self.timeToLead[time] = lead

  def q(self, t: int) -> int:
    i = bisect_right(self.times, t)
    return self.timeToLead[self.times[i - 1]]"
"912","class Solution:
  def sortArray(self, nums: list[int]) -> list[int]:
    def heapSort(A: list[int]) -> None:
      def maxHeapify(A: list[int], i: int, heapSize: int) -> None:
        l = 2 * i + 1
        r = 2 * i + 2
        largest = i
        if l < heapSize and A[largest] < A[l]:
          largest = l
        if r < heapSize and A[largest] < A[r]:
          largest = r
        if largest != i:
          A[largest], A[i] = A[i], A[largest]
          maxHeapify(A, largest, heapSize)

      def buildMaxHeap(A: list[int]) -> None:
        for i in range(len(A) // 2, -1, -1):
          maxHeapify(A, i, len(A))

      buildMaxHeap(A)
      heapSize = len(A)
      for i in reversed(range(1, len(A))):
        A[i], A[0] = A[0], A[i]
        heapSize -= 1
        maxHeapify(A, 0, heapSize)

    heapSort(nums)
    return nums"
"913","from enum import IntEnum


class State(IntEnum):
  kDraw = 0
  kMouseWin = 1
  kCatWin = 2


class Solution:
  def catMouseGame(self, graph: list[list[int]]) -> int:
    n = len(graph)
    # result of (cat, mouse, move)
    # move := 0 (mouse) // 1 (cat)
    states = [[[0] * 2 for i in range(n)] for j in range(n)]
    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]
    q = collections.deque()  # (cat, mouse, move, state)

    for cat in range(n):
      for mouse in range(n):
        outDegree[cat][mouse][0] = len(graph[mouse])
        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)

    # Start from the states s.t. the winner can be determined.
    for cat in range(1, n):
      for move in range(2):
        # Mouse is in the hole.
        states[cat][0][move] = int(State.kMouseWin)
        q.append((cat, 0, move, int(State.kMouseWin)))
        # Cat catches mouse.
        states[cat][cat][move] = int(State.kCatWin)
        q.append((cat, cat, move, int(State.kCatWin)))

    while q:
      cat, mouse, move, state = q.popleft()
      if cat == 2 and mouse == 1 and move == 0:
        return state
      prevMove = move ^ 1
      for prev in graph[cat if prevMove else mouse]:
        prevCat = prev if prevMove else cat
        if prevCat == 0:  # invalid
          continue
        prevMouse = mouse if prevMove else prev
        # The state has been determined.
        if states[prevCat][prevMouse][prevMove]:
          continue
        if (prevMove == 0 and state == int(State.kMouseWin) or
                prevMove == 1 and state == int(State.kCatWin)):
          states[prevCat][prevMouse][prevMove] = state
          q.append((prevCat, prevMouse, prevMove, state))
        else:
          outDegree[prevCat][prevMouse][prevMove] -= 1
          if outDegree[prevCat][prevMouse][prevMove] == 0:
            states[prevCat][prevMouse][prevMove] = state
            q.append((prevCat, prevMouse, prevMove, state))

    return states[2][1][0]"
"914","class Solution:
  def hasGroupsSizeX(self, deck: list[int]) -> bool:
    count = collections.Counter(deck)
    return functools.reduce(math.gcd, count.values()) >= 2"
"915","class Solution:
  def partitionDisjoint(self, nums: list[int]) -> int:
    n = len(nums)
    mn = [0] * (n - 1) + [nums[-1]]
    mx = -math.inf

    for i in range(n - 2, - 1, -1):
      mn[i] = min(mn[i + 1], nums[i])

    for i, num in enumerate(nums):
      mx = max(mx, num)
      if mx <= mn[i + 1]:
        return i + 1"
"916","class Solution:
  def wordSubsets(self, A: list[str], B: list[str]) -> list[str]:
    count = collections.Counter()

    for b in B:
      count = count | collections.Counter(b)

    return [a for a in A if collections.Counter(a) & count == count]"
"917","class Solution:
  def reverseOnlyLetters(self, s: str) -> str:
    ans = list(s)
    i = 0
    j = len(s) - 1

    while i < j:
      while i < j and not s[i].isalpha():
        i += 1
      while i < j and not s[j].isalpha():
        j -= 1
      ans[i], ans[j] = ans[j], ans[i]
      i += 1
      j -= 1

    return ''.join(ans)"
"918","class Solution:
  def maxSubarraySumCircular(self, nums: list[int]) -> int:
    totalSum = 0
    currMaxSum = 0
    currMinSum = 0
    maxSum = -math.inf
    minSum = math.inf

    for num in nums:
      totalSum += num
      currMaxSum = max(currMaxSum + num, num)
      currMinSum = min(currMinSum + num, num)
      maxSum = max(maxSum, currMaxSum)
      minSum = min(minSum, currMinSum)

    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)"
"919","class CBTInserter:
  def __init__(self, root: TreeNode | None):
    self.tree = [root]
    for node in self.tree:
      if node.left:
        self.tree.append(node.left)
      if node.right:
        self.tree.append(node.right)

  def insert(self, v: int) -> int:
    n = len(self.tree)
    self.tree.append(TreeNode(v))
    parent = self.tree[(n - 1) // 2]
    if n % 2 == 1:
      parent.left = self.tree[-1]
    else:
      parent.right = self.tree[-1]
    return parent.val

  def get_root(self) -> TreeNode | None:
    return self.tree[0]"
"92","class Solution:
  def reverseBetween(
      self,
      head: ListNode | None,
      left: int,
      right: int,
  ) -> ListNode | None:
    if left == 1:
      return self.reverseN(head, right)

    head.next = self.reverseBetween(head.next, left - 1, right - 1)
    return head

  def reverseN(self, head: ListNode | None, n: int) -> ListNode | None:
    if n == 1:
      return head

    newHead = self.reverseN(head.next, n - 1)
    headNext = head.next
    head.next = headNext.next
    headNext.next = head
    return newHead"
"920","class Solution {
  public int numMusicPlaylists(int n, int goal, int k) {
    final int kMod = 1_000_000_007;
    // dp[i][j] := the number of playlists with i songs and j different songs
    long[][] dp = new long[goal + 1][n + 1];
    dp[0][0] = 1;

    for (int i = 1; i <= goal; ++i)
      for (int j = 1; j <= n; ++j) {
        dp[i][j] += dp[i - 1][j - 1] * (n - (j - 1));  // The last song is new.
        dp[i][j] += dp[i - 1][j] * Math.max(0, j - k); // The last song is old.
        dp[i][j] %= kMod;
      }

    return (int) dp[goal][n];
  }
}"
"921","class Solution:
  def minAddToMakeValid(self, s: str) -> int:
    l = 0
    r = 0

    for c in s:
      if c == '(':
        l += 1
      else:
        if l == 0:
          r += 1
        else:
          l -= 1

    return l + r"
"922","class Solution:
  def sortArrayByParityII(self, nums: list[int]) -> list[int]:
    n = len(nums)

    i = 0
    j = 1
    while i < n:
      while i < n and nums[i] % 2 == 0:
        i += 2
      while j < n and nums[j] % 2 == 1:
        j += 2
      if i < n:
        nums[i], nums[j] = nums[j], nums[i]

    return nums"
"923","class Solution:
  def threeSumMulti(self, arr: list[int], target: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = collections.Counter(arr)

    for i, x in count.items():
      for j, y in count.items():
        k = target - i - j
        if k not in count:
          continue
        if i == j and j == k:
          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod
        elif i == j and j != k:
          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod
        elif i < j and j < k:
          ans = (ans + x * y * count[k]) % kMod

    return ans % kMod"
"924","class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    const int n = graph.size();
    UnionFind uf(n);
    vector<int> ufSize(n);
    vector<int> malwareCount(n);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (graph[i][j] == 1)
          uf.unionByRank(i, j);

    for (int i = 0; i < n; ++i)
      ++ufSize[uf.find(i)];

    for (const int i : initial)
      ++malwareCount[uf.find(i)];

    ranges::sort(initial);

    int ans = initial[0];
    int maxUfSize = 0;

    // Find the maximum union's malware if it only contains 1 malware.
    for (const int i : initial) {
      const int id = uf.find(i);
      if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {
        maxUfSize = ufSize[id];
        ans = i;
      }
    }

    return ans;
  }
};"
"925","class Solution:
  def isLongPressedName(self, name: str, typed: str) -> bool:
    i = 0

    for j, t in enumerate(typed):
      if i < len(name) and name[i] == t:
        i += 1
      elif j == 0 or t != typed[j - 1]:
        return False

    return i == len(name)"
"926","class Solution:
  def minFlipsMonoIncr(self, s: str) -> int:
    # the number of characters to be flilpped to make the substring so far
    # monotone increasing
    dp = 0
    count1 = 0

    for c in s:
      if c == '0':
        # 1. Flip '0'.
        # 2. Keep '0' and flip all the previous 1s.
        dp = min(dp + 1, count1)
      else:
        count1 += 1

    return dp"
"927","class Solution:
  def threeEqualParts(self, arr: list[int]) -> list[int]:
    ones = sum(a == 1 for a in arr)

    if ones == 0:
      return [0, len(arr) - 1]
    if ones % 3 != 0:
      return [-1, -1]

    k = ones // 3
    i = 0

    for i in range(len(arr)):
      if arr[i] == 1:
        first = i
        break

    gapOnes = k

    for j in range(i + 1, len(arr)):
      if arr[j] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          second = j
          break

    gapOnes = k

    for i in range(j + 1, len(arr)):
      if arr[i] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          third = i
          break

    while third < len(arr) and arr[first] == arr[second] == arr[third]:
      first += 1
      second += 1
      third += 1

    if third == len(arr):
      return [first - 1, second]
    return [-1, -1]"
"928","class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int ans = 0;
    int minCount = graph.size();

    ranges::sort(initial);

    for (const int i : initial) {
      const int count = bfs(graph, i, initial);
      if (count < minCount) {
        minCount = count;
        ans = i;
      }
    }

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {
    queue<int> q;
    vector<bool> seen(graph.size());
    seen[removed] = true;

    int count = 0;

    for (const int i : initial)
      if (i != removed) {
        q.push(i);
        seen[i] = true;
      }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      ++count;
      for (int i = 0; i < graph.size(); ++i) {
        if (seen[i])
          continue;
        if (i != u && graph[i][u]) {
          q.push(i);
          seen[i] = true;
        }
      }
    }

    return count;
  }
};"
"929","class Solution:
  def numUniqueEmails(self, emails: list[str]) -> int:
    seen = set()

    for email in emails:
      local, domain = email.split('@')
      local = local.split('+')[0].replace('.', '')
      seen.add(local + '@' + domain)

    return len(seen)"
"93","class Solution:
  def restoreIpAddresses(self, s: str) -> list[str]:
    ans = []

    def dfs(start: int, path: list[int]) -> None:
      if len(path) == 4 and start == len(s):
        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])
        return
      if len(path) == 4 or start == len(s):
        return

      for length in range(1, 4):
        if start + length > len(s):
          return  # out-of-bounds
        if length > 1 and s[start] == '0':
          return  # leading '0'
        num = s[start: start + length]
        if int(num) > 255:
          return
        dfs(start + length, path + [num])

    dfs(0, [])
    return ans"
"930","class Solution:
  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:
    def numSubarraysWithSumAtMost(goal: int) -> int:
      res = 0
      count = 0
      l = 0
      r = 0

      while r < len(nums):
        count += nums[r]
        r += 1
        while l < r and count > goal:
          count -= nums[l]
          l += 1
        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]
        res += r - l

      return res

    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)"
"931","class Solution:
  def minFallingPathSum(self, A: list[list[int]]) -> int:
    n = len(A)

    for i in range(1, n):
      for j in range(n):
        mn = math.inf
        for k in range(max(0, j - 1), min(n, j + 2)):
          mn = min(mn, A[i - 1][k])
        A[i][j] += mn

    return min(A[-1])"
"932","class Solution:
  def beautifulArray(self, n: int) -> list[int]:
    A = [i for i in range(1, n + 1)]

    def partition(l: int, r: int, mask: int) -> int:
      nextSwapped = l
      for i in range(l, r + 1):
        if A[i] & mask:
          A[i], A[nextSwapped] = A[nextSwapped], A[i]
          nextSwapped += 1
      return nextSwapped - 1

    def divide(l: int, r: int, mask: int) -> None:
      if l >= r:
        return
      m = partition(l, r, mask)
      divide(l, m, mask << 1)
      divide(m + 1, r, mask << 1)

    divide(0, n - 1, 1)
    return A"
"933","class RecentCounter:
  def __init__(self):
    self.q = collections.deque()

  def ping(self, t: int) -> int:
    self.q.append(t)
    while self.q[0] < t - 3000:
      self.q.popleft()
    return len(self.q)"
"934","class Solution {
  public int shortestBridge(int[][] grid) {
    final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    final int n = grid.length;
    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>();

    markGridTwo(grid, q);

    for (int ans = 0; !q.isEmpty(); ++ans)
      for (int sz = q.size(); sz > 0; --sz) {
        final int i = q.peek().getKey();
        final int j = q.poll().getValue();
        for (int[] dir : dirs) {
          final int x = i + dir[0];
          final int y = j + dir[1];
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (grid[x][y] == 2)
            continue;
          if (grid[x][y] == 1)
            return ans;
          grid[x][y] = 2;
          q.offer(new Pair<>(x, y));
        }
      }

    throw new IllegalArgumentException();
  }

  // Marks one group to 2s by DFS.
  private void markGridTwo(int[][] grid, Queue<Pair<Integer, Integer>> q) {
    for (int i = 0; i < grid.length; ++i)
      for (int j = 0; j < grid[0].length; ++j)
        if (grid[i][j] == 1) {
          markGridTwo(grid, i, j, q);
          return;
        }
  }

  // Marks one group to 2s by DFS and pushes them to the queue.
  private void markGridTwo(int[][] grid, int i, int j, Queue<Pair<Integer, Integer>> q) {
    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)
      return;
    if (grid[i][j] != 1)
      return;
    grid[i][j] = 2;
    q.offer(new Pair<>(i, j));
    markGridTwo(grid, i + 1, j, q);
    markGridTwo(grid, i - 1, j, q);
    markGridTwo(grid, i, j + 1, q);
    markGridTwo(grid, i, j - 1, q);
  }
}"
"935","class Solution:
  def knightDialer(self, n: int) -> int:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    kMod = 1_000_000_007

    # dp[i][j] := the number of ways stand on (i, j)
    dp = [[1] * 3 for _ in range(4)]
    dp[3][0] = dp[3][2] = 0

    for _ in range(n - 1):
      newDp = [[0] * 3 for _ in range(4)]
      for i in range(4):
        for j in range(3):
          if (i, j) in ((3, 0), (3, 2)):
            continue
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if x < 0 or x >= 4 or y < 0 or y >= 3:
              continue
            if (x, y) in ((3, 0), (3, 2)):
              continue
            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod
      dp = newDp

    return sum(map(sum, dp)) % kMod"
"936","class Solution:
  def movesToStamp(self, stamp: str, target: str) -> list[int]:
    def stampify(s: int) -> int:
      """"""
      Stamps target[i..i + |stamp|) and returns the number of newly stamped
      characters.
      e.g. stampify(""abc"", ""ababc"", 2) returns 3 because target becomes ""ab***"".
      """"""
      stampified = len(stamp)

      for i, st in enumerate(stamp):
        if target[s + i] == '*':  # It's already been stamped.
          stampified -= 1
        elif target[s + i] != st:  # We can't stamp on the index i.
          return 0

      for i in range(s, s + len(stamp)):
        target[i] = '*'

      return stampified

    ans = []
    target = list(target)
    # stamped[i] := True if we already stamped target by stamping on index i
    stamped = [False] * len(target)
    stampedCount = 0  # Our goal is to make stampedCount = |target|.

    while stampedCount < len(target):
      isStamped = False
      # Try to stamp target[i..i + |stamp|) for each index.
      for i in range(len(target) - len(stamp) + 1):
        if stamped[i]:
          continue
        stampified = stampify(i)
        if stampified == 0:
          continue
        stampedCount += stampified
        isStamped = True
        stamped[i] = True
        ans.append(i)
      # After trying to stamp on each index, we can't find a valid stamp.
      if not isStamped:
        return []

    return ans[::-1]"
"937","class Solution:
  def reorderLogFiles(self, logs: list[str]) -> list[str]:
    digitLogs = []
    letterLogs = []

    for log in logs:
      i = log.index(' ')
      if log[i + 1].isdigit():
        digitLogs.append(log)
      else:
        letterLogs.append((log[:i], log[i + 1:]))

    letterLogs.sort(key=lambda x: (x[1], x[0]))
    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs"
"938","class Solution {
 public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return 0;
    if (root->val < L)
      return rangeSumBST(root->right, L, R);
    if (root->val > R)
      return rangeSumBST(root->left, L, R);
    return root->val + rangeSumBST(root->left, L, R) +
           rangeSumBST(root->right, L, R);
  }
};"
"939","class Solution:
  def minAreaRect(self, points: list[list[int]]) -> int:
    ans = math.inf
    xToYs = collections.defaultdict(set)

    for x, y in points:
      xToYs[x].add(y)

    for i in range(len(points)):
      for j in range(i):
        x1, y1 = points[i]
        x2, y2 = points[j]
        if x1 == x2 or y1 == y2:
          continue
        if y2 in xToYs[x1] and y1 in xToYs[x2]:
          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))

    return ans if ans < math.inf else 0"
"94","class Solution:
  def inorderTraversal(self, root: TreeNode | None) -> list[int]:
    ans = []
    stack = []

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      ans.append(root.val)
      root = root.right

    return ans"
"940","class Solution:
  def distinctSubseqII(self, s: str) -> int:
    kMod = 1_000_000_007
    # endsIn[i] := the number of subsequence that end in ('a' + i)
    endsIn = [0] * 26

    for c in s:
      endsIn[string.ascii_lowercase.index(c)] = (sum(endsIn) + 1) % kMod

    return sum(endsIn) % kMod"
"941","class Solution:
  def validMountainArray(self, arr: list[int]) -> bool:
    if len(arr) < 3:
      return False

    l = 0
    r = len(arr) - 1

    while l + 1 < len(arr) and arr[l] < arr[l + 1]:
      l += 1
    while r > 0 and arr[r] < arr[r - 1]:
      r -= 1

    return l > 0 and r < len(arr) - 1 and l == r"
"942","class Solution:
  def diStringMatch(self, s: str) -> list[int]:
    ans = []
    mn = 0
    mx = len(s)

    for c in s:
      if c == 'I':
        ans.append(mn)
        mn += 1
      else:
        ans.append(mx)
        mx -= 1

    return ans + [mn]"
"943","class Solution {
  public String shortestSuperstring(String[] words) {
    final int n = words.length;
    // cost[i][j] := the cost to append words[j] after words[i]
    int[][] cost = new int[n][n];
    // Pre-calculate the `cost` array to save time.
    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        cost[i][j] = getCost(words[i], words[j]);
        cost[j][i] = getCost(words[j], words[i]);
      }
    // dp[s][j] := the minimum cost to visit nodes of s ending in j, s is a
    // binary Value, e.g. dp[6][2] means the minimum cost to visit {1, 2} ending
    // in 2 (6 = 2^1 + 2^2)
    int[][] dp = new int[1 << n][n];
    Arrays.stream(dp).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE / 2));
    // parent[s][j] := the parent of ""nodes of s ending in j""
    int[][] parent = new int[1 << n][n];
    Arrays.stream(parent).forEach(A -> Arrays.fill(A, -1));

    for (int i = 0; i < n; ++i)
      dp[1 << i][i] = words[i].length();

    // Enumerate all the states ending in different nodes.
    for (int s = 1; s < (1 << n); ++s)
      for (int i = 0; i < n; ++i) {
        if ((s & (1 << i)) == 0)
          continue;
        for (int j = 0; j < n; ++j)
          if (dp[s - (1 << i)][j] + cost[j][i] < dp[s][i]) {
            dp[s][i] = dp[s - (1 << i)][j] + cost[j][i];
            parent[s][i] = j;
          }
      }

    String ans = """";
    int j = getLastNode(dp[(1 << n) - 1]);
    int s = (1 << n) - 1; // 2^0 + 2^1 + ... + 2^(n - 1)

    // Traverse back to build the string.
    while (s > 0) {
      final int i = parent[s][j];
      if (i == -1)
        ans = words[j] + ans;
      else
        ans = words[j].substring(words[j].length() - cost[i][j]) + ans;
      s -= 1 << j;
      j = i;
    }

    return ans;
  }

  // Returns the cost to append b after a.
  private int getCost(final String a, final String b) {
    int cost = b.length();
    final int minLength = Math.min(a.length(), b.length());
    for (int k = 1; k <= minLength; ++k)
      if (a.substring(a.length() - k).equals(b.substring(0, k)))
        cost = b.length() - k;
    return cost;
  }

  private int getLastNode(int[] row) {
    int minIndex = 0;
    for (int i = 1; i < row.length; ++i)
      if (row[i] < row[minIndex])
        minIndex = i;
    return minIndex;
  }
}"
"944","class Solution:
  def minDeletionSize(self, strs: list[str]) -> int:
    ans = 0

    for j in range(len(strs[0])):
      for i in range(len(strs) - 1):
        if strs[i][j] > strs[i + 1][j]:
          ans += 1
          break

    return ans"
"945","class Solution:
  def minIncrementForUnique(self, nums: list[int]) -> int:
    ans = 0
    minAvailable = 0

    for num in sorted(nums):
      ans += max(minAvailable - num, 0)
      minAvailable = max(minAvailable, num) + 1

    return ans"
"946","class Solution:
  def validateStackSequences(
      self,
      pushed: list[int],
      popped: list[int],
  ) -> bool:
    stack = []
    i = 0  # popped's index

    for x in pushed:
      stack.append(x)
      while stack and stack[-1] == popped[i]:
        stack.pop()
        i += 1

    return not stack"
"947","class Solution {
  public int removeStones(int[][] stones) {
    int numOfIslands = 0;
    List<Integer>[] graph = new List[stones.length];
    Set<Integer> seen = new HashSet<>();

    for (int i = 0; i < graph.length; ++i)
      graph[i] = new ArrayList<>();

    for (int i = 0; i < stones.length; ++i)
      for (int j = i + 1; j < stones.length; ++j)
        if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
          graph[i].add(j);
          graph[j].add(i);
        }

    for (int i = 0; i < stones.length; ++i)
      if (seen.add(i)) {
        dfs(graph, i, seen);
        ++numOfIslands;
      }

    return stones.length - numOfIslands;
  }

  private void dfs(List<Integer>[] graph, int u, Set<Integer> seen) {
    for (final int v : graph[u])
      if (seen.add(v))
        dfs(graph, v, seen);
  }
}"
"948","class Solution:
  def bagOfTokensScore(self, tokens: list[int], power: int) -> int:
    ans = 0
    score = 0
    q = collections.deque(sorted(tokens))

    while q and (power >= q[0] or score):
      while q and power >= q[0]:
        # Play the smallest face up.
        power -= q.popleft()
        score += 1
      ans = max(ans, score)
      if q and score:
        # Play the largest face down.
        power += q.pop()
        score -= 1

    return ans"
"949","class Solution:
  def largestTimeFromDigits(self, arr: list[int]) -> str:
    for time in itertools.permutations(sorted(arr, reverse=True)):
      if time[:2] < (2, 4) and time[2] < 6:
        return '%d%d:%d%d' % time
    return ''"
"95","class Solution:
  def generateTrees(self, n: int) -> list[TreeNode]:
    if n == 0:
      return []

    def generateTrees(mn: int, mx: int) -> list[int | None]:
      if mn > mx:
        return [None]

      ans = []

      for i in range(mn, mx + 1):
        for left in generateTrees(mn, i - 1):
          for right in generateTrees(i + 1, mx):
            ans.append(TreeNode(i))
            ans[-1].left = left
            ans[-1].right = right

      return ans

    return generateTrees(1, n)"
"950","class Solution:
  def deckRevealedIncreasing(self, deck: list[int]) -> list[int]:
    dq = collections.deque()

    for card in reversed(sorted(deck)):
      dq.rotate()
      dq.appendleft(card)

    return list(dq)"
"951","class Solution:
  def flipEquiv(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:
    if not root1:
      return not root2
    if not root2:
      return not root1
    if root1.val != root2.val:
      return False
    return (self.flipEquiv(root1.left, root2.left) and
            self.flipEquiv(root1.right, root2.right) or
            self.flipEquiv(root1.left, root2.right) and
            self.flipEquiv(root1.right, root2.left))"
"952","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def largestComponentSize(self, nums: list[int]) -> int:
    ans = 0
    uf = UnionFind(max(nums) + 1)
    count = collections.Counter()

    for num in nums:
      for x in range(2, math.isqrt(num) + 1):
        if num % x == 0:
          uf.unionByRank(num, x)
          uf.unionByRank(num, num // x)

    for num in nums:
      numRoot = uf.find(num)
      count[numRoot] += 1
      ans = max(ans, count[numRoot])

    return ans"
"953","class Solution:
  def isAlienSorted(self, words: list[str], order: str) -> bool:
    dict = {c: i for i, c in enumerate(order)}
    words = [[dict[c] for c in word] for word in words]
    return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))"
"954","class Solution:
  def canReorderDoubled(self, arr: list[int]) -> bool:
    count = collections.Counter(arr)

    for key in sorted(count, key=abs):
      if count[key] > count[2 * key]:
        return False
      count[2 * key] -= count[key]

    return True"
"955","class Solution {
  public int minDeletionSize(String[] strs) {
    final int n = strs.length;
    int ans = 0;
    // sorted[i] := true if strs[i] < strs[i + 1]
    boolean[] sorted = new boolean[n - 1];

    for (int j = 0; j < strs[0].length(); ++j) {
      int i;
      for (i = 0; i + 1 < n; ++i)
        if (!sorted[i] && strs[i].charAt(j) > strs[i + 1].charAt(j)) {
          ++ans;
          break;
        }
      // strslready compared each pair, so update the sorted array if needed.
      if (i + 1 == n)
        for (i = 0; i + 1 < n; ++i)
          sorted[i] = sorted[i] || strs[i].charAt(j) < strs[i + 1].charAt(j);
    }

    return ans;
  }
}"
"956","class Solution {
 public:
  int tallestBillboard(vector<int>& rods) {
    const int sum = accumulate(rods.begin(), rods.end(), 0);
    // dp[i] := the maximum min-height of using rods so far to pile two piles
    // that have height difference i
    vector<int> dp(sum + 1, -1);
    dp[0] = 0;

    for (const int h : rods) {
      vector<int> prev(dp);
      for (int i = 0; i <= sum - h; ++i) {
        if (prev[i] < 0)
          continue;
        // Don't use this rod.
        dp[i] = max(dp[i], prev[i]);
        // Put on the taller pile.
        dp[i + h] = max(dp[i + h], prev[i]);
        // Put on the shorter pile.
        dp[abs(i - h)] = max(dp[abs(i - h)], prev[i] + min(i, h));
      }
    }

    return dp[0];
  }
};"
"957","class Solution:
  def prisonAfterNDays(self, cells: list[int], n: int) -> list[int]:
    nextDayCells = [0] * len(cells)
    day = 0

    while n > 0:
      n -= 1
      for i in range(1, len(cells) - 1):
        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0
      if day == 0:
        firstDayCells = nextDayCells.copy()
      elif nextDayCells == firstDayCells:
        n %= day
      cells = nextDayCells.copy()
      day += 1

    return cells"
"958","class Solution {
 public:
  bool isCompleteTree(TreeNode* root) {
    if (root == nullptr)
      return true;

    queue<TreeNode*> q{{root}};

    while (q.front() != nullptr) {
      TreeNode* node = q.front();
      q.pop();
      q.push(node->left);
      q.push(node->right);
    }

    while (!q.empty() && q.front() == nullptr)
      q.pop();

    return q.empty();
  }
};"
"959","class Solution {
 public:
  int regionsBySlashes(vector<string>& grid) {
    const int n = grid.size();
    // G := upscaled grid
    vector<vector<int>> g(n * 3, vector<int>(n * 3));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '/') {
          g[i * 3][j * 3 + 2] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3] = 1;
        } else if (grid[i][j] == '\\') {
          g[i * 3][j * 3] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3 + 2] = 1;
        }

    int ans = 0;

    for (int i = 0; i < n * 3; ++i)
      for (int j = 0; j < n * 3; ++j)
        if (g[i][j] == 0) {
          dfs(g, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return;
    if (g[i][j] != 0)
      return;

    g[i][j] = 2;  // Mark 2 as visited.
    dfs(g, i + 1, j);
    dfs(g, i - 1, j);
    dfs(g, i, j + 1);
    dfs(g, i, j - 1);
  }
};"
"96","class Solution:
  def numTrees(self, n: int) -> int:
    # dp[i] := the number of unique BST's that store values 1..i
    dp = [1, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
      for j in range(i):
        dp[i] += dp[j] * dp[i - j - 1]

    return dp[n]"
"960","class Solution {
 public:
  int minDeletionSize(vector<string>& strs) {
    const int k = strs[0].length();
    // dp[i] the length of LIS ending in strs[*][i]
    vector<int> dp(k, 1);

    for (int i = 1; i < k; ++i)
      for (int j = 0; j < i; ++j)
        if (ranges::all_of(strs, [&](const string& s) { return s[j] <= s[i]; }))
          dp[i] = max(dp[i], dp[j] + 1);

    return k - ranges::max(dp);
  }
};"
"961","class Solution:
  def repeatedNTimes(self, nums: list[int]) -> int:
    for i in range(len(nums) - 2):
      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:
        return nums[i]
    return nums[-1]"
"962","class Solution:
  def maxWidthRamp(self, nums: list[int]) -> int:
    ans = 0
    stack = []

    for i, num in enumerate(nums):
      if stack == [] or num <= nums[stack[-1]]:
        stack.append(i)

    for i, num in reversed(list(enumerate(nums))):
      while stack and num >= nums[stack[-1]]:
        ans = max(ans, i - stack.pop())

    return ans"
"963","class Solution:
  def minAreaFreeRect(self, points: list[list[int]]) -> float:
    ans = math.inf
    # For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.
    centerToPoints = collections.defaultdict(list)

    for ax, ay in points:
      for bx, by in points:
        center = ((ax + bx) / 2, (ay + by) / 2)
        centerToPoints[center].append((ax, ay, bx, by))

    def dist(px: int, py: int, qx: int, qy: int) -> float:
      return (px - qx)**2 + (py - qy)**2

    # For all pair points ""that share the same center"".
    for points in centerToPoints.values():
      for ax, ay, _, _ in points:
        for cx, cy, dx, dy in points:
          # AC is perpendicular to AD.
          # AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.
          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:
            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)
            if squaredArea > 0:
              ans = min(ans, squaredArea)

    return 0 if ans == math.inf else math.sqrt(ans)"
"964","class Solution:
  def leastOpsExpressTarget(self, x: int, target: int) -> int:
    @functools.lru_cache(None)
    def dfs(target):
      if x > target:
        return min(2 * target - 1, 2 * (x - target))
      if x == target:
        return 0

      prod = x
      n = 0
      while prod < target:
        prod *= x
        n += 1
      if prod == target:
        return n

      ans = dfs(target - prod // x) + n
      if prod < 2 * target:
        ans = min(ans, dfs(prod - target) + n + 1)
      return ans

    return dfs(target)"
"965","class Solution:
  def isUnivalTree(self, root: TreeNode | None) -> bool:
    if not root:
      return True
    if root.left and root.left.val != root.val:
      return False
    if root.right and root.right.val != root.val:
      return False
    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)"
"966","class Solution:
  def spellchecker(self, wordlist: list[str], queries: list[str]) -> list[str]:
    def lowerKey(word: str) -> str:
      return '$' + ''.join([c.lower() for c in word])

    def vowelKey(word: str) -> str:
      return ''.join(['*' if c.lower() in 'aeiou' else c.lower() for c in word])

    ans = []
    dict = {}

    for word in wordlist:
      dict.setdefault(word, word)
      dict.setdefault(lowerKey(word), word)
      dict.setdefault(vowelKey(word), word)

    for query in queries:
      if query in dict:
        ans.append(dict[query])
      elif lowerKey(query) in dict:
        ans.append(dict[lowerKey(query)])
      elif vowelKey(query) in dict:
        ans.append(dict[vowelKey(query)])
      else:
        ans.append('')

    return ans"
"967","class Solution {
  public int[] numsSameConsecDiff(int n, int k) {
    if (n == 1)
      return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    List<Integer> ans = new ArrayList<>();

    if (k == 0) {
      for (char c = '1'; c <= '9'; ++c) {
        final String s = String.valueOf(c).repeat(n);
        ans.add(Integer.parseInt(s));
      }
      return ans.stream().mapToInt(Integer::intValue).toArray();
    }

    for (int num = 1; num <= 9; ++num)
      dfs(n - 1, k, num, ans);

    return ans.stream().mapToInt(Integer::intValue).toArray();
  }

  private void dfs(int n, int k, int num, List<Integer> ans) {
    if (n == 0) {
      ans.add(num);
      return;
    }

    final int lastDigit = num % 10;

    for (final int nextDigit : new int[] {lastDigit - k, lastDigit + k})
      if (0 <= nextDigit && nextDigit <= 9)
        dfs(n - 1, k, num * 10 + nextDigit, ans);
  }
}"
"968","class Solution {
 public:
  int minCameraCover(TreeNode* root) {
    vector<int> ans = dfs(root);
    return min(ans[1], ans[2]);
  }

 private:
  // 0 := all the nodes below the root are covered except the root
  // 1 := all the nodes below and including the root are covered with no camera
  // 2 := all nodes below and including the root are covered with a camera
  vector<int> dfs(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 1000};

    vector<int> l = dfs(root->left);
    vector<int> r = dfs(root->right);

    const int s0 = l[1] + r[1];
    const int s1 = min(l[2] + min(r[1], r[2]),  //
                       r[2] + min(l[1], l[2]));
    const int s2 = min({l[0], l[1], l[2]}) +  //
                   min({r[0], r[1], r[2]}) + 1;
    return {s0, s1, s2};
  }
};"
"969","class Solution:
  def pancakeSort(self, arr: list[int]) -> list[int]:
    ans = []

    for target in range(len(arr), 0, -1):
      index = arr.index(target)
      arr[:index + 1] = arr[:index + 1][::-1]
      arr[:target] = arr[:target][::-1]
      ans.append(index + 1)
      ans.append(target)

    return ans"
"97","class Solution:
  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
    m = len(s1)
    n = len(s2)
    if m + n != len(s3):
      return False

    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of
    # s1[0..i) and s2[0..j)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for i in range(1, m + 1):
      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]

    for j in range(1, n + 1):
      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or
                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]"
"970","class Solution:
  def powerfulIntegers(self, x: int, y: int, bound: int) -> list[int]:
    xs = {x**i for i in range(20) if x**i < bound}
    ys = {y**i for i in range(20) if y**i < bound}
    return list({i + j for i in xs for j in ys if i + j <= bound})"
"971","class Solution {
  public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
    List<Integer> ans = new ArrayList<>();

    dfs(root, voyage, ans);

    return ans;
  }

  private int i = 0;

  private void dfs(TreeNode root, int[] voyage, List<Integer> ans) {
    if (root == null)
      return;
    if (root.val != voyage[i++]) {
      ans.clear();
      ans.add(-1);
      return;
    }

    if (i < voyage.length && root.left != null && root.left.val != voyage[i]) {
      // Flip the root.
      ans.add(root.val);
      dfs(root.right, voyage, ans);
      dfs(root.left, voyage, ans);
    } else {
      dfs(root.left, voyage, ans);
      dfs(root.right, voyage, ans);
    }
  }
}"
"972","class Solution:
  def isRationalEqual(self, s: str, t: str) -> bool:
    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]

    def valueOf(s: str) -> float:
      if s.find('(') == -1:
        return float(s)

      # Get the indices.
      leftParenIndex = s.find('(')
      rightParenIndex = s.find(')')
      dotIndex = s.find('.')

      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>
      integerAndNonRepeating = float(s[:leftParenIndex])
      nonRepeatingLength = leftParenIndex - dotIndex - 1

      # repeating := <RepeatingPart>
      repeating = int(s[leftParenIndex + 1:rightParenIndex])
      repeatingLength = rightParenIndex - leftParenIndex - 1
      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]

    return abs(valueOf(s) - valueOf(t)) < 1e-9"
"973","class Solution:
  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:
    def squareDist(p: list[int]) -> int:
      return p[0] * p[0] + p[1] * p[1]

    def quickSelect(l: int, r: int, k: int) -> None:
      pivot = points[r]

      nextSwapped = l
      for i in range(l, r):
        if squareDist(points[i]) <= squareDist(pivot):
          points[nextSwapped], points[i] = points[i], points[nextSwapped]
          nextSwapped += 1
      points[nextSwapped], points[r] = points[r], points[nextSwapped]

      count = nextSwapped - l + 1  the number of points <= pivot
      if count == k:
        return
      if count > k:
        quickSelect(l, nextSwapped - 1, k)
      else:
        quickSelect(nextSwapped + 1, r, k - count)

    quickSelect(0, len(points) - 1, k)
    return points[0:k]"
"974","class Solution:
  def subarraysDivByK(self, nums: list[int], k: int) -> int:
    ans = 0
    prefix = 0
    count = [0] * k
    count[0] = 1

    for num in nums:
      prefix = (prefix + num % k + k) % k
      ans += count[prefix]
      count[prefix] += 1

    return ans"
"975","class Solution {
 public:
  int oddEvenJumps(vector<int>& arr) {
    const int n = arr.size();
    map<int, int> map;  // {num: min index}
    // inc[i] := true if can reach arr[n - 1] from i using increasing jumps
    vector<bool> inc(n);
    // dec[i] := true if can reach arr[n - 1] from i using decreasing jumps
    vector<bool> dec(n);

    map[arr[n - 1]] = n - 1;
    inc.back() = true;
    dec.back() = true;

    for (int i = n - 2; i >= 0; --i) {
      const auto lo = map.lower_bound(arr[i]);  // the minimum value >= arr[i]
      const auto hi = map.upper_bound(arr[i]);  // the minimum value > arr[i]
      if (lo != map.cend())
        inc[i] = dec[lo->second];
      if (hi != map.cbegin())
        dec[i] = inc[prev(hi)->second];
      map[arr[i]] = i;
    }

    return ranges::count(inc, true);
  }
};"
"976","class Solution:
  def largestPerimeter(self, nums: list[int]) -> int:
    nums = sorted(nums)

    for i in range(len(nums) - 1, 1, -1):
      if nums[i - 2] + nums[i - 1] > nums[i]:
        return nums[i - 2] + nums[i - 1] + nums[i]

    return 0"
"977","class Solution:
  def sortedSquares(self, nums: list[int]) -> list[int]:
    n = len(nums)
    l = 0
    r = n - 1
    ans = [0] * n

    while n:
      n -= 1
      if abs(nums[l]) > abs(nums[r]):
        ans[n] = nums[l] * nums[l]
        l += 1
      else:
        ans[n] = nums[r] * nums[r]
        r -= 1

    return ans"
"978","class Solution:
  def maxTurbulenceSize(self, arr: list[int]) -> int:
    ans = 1
    increasing = 1
    decreasing = 1

    for i in range(1, len(arr)):
      if arr[i] > arr[i - 1]:
        increasing = decreasing + 1
        decreasing = 1
      elif arr[i] < arr[i - 1]:
        decreasing = increasing + 1
        increasing = 1
      else:
        increasing = 1
        decreasing = 1
      ans = max(ans, max(increasing, decreasing))

    return ans"
"979","class Solution {
  public int distributeCoins(TreeNode root) {
    dfs(root);
    return ans;
  }

  private int ans = 0;

  // Returns the number of coins I can give (positive) / take (negative).
  private int dfs(TreeNode root) {
    if (root == null)
      return 0;

    final int l = dfs(root.left);
    final int r = dfs(root.right);
    ans += Math.abs(l) + Math.abs(r);

    return (root.val - 1) + l + r;
  }
}"
"98","class Solution:
  def isValidBST(self, root: TreeNode | None) -> bool:
    def isValidBST(root: TreeNode | None,
                   minNode: TreeNode | None, maxNode: TreeNode | None) -> bool:
      if not root:
        return True
      if minNode and root.val <= minNode.val:
        return False
      if maxNode and root.val >= maxNode.val:
        return False

      return (isValidBST(root.left, minNode, root) and
              isValidBST(root.right, root, maxNode))

    return isValidBST(root, None, None)"
"980","class Solution {
  public int uniquePathsIII(int[][] grid) {
    int empty = 1;
    int sx = -1;
    int sy = -1;
    int ex = -1;
    int ey = -1;

    for (int i = 0; i < grid.length; ++i)
      for (int j = 0; j < grid[0].length; ++j)
        if (grid[i][j] == 0) {
          ++empty;
        } else if (grid[i][j] == 1) {
          sx = i;
          sy = j;
        } else if (grid[i][j] == 2) {
          ex = i;
          ey = j;
        }

    dfs(grid, empty, sx, sy, ex, ey);

    return ans;
  }

  private int ans = 0;

  private void dfs(int[][] grid, int empty, int i, int j, int ex, int ey) {
    if (i < 0 || i == grid.length || j < 0 || j == grid[0].length)
      return;
    if (grid[i][j] < 0)
      return;
    if (i == ex && j == ey) {
      if (empty == 0)
        ++ans;
      return;
    }

    grid[i][j] = -2;
    dfs(grid, empty - 1, i + 1, j, ex, ey);
    dfs(grid, empty - 1, i - 1, j, ex, ey);
    dfs(grid, empty - 1, i, j + 1, ex, ey);
    dfs(grid, empty - 1, i, j - 1, ex, ey);
    grid[i][j] = 0;
  }
}"
"981","class TimeMap:
  def __init__(self):
    self.values = collections.defaultdict(list)
    self.timestamps = collections.defaultdict(list)

  def set(self, key: str, value: str, timestamp: int) -> None:
    self.values[key].append(value)
    self.timestamps[key].append(timestamp)

  def get(self, key: str, timestamp: int) -> str:
    if key not in self.timestamps:
      return ''
    i = bisect.bisect(self.timestamps[key], timestamp)
    return self.values[key][i - 1] if i > 0 else ''"
"982","class Solution:
  def countTriplets(self, nums: list[int]) -> int:
    kMax = 1 << 16
    ans = 0
    count = [0] * kMax  # {nums[i] & nums[j]: times}

    for a in nums:
      for b in nums:
        count[a & b] += 1

    for num in nums:
      for i in range(kMax):
        if (num & i) == 0:
          ans += count[i]

    return ans"
"983","class Solution:
  def mincostTickets(self, days: list[int], costs: list[int]) -> int:
    ans = 0
    last7 = collections.deque()
    last30 = collections.deque()

    for day in days:
      while last7 and last7[0][0] + 7 <= day:
        last7.popleft()
      while last30 and last30[0][0] + 30 <= day:
        last30.popleft()
      last7.append([day, ans + costs[1]])
      last30.append([day, ans + costs[2]])
      ans = min(ans + costs[0], last7[0][1], last30[0][1])

    return ans"
"984","class Solution {
 public:
  string strWithout3a3b(int A, int B, char a = 'a', char b = 'b') {
    if (A < B)
      return strWithout3a3b(B, A, b, a);
    if (B == 0)
      return string(min(A, 2), a);

    const int useA = min(A, 2);
    const int useB = (A - useA >= B) ? 1 : 0;
    return string(useA, a) + string(useB, b) +
           strWithout3a3b(A - useA, B - useB, a, b);
  }
};"
"985","class Solution:
  def sumEvenAfterQueries(
      self,
      nums: list[int],
      queries: list[list[int]],
  ) -> list[int]:
    ans = []
    summ = sum(a for a in nums if a % 2 == 0)

    for val, index in queries:
      if nums[index] % 2 == 0:
        summ -= nums[index]
      nums[index] += val
      if nums[index] % 2 == 0:
        summ += nums[index]
      ans.append(summ)

    return ans"
"986","class Solution:
  def intervalIntersection(self, firstList: list[list[int]],
                           secondList: list[list[int]]) -> list[list[int]]:
    ans = []
    i = 0
    j = 0

    while i < len(firstList) and j < len(secondList):
      # lo := the start of the intersection
      # hi := the end of the intersection
      lo = max(firstlist[i][0], secondlist[j][0])
      hi = min(firstlist[i][1], secondlist[j][1])
      if lo <= hi:
        ans.append([lo, hi])
      if firstlist[i][1] < secondlist[j][1]:
        i += 1
      else:
        j += 1

    return ans"
"987","class Solution:
  def verticalTraversal(self, root: TreeNode | None) -> list[list[int]]:
    ans = []
    xToNodes = collections.defaultdict(list)

    def dfs(node: TreeNode | None, x: int, y: int) -> None:
      if not node:
        return
      xToNodes[x].append((-y, node.val))
      dfs(node.left, x - 1, y - 1)
      dfs(node.right, x + 1, y - 1)

    dfs(root, 0, 0)

    for _, nodes in sorted(xToNodes.items(), key=lambda x: x[0]):
      ans.append([val for _, val in sorted(nodes)])

    return ans"
"988","class Solution {
 public:
  string smallestFromLeaf(TreeNode* root) {
    string ans;
    dfs(root, """", ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, string&& path, string& ans) {
    if (root == nullptr)
      return;

    path.push_back(root->val + 'a');

    if (root->left == nullptr && root->right == nullptr) {
      ranges::reverse(path);
      if (ans == """" || ans > path)
        ans = path;
      ranges::reverse(path);  // Roll back.
    }

    dfs(root->left, std::move(path), ans);
    dfs(root->right, std::move(path), ans);
    path.pop_back();
  }
};"
"989","class Solution:
  def addToArrayForm(self, num: list[int], k: int) -> list[int]:
    for i in reversed(range(len(num))):
      k, num[i] = divmod(num[i] + k, 10)

    while k > 0:
      num = [k % 10] + num
      k //= 10

    return num"
"99","class Solution:
  def recoverTree(self, root: TreeNode | None) -> None:
    def swap(x: TreeNode | None, y: TreeNode | None) -> None:
      temp = x.val
      x.val = y.val
      y.val = temp

    def inorder(root: TreeNode | None) -> None:
      if not root:
        return

      inorder(root.left)

      if self.pred and root.val < self.pred.val:
        self.y = root
        if not self.x:
          self.x = self.pred
        else:
          return
      self.pred = root

      inorder(root.right)

    inorder(root)
    swap(self.x, self.y)

  pred = None
  x = None  # the first wrong node
  y = None  # the second wrong node"
"990","class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))

  def union(self, u: int, v: int) -> None:
    self.id[self.find(u)] = self.find(v)

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def equationsPossible(self, equations: list[str]) -> bool:
    uf = UnionFind(26)

    for x, op, _, y in equations:
      if op == '=':
        uf.union(string.ascii_lowercase.index(x),
                 string.ascii_lowercase.index(y))

    return all(
        uf.find(string.ascii_lowercase.index(x)) !=
        uf.find(string.ascii_lowercase.index(y))
        for x, op, _, y in equations
        if op == '!')"
"991","class Solution:
  def brokenCalc(self, startValue: int, target: int) -> int:
    ops = 0

    while startValue < target:
      if target % 2 == 0:
        target //= 2
      else:
        target += 1
      ops += 1

    return ops + startValue - target"
"992","class Solution:
  def subarraysWithKDistinct(self, nums: list[int], k: int) -> int:
    def subarraysWithAtMostKDistinct(k: int) -> int:
      res = 0
      count = collections.Counter()

      l = 0
      for r, num in enumerate(nums):
        count[num] += 1
        if count[num] == 1:
          k -= 1
        while k < 0:
          count[nums[l]] -= 1
          if count[nums[l]] == 0:
            k += 1
          l += 1
        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]

      return res

    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)"
"993","class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
    if (root == nullptr)
      return false;

    queue<TreeNode*> queue{{root}};

    while (!queue.empty()) {
      bool isFindX = false;
      bool isFindY = false;
      for (int i = queue.size(); i > 0; --i) {
        root = queue.front(), queue.pop();
        if (root->val == x)
          isFindX = true;
        else if (root->val == y)
          isFindY = true;
        else if (root->left && root->right) {
          if (root->left->val == x && root->right->val == y)
            return false;
          if (root->left->val == y && root->right->val == x)
            return false;
        }
        if (root->left)
          queue.push(root->left);
        if (root->right)
          queue.push(root->right);
      }
      if (isFindX && isFindY)
        return true;
      else if (isFindX || isFindY)
        return false;
    }

    return false;
  }
};"
"994","class Solution {
 public:
  int orangesRotting(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    int countFresh = 0;
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          ++countFresh;
        else if (grid[i][j] == 2)
          q.emplace(i, j);

    if (countFresh == 0)
      return 0;

    int step = 0;
    for (; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] != 1)
            continue;
          grid[x][y] = 2;   // Mark grid[x][y] as rotten.
          q.emplace(x, y);  // Push the newly rotten orange to the queue.
          --countFresh;     // Decrease the count of fresh oranges by 1.
        }
      }

    return countFresh == 0 ? step - 1 : -1;
  }
};"
"995","class Solution:
  def minKBitFlips(self, nums: list[int], k: int) -> int:
    ans = 0
    flippedTime = 0

    for i, num in enumerate(nums):
      if i >= k and nums[i - k] == 2:
        flippedTime -= 1
      if flippedTime % 2 == num:
        if i + k > len(nums):
          return -1
        ans += 1
        flippedTime += 1
        nums[i] = 2

    return ans"
"996","class Solution:
  def numSquarefulPerms(self, nums: list[int]) -> int:
    ans = 0
    used = [False] * len(nums)

    def isSquare(num: int) -> bool:
      root = math.isqrt(num)
      return root * root == num

    def dfs(path: list[int]) -> None:
      nonlocal ans
      if len(path) > 1 and not isSquare(path[-1] + path[-2]):
        return
      if len(path) == len(nums):
        ans += 1
        return

      for i, a in enumerate(nums):
        if used[i]:
          continue
        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
          continue
        used[i] = True
        dfs(path + [a])
        used[i] = False

    nums.sort()
    dfs([])
    return ans"
"997","class Solution:
  def findJudge(self, n: int, trust: list[list[int]]) -> int:
    count = [0] * (n + 1)

    for a, b in trust:
      count[a] -= 1
      count[b] += 1

    for i in range(1, n + 1):
      if count[i] == n - 1:
        return i

    return -1"
"998","class Solution:
  def insertIntoMaxTree(
      self,
      root: TreeNode | None,
      val: int,
  ) -> TreeNode | None:
    if root.val < val:
      return TreeNode(val, root, None)
    curr = root
    while curr.right and curr.right.val > val:
      curr = curr.right
    inserted = TreeNode(val, curr.right, None)
    curr.right = inserted
    return root"
"999","class Solution:
  def numRookCaptures(self, board: list[list[str]]) -> int:
    ans = 0

    for i in range(8):
      for j in range(8):
        if board[i][j] == 'R':
          i0 = i
          j0 = j

    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
      i = i0 + d[0]
      j = j0 + d[1]
      while 0 <= i < 8 and 0 <= j < 8:
        if board[i][j] == 'p':
          ans += 1
        if board[i][j] != '.':
          break
        i += d[0]
        j += d[1]

    return ans"
